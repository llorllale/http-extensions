{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2020-11-01T00:16:47.209110+00:00",
  "repo": "httpwg/http-extensions",
  "labels": [
    {
      "name": "alt-svc",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "editorial",
      "description": null,
      "color": "009800"
    },
    {
      "name": "opp-sec",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "tunnel-proto",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "auth-info",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "308bis",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "cice",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "451",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "5987bis",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "key",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "client-hints",
      "description": null,
      "color": "fbca04"
    },
    {
      "name": "encryption",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "6265bis",
      "description": null,
      "color": "fbca04"
    },
    {
      "name": "origin-frame",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "jfv",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "cache-digest",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "header-structure",
      "description": null,
      "color": "fbca04"
    },
    {
      "name": "meta",
      "description": null,
      "color": "e99695"
    },
    {
      "name": "immutable",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "early-hints",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "expect-ct",
      "description": null,
      "color": "fbca04"
    },
    {
      "name": "rand-access-live",
      "description": null,
      "color": "fbca04"
    },
    {
      "name": "replay",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "secondary-certs",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "bcp56bis",
      "description": null,
      "color": "fbca04"
    },
    {
      "name": "h2-websockets",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "variants",
      "description": "",
      "color": "fbca04"
    },
    {
      "name": "cache-header",
      "description": "",
      "color": "fbca04"
    },
    {
      "name": "proxy-status",
      "description": "",
      "color": "fbca04"
    },
    {
      "name": "http2-tls13",
      "description": "",
      "color": "cccccc"
    },
    {
      "name": "digest-headers",
      "description": "",
      "color": "fbca04"
    },
    {
      "name": "priorities",
      "description": "",
      "color": "fbca04"
    },
    {
      "name": "samesite",
      "description": "RFC6265bis's `SameSite` cookie attribute.",
      "color": "e28cb6"
    },
    {
      "name": "signatures",
      "description": "",
      "color": "fbca04"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWUzNjM0NjE5MQ==",
      "title": "Indicating Chosen Service",
      "url": "https://github.com/httpwg/http-extensions/issues/1",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "<a href=\"https://github.com/mnot\"><img src=\"https://avatars.githubusercontent.com/u/74384?\" align=\"left\" width=\"96\" height=\"96\" hspace=\"10\"></img></a> **Issue by [mnot](https://github.com/mnot)**\n_Monday Mar 31, 2014 at 03:19 GMT_\n_Originally opened as https://github.com/http2/http2-spec/issues/443_\n\n---\n\nIt's likely necessary for the server to know which protocol the user agent has chosen, and perhaps even the hostname (for load balancing). At the very least, there should be a flag in SETTINGS that indicates that an alternate service has been used.\n",
      "createdAt": "2014-06-24T01:27:32Z",
      "updatedAt": "2014-06-24T01:29:00Z",
      "closedAt": "2014-06-24T01:29:00Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "<a href=\"https://github.com/reschke\"><img src=\"https://avatars.githubusercontent.com/u/332994?\" align=\"left\" width=\"48\" height=\"48\" hspace=\"10\"></img></a> **Comment by [reschke](https://github.com/reschke)**\n_Tuesday Apr 01, 2014 at 06:18 GMT_\n\n---\n\nis this about the frame or the header field?\n",
          "createdAt": "2014-06-24T01:27:33Z",
          "updatedAt": "2014-06-24T01:27:33Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "<a href=\"https://github.com/martinthomson\"><img src=\"https://avatars.githubusercontent.com/u/67641?\" align=\"left\" width=\"48\" height=\"48\" hspace=\"10\"></img></a> **Comment by [martinthomson](https://github.com/martinthomson)**\n_Tuesday Apr 01, 2014 at 17:27 GMT_\n\n---\n\nI think that this refers to the Service header field.\n",
          "createdAt": "2014-06-24T01:27:34Z",
          "updatedAt": "2014-06-24T01:27:34Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "<a href=\"https://github.com/mnot\"><img src=\"https://avatars.githubusercontent.com/u/74384?\" align=\"left\" width=\"48\" height=\"48\" hspace=\"10\"></img></a> **Comment by [mnot](https://github.com/mnot)**\n_Thursday Jun 05, 2014 at 20:34 GMT_\n\n---\n\nDiscussed in NYC; current approach (Service header) is the right approach; still need to justify / discuss the motivations on the list.\n",
          "createdAt": "2014-06-24T01:27:35Z",
          "updatedAt": "2014-06-24T01:27:35Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWUzNjM0NjE5Ng==",
      "title": "Flushing Alt-Svc Cache",
      "url": "https://github.com/httpwg/http-extensions/issues/2",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "<a href=\"https://github.com/mnot\"><img src=\"https://avatars.githubusercontent.com/u/74384?\" align=\"left\" width=\"96\" height=\"96\" hspace=\"10\"></img></a> **Issue by [mnot](https://github.com/mnot)**\n_Monday Mar 31, 2014 at 03:20 GMT_\n_Originally opened as https://github.com/http2/http2-spec/issues/444_\n\n---\n\nFor the load balancing use case, it's necessary for clients to always flush altsvc cache upon a network change, but right now they're only required to examine the cache for suspicious entries. We should discuss whether this should be upgraded to always flush.\n",
      "createdAt": "2014-06-24T01:27:36Z",
      "updatedAt": "2014-07-23T14:31:37Z",
      "closedAt": "2014-07-23T14:31:37Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "<a href=\"https://github.com/mnot\"><img src=\"https://avatars.githubusercontent.com/u/74384?\" align=\"left\" width=\"48\" height=\"48\" hspace=\"10\"></img></a> **Comment by [mnot](https://github.com/mnot)**\n_Thursday Jun 05, 2014 at 19:39 GMT_\n\n---\n\nDiscussed in NYC; need to be careful about wording so we don't rule out strategies like keeping segmented caches per network. Otherwise seems reasonable.\n",
          "createdAt": "2014-06-24T01:27:38Z",
          "updatedAt": "2014-06-24T01:27:38Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWUzNjM0NjE5Nw==",
      "title": "alt-svc header field syntax",
      "url": "https://github.com/httpwg/http-extensions/issues/3",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "<a href=\"https://github.com/reschke\"><img src=\"https://avatars.githubusercontent.com/u/332994?\" align=\"left\" width=\"96\" height=\"96\" hspace=\"10\"></img></a> **Issue by [reschke](https://github.com/reschke)**\n_Tuesday Apr 01, 2014 at 06:16 GMT_\n_Originally opened as https://github.com/http2/http2-spec/issues/446_\n\n---\n\nSee http://lists.w3.org/Archives/Public/ietf-http-wg/2014JanMar/0856.html\n",
      "createdAt": "2014-06-24T01:27:39Z",
      "updatedAt": "2014-06-24T01:29:21Z",
      "closedAt": "2014-06-24T01:29:12Z",
      "comments": []
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWUzNjM0NjE5OQ==",
      "title": "Intermediaries and Alt-Svc",
      "url": "https://github.com/httpwg/http-extensions/issues/4",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "<a href=\"https://github.com/mnot\"><img src=\"https://avatars.githubusercontent.com/u/74384?\" align=\"left\" width=\"96\" height=\"96\" hspace=\"10\"></img></a> **Issue by [mnot](https://github.com/mnot)**\n_Monday Apr 21, 2014 at 03:02 GMT_\n_Originally opened as https://github.com/http2/http2-spec/issues/462_\n\n---\n\nCurrently, Alt-Svc says:\n\n```\nIntermediaries MUST NOT change or append Alt-Svc field values.\n```\n\nThis seems too restrictive; e.g., a gateway (CDN) could do something useful here.\n\nSuggestion:\n\n```\nProxies MUST NOT change or append Alt-Svc field values.\n```\n\nAn argument could be made to degrade to SHOULD NOT, but if we do that, the specific conditions ought to be enumerated.\n",
      "createdAt": "2014-06-24T01:27:40Z",
      "updatedAt": "2014-06-24T01:29:46Z",
      "closedAt": "2014-06-24T01:29:46Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "<a href=\"https://github.com/mnot\"><img src=\"https://avatars.githubusercontent.com/u/74384?\" align=\"left\" width=\"48\" height=\"48\" hspace=\"10\"></img></a> **Comment by [mnot](https://github.com/mnot)**\n_Thursday Jun 05, 2014 at 19:53 GMT_\n\n---\n\nDiscussed in NYC; remove the sentence completely.\n",
          "createdAt": "2014-06-24T01:27:41Z",
          "updatedAt": "2014-06-24T01:27:41Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWUzNjM0NjIwNQ==",
      "title": "Alt-Svc header host restriction",
      "url": "https://github.com/httpwg/http-extensions/issues/5",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "<a href=\"https://github.com/mnot\"><img src=\"https://avatars.githubusercontent.com/u/74384?\" align=\"left\" width=\"96\" height=\"96\" hspace=\"10\"></img></a> **Issue by [mnot](https://github.com/mnot)**\n_Wednesday Jun 04, 2014 at 16:11 GMT_\n_Originally opened as https://github.com/http2/http2-spec/issues/492_\n\n---\n\nWhen we were originally working on Alt-Svc, Patrick and I put a restriction on the Alt-Svc header field so that it couldn\u2019t redirect clients to a different host.\n\nSince then, several people have pointed out that the requirement to have strong server authentication, as well as cache flushing, seems to contain the risk associated with doing this, and that the facility could be quite useful.\n\nSo, I\u2019m suggesting we (re-) add the capability to the header.\n",
      "createdAt": "2014-06-24T01:27:43Z",
      "updatedAt": "2014-07-23T14:09:59Z",
      "closedAt": "2014-07-23T14:09:59Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "<a href=\"https://github.com/mnot\"><img src=\"https://avatars.githubusercontent.com/u/74384?\" align=\"left\" width=\"48\" height=\"48\" hspace=\"10\"></img></a> **Comment by [mnot](https://github.com/mnot)**\n_Thursday Jun 05, 2014 at 19:42 GMT_\n\n---\n\nDiscussed in NYC; do it.\n",
          "createdAt": "2014-06-24T01:27:44Z",
          "updatedAt": "2014-06-24T01:27:44Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "<a href=\"https://github.com/reschke\"><img src=\"https://avatars.githubusercontent.com/u/332994?\" align=\"left\" width=\"48\" height=\"48\" hspace=\"10\"></img></a> **Comment by [reschke](https://github.com/reschke)**\n_Monday Jun 09, 2014 at 18:39 GMT_\n\n---\n\nTwo questions:\n\n1) the text around the ALTSVC frame currently talks about IDNA; I assume the same considerations would apply for the header field once we include the host, right?\n\n2) if we change the value from port to host:port we'll have to allow quoted-string syntax as well (because of the \":\"), right?\n",
          "createdAt": "2014-06-24T01:27:45Z",
          "updatedAt": "2014-06-24T01:27:45Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "<a href=\"https://github.com/martinthomson\"><img src=\"https://avatars.githubusercontent.com/u/67641?\" align=\"left\" width=\"48\" height=\"48\" hspace=\"10\"></img></a> **Comment by [martinthomson](https://github.com/martinthomson)**\n_Monday Jun 09, 2014 at 23:32 GMT_\n\n---\n\nYes, IDNA restrictions apply equally (to bother or neither).  The colon sucks, if you want a consistent grammar.  (I suppose Host is an exception in that regard.)\n",
          "createdAt": "2014-06-24T01:27:46Z",
          "updatedAt": "2014-06-24T01:27:46Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "<a href=\"https://github.com/reschke\"><img src=\"https://avatars.githubusercontent.com/u/332994?\" align=\"left\" width=\"48\" height=\"48\" hspace=\"10\"></img></a> **Comment by [reschke](https://github.com/reschke)**\n_Tuesday Jun 10, 2014 at 20:31 GMT_\n\n---\n\nOn 2014-06-10 01:32, Martin Thomson wrote:\n\n> Yes, IDNA restrictions apply equally (to bother or neither). The colon\n> sucks, if you want a consistent grammar. (I suppose Host is an exception\n> in that regard.)\n\nWe already require understanding of quoted-string when processing the \nparameters, so I'll stick to the colon and make the value \ntoken/quoted-string.\n\nBest regards, Julian\n",
          "createdAt": "2014-06-24T01:27:48Z",
          "updatedAt": "2014-06-24T01:27:48Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "<a href=\"https://github.com/enygren\"><img src=\"https://avatars.githubusercontent.com/u/6840678?\" align=\"left\" width=\"48\" height=\"48\" hspace=\"10\"></img></a> **Comment by [enygren](https://github.com/enygren)**\n_Thursday Jun 12, 2014 at 12:43 GMT_\n\n---\n\nDo we need to clarify whether IP addresses (IPv4 and/or IPv6) are or are not allowed?\nIf so, for the IPv6 case are the square brackets required and do the colons need to be escaped?\n",
          "createdAt": "2014-06-24T01:27:49Z",
          "updatedAt": "2014-06-24T01:27:49Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "<a href=\"https://github.com/reschke\"><img src=\"https://avatars.githubusercontent.com/u/332994?\" align=\"left\" width=\"48\" height=\"48\" hspace=\"10\"></img></a> **Comment by [reschke](https://github.com/reschke)**\n_Thursday Jun 12, 2014 at 12:54 GMT_\n\n---\n\nThe intent is to allow exactly what's allowed in an HTTP Host header field, which includes IP addresses.\n\nSee http://greenbytes.de/tech/webdav/rfc3986.html#host\n\nSo yes, IPv6 addresses would require square brackets. And no, colons would not need any additional escaping.\n",
          "createdAt": "2014-06-24T01:27:50Z",
          "updatedAt": "2014-06-24T01:27:50Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "<a href=\"https://github.com/reschke\"><img src=\"https://avatars.githubusercontent.com/u/332994?\" align=\"left\" width=\"48\" height=\"48\" hspace=\"10\"></img></a> **Comment by [reschke](https://github.com/reschke)**\n_Thursday Jun 12, 2014 at 18:07 GMT_\n\n---\n\nStill need to explain what checks need to be done when switching hosts; see http://lists.w3.org/Archives/Public/ietf-http-wg/2014AprJun/1232.html\n",
          "createdAt": "2014-06-24T01:27:51Z",
          "updatedAt": "2014-06-24T01:27:51Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Section 2.1 already has: \"Clients MUST NOT use alternative services with a host other than the origin's without strong server authentication; this mitigates the attack described in Section 9.2. One way to achieve this is for the alternative to use TLS with a certificate that is valid for that origin.\"\n\nSo it seems we're good.\n",
          "createdAt": "2014-07-23T14:09:59Z",
          "updatedAt": "2014-07-23T14:09:59Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWUzNjM0NjIxNQ==",
      "title": "Make the Service header field SHOULD",
      "url": "https://github.com/httpwg/http-extensions/issues/6",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "<a href=\"https://github.com/martinthomson\"><img src=\"https://avatars.githubusercontent.com/u/67641?\" align=\"left\" width=\"96\" height=\"96\" hspace=\"10\"></img></a> **Issue by [martinthomson](https://github.com/martinthomson)**\n_Thursday Jun 05, 2014 at 19:46 GMT_\n_Originally opened as https://github.com/http2/http2-spec/issues/502_\n\n---\n\n...with a good explanation.  This helps alleviate the privacy considerations (see #501)\n",
      "createdAt": "2014-06-24T01:27:52Z",
      "updatedAt": "2014-06-24T01:30:06Z",
      "closedAt": "2014-06-24T01:30:06Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "<a href=\"https://github.com/mnot\"><img src=\"https://avatars.githubusercontent.com/u/74384?\" align=\"left\" width=\"48\" height=\"48\" hspace=\"10\"></img></a> **Comment by [mnot](https://github.com/mnot)**\n_Friday Jun 06, 2014 at 17:26 GMT_\n\n---\n\nDiscussed in NYC; agreed to change Service header to have a fixed value of \"1\" to indicate that an alternative service is being accessed; put extensibility in the field to allow future elaboration. Change header name to Alt-Svc-Used. Remains a MUST.\n",
          "createdAt": "2014-06-24T01:27:53Z",
          "updatedAt": "2014-06-24T01:27:53Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWUzNjM0NjIxOA==",
      "title": "Ranking multiple alternative services",
      "url": "https://github.com/httpwg/http-extensions/issues/7",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "<a href=\"https://github.com/martinthomson\"><img src=\"https://avatars.githubusercontent.com/u/67641?\" align=\"left\" width=\"96\" height=\"96\" hspace=\"10\"></img></a> **Issue by [martinthomson](https://github.com/martinthomson)**\n_Thursday Jun 12, 2014 at 17:56 GMT_\n_Originally opened as https://github.com/http2/http2-spec/issues/521_\n\n---\n\nThe Alt-Svc header field permits multiple entries.  How does a client select between them when there are multiple options that are acceptable to the client?\n1. Add a q= parameter.\n2. Select the first acceptable option.\n3. Something else.\n",
      "createdAt": "2014-06-24T01:27:55Z",
      "updatedAt": "2014-07-23T14:58:16Z",
      "closedAt": "2014-07-23T14:58:16Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The intent was to allow different protocols to be advertised; (2) might work, but I think the recipient would choose the one that it believes is most advantageous (e.g, best protocol for its environment). That said, it could be that the client has information about availability or locality of certain endpoints that would also influence its choices.\n\nGiven that alt-svc is a completely optional signal (and indeed each advertised alt-svc lives in isolation), does this need to be specified?\n",
          "createdAt": "2014-07-02T06:16:33Z",
          "updatedAt": "2014-07-02T06:16:33Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We discussed this and it seems we don't want/need any ranking.\n",
          "createdAt": "2014-07-23T14:58:16Z",
          "updatedAt": "2014-07-23T14:58:16Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWUzNjM0NjIyMQ==",
      "title": "Multiple ALTSVC frames",
      "url": "https://github.com/httpwg/http-extensions/issues/8",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [
        "mnot"
      ],
      "labels": [
        "alt-svc"
      ],
      "body": "<a href=\"https://github.com/martinthomson\"><img src=\"https://avatars.githubusercontent.com/u/67641?\" align=\"left\" width=\"96\" height=\"96\" hspace=\"10\"></img></a> **Issue by [martinthomson](https://github.com/martinthomson)**\n_Thursday Jun 12, 2014 at 18:00 GMT_\n_Originally opened as https://github.com/http2/http2-spec/issues/522_\n\n---\n\nWhat are the semantics of subsequent ALTSVC frames for a given origin?\n\nThe current story is that a new value replaces the value of the old for that origin.\n\nAlternatively, we could have multiple frames present alternative alternative services.  That opens the question of how to indicate that a given service is obsolete.  But it's not clear we even need to do that.\n\nThen there is the fact that the Alt-Svc header field can have multiple values (see #521).  Do we need to replicate that capability for frames?\n",
      "createdAt": "2014-06-24T01:27:56Z",
      "updatedAt": "2014-08-18T01:06:07Z",
      "closedAt": "2014-08-18T01:06:07Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "<a href=\"https://github.com/mnot\"><img src=\"https://avatars.githubusercontent.com/u/74384?\" align=\"left\" width=\"48\" height=\"48\" hspace=\"10\"></img></a> **Comment by [mnot](https://github.com/mnot)**\n_Thursday Jun 12, 2014 at 19:11 GMT_\n\n---\n\nThe original proposal had a priority mechanism in it, so you could rank alternative services; the current approach is effectively a one-deep queue. \n\nThe header has the ability to convey multiple values because it might be that there are several protocols that the server can speak, and it wants the client to choose its most preferable. Same with multiple frames, IIRC. I.e., there are multiple choices of what to put into the queue, but only one gets in.\n",
          "createdAt": "2014-06-24T01:27:58Z",
          "updatedAt": "2014-06-24T01:27:58Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mark to propose an example involving multiple frames.\n",
          "createdAt": "2014-07-23T14:57:19Z",
          "updatedAt": "2014-07-23T14:57:19Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closed.\n",
          "createdAt": "2014-08-18T01:06:07Z",
          "updatedAt": "2014-08-18T01:06:07Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWUzNjk1NDQ1Mg==",
      "title": "OppSec and proxies",
      "url": "https://github.com/httpwg/http-extensions/issues/9",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "We need to define how a client using OppSec connects to a configured proxy; e.g., does it CONNECT, or does it downgrade? Does the answer change if the proxy is http vs https? Can the proxy advertise OppSec?\n",
      "createdAt": "2014-07-02T06:06:15Z",
      "updatedAt": "2014-08-15T04:00:07Z",
      "closedAt": "2014-08-15T04:00:07Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Toronto; proposal is to close with no action.\n",
          "createdAt": "2014-07-22T19:21:20Z",
          "updatedAt": "2014-07-22T19:21:20Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWUzNzk4NDE2Nw==",
      "title": "need to state what \"alt-svc-used: 0\" means",
      "url": "https://github.com/httpwg/http-extensions/issues/11",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "",
      "createdAt": "2014-07-16T13:56:17Z",
      "updatedAt": "2014-07-23T14:01:34Z",
      "closedAt": "2014-07-23T14:01:34Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWUzODYzMjQ3Mg==",
      "title": "Positive indicator of server understanding",
      "url": "https://github.com/httpwg/http-extensions/issues/12",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "reschke"
      ],
      "labels": [
        "alt-svc"
      ],
      "body": "I'm not sure how this can be turned into something useful, but this seems pretty bad:\n1. An HTTP/1.1 server doesn't check the scheme, but permits authority form requests for both `http` and `https` equally.  Scheme is instead inferred from the presence/absence of TLS in the stack.\n2. Attacker sends an Alt-Svc header field to clients referencing the `https` endpoint on that server.  This can come from any resource on the `http` endpoint, so it might not require any MitM attack.\n3. Clients now make `http` requests to the secure endpoint and now the content from the `https` origin is entered into the `http` origin.\n\nDo we want to require an explicit indication from HTTP/1.1 servers so that clients can\nbe assured that this error did not occur?\n\nThis should not be a problem for HTTP/2.\n",
      "createdAt": "2014-07-24T13:46:18Z",
      "updatedAt": "2015-05-01T14:49:52Z",
      "closedAt": "2015-05-01T14:49:52Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd been under the assumption that http-scheme-over-TLS would only be allowed over HTTP/2?  We should make this crystal clear.  For example, if Alt-Svc \"h2\" is used to move http up to TLS then if the TLS fails to negotiate HTTP/2 then the client must fall-back to HTTP/1.1 over clearntext.\nSimilarly, it should be crystal clear that https scheme must never be allowed over cleartext (h2c or http/1.1).\n\nDoes this cover the issues above here?\n",
          "createdAt": "2014-07-24T18:20:36Z",
          "updatedAt": "2014-07-24T18:20:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Patrick and I have discussed this before, both on and off list IIRC. Yes, it's a problem for HTTP/1.\n\nAt a minimum, we need security considerations for this. A mechanism for HTTP/1 would be nice, but I'm not sure it's realistic; we'd need some indication of positive support from the server. \n",
          "createdAt": "2014-07-29T06:34:31Z",
          "updatedAt": "2014-07-29T06:34:31Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Honolulu; document in security considerations.\n",
          "createdAt": "2014-11-11T23:39:36Z",
          "updatedAt": "2014-11-11T23:39:36Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Proposed text?\n",
          "createdAt": "2015-01-29T15:58:53Z",
          "updatedAt": "2015-01-29T15:58:53Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is text in the opp-sec draft that might be used.  I see no good reason to create a circular dependency, so maybe just copy (and reword) it.\n",
          "createdAt": "2015-01-29T19:20:16Z",
          "updatedAt": "2015-01-29T19:20:16Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson can you point @reschke in the right direction?\n",
          "createdAt": "2015-02-11T06:57:32Z",
          "updatedAt": "2015-02-11T06:57:32Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "http://httpwg.github.io/http-extensions/encryption.html#confusion-regarding-request-scheme\n\n> Many existing HTTP/1.1 implementations use the presence or absence of TLS in the stack to determine whether requests are for http or https resources. This is necessary in many cases because the most common form of an HTTP/1.1 request does not carry an explicit indication of the URI scheme.\n> \n> HTTP/1.1 MUST NOT be used for opportunistically secured requests.\n\nI think that this document can alter the last statement.  I can't think of a good way to generically phrase the statement, but maybe:\n\n> Alternative Services MUST NOT be advertised for a protocol that is not designed to carry the scheme.  In particular, HTTP/1.1 over TLS cannot carry safely requests for http resources.\n",
          "createdAt": "2015-02-11T23:20:43Z",
          "updatedAt": "2015-02-11T23:20:43Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWUzODk2MjAyMA==",
      "title": "Tracking Clients Using Alternative Services",
      "url": "https://github.com/httpwg/http-extensions/issues/13",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "alt-svc",
        "editorial"
      ],
      "body": "Section 9.4 - is this still necessary, now that it's just one bit? At a minimum, this section should be toned down.\n",
      "createdAt": "2014-07-29T06:35:01Z",
      "updatedAt": "2014-08-18T01:06:44Z",
      "closedAt": "2014-08-18T01:06:44Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, though as a practical matter, I don't think that there's anything to be done about it.  We could ask that servers not do this if `DNT: 1` is sent ;)  \n\nIt's fundamentally the same as HSTS, which is also superficially one bit.  \n\nTracking data is stored in the name and port that is provided, so it can be more than a single bit.  When you get down to the nuts and bolts, this likely requires that the server drop connections to avoid coalescing, but it's a totally manageable and undetectable tracking bug.\n",
          "createdAt": "2014-08-15T18:23:58Z",
          "updatedAt": "2014-08-15T18:23:58Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK, closing then.\n",
          "createdAt": "2014-08-18T01:06:44Z",
          "updatedAt": "2014-08-18T01:06:44Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU0MDQ2MDMzMA==",
      "title": "Alt-Svc alternative cache invalidation",
      "url": "https://github.com/httpwg/http-extensions/issues/16",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "In 3 The Alt-Svc HTTP Header Field, there's:\n\n> When an Alt-Svc response header field is received from an origin, its value invalidates and replaces all cached alternative services for that origin.\n\nHowever, in several other places, we now say that multiple alternatives can co-exist (with the client figuring out which to use). \n\nIs this still our intent -- i.e., that the header field has a special cache invalidation semantic -- or is it just left over from our previous approach?\n",
      "createdAt": "2014-08-18T06:54:06Z",
      "updatedAt": "2015-09-19T18:33:45Z",
      "closedAt": "2015-09-19T18:33:45Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed on-list. Cache invalidation is to be scoped to a specific discovery mechanism; e.g., the alternatives you discover via the response header will be invalidated when you see a new response header, while those that were discovered via the frame will be invalidated only when a new frame is received.\n\nThis means each mechanism needs to define its own exact invalidation semantics, and probably needs to be capable of carrying multiple alternatives.\n",
          "createdAt": "2015-03-17T05:42:04Z",
          "updatedAt": "2015-03-17T05:42:04Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For the header field we already say: \"When an Alt-Svc response header field is received from an origin, its value invalidates and replaces all cached alternative services for that origin.\"\n\nJust duplicate that in the description of the frame?\n",
          "createdAt": "2015-07-20T11:26:03Z",
          "updatedAt": "2015-07-20T11:26:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Almost. That existing text needs to be qualified to say that the response header invalidates previous services discovered via the response header, and then the section on the frame needs to say that it invalidates previous alt services discovered via a frame.\n",
          "createdAt": "2015-07-20T12:28:06Z",
          "updatedAt": "2015-07-20T12:28:06Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That sounds a bit like the client might have to maintain two sets; is that really true?\n",
          "createdAt": "2015-07-20T12:31:24Z",
          "updatedAt": "2015-07-20T12:31:24Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "That's what we discussed on list.\n",
          "createdAt": "2015-07-20T12:34:20Z",
          "updatedAt": "2015-07-20T12:34:20Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I looked at the email thread, and it seems the use case mentioned was 1.1 --> op-sec --> 2 and then alt-svc being used for load balancing. In this particular case we'd indeed have one set received by header field and one set received by frame. But is relying on exactly these two sets sufficient? In particular, tying it just to the header field/frame distinction seems funky...\n",
          "createdAt": "2015-07-20T13:20:51Z",
          "updatedAt": "2015-08-14T14:11:54Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's not the case that there are exactly two sets.   It's the case that one source cannot override information acquired from another source, but it must override information from the same source.\n",
          "createdAt": "2015-07-20T13:38:59Z",
          "updatedAt": "2015-07-20T13:38:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Prague; sense of room was to keep a single global scope for invalidation, to keep things simple. Need to adjust ABNF to allow an empty set. Add advice that server preference is expressed by lexical ordering.\n",
          "createdAt": "2015-07-21T11:29:13Z",
          "updatedAt": "2015-07-21T11:29:13Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm having second thoughts abound the \"empty list\" solution. In the past I've seen broken support for empty header field values (software components not being able to distinguish between \"empty\" and \"not present\").\n",
          "createdAt": "2015-08-14T14:29:25Z",
          "updatedAt": "2015-08-14T14:29:25Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I agree that that distinction is often a problem on server-side consumers (which span a large variety of implementations and quality thereof), but I'd suggest that it's less an issue in this case, given that a) the set of consuming clients is relatively smaller, and b) the party implementing the alt-svc behaviour presumably has control over the implementation, and can fix the bug if necessary.\n",
          "createdAt": "2015-08-19T06:44:40Z",
          "updatedAt": "2015-08-19T06:44:40Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm still uncomfortable with having a list-shaped header field value where the empty list carries a special meaning. How about allowing \"Alt-Svc: clear\" instead?\n",
          "createdAt": "2015-08-20T08:10:45Z",
          "updatedAt": "2015-08-20T08:10:45Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "my instincts agree with Julian - empty headers with semantics are asking for trouble\n",
          "createdAt": "2015-08-20T12:38:32Z",
          "updatedAt": "2015-08-20T12:38:32Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Using \"Alt-Svc: clear\"  (which would just be \"clear\" in the ALTSVC frame) makes sense to me.  I think the key thing here is to have a specified and well-defined mechanism.  \n",
          "createdAt": "2015-08-20T14:35:01Z",
          "updatedAt": "2015-08-20T14:35:01Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "WFM.\n",
          "createdAt": "2015-08-24T06:25:41Z",
          "updatedAt": "2015-08-24T06:25:41Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that the statement about invalidation is in Section 3.1 already, so it's not specific to the header field variant.\n",
          "createdAt": "2015-08-26T17:37:18Z",
          "updatedAt": "2015-08-26T17:37:18Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Re-opening because of https://lists.w3.org/Archives/Public/ietf-http-wg/2015JulSep/0322.html\n",
          "createdAt": "2015-09-19T17:41:36Z",
          "updatedAt": "2015-09-19T17:41:36Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU0MDQ2MDM4NA==",
      "title": "Alt-Svc-Used",
      "url": "https://github.com/httpwg/http-extensions/issues/17",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "The field-name for Alt-Svc-Used is 12 characters, and it's required to be sent in every request. \n\nWhile we have header compression in /2, we don't in /1.\n\nCan we make this shorter? Perhaps \"ASU\"?\n",
      "createdAt": "2014-08-18T06:55:02Z",
      "updatedAt": "2014-10-25T16:38:37Z",
      "closedAt": "2014-10-25T16:38:37Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Or just \"Svc\" ?\n",
          "createdAt": "2014-08-25T18:20:08Z",
          "updatedAt": "2014-08-25T18:20:08Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that \"Svc\" was suggested and it was too generic.  \"Alt\" might be as well.\n",
          "createdAt": "2014-08-25T19:34:56Z",
          "updatedAt": "2014-08-25T19:34:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Alt-Used?\n",
          "createdAt": "2014-10-07T07:05:16Z",
          "updatedAt": "2014-10-07T07:05:16Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "...is OK.\n",
          "createdAt": "2014-10-07T22:17:20Z",
          "updatedAt": "2014-10-07T22:17:20Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "MDU6SXNzdWU0MDQ2MDQ2NA==",
      "title": "Unexpected Alt-Svc frames",
      "url": "https://github.com/httpwg/http-extensions/issues/18",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "alt-svc",
        "editorial"
      ],
      "body": "Section 4 requires PROTOCOL_ERROR on an ALTSVC frame. However, earlier we say that it's a non-critical extension, and can be ignored. Which is it?\n\nYes, we could make a distinction on \"supporting the frame\", but that doesn't seem to helpful.\n\nCan we just drop the requirement and say it doesn't mean anything?\n",
      "createdAt": "2014-08-18T06:56:55Z",
      "updatedAt": "2015-06-21T17:41:00Z",
      "closedAt": "2015-06-21T17:41:00Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Somewhat similar, the next para says that intermediaries MUST NOT forward alt-svc. I understand what's being attempted here (intermediaries forming new altsvc based upon them, etc.), but the MUST NOT is going to confuse people; can we just do this in prose?\n",
          "createdAt": "2014-08-18T07:00:19Z",
          "updatedAt": "2014-08-18T07:00:19Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that we can do what we do with push.  That is, note that they are hop-by-hop and note that an intermediary is able to choose whether to forward them.  Any ALTSVC frames an intermediary receives is merely input it can use to determine what it sends onward.\n",
          "createdAt": "2014-08-18T17:32:04Z",
          "updatedAt": "2014-08-18T17:32:04Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "SGTM (for the second part).\n",
          "createdAt": "2014-10-07T07:04:56Z",
          "updatedAt": "2014-10-07T07:04:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in HNL; can be editorial.\n",
          "createdAt": "2015-01-21T05:08:49Z",
          "updatedAt": "2015-01-21T05:08:49Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "So, I think the plan is to a) talk about Alt-Svc as a hop-by-hop construct as Martin suggests, and b) drop the requirement to PROTOCOL_ERROR (but note that they'll just be ignored, and might cause the recipient to consider you to be hostile/broken, thus resulting in something similar).\n",
          "createdAt": "2015-02-11T06:53:42Z",
          "updatedAt": "2015-02-11T06:53:42Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "a) the PROTOCOL_ERROR requirement is on the server; that still makes sense, no?\n\nb) The spec already says: \"The ALTSVC frame is processed hop-by-hop. An intermediary MUST NOT forward ALTSVC frames, though it can use the information contained in ALTSVC frames in forming new ALTSVC frames to send to its own clients.\" - so is there anything left to do?\n",
          "createdAt": "2015-04-30T15:27:31Z",
          "updatedAt": "2015-04-30T15:27:31Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It's nonsensical that an implementation that doesn't support ALTSVC can ignore it (and as a recipient, no server implements ALTSVC), only to require servers to PROTOCOL_ERROR when receiving it. \n",
          "createdAt": "2015-05-01T02:10:44Z",
          "updatedAt": "2015-05-01T02:10:44Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed -- requiring a PROTOCOL_ERROR if you understand something doesn't really make sense.  Just drop it.\n",
          "createdAt": "2015-05-28T23:29:17Z",
          "updatedAt": "2015-05-28T23:29:17Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU0MDQ2MDU4Mw==",
      "title": "Missing origin on stream 0",
      "url": "https://github.com/httpwg/http-extensions/issues/19",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "alt-svc",
        "editorial"
      ],
      "body": "Section 4 doesn't explain what to do when the frame is missing the origin on stream 0.\n\nSimplest thing would be to say that a frame on stream 0 that doesn't contain an origin should be ignored.\n",
      "createdAt": "2014-08-18T06:58:43Z",
      "updatedAt": "2014-10-25T17:09:38Z",
      "closedAt": "2014-10-25T17:09:38Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm going for \"MUST\" ignore, and also add the reverse requirement for client-initiated streams.\n",
          "createdAt": "2014-10-25T17:03:25Z",
          "updatedAt": "2014-10-25T17:03:25Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU0MDQ2MDkwNg==",
      "title": "Associating Alt-Svc header with an origin",
      "url": "https://github.com/httpwg/http-extensions/issues/21",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "alt-svc",
        "editorial"
      ],
      "body": "I think we need to be REALLY careful about making assertions about an origin in a response, given things like pretty-bad-proxy.\n\nSection 3 says:\n\n> Alt-Svc MAY occur in any HTTP response message, regardless of the status code.\n\nThat's way too broad. For example, what if it's in response to a CONNECT -- will clients associate it with the origin?\n\nI think the resolution of this will need to reference this:\n  http://httpwg.github.io/specs/rfc7231.html#identification\n",
      "createdAt": "2014-08-18T07:05:48Z",
      "updatedAt": "2015-09-01T15:34:45Z",
      "closedAt": "2015-09-01T15:34:45Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in HNL; editorial.\n",
          "createdAt": "2015-01-21T05:05:35Z",
          "updatedAt": "2015-01-21T05:05:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Suggest:\n\n\"Alt-Svc MUST be ignored in messages whose payloads are not the payload is known to be a representation of the resource identified by the effective request URI (see [RFC7231], Section 3.1.4.1).\"\n",
          "createdAt": "2015-02-11T06:51:34Z",
          "updatedAt": "2015-02-11T06:51:34Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Suggestion does not parse.\n",
          "createdAt": "2015-02-11T23:11:21Z",
          "updatedAt": "2015-02-11T23:11:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "2nd try:\n\n\"Alt-Svc MUST be ignored in messages whose payloads are not known to be a representation of the resource identified by the effective request URI (see [RFC7231], Section 3.1.4.1).\"\n",
          "createdAt": "2015-02-11T23:46:51Z",
          "updatedAt": "2015-02-11T23:46:51Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, a little laboured, but fine.\n",
          "createdAt": "2015-02-12T01:26:10Z",
          "updatedAt": "2015-02-12T01:26:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thinking about this a bit more, that's probably not a good match; it means that Alt-Svc has to be ignored on most POST responses, which is weird.\n\nPerhaps we just need a caveat;\n\n\"Alt-Svc MAY occur in any HTTP response message, regardless of the status code. Note that recipients of Alt-Svc are free to ignore the header field (and indeed are require to in some situations; see [ref to 2.1]).\"\n\n?\n",
          "createdAt": "2015-02-20T04:07:35Z",
          "updatedAt": "2015-02-20T04:07:35Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "WFM.\n",
          "createdAt": "2015-07-20T11:28:04Z",
          "updatedAt": "2015-07-20T11:28:04Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU0MDUxMTM3Mg==",
      "title": "HTTP-TLS and Alt-Svc changes",
      "url": "https://github.com/httpwg/http-extensions/issues/22",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "HTTP-TLS creates a commitment to use an authenticated connection.  We need to make it clear that changes to Alt-Svc, even on that connection cannot change the fact that the origin needs to be authenticated for the duration of the commitment.\n\nOne potential attack here is for a MitM to advertise a different Alt-Svc, perhaps overriding the advertisement for the secured endpoint.  A naive implementation might update the set of available Alt-Svc advertisements and then continue.  What should happen here is that the service becomes unreachable. \n",
      "createdAt": "2014-08-18T17:26:24Z",
      "updatedAt": "2014-12-16T00:17:38Z",
      "closedAt": "2014-12-16T00:17:38Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think that this is just a clarification that the commitment is to the origin, not the alternative service.\n",
          "createdAt": "2014-08-19T00:21:17Z",
          "updatedAt": "2014-08-19T00:21:17Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that this is clearer in the reworked text.  The key commit being: https://github.com/httpwg/http-extensions/commit/67b2d094fa69f692cffcb5a2b19815e77bd49dcb\n",
          "createdAt": "2014-12-16T00:17:38Z",
          "updatedAt": "2014-12-16T00:17:38Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU0MDU1MTIxNw==",
      "title": "Server Auth - required or not?",
      "url": "https://github.com/httpwg/http-extensions/issues/25",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "Second para of 3. Server Authentication starts:\n\n> When connecting to an alternative service for an \"http\" URI, clients are required to perform the server authentication procedure descriptor in Section 3.1 of [RFC2818].\n\nIs this merely a missing \"not\"? If that isn't the case, this is a design issue...\n",
      "createdAt": "2014-08-19T01:55:07Z",
      "updatedAt": "2014-08-19T18:18:32Z",
      "closedAt": "2014-08-19T18:18:32Z",
      "comments": []
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU0MDU1MTI5NQ==",
      "title": "Ciphersuite requirements",
      "url": "https://github.com/httpwg/http-extensions/issues/26",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "Section 3 implies that there are no cipher suite requirements on Opp Sec, but it'd be good to discuss and formalise this. May require tweaks to HTTP/2 (which places requirements on use of TLS, _not_ TLS with \"https\").\n",
      "createdAt": "2014-08-19T01:57:01Z",
      "updatedAt": "2014-12-16T00:17:54Z",
      "closedAt": "2014-12-16T00:17:54Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PHK will disagree, but I think that we're OK here.  Better to have a single robust profile than to permit exceptions.  There are several problems with exceptions or variations:\n- oppsec will be detectable as such to a passive observer\n- more configurations to build and test; better to use a single code path than risk weakening \"https\"\n",
          "createdAt": "2014-08-19T18:21:15Z",
          "updatedAt": "2014-08-19T18:21:15Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Honolulu; proposal is to close with no action. \n",
          "createdAt": "2014-11-11T23:44:34Z",
          "updatedAt": "2014-11-11T23:44:34Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU0MDU1MTM1Nw==",
      "title": "Cert change over time example",
      "url": "https://github.com/httpwg/http-extensions/issues/27",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "Section 3 third para ends:\n\n> For instance, a client could examine the certificate to see if it has changed over time.\n\nThis implies that certs SHOULD NOT change over time; as it is, though, they can't rely upon that, so this text is highly speculative. I think we should either firm it up or take it out (probably the latter).\n",
      "createdAt": "2014-08-19T01:58:25Z",
      "updatedAt": "2014-08-19T18:31:54Z",
      "closedAt": "2014-08-19T18:31:54Z",
      "comments": []
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWU0MDU1MTk4Mg==",
      "title": "Set tone regarding security guarantees",
      "url": "https://github.com/httpwg/http-extensions/issues/28",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "I think the introduction needs to do a stronger job of framing expectations regarding security properties.\n\nE.g., insert new para after para 2:\n\n> Opportunistic Security does not provide the same guarantees as using TLS with \"https\" URIs; it is vulnerable to active attacks, and does not change the security context of the connection. Normally, users will not be able to tell that it is in use (e.g., there will be no \"lock icon\").\n",
      "createdAt": "2014-08-19T02:11:54Z",
      "updatedAt": "2014-08-19T18:29:05Z",
      "closedAt": "2014-08-19T18:29:05Z",
      "comments": []
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU0MDYyMDA2OA==",
      "title": "strongly authenticated (as the origin's host)",
      "url": "https://github.com/httpwg/http-extensions/issues/30",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "What does that even mean?\n\nI think that we can be a little clearer and more precise about this statement.\n",
      "createdAt": "2014-08-19T18:13:59Z",
      "updatedAt": "2014-12-16T00:17:01Z",
      "closedAt": "2014-12-16T00:17:01Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We're not formally specifying it here, just reminding people of the requirements of alt-svc; if this is confusing / imprecise, perhaps it's best to drop the text and make a more specific reference into alt-svc.\n",
          "createdAt": "2014-08-19T23:48:30Z",
          "updatedAt": "2014-08-19T23:48:30Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, I think that I've clarified this.\n",
          "createdAt": "2014-12-16T00:16:59Z",
          "updatedAt": "2014-12-16T00:16:59Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWU0MDYyMDMzOA==",
      "title": "Use a better opsec definition",
      "url": "https://github.com/httpwg/http-extensions/issues/32",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "If draft-dukhovni-blah ever gets published, or at least the constant spiraling in SAAG quiets down, then we want to include a reference to that.\n",
      "createdAt": "2014-08-19T18:16:43Z",
      "updatedAt": "2014-08-19T18:29:05Z",
      "closedAt": "2014-08-19T18:29:05Z",
      "comments": []
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWU0MDk1NTE0Mg==",
      "title": "Align opp-sec and alt-svc",
      "url": "https://github.com/httpwg/http-extensions/issues/33",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "After a re-read of alt-svc and opp-sec, it may make sense to have use some better alignment between the two docs around the cases where authentication is not employed.  In particular, alt-svc indicates:\n\n>   Importantly, this includes its security context; in particular, when TLS\n>  <xref target=\"RFC5246\"/> is in use, the alternative server will need to present a certificate\n>  for the origin's host name, not that of the alternative. \n\nReplacing \"is in use\" with \"is used to authenticate\" would align that text better with opp-sec. \n\nOn the opp-sec side:\n\n>   A client MAY perform additional checks on the offered certificate if the server does not select an\n>  unauthenticated TLS cipher suite.  This document doesn't define any such checks, though clients\n>  could be configured with a policy that defines what is acceptable.\n\nis very unclear for a server implementer (as well as clients).  If authentication doesn't succeed, should the client fail-back to clear-text (the origin) or hard fail?\n\nOne possibility (which may start getting outside of the editorial realm) is for an Alt-Svc parameter indicating that authentication will not be present (either via an unauthenticated cipher suite or a mismatching cert).  This would allow clients to chose to ignore the Alt-Svc rather than following it and erroring or needing to fall-back).  For example:\n\n```\n Alt-Svc: h2=\":443\" ; unauth\n```\n",
      "createdAt": "2014-08-22T22:14:27Z",
      "updatedAt": "2016-03-02T05:20:54Z",
      "closedAt": "2016-03-02T05:20:54Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I think that this did cross that line.  The first suggestion is fine, and we probably need to identify what is actually used to authenticate the server identify (which is not TLS :).\n\nThe second suggestion I'd like to respond to, but won't go into detail here because the list is more appropriate (and I'm very tired right now).  We have discussed this sort of signal before.  Mark's original draft proposed a very similar feature in a different form.\n",
          "createdAt": "2014-08-22T23:54:03Z",
          "updatedAt": "2014-08-22T23:54:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Marked \"design\" for the second part. Eric, in the future please open separate issues. \n",
          "createdAt": "2014-08-26T04:41:43Z",
          "updatedAt": "2014-08-26T04:41:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Honolulu; can flip to editorial.\n",
          "createdAt": "2014-11-11T23:53:59Z",
          "updatedAt": "2014-11-11T23:53:59Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I looked at https://github.com/httpwg/wg-materials/blob/gh-pages/ietf91/minutes.md#alt-svc; not sure what the concrete proposal here is. Just apply the first part of Eric's  proposed change?\n",
          "createdAt": "2015-04-30T15:22:27Z",
          "updatedAt": "2015-04-30T15:22:27Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "For alt-svc, yes.\n",
          "createdAt": "2015-05-01T02:12:15Z",
          "updatedAt": "2015-05-01T02:12:15Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "removing alt-svc label because that change has been applied\n",
          "createdAt": "2015-05-01T13:50:53Z",
          "updatedAt": "2015-05-01T13:50:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Is there anything that needs to change in OppSec here?\n",
          "createdAt": "2016-02-06T02:24:09Z",
          "updatedAt": "2016-02-06T02:24:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing.\n",
          "createdAt": "2016-03-02T05:20:54Z",
          "updatedAt": "2016-03-02T05:20:54Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU0MDk1Njc5Nw==",
      "title": "Alt-Svc-Used indicator granularity",
      "url": "https://github.com/httpwg/http-extensions/issues/34",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "The current Alt-Svc-Used indicator is a boolean (\"0\"/\"1\"), due to the desire to preserve privacy.\nBased on some explorations of how this would be implemented on the server side, we realized that this doesn't provide enough information to distinguish between the different use-cases for Alt-Svc.  In particular, a server would have no way to know if just the protocol was changed, or if both the protocol and host were changed.  If we start using multiple Alt-Svc sources (such as DNS) this also becomes relevant.\n\nAn option short of including (proto,host,port) in Alt-Svc-Used would be to include a better indicator of how the Alt-Svc was used.  This could be either a bitmask or a string of tokens.  For example, with a bitmask:\n- 1 = Alt-Svc was used to change protocol  (ie, service proto != default origin scheme's proto)\n- 2 = Alt-Svc was used to change port     (ie, service port != origin port)\n- 4 = Alt-Svc was used to change host    (ie, service host != origin host)\n- 8 = Alt-Svc was obtained via Alt-Svc header\n- 16 = Alt-Svc was obtained via ALTSVC frame\n- 32 = Alt-Svc was obtained via DNS record  (reserved, not yet defined)\n\nWith a token approach, short character strings could replace the bitmask.\nIn either case this would result in a value like:\n\n  Alt-Svc-Used: 20\n  Alt-Svc-Used: h,f\n\nFor load-balancing, this would make it possible to infer the (proto,host,port) that may have been used in cases where it differs by use-case but is consistent within a use-case.\n\nThis would also significantly help with debuggability on the server side.\n### Editorial\n\nRegardless of how this is resolved, there is still text referring to previous Alt-Svc-Used indicator proposals that should be cleaned up to be consistent with whatever we decide on.  For example, with the current text the following is confusing and should be removed:\n\n>   To reduce the ability of servers to track individual clients over time (see <xref\n>   target=\"tracking\"/>), an alternative service indication sent by a client &SHOULD-NOT; include\n>   any alternative service information other than the protocol, host and port.\n\n(as the protocol, host, and port aren't part of what is being sent in the current indication).\n\nThe same applies of the \"Tracking Clients Using Alternative Services\" section which may be a remnant from previous versions.\n\nThe current text also mentions a \"token\" in the Alt-Svc-Used definition, but does not explain it or specify how it might be used or set.\n",
      "createdAt": "2014-08-22T22:33:58Z",
      "updatedAt": "2015-02-05T21:04:04Z",
      "closedAt": "2015-02-05T21:04:04Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm going to remove the text from the Alt-Used definition that is out of date.\n\nI don't see any occurrence of \"token\" that shouldn't be there.\n\nWRT \"Tracking Clients Using Alternative Services\" - can we get rid of that consideration altogether now that we only have 0 and 1?\n",
          "createdAt": "2014-10-25T17:28:29Z",
          "updatedAt": "2014-10-25T17:28:29Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I don't think we can get rid of that consideration; the alt-svc hostname can still encode a significant amount of information. \n",
          "createdAt": "2014-10-27T21:14:11Z",
          "updatedAt": "2014-10-27T21:14:11Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I rephrased it assuming we were talking about one additional bit.\n\nSo yes, we need to keep it and explain the issue caused by the hostname choice.\n",
          "createdAt": "2014-10-27T21:27:52Z",
          "updatedAt": "2014-10-27T21:27:52Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Honolulu; \n- no alt-svc-used indicator (some support)\n- 1-bit (no hum!)\n- multi-bit\n- full hostname (some support)\n- 1-bit or full-hostname (some support)\n\n\"Doesn't know\" wins\n",
          "createdAt": "2014-11-11T23:32:51Z",
          "updatedAt": "2014-11-11T23:32:51Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU0NDgwMDAxNg==",
      "title": "Section 5.3 - Expires of RFC7234 has a bad link",
      "url": "https://github.com/httpwg/http-extensions/issues/35",
      "state": "CLOSED",
      "author": "andydavies",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://tools.ietf.org/html/rfc7234#section-5.3\n\nContains the text:  \"The Expires value is an HTTP-date timestamp, as defined in Section 7.1.1.1 of [RFC7231].\"\n\nThe target of the link to Section 7.1.1.1 is https://tools.ietf.org/html/rfc7234#section-7.1.1.1 but should be https://tools.ietf.org/html/rfc7231#section-7.1.1.1 instead\n",
      "createdAt": "2014-10-03T12:53:53Z",
      "updatedAt": "2014-10-03T17:09:36Z",
      "closedAt": "2014-10-03T17:09:36Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is a problem with the tools.ietf.org HTML processing.  Contact tools-discuss@ietf.org.\n",
          "createdAt": "2014-10-03T17:09:36Z",
          "updatedAt": "2014-10-03T17:09:36Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "MDU6SXNzdWU0Nzg0Mjk3NA==",
      "title": "Security Considerations: tracking using the alt-svc host name",
      "url": "https://github.com/httpwg/http-extensions/issues/36",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "reschke"
      ],
      "labels": [
        "alt-svc",
        "editorial"
      ],
      "body": "The security considerations (\"Tracking Clients Using Alternative Services\") are currently focused on the Alt-Used header field, which adds one bit of tracking info. They also need to mention that the alt-svc host name itself could be used for tracking.\n",
      "createdAt": "2014-11-05T14:43:51Z",
      "updatedAt": "2014-11-14T01:12:43Z",
      "closedAt": "2014-11-14T01:12:43Z",
      "comments": []
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU0ODQ1MTE0MQ==",
      "title": "frame vs header field",
      "url": "https://github.com/httpwg/http-extensions/issues/37",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "reschke"
      ],
      "labels": [
        "alt-svc"
      ],
      "body": "1. allow the frame to carry multiple indicators\n2. while doing so, use the same payload formats for both\n",
      "createdAt": "2014-11-11T23:43:41Z",
      "updatedAt": "2014-11-30T21:51:12Z",
      "closedAt": "2014-11-30T21:51:12Z",
      "comments": []
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWU1Mzc3NDQ3Nw==",
      "title": "Specifying origin in altsvc frame",
      "url": "https://github.com/httpwg/http-extensions/issues/38",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "http://lists.w3.org/Archives/Public/ietf-http-wg/2015JanMar/0056.html\n",
      "createdAt": "2015-01-08T17:06:12Z",
      "updatedAt": "2015-01-29T16:21:43Z",
      "closedAt": "2015-01-29T16:21:43Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Proposal in #39.\n",
          "createdAt": "2015-01-21T05:11:08Z",
          "updatedAt": "2015-01-21T05:11:08Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU1NjQwNzI5NQ==",
      "title": "ALPN identifiers in Alt-Svc",
      "url": "https://github.com/httpwg/http-extensions/issues/43",
      "state": "CLOSED",
      "author": "hruellan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "ALPN identifiers from the ALPN spec have been defined in the context of negotiating the application protocol in TLS. In this context, they imply a layering above TLS.\nWhen used outside this context, there is an ambiguity, mainly for the http/1.1 token: does it refer to HTTP/1.1 over TLS, or can it refer also to HTTP/1.1 over TCP?\nThe draft should resolve this ambiguity by stating that the http/1.1 identifier is used to identify HTTP/1.1 over TLS.\n\nIn addition, a new identifier, h1c for example, could be defined to identify HTTP/1.1 over cleartext TCP, in order to allow using Alt-Svc to be used to target an HTTP/1.1 server over cleartext TCP.\n",
      "createdAt": "2015-02-03T17:12:38Z",
      "updatedAt": "2015-08-14T16:33:50Z",
      "closedAt": "2015-08-14T16:33:50Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Texas; agreed that http/1.1 means over TLS.\n",
          "createdAt": "2015-03-24T18:12:50Z",
          "updatedAt": "2015-03-24T18:12:50Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We currently do not have any text or example that uses the \"http/1.1\" ALPN identifier. Should we add something?\n",
          "createdAt": "2015-04-30T14:42:03Z",
          "updatedAt": "2015-04-30T14:42:03Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think its fine as is. no need to promote legacy through cut and paste.\n",
          "createdAt": "2015-04-30T16:42:07Z",
          "updatedAt": "2015-04-30T16:42:07Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It seems like changes similar to those we put into tunnel-proto for Barry should be sufficient here.\n",
          "createdAt": "2015-05-27T06:37:39Z",
          "updatedAt": "2015-05-27T06:37:39Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Which, specifically?\n",
          "createdAt": "2015-06-21T17:42:25Z",
          "updatedAt": "2015-06-21T17:42:25Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think it was this text:\n\n> The ALPN header field carries an indication of client intent only. An ALPN identifier is used here only to identify the application protocol or suite of protocols that the client intends to use in the tunnel. No negotiation takes place using this header field. In TLS, the final choice of application protocol is made by the server from the set of choices presented by the client. Other substrates could negotiate the application protocol differently.\n\n(modified suitably, of course)\n",
          "createdAt": "2015-07-20T12:29:30Z",
          "updatedAt": "2015-07-20T12:29:30Z"
        },
        {
          "author": "hruellan",
          "authorAssociation": "NONE",
          "body": "I adapted this text for solving this issue, see: #88.\n",
          "createdAt": "2015-07-20T13:06:48Z",
          "updatedAt": "2015-07-20T13:06:48Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "MDU6SXNzdWU1Njg3ODUwNQ==",
      "title": "alt svc frame on pushed (even and non-0) frame",
      "url": "https://github.com/httpwg/http-extensions/issues/44",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "section 4 of alt-svc clearly describes origin field handling for stream 0 and client initiated (odd) streams, but it is silent on pushed streams.\n\nI think it should say must ignore\n",
      "createdAt": "2015-02-06T22:42:44Z",
      "updatedAt": "2015-04-21T06:29:10Z",
      "closedAt": "2015-04-21T06:29:10Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's missing not only for the \"origin\" handling but also for the Alt-svc handling in general.\n",
          "createdAt": "2015-02-07T10:11:16Z",
          "updatedAt": "2015-02-07T10:11:16Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWU1ODAzMjk0Mg==",
      "title": "\"HTTP Authentication-Info Header Field\" links are broken",
      "url": "https://github.com/httpwg/http-extensions/issues/45",
      "state": "CLOSED",
      "author": "jomo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(In the Readme)\nJust shows GitHub Pages' default 404 site.\n",
      "createdAt": "2015-02-18T06:34:05Z",
      "updatedAt": "2015-02-18T13:03:44Z",
      "closedAt": "2015-02-18T13:03:44Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed.\n",
          "createdAt": "2015-02-18T13:03:44Z",
          "updatedAt": "2015-02-18T13:03:44Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "MDU6SXNzdWU1ODE4MzQ0Nw==",
      "title": "Auth-Info purpose consistency",
      "url": "https://github.com/httpwg/http-extensions/issues/49",
      "state": "CLOSED",
      "author": "hruellan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "auth-info"
      ],
      "body": "I think the purpose of the headers should be made more consistent across the document.\nIn the Introduction, they are used to \"_return additional information during or after authentication_\", while in 3, the Authentication-Info header is used to \"_communicate additional information regarding the successful authentication_\".\n\nDIGEST use it in an optional manner, to convey additional information after a successful authentication.\nScram is using it in a mandatory manner, to finalize the authentication, by conveying information for authenticating the server.\n\nI think that Authentication-Info should be used by the server once the client is authenticated (i.e. the status code is not 401), to either convey additional information or finalize the authentication. \n\nProposal in #47.\n",
      "createdAt": "2015-02-19T09:15:55Z",
      "updatedAt": "2015-03-01T09:24:48Z",
      "closedAt": "2015-03-01T09:24:48Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This change was applied in https://github.com/httpwg/http-extensions/commit/849702e4f7f6476b09a8e7777941dac21a848e00\n",
          "createdAt": "2015-03-01T09:03:34Z",
          "updatedAt": "2015-03-01T09:03:34Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "MDU6SXNzdWU1OTM5MjE5MA==",
      "title": "clarify rules on modifying auth-info for intermediaries",
      "url": "https://github.com/httpwg/http-extensions/issues/50",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "auth-info"
      ],
      "body": "Raised by Amos in https://lists.w3.org/Archives/Public/ietf-http-wg/2015JanMar/0452.html:\n\nSection 3 paragraph 3 says \"Intermediaries are not allowed to modify the field value in any way.\"\n\nRFC 7235 uses wording in the form: \"A proxy forwarding ... MUST NOT modify ...\"\n\nI believe the Authentication-Info should share both normative MUST NOT,\nand term \"proxy\" instead of intermediary. Since there are legitimate\ncases where gateways and/or other intermediaries may need to change it\nper the relevant auth scheme.\n",
      "createdAt": "2015-03-01T11:14:41Z",
      "updatedAt": "2015-03-01T12:41:45Z",
      "closedAt": "2015-03-01T12:41:45Z",
      "comments": []
    },
    {
      "number": 51,
      "id": "MDU6SXNzdWU1OTM5MjIzOQ==",
      "title": "clarify Proxy-Auth-Info",
      "url": "https://github.com/httpwg/http-extensions/issues/51",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "auth-info"
      ],
      "body": "Raised by Amos in https://lists.w3.org/Archives/Public/ietf-http-wg/2015JanMar/0452.html:\n\nSection 4 uses the term \"proxy authentication\" referencing RFC 7235.\n\nIn RFC 7235 there is no definition, and only a vague implied explanation\nof that term via explaining what the 407 status means.\n\nI believe the text in section 4 should be re-written to match the\nper-header descriptions found in RFC 7235 sectio 4.3/4.3 paragraph 2.\nWith mention specifically about how it differs from Authentication-Info\nby being hop-by-hop.\n",
      "createdAt": "2015-03-01T11:16:53Z",
      "updatedAt": "2015-03-02T10:40:37Z",
      "closedAt": "2015-03-02T10:40:37Z",
      "comments": []
    },
    {
      "number": 52,
      "id": "MDU6SXNzdWU1OTM5NDI0MA==",
      "title": "use of BCP14 keywords",
      "url": "https://github.com/httpwg/http-extensions/issues/52",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "auth-info",
        "editorial"
      ],
      "body": "The spec currently doesn't use BCP14 which MAY or MAY NOT confuse people.\n",
      "createdAt": "2015-03-01T12:32:30Z",
      "updatedAt": "2015-04-30T15:09:59Z",
      "closedAt": "2015-04-30T15:09:59Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The specs has been approved in the meantime, thus closing.\n",
          "createdAt": "2015-04-30T15:09:58Z",
          "updatedAt": "2015-04-30T15:09:58Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU2MDQ0Mzc0Ng==",
      "title": "WG name",
      "url": "https://github.com/httpwg/http-extensions/issues/53",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "308bis",
        "alt-svc",
        "auth-info",
        "editorial",
        "opp-sec"
      ],
      "body": "The full name of the WG is \"HTTP Working Group\" -- httpbis is only the short identifier (kept because changing it would be a pain). Please replace throughout your drafts, and note below when each is done.\n",
      "createdAt": "2015-03-10T02:59:06Z",
      "updatedAt": "2015-03-11T14:39:26Z",
      "closedAt": "2015-03-11T14:38:37Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I took the freedom to fix it everywhere...\n",
          "createdAt": "2015-03-11T14:39:26Z",
          "updatedAt": "2015-03-11T14:39:26Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "MDU6SXNzdWU2NDgxNzU2Mg==",
      "title": "Tunnel-Protocol name",
      "url": "https://github.com/httpwg/http-extensions/issues/57",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "tunnel-proto"
      ],
      "body": "Apparently, this is confusing.  Picking a new name might help.\n",
      "createdAt": "2015-03-27T17:54:36Z",
      "updatedAt": "2015-04-27T16:12:16Z",
      "closedAt": "2015-04-27T16:12:16Z",
      "comments": []
    },
    {
      "number": 58,
      "id": "MDU6SXNzdWU2NTQ4NTYyMA==",
      "title": "Number of alternate services used",
      "url": "https://github.com/httpwg/http-extensions/issues/58",
      "state": "CLOSED",
      "author": "hruellan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "At the end of section 3, the paragraph:\n\n> The value(s) advertised by Alt-Svc can be used by clients to open a new connection to one or more alternative services immediately, or simultaneously with subsequent requests on the same connection.\n\nsays that several alternative services can be used simultaneously by a client. \n\nHowever, section 2.4 Using Alternative Services, recommend choosing one alternative service and using only one alternative service (except during the transition time).\n\nI think we should align the two by rephrasing the sentence in 3.\n",
      "createdAt": "2015-03-31T16:03:09Z",
      "updatedAt": "2015-05-30T10:56:18Z",
      "closedAt": "2015-05-30T10:56:18Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I tend to agree. Marking this as design, just to confirm with the WG that this is the intent. Please ping the list.\n",
          "createdAt": "2015-05-01T02:16:55Z",
          "updatedAt": "2015-05-01T02:16:55Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done in https://lists.w3.org/Archives/Public/ietf-http-wg/2015AprJun/0331.html\n",
          "createdAt": "2015-05-01T13:35:21Z",
          "updatedAt": "2015-05-01T13:35:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "No objection on list.\n",
          "createdAt": "2015-05-27T06:35:58Z",
          "updatedAt": "2015-05-27T06:35:58Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWU2NjE4NDQxOQ==",
      "title": "Proxy and .pac interaction",
      "url": "https://github.com/httpwg/http-extensions/issues/62",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Ryan asks what you should pass to proxy.pac when you know about a potential alt-svc.\n\nI suggested that you use the original request origin and only use alternatives if the proxy.pac doesn't provide a proxy address.  That is proxy.pac overrides alternative services.\n",
      "createdAt": "2015-04-03T16:51:39Z",
      "updatedAt": "2015-07-20T12:47:11Z",
      "closedAt": "2015-07-20T12:47:11Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yeah. Alt-Sv is for finding an origin, not for finding a proxy -- a proxy might use it, though.\n\nThis _should_ all be clear based upon reading of RFC7230, but if not we could add a sentence or two to clarify. \n",
          "createdAt": "2015-04-07T01:45:12Z",
          "updatedAt": "2015-04-07T01:45:12Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is there something we need to do here?\n",
          "createdAt": "2015-04-30T14:31:05Z",
          "updatedAt": "2015-04-30T14:31:05Z"
        },
        {
          "author": "RolandZink",
          "authorAssociation": "NONE",
          "body": "Maybe we need to specify an alternative to pac files or define how to \nget a proxy for http over TLS in pac.\n\nRegards,\nRoland\n\nOn 30.04.2015 16:31, Julian Reschke wrote:\n\n> Is there something we need to do here?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub \n> https://github.com/httpwg/http-extensions/issues/62#issuecomment-97818988.\n",
          "createdAt": "2015-04-30T15:29:53Z",
          "updatedAt": "2015-04-30T15:29:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "For _this_ spec, I think we could just add a sentence to the effect that 'clients configured to use a proxy SHOULD NOT use alternative services.\"\n",
          "createdAt": "2015-05-01T02:02:38Z",
          "updatedAt": "2015-05-01T02:02:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Add: \"A client configured to use a proxy for a given request SHOULD NOT send it to an alternative service, but instead use that proxy.\"\n",
          "createdAt": "2015-06-09T23:53:41Z",
          "updatedAt": "2015-06-09T23:53:41Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Modification: \"A client configured to use a proxy for a given request SHOULD NOT directly connect to an alternative service for it, but instead route it through that proxy.\"\n",
          "createdAt": "2015-06-16T01:08:03Z",
          "updatedAt": "2015-06-16T01:08:03Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(seems the discussion on the mailing list hasn't come to a conclusion)\n",
          "createdAt": "2015-06-21T17:48:43Z",
          "updatedAt": "2015-06-21T17:48:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It did regarding this issue, I think; the remaining discussion is a tangent.\n",
          "createdAt": "2015-07-20T12:30:52Z",
          "updatedAt": "2015-07-20T12:30:52Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "MDU6SXNzdWU2OTQ0NDA5OA==",
      "title": "no need to update RFC 2616",
      "url": "https://github.com/httpwg/http-extensions/issues/64",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "451",
        "editorial"
      ],
      "body": "a) it's obsoleted anyway, b) that's what we have the IANA status code registry for.\n",
      "createdAt": "2015-04-19T17:07:14Z",
      "updatedAt": "2015-09-19T18:39:03Z",
      "closedAt": "2015-09-19T18:39:03Z",
      "comments": []
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU3MDQwNDI4Ng==",
      "title": "ABNF for \"parameter\"",
      "url": "https://github.com/httpwg/http-extensions/issues/65",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc",
        "editorial"
      ],
      "body": "Bence B\u00e9ky in http://lists.w3.org/Archives/Public/ietf-http-wg/2015AprJun/0220.html:\n\n\"I need some clarification.  I am writing a parser for ALTSVC header\nfields and wish to ignore unknown parameters.  However, it is unclear\nto me whether a parameter without \"=value\" should be ignored or\ntreated as malformed.\n\ndraft-ietf-httpbis-alt-svc-06 Section 3 refers to \"parameter\".\nSection 1.1 says \"parameter\" is defined in RFC7230.  In fact, RFC7230\nhas \"transfer-parameter\" but not \"parameter\".  Also, RFC7230 Section\nsays \"Parameters are in the form of a name or name=value pair.\",\nimplicilty allowing names without values, but in the next line\n\"transfer-parameter\" is defined as a name=value pair, which disallowes\nnames without values.  On the other hand, RFC7231 Section 3.1.1.1\ndefines \"parameter\" as a name=value pair, but this is not what\ndraft-ietf-httpbis-alt-svc-06 refers to.\"\n",
      "createdAt": "2015-04-23T12:50:47Z",
      "updatedAt": "2015-04-30T14:05:06Z",
      "closedAt": "2015-04-30T14:05:06Z",
      "comments": []
    },
    {
      "number": 67,
      "id": "MDU6SXNzdWU3MjE4OTI3Mw==",
      "title": "opp-sec: needs to reference RFC 5234, and needs to define \"parameter\" ABNF",
      "url": "https://github.com/httpwg/http-extensions/issues/67",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "Or, for \"parameter\", reference the alt-svc spec.\n",
      "createdAt": "2015-04-30T15:09:09Z",
      "updatedAt": "2016-03-17T01:07:15Z",
      "closedAt": "2016-03-17T01:07:15Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "If we decide to keep the header; see #145.\n",
          "createdAt": "2016-03-02T05:22:01Z",
          "updatedAt": "2016-03-02T05:22:01Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Header is gone.\n",
          "createdAt": "2016-03-17T01:07:15Z",
          "updatedAt": "2016-03-17T01:07:15Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWU3NDcwMjQwMQ==",
      "title": "need to define extensibility for alt-svc parameters",
      "url": "https://github.com/httpwg/http-extensions/issues/69",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "must ignore? how to register new ones? IANA registry?\n",
      "createdAt": "2015-05-09T15:57:42Z",
      "updatedAt": "2015-09-20T09:05:05Z",
      "closedAt": "2015-09-20T09:05:05Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From discussions in various threads, it is sounding like \"must ignore\" is a better default behavior for unknown parameters.  Otherwise trying to guess which combinations of parameters will cause an AltSvc to be ignored becomes impossibly unwieldy.   If \"manditory to understand before using a service\" parameters are necessary, Martin has the good suggestion of adding a parameter that lists those extension parameters where not understanding them should cause a client to ignore a service.  For example a parameter:\n      must=\"manditory1,manditory2\"\nsuch that:\n    Alt-Svc: h2=\":443\"; ma=60; manditory1=1; manditory2=\"foo\"; optional1=\"bar\"; must=\"manditory1,manditory2\"\n\nWould cause the service to be ignored if the client didn't understand manditory1 or manditory2, but optional1 would be ignored if not understood.\n",
          "createdAt": "2015-07-02T15:08:55Z",
          "updatedAt": "2015-07-02T15:08:55Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've seen that before in http://greenbytes.de/tech/webdav/rfc2774.html#end-to-end.extensions :-)\n",
          "createdAt": "2015-07-17T10:34:51Z",
          "updatedAt": "2015-07-17T10:34:51Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "... which was promptly ignored by the whole world (except for spawning SOAP, and we know how that went...)\n",
          "createdAt": "2015-07-17T13:32:53Z",
          "updatedAt": "2015-07-17T13:32:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Prague; sense of the room is to have extensibility at the parameter level. Also, sense was to go ahead and establish a registry. \n",
          "createdAt": "2015-07-21T11:36:41Z",
          "updatedAt": "2015-07-21T11:36:41Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So must-ignore-unknown parameters (but process what remains), and add registry, right?\n",
          "createdAt": "2015-09-01T15:38:58Z",
          "updatedAt": "2015-09-01T15:38:58Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "yes.\n",
          "createdAt": "2015-09-02T07:46:01Z",
          "updatedAt": "2015-09-02T07:46:01Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"IETF review\", I guess? (would be the same as Cache-Control)\n",
          "createdAt": "2015-09-02T09:51:29Z",
          "updatedAt": "2015-09-02T09:51:29Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Let's talk on-list. I think that bar might be a bit high.\n",
          "createdAt": "2015-09-02T10:18:04Z",
          "updatedAt": "2015-09-02T10:18:04Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Changes done in https://github.com/httpwg/http-extensions/commit/eed78be6f8340a1019a22022168c35fa68654feb, let's discuss IANA details separately when needed. \n",
          "createdAt": "2015-09-19T18:47:54Z",
          "updatedAt": "2015-09-19T18:47:54Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "MDU6SXNzdWU4MjE3MDEwMw==",
      "title": "Persistence of alternates across network changes",
      "url": "https://github.com/httpwg/http-extensions/issues/71",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Alternates provided because of location (seattle.edge.net vs. sfc.edge.net) need to be cleared on network changes.  (They\u2019re probably direct pointers to individual nodes/datacenters.)  Alternates provided because of capabilities (sni.edge.net as alternate of legacy.edge.net) shouldn\u2019t be cleared on network changes, because they\u2019re not location-dependent.  (The names probably resolve to different IPs based on location at the DNS level, or they resolve to anycast addresses.)\n\nShould there be a hint to the client that a particular alternate does/doesn\u2019t need to be flushed on changes?  Might impact the issues described in 9.2, but TLS should still mitigate without the flushing.\n",
      "createdAt": "2015-05-28T23:31:05Z",
      "updatedAt": "2015-09-20T08:17:39Z",
      "closedAt": "2015-09-20T08:17:39Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that flushing is the always-safe option.  We can define extensions later if this turns out to be especially problematic (or the optimization that retention affords is especially attractive).\n",
          "createdAt": "2015-05-28T23:47:12Z",
          "updatedAt": "2015-05-28T23:47:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "See also #2. It's not clear that flushing a alt-svc used for oppsec is the safest thing.\n",
          "createdAt": "2015-05-31T23:59:51Z",
          "updatedAt": "2015-05-31T23:59:51Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Prague; add a parameter to do this now.\n",
          "createdAt": "2015-07-21T11:39:43Z",
          "updatedAt": "2015-07-21T11:39:43Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "MDU6SXNzdWU4MjE3MTI2NA==",
      "title": "Conflicts between Alt-Svc and ALPN",
      "url": "https://github.com/httpwg/http-extensions/issues/72",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Alt-Svc tells me to use h2, so I open a TLS connection, and the server either doesn\u2019t support ALPN or doesn\u2019t select h2.  What now?  Weird corner cases ensue where I\u2019m connected to something that may or may not be the alternate I was intending to reach.  (Similar issues ensue attempting to connect using h2c -- does it mean a direct TCP connection to the specified port, or that the client should offer Upgrade?  What if the server doesn't accept the Upgrade?)\n\nIt's simpler to just say TLS is the protocol and require ALPN support in 2.3 as well.  Point me to a TLS-enabled endpoint, and the specific protocols we'll use will be negotiated in real-time.\n\nHowever, this does pose a challenge if you wanted _only_ HTTP/3 traffic going to your alternate.\n",
      "createdAt": "2015-05-28T23:34:18Z",
      "updatedAt": "2015-10-07T08:21:49Z",
      "closedAt": "2015-10-07T08:21:49Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, that's a bad sort of failure, but I don't think that it needs special handling.  Any failure in establishing the alternative just results in falling back to the primary.\n\n(BTW, h2c has to mean one thing, and I think that it's clear that this is Upgrade.)\n",
          "createdAt": "2015-05-28T23:48:47Z",
          "updatedAt": "2015-05-28T23:48:47Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Maybe some security considerations text to the effect that the alternative isn't usable if it doesn't negotiate the advertised protocol.\n",
          "createdAt": "2015-06-01T00:01:46Z",
          "updatedAt": "2015-06-01T00:01:46Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "s/security considerations//; just text.\n",
          "createdAt": "2015-06-01T16:24:36Z",
          "updatedAt": "2015-06-01T16:24:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed on list, add text.\n",
          "createdAt": "2015-06-09T23:52:47Z",
          "updatedAt": "2015-06-09T23:52:47Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "in 2.4?\n",
          "createdAt": "2015-07-20T11:41:20Z",
          "updatedAt": "2015-07-20T11:41:20Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Makes sense to me.\n",
          "createdAt": "2015-07-20T12:31:37Z",
          "updatedAt": "2015-07-20T12:31:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@reschke do you need text to be proposed?\n",
          "createdAt": "2015-10-05T00:19:06Z",
          "updatedAt": "2015-10-05T00:19:06Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yes\n",
          "createdAt": "2015-10-05T05:41:15Z",
          "updatedAt": "2015-10-05T05:41:15Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "MDU6SXNzdWU4MjE3MjQxNg==",
      "title": "Alt-Svc:  Elevation of privilege",
      "url": "https://github.com/httpwg/http-extensions/issues/73",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Someone who controls any resource on an origin can issue directives that affect all resources on that origin.  (Thinking of the server the CS/CE students could work with in college, where we all had pages at server.example.edu/~username.)  Sure, I can\u2019t change the host because I don\u2019t have the server cert, but I can change ports without that requirement.\n\nThe guidance in 9.1 just says \u201cdon\u2019t let people do that,\u201d which is easier said than done on systems that already exist.  People can run apps listening on ephemeral ports, and people can control their home pages.  With this combination, everyone else's home pages can be hijacked unless the server admin reads this draft before any students do and promptly prohibits pages from emitting headers named Alt-Svc.\n\nThe way to partially fix this is to require strong auth for changes of port as well.  Resources can still slow down access by causing attempts to access an alternate, but the alternate won't be able to supply fake resources.\n",
      "createdAt": "2015-05-28T23:37:28Z",
      "updatedAt": "2015-10-07T00:42:39Z",
      "closedAt": "2015-10-06T19:37:13Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Noting that that would effectively disallow OppSec - one of the main (but not only) use cases for Alt-Svc.\n",
          "createdAt": "2015-06-01T00:02:31Z",
          "updatedAt": "2015-06-01T00:02:31Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, that goes back to the \"do you validate certs in Opp-Sec?\" discussion.  If the server has a valid cert, there's no problem changing ports.  Opp-Sec already states \"A client MAY perform additional checks on the offered certificate if the server does not select an unauthenticated TLS cipher suite. This document doesn\u2019t define any such checks, though clients could be configured with a policy that defines what is acceptable.\"\n\nI think we're saying that if we implement, our additional checks (default, at least) will be the same as for an https:// origin.  Otherwise, we see a security risk here.\n",
          "createdAt": "2015-06-01T00:39:01Z",
          "updatedAt": "2015-06-01T00:39:01Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Does having different behavior for privileged vs non-privileged ports help?  (i.e., being able to bind to port 443 in most of these circumstances is typically quite different from being able to bind to 8443.)\n",
          "createdAt": "2015-06-01T01:36:26Z",
          "updatedAt": "2015-06-01T01:36:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Prague; feeling in room was to non-normatively describe the risks, and recommend a privilege barrier ++ .\n",
          "createdAt": "2015-07-21T11:53:24Z",
          "updatedAt": "2015-07-21T11:53:24Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Can someone work on some text here?\n",
          "createdAt": "2015-10-05T00:40:52Z",
          "updatedAt": "2015-10-05T00:40:52Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWU4MjE3MzE3Ng==",
      "title": "Alt-Svc:  Alternates of alternates",
      "url": "https://github.com/httpwg/http-extensions/issues/74",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "When the origin delegates to an alternate for 30 seconds, and the alternate delegates somewhere else (or to itself) for 7 days, how long does the client keep it?  30 seconds because that\u2019s what the origin said, or 7 days because the alternate is supposed to be equivalent in authority to the origin?\n\nI'm inclined toward the second, since the alternate is supposed to be fully authoritative and since it enables use of an alternate to be persistent so long as you regularly visit the origin.  It feels odd to let a delegate grant itself more power than the delegation originally gave it, though....\n",
      "createdAt": "2015-05-28T23:39:57Z",
      "updatedAt": "2015-10-07T00:42:39Z",
      "closedAt": "2015-10-06T20:00:20Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that it's the latter.  The alternative service is an alternative with full rights.  Those rights are based on the authentication credentials it presents, not the Alt-Svc delegation.\n",
          "createdAt": "2015-05-28T23:51:28Z",
          "updatedAt": "2015-05-28T23:51:28Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "This was discussed some pre-WG and IIRC we came to the same conclusion, but it'd be good to have the discussion play out on list.\n",
          "createdAt": "2015-06-01T00:03:31Z",
          "updatedAt": "2015-06-01T00:03:31Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Prague; second reading is correct. May need to clarify in document.\n",
          "createdAt": "2015-07-21T11:54:49Z",
          "updatedAt": "2015-07-21T11:54:49Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Do we need someone to suggest text?\n",
          "createdAt": "2015-10-05T00:23:57Z",
          "updatedAt": "2015-10-05T00:23:57Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yes\n",
          "createdAt": "2015-10-05T05:41:34Z",
          "updatedAt": "2015-10-05T05:41:34Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See https://github.com/httpwg/http-extensions/commit/7f320202815c431df89a63cfa66ebb0623ed8883\n",
          "createdAt": "2015-10-06T19:42:33Z",
          "updatedAt": "2015-10-06T19:42:33Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "MDU6SXNzdWU4MjE3NDA1Ng==",
      "title": "Alt-Svc header with 421 status",
      "url": "https://github.com/httpwg/http-extensions/issues/75",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Why does the spec explicitly allow the alternate to simultaneously send you an alternate list (which we trust, because the alternate is authoritative for this origin) and a status code telling us this host is not authoritative for this origin?\n\nIt seems like 421 should automatically remove the alternate (as stated) and cause the user agent to fall back to the origin server.  While one can also envision a scenario where the server says \"I'm not authoritative, but I know who might be....\", that way lies loops.\n",
      "createdAt": "2015-05-28T23:42:41Z",
      "updatedAt": "2015-09-01T16:04:28Z",
      "closedAt": "2015-09-01T16:04:28Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Prague; an alt-svc header in a 421 response MUST be ignored.\n",
          "createdAt": "2015-07-21T11:56:50Z",
          "updatedAt": "2015-07-21T11:56:50Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "MDU6SXNzdWU4MjE3NDc3NQ==",
      "title": "Alt-Svc and Cert Pinning",
      "url": "https://github.com/httpwg/http-extensions/issues/76",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "If http://www.example.com sends Alt-Svc pointing to evil.haxor.bg showing a cert from a hacked CA for the right origin, we don\u2019t want to trust it.  Cert pinning would mitigate this for https:// origins, and we could go a step further for https:// origins without pinning and validate that the cert on the alternate resembles the cert we last saw on the origin (identical cert, same issuer, same issuer country, etc.).\n\nHowever, for http:// origins, we're pretty vulnerable.  That scenario looks a lot like 9.2 again for http:// origins \u2013 if you\u2019re MITM\u2019d once, you can be MITM\u2019d for as long as you trust the fishy cert.\n",
      "createdAt": "2015-05-28T23:45:37Z",
      "updatedAt": "2015-11-04T16:12:50Z",
      "closedAt": "2015-11-04T16:12:50Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The alternative needs to present credentials that are valid.  That means that if the original requires pinning, then the alternative needs to present a certificate that is valid against the pin set.\n\nRequiring that an alternative present an identical certificate would make this considerably less attractive.\n",
          "createdAt": "2015-05-28T23:53:29Z",
          "updatedAt": "2015-05-28T23:53:29Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Mike, is this really an issue, or just a question? Do you have proposed text?\n",
          "createdAt": "2015-06-08T01:48:12Z",
          "updatedAt": "2015-06-08T01:48:12Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is a concern that came up in our internal discussions.  Reasonable text could range anywhere from general guidance that implementations might use caution in which certificates they accept to specific requirements on the cert, depending on the consensus of the rest of the group.\n\nMore generally, I think this is something a cautious implementation might do anyway, and if it's at least mentioned in the spec, origin operators will be more prepared for it than if it's strictly an implementation \"quirk.\"\n",
          "createdAt": "2015-06-08T14:05:50Z",
          "updatedAt": "2015-06-08T14:05:50Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Prague; need to add security considerations text explaining the potential attack and possible mitigations. \n",
          "createdAt": "2015-07-21T12:03:15Z",
          "updatedAt": "2015-07-21T12:03:15Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@MikeBishop, perhaps you could suggest some text?\n",
          "createdAt": "2015-10-05T00:26:50Z",
          "updatedAt": "2015-10-05T00:26:50Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWU4MzIzMzM5Nw==",
      "title": "WG item",
      "url": "https://github.com/httpwg/http-extensions/issues/79",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "451",
        "editorial"
      ],
      "body": "1. Introduction says \"...although this draft is NOT a work item of the IETF HTTPbis Working Group.\"\n\nNot true :)\n",
      "createdAt": "2015-06-01T00:13:11Z",
      "updatedAt": "2015-06-29T02:24:41Z",
      "closedAt": "2015-06-29T02:24:41Z",
      "comments": [
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hm, I don't see this in -00, boilerplate fail?\n",
          "createdAt": "2015-06-28T19:20:23Z",
          "updatedAt": "2015-06-28T19:20:23Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh wait, already fixed in a previous pass, don't mind me\n",
          "createdAt": "2015-06-28T19:21:15Z",
          "updatedAt": "2015-06-28T19:21:15Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "MDU6SXNzdWU4MzIzNDMxMQ==",
      "title": "Distinguishing intermediaries from origins",
      "url": "https://github.com/httpwg/http-extensions/issues/80",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [
        "timbray"
      ],
      "labels": [
        "451"
      ],
      "body": "In the current draft, 451 is used both to indicate when the origin server has the legal demands placed upon it, and when an intervening intermediary is enforcing such a demand.\n\nIn discussion, some have wondered whether it would be useful to be able to distinguish them in a machine-readable way; e.g., using a different status code (452?) or a response header.\n",
      "createdAt": "2015-06-01T00:17:19Z",
      "updatedAt": "2015-11-16T00:13:59Z",
      "closedAt": "2015-11-16T00:13:59Z",
      "comments": [
        {
          "author": "wseltzer",
          "authorAssociation": "NONE",
          "body": "Yes, I think it would be useful to distinguish.\n",
          "createdAt": "2015-07-21T12:22:02Z",
          "updatedAt": "2015-07-21T12:22:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Prague; sense in the room was that it is worth distinguishing, but no strong opinions about how to express it (except @mnot). \n",
          "createdAt": "2015-07-21T12:25:28Z",
          "updatedAt": "2015-07-21T12:25:28Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the meantime, draft 02 defines a \"blocked-by\" link relation.\n",
          "createdAt": "2015-09-02T06:29:11Z",
          "updatedAt": "2015-09-02T06:29:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "LGTM; I think we just need to put a template registering 'blocked-by' in IANA considerations, as per http://tools.ietf.org/html/rfc5988#section-6.2.1\n",
          "createdAt": "2015-09-25T06:18:25Z",
          "updatedAt": "2015-09-25T06:18:25Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "In WGLC, but the template can be taken care of in the next version.\n",
          "createdAt": "2015-09-30T04:30:36Z",
          "updatedAt": "2015-09-30T04:30:36Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added in -03\n",
          "createdAt": "2015-10-25T21:25:58Z",
          "updatedAt": "2015-10-25T21:25:58Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "MDU6SXNzdWU4MzIzNDcwMQ==",
      "title": "responsibility",
      "url": "https://github.com/httpwg/http-extensions/issues/81",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "451",
        "editorial"
      ],
      "body": "\"The author takes all responsibility for errors and omissions.\"\n\nThis isn't necessary any more.\n",
      "createdAt": "2015-06-01T00:18:40Z",
      "updatedAt": "2015-06-29T02:24:00Z",
      "closedAt": "2015-06-29T02:24:00Z",
      "comments": [
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "fixed for -01\n",
          "createdAt": "2015-06-28T19:18:49Z",
          "updatedAt": "2015-06-28T19:18:58Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "MDU6SXNzdWU4MzIzNTk5Ng==",
      "title": "Cacheability",
      "url": "https://github.com/httpwg/http-extensions/issues/82",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "451"
      ],
      "body": "Is 451 cacheable by default? I suspect so.\n\nSee:\n  http://httpwg.github.io/specs/rfc7231.html#overview.of.status.codes\n",
      "createdAt": "2015-06-01T00:22:36Z",
      "updatedAt": "2015-06-29T02:24:09Z",
      "closedAt": "2015-06-29T02:24:09Z",
      "comments": [
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixing for -01\n",
          "createdAt": "2015-06-28T19:18:23Z",
          "updatedAt": "2015-06-28T19:18:23Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "MDU6SXNzdWU4NTk3MzczNg==",
      "title": "Alt-Svc Header - hop by hop",
      "url": "https://github.com/httpwg/http-extensions/issues/83",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Amos pointed out that we should consider making the header field explicitly hop-by-hop, to match the semantics of the frame.\n",
      "createdAt": "2015-06-08T00:59:04Z",
      "updatedAt": "2015-10-07T00:42:39Z",
      "closedAt": "2015-09-25T06:21:18Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Prague; end-to-end header is useful in the OppSec use case, and it doesn't need to be consistent with the frame. Feeling in room was to close with no action. \n",
          "createdAt": "2015-07-21T12:06:05Z",
          "updatedAt": "2015-07-21T12:06:05Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "see https://lists.w3.org/Archives/Public/ietf-http-wg/2015JulSep/0369.html\n",
          "createdAt": "2015-09-20T11:56:10Z",
          "updatedAt": "2015-09-20T11:56:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing due to lack of further input.\n",
          "createdAt": "2015-09-25T06:21:18Z",
          "updatedAt": "2015-09-25T06:21:18Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWU4NjE4MzcyOA==",
      "title": "properly cite definition of ABNF",
      "url": "https://github.com/httpwg/http-extensions/issues/84",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "tunnel-proto"
      ],
      "body": "\"The ABNF (Augmented Backus-Naur Form) syntax for the ALPN header field is given below. It is based on the Generic Grammar defined in Section 2 of [RFC7230].\"\n\nThis needs to say something like\n\n\"The ABNF (Augmented Backus-Naur Form) syntax for the ALPN header field value is given below. It uses the syntax defined in Section 1.2 of [RFC7230].\" \n",
      "createdAt": "2015-06-08T13:45:48Z",
      "updatedAt": "2015-06-08T19:10:24Z",
      "closedAt": "2015-06-08T19:10:24Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that you have commit access.  If it is my permission that you need, you have it.\n",
          "createdAt": "2015-06-08T18:21:49Z",
          "updatedAt": "2015-06-08T18:21:49Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "MDU6SXNzdWU5NjA0OTYxMA==",
      "title": "alt-svc response header field in HTTP/2 frame",
      "url": "https://github.com/httpwg/http-extensions/issues/87",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Should we say what an alt-svc header field means when received over HTTP/2? Does it mean anything? Does it override a previously received alt-svc frame?\n",
      "createdAt": "2015-07-20T12:02:40Z",
      "updatedAt": "2015-09-02T07:21:24Z",
      "closedAt": "2015-09-02T07:21:24Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Prague; no special handling, they're still valid. Clarify in document if necessary. \n",
          "createdAt": "2015-07-21T12:09:09Z",
          "updatedAt": "2015-07-21T12:09:09Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I originally raised this because of https://github.com/httpwg/http-extensions/issues/16 which talked about multiple sets of information that could be independently updates or invalidated. Now that we don't have this anymore this issue is less important.\n",
          "createdAt": "2015-09-02T06:32:35Z",
          "updatedAt": "2015-09-02T06:32:35Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "MDU6SXNzdWU5NjI5NjYxOQ==",
      "title": "Using alt-svc on localhost",
      "url": "https://github.com/httpwg/http-extensions/issues/89",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "You can identify an alternative on a different port on localhost trivially and it might be considered authoritative.  You probably don't want to accept localhost as a valid alternative for an `http://example.com` origin.\n",
      "createdAt": "2015-07-21T11:46:43Z",
      "updatedAt": "2015-11-09T07:29:05Z",
      "closedAt": "2015-11-09T07:29:05Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See also #73\n",
          "createdAt": "2015-07-21T11:50:51Z",
          "updatedAt": "2015-07-21T11:50:51Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "1918 space is similarly problematic.\n",
          "createdAt": "2015-07-21T12:11:12Z",
          "updatedAt": "2015-07-21T12:11:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Prague; add security considerations / non-normative text that this is another form of privilege escalation, and should be taken into account. (both localhost and special use networks / rfc1918). Need to discuss with webappsec as well as security folks in ietf. \n",
          "createdAt": "2015-07-21T12:12:23Z",
          "updatedAt": "2015-07-21T12:12:23Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Treating rfc1918 as special opens up a can of worms, especially as there is no clear mapping there in the IPv6 world and as other related spaces (rfc6598).  We may just generally want to ensure AltSvc can't be used to probe/attack internal hosts behind a firewall regardless of what IP space is present.  Due to the async behavior of Alt-Svc and the reliance on cert validation, we may be OK here as long as we don't treat rfc1918 space special (eg, as long as we don't relax cert validation requirements there).\n",
          "createdAt": "2015-07-21T12:21:01Z",
          "updatedAt": "2015-07-21T12:21:01Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The prohibition on host changes for cleartext `http://` should cover this.\n",
          "createdAt": "2015-07-21T12:22:01Z",
          "updatedAt": "2015-07-21T12:22:01Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "due to the prohibition on host changes and the async nature of alt-svc, the only issue I can see here is that example.com can probe for things behind the firewall that have the example.com cert :) but maybe I'm missing the concern?\n",
          "createdAt": "2015-07-21T13:46:17Z",
          "updatedAt": "2015-07-21T13:46:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Yokohama; we think we can close this with no action.\n",
          "createdAt": "2015-11-02T04:15:06Z",
          "updatedAt": "2015-11-02T04:15:06Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@reschke please add to the changes section.\n",
          "createdAt": "2015-11-09T07:29:05Z",
          "updatedAt": "2015-11-09T07:29:05Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "MDU6SXNzdWUxMDA4MTg3NzI=",
      "title": "alt-svc from https (1.1) to https (1.1)",
      "url": "https://github.com/httpwg/http-extensions/issues/91",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc",
        "editorial"
      ],
      "body": "See https://lists.w3.org/Archives/Public/ietf-http-wg/2015JulSep/0193.html:\n\n\"Alternative Services MUST NOT be advertised for a protocol that is not designed to carry the scheme. In particular, HTTP/1.1 over TLS cannot carry safely requests for http resources.\"\n\n...which refers to the :scheme pseudo header field in HTTP/2 (http://greenbytes.de/tech/webdav/rfc7540.html#HttpRequest).\n\nAs far as I recall the intention of the statement above is to avoid that when alt-svc is used to move http traffic to a TLSsy port such as 443, the alternative server gets confused about whether it's serving HTTP or HTTPS.\n\nThe clause seems to be less relevant when alt-svc is used to load-balance HTTP/1.1 http_s_ traffic.\n",
      "createdAt": "2015-08-13T16:57:28Z",
      "updatedAt": "2015-11-19T02:16:41Z",
      "closedAt": "2015-11-19T02:16:41Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think this is editorial.\n",
          "createdAt": "2015-08-19T06:46:02Z",
          "updatedAt": "2015-08-19T06:46:02Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Like that?\n\n\"Special care is needed when the use of an alternative service causes a change in the URI scheme of the transport (e.g., when HTTP traffic is transferred over an HTTPS connection). In cases like these, alternative services MUST NOT be advertised for a protocol that is not designed to carry the scheme. In particular, HTTP/1.1 over TLS cannot carry safely requests for http resources.\").\n",
          "createdAt": "2015-09-20T13:53:18Z",
          "updatedAt": "2015-09-20T13:53:18Z"
        },
        {
          "author": "icing",
          "authorAssociation": "NONE",
          "body": "Or:\n\"Alternative Services MUST NOT be advertised for a protocol that is not designed to carry the scheme, for resources whose scheme differs from the Alternate Service one. In particular, HTTP/1.1 over TLS cannot carry safely requests for http resources.\"\n",
          "createdAt": "2015-09-23T15:32:36Z",
          "updatedAt": "2015-09-23T15:32:36Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that both could be a little problematic in the sense that they confuse scheme with protocol.  How about:\n\n> Alternative services MUST NOT be advertised or used if the protocol for the alternative is not designed to carry the scheme. In particular, HTTP/1.1 over TLS cannot ...\n",
          "createdAt": "2015-09-23T17:19:35Z",
          "updatedAt": "2015-09-23T17:19:35Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "...but that doesn't address the problem this ticket is about...\n",
          "createdAt": "2015-09-23T17:25:33Z",
          "updatedAt": "2015-09-23T17:25:33Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe\n\n> ...not designed to carry the scheme, unless the alternate uses the same protocol implied by the scheme.\n",
          "createdAt": "2015-10-06T18:40:47Z",
          "updatedAt": "2015-10-06T18:40:47Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "proposal from @mnot in https://github.com/httpwg/http-extensions/issues/92#issuecomment-156880299 would address this issue as well\n",
          "createdAt": "2015-11-16T18:26:06Z",
          "updatedAt": "2015-11-16T18:26:06Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "MDU6SXNzdWUxMDA4MTkwNjY=",
      "title": "alt-svc vs the ability to convey the scheme inside the protocol",
      "url": "https://github.com/httpwg/http-extensions/issues/92",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "See https://lists.w3.org/Archives/Public/ietf-http-wg/2015JulSep/0193.html:\n\n\"Alternative Services MUST NOT be advertised for a protocol that is not \ndesigned to carry the scheme. In particular, HTTP/1.1 over TLS cannot \ncarry safely requests for http resources.\"\n\n...which refers to the :scheme pseudo header field in HTTP/2 \n(http://greenbytes.de/tech/webdav/rfc7540.html#HttpRequest).\n\nAs far as I recall the intention of the statement above is to avoid that \nwhen alt-svc is used to move http traffic to a TLSsy port such as 443, \nthe alternative server gets confused about whether it's serving HTTP or \nHTTPS.\n\nIn reality, even when the protocol _does_ carry the scheme (such as \nin HTTP/2), the _application_ (think PHP running on top of Apache httpd) \nis so distant from the actual server stack that it wouldn't have that \ninformation. This is especially true as long many servers shield \napplications from any knowledge about whether they are accessed over \nHTTP/1.1 or HTTP/2. (Speaking of which, HTTP/1.1 can carry this \ninformation as well, see \nhttp://greenbytes.de/tech/webdav/rfc7230.html#absolute-form).\n",
      "createdAt": "2015-08-13T16:59:06Z",
      "updatedAt": "2015-11-19T15:00:30Z",
      "closedAt": "2015-11-19T02:16:22Z",
      "comments": [
        {
          "author": "icing",
          "authorAssociation": "NONE",
          "body": "It's a security consideration. From protocol pov, using HTTP/2 as Alternate Service will retain the scheme. If that scheme will make it to the web application, possibly residing behind HTTP/1.1 inspired APIs, needs to be considered when advertising Alternate Services.\n\nIn a similar way, TLS+HTTP/1.1 _could_ carry the scheme when using absolute request URIs, but in practise, there is probably a very tall implementation barrier to overcome. There are dusty code paths, never trodden for ages - if at all, where scheme may fall into deep pits of insignificance.\n\nAgain, from pure protocol pov, absolute URIs over TLS could carry the information as well, but no one wants to explore that.\n",
          "createdAt": "2015-09-23T15:40:57Z",
          "updatedAt": "2015-09-23T15:40:57Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I think that @icing has it right.  It is possible in theory, but the rift between theory and practice in this case is large.\n\nThe key thing to highlight here is that the server (implementation or deployment) might need to make its own assessment about safety.  If the API doesn't allow the server to guarantee that the application is properly aware of the scheme of a request, then it should be possible for the server to deny the request on those grounds.\n",
          "createdAt": "2015-09-23T17:24:13Z",
          "updatedAt": "2015-09-23T17:24:13Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Yokohama; needs more discussion on list, as Julian and Martin have different viewpoints on whether the requirement can be removed.\n",
          "createdAt": "2015-11-02T04:24:31Z",
          "updatedAt": "2015-11-02T04:24:31Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "... but adding more guidance to 9.5 is desirable in any case.\n",
          "createdAt": "2015-11-02T04:24:46Z",
          "updatedAt": "2015-11-02T04:24:46Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Straw-man proposal:\n\n\u2702\ufe0e\n\nSome server-side HTTP applications make assumptions about security based upon connection context; for example, equating being served upon port 443 with the use of a HTTPS URL (and the various security properties that implies).\n\nThis affects not only the security properties of the connection itself, but also the state of the client at the other end of it; for example, a Web browser treats HTTPS URLs differently than HTTP URLs in many ways, not just for purposes of protocol handling.\n\nSince one of the uses of Alternative Services is to allow a connection to be migrated to a different protocol and port, these applications can become confused about the security properties of a given connection, sending information (e.g., cookies, content) that is intended for a secure context (e.g., a HTTPS URL) to a client that is not treating it as one.\n\nThis risk can be mitigated in servers by using the URL scheme explicitly carried by the protocol (e.g., \":scheme\" in HTTP/2) as an indication of security context, instead of other connection properties. When the protocol does not explicitly carry the scheme (e.g., as is usually the case for HTTP/1.1 over TLS), servers can mitigate this risk by either assuming that all requests have an insecure context, or by refraining from advertising alternative services for insecure schemes (such as HTTP).\n",
          "createdAt": "2015-11-16T00:54:57Z",
          "updatedAt": "2015-11-16T00:54:57Z"
        },
        {
          "author": "icing",
          "authorAssociation": "NONE",
          "body": "Good enough for me. How exactly scheme needs to be visible and how connection details need to be hidden is beyond the scope of the spec anyway.\n",
          "createdAt": "2015-11-16T09:09:45Z",
          "updatedAt": "2015-11-16T09:09:45Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good. @martinthomson does this work for you?\n",
          "createdAt": "2015-11-16T12:17:25Z",
          "updatedAt": "2015-11-16T12:17:25Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": ":+1: \n",
          "createdAt": "2015-11-16T17:31:37Z",
          "updatedAt": "2015-11-16T17:31:37Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I note that this would also address https://github.com/httpwg/http-extensions/issues/91.\n",
          "createdAt": "2015-11-16T18:25:02Z",
          "updatedAt": "2015-11-16T18:25:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK, let's incorporate that and push a new draft for the WG to review. \n",
          "createdAt": "2015-11-16T23:47:26Z",
          "updatedAt": "2015-11-16T23:47:26Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(adding a mention of HTTP/1.1 absolute form plus references for that and HTTP/2's :scheme)\n\n9.5.  Confusion Regarding Request Scheme\n\n   Some server-side HTTP applications make assumptions about security\n   based upon connection context; for example, equating being served\n   upon port 443 with the use of a HTTPS URL (and the various security\n   properties that implies).\n\n   This affects not only the security properties of the connection\n   itself, but also the state of the client at the other end of it; for\n   example, a Web browser treats HTTPS URLs differently than HTTP URLs\n   in many ways, not just for purposes of protocol handling.\n\n   Since one of the uses of Alternative Services is to allow a\n   connection to be migrated to a different protocol and port, these\n   applications can become confused about the security properties of a\n   given connection, sending information (e.g., cookies, content) that\n   is intended for a secure context (e.g., a HTTPS URL) to a client that\n   is not treating it as one.\n\n   This risk can be mitigated in servers by using the URL scheme\n   explicitly carried by the protocol (e.g., \":scheme\" in HTTP/2 or the\n   \"absolute form\" of the request URI in HTTP/1.1) as an indication of\n   security context, instead of other connection properties ([RFC7540],\n   Section 8.1.2.3 and [RFC7230], Section 5.3.2).\n\n   When the protocol does not explicitly carry the scheme (e.g., as is\n   usually the case for HTTP/1.1 over TLS, servers can, mitigate this\n   risk by either assuming that all requests have an insecure context,\n   or by refraining from advertising alternative services for insecure\n   schemes (such as HTTP).\n",
          "createdAt": "2015-11-17T08:32:14Z",
          "updatedAt": "2015-11-17T08:33:04Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the list of server mitigations we likely want to also include:\n\n  \"or return (421 Not Authoritative?) for insecure scheme requests\n  received over TLS\".\n\nNeither of the other proposed mechanisms protect existing\nsecure applications/servers that assume that port-443/TLS\ntraffic is \"secure\".  Since the \"advertising alternative services\nfor insecure schemes\" would be done over an insecure channel,\nsimply refraining doesn't mitigate attacks if there is an application\nvulnerability due to existing assumptions.\n\nOn Tue, Nov 17, 2015 at 3:32 AM, Julian Reschke notifications@github.com\nwrote:\n\n> 9.5. Confusion Regarding Request Scheme\n> \n> Some server-side HTTP applications make assumptions about security\n> based upon connection context; for example, equating being served\n> upon port 443 with the use of a HTTPS URL (and the various security\n> properties that implies).\n> \n> This affects not only the security properties of the connection\n> itself, but also the state of the client at the other end of it; for\n> example, a Web browser treats HTTPS URLs differently than HTTP URLs\n> in many ways, not just for purposes of protocol handling.\n> \n> Since one of the uses of Alternative Services is to allow a\n> connection to be migrated to a different protocol and port, these\n> applications can become confused about the security properties of a\n> given connection, sending information (e.g., cookies, content) that\n> is intended for a secure context (e.g., a HTTPS URL) to a client that\n> is not treating it as one.\n> \n> This risk can be mitigated in servers by using the URL scheme\n> explicitly carried by the protocol (e.g., \":scheme\" in HTTP/2 or the\n> \"absolute form\" of the request URI in HTTP/1.1) as an indication of\n> security context, instead of other connection properties ([RFC7540],\n> Section 8.1.2.3 and [RFC7230], Section 5.3.2).\n> \n> When the protocol does not explicitly carry the scheme (e.g., as is\n> usually the case for HTTP/1.1 over TLS, servers can, mitigate this\n> risk by either assuming that all requests have an insecure context,\n> or by refraining from advertising alternative services for insecure\n> schemes (such as HTTP).\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/httpwg/http-extensions/issues/92#issuecomment-157308154\n> .\n",
          "createdAt": "2015-11-19T15:00:30Z",
          "updatedAt": "2015-11-19T15:00:30Z"
        }
      ]
    },
    {
      "number": 94,
      "id": "MDU6SXNzdWUxMDUwMTA3MDQ=",
      "title": "add BREACH like attacks to security considerations",
      "url": "https://github.com/httpwg/http-extensions/issues/94",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "cice"
      ],
      "body": "(see thread starting at https://lists.w3.org/Archives/Public/ietf-http-wg/2015JulSep/0295.html)\n",
      "createdAt": "2015-09-05T07:13:28Z",
      "updatedAt": "2015-09-19T18:37:57Z",
      "closedAt": "2015-09-19T18:37:57Z",
      "comments": []
    },
    {
      "number": 95,
      "id": "MDU6SXNzdWUxMDYxNjUwMzE=",
      "title": "Editorial AUTH48 changes for draft-ietf-httpbis-auth-info",
      "url": "https://github.com/httpwg/http-extensions/issues/95",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "auth-info",
        "editorial"
      ],
      "body": "",
      "createdAt": "2015-09-12T14:50:50Z",
      "updatedAt": "2015-09-19T18:37:29Z",
      "closedAt": "2015-09-19T18:37:29Z",
      "comments": []
    },
    {
      "number": 96,
      "id": "MDU6SXNzdWUxMDczODA2MjE=",
      "title": "IANA procedure for alt-svc parameters",
      "url": "https://github.com/httpwg/http-extensions/issues/96",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Currently defined as \"IETF Review\". Is this bar too high?\n",
      "createdAt": "2015-09-20T08:58:28Z",
      "updatedAt": "2015-11-04T09:08:17Z",
      "closedAt": "2015-11-04T09:08:17Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Specification required?\n",
          "createdAt": "2015-10-05T00:05:53Z",
          "updatedAt": "2015-10-05T00:05:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "(or Expert Review?)\n",
          "createdAt": "2015-10-05T00:12:40Z",
          "updatedAt": "2015-10-05T00:12:40Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Yokohama; Expert Review seems most appropriate. \n",
          "createdAt": "2015-11-02T04:27:56Z",
          "updatedAt": "2015-11-02T04:27:56Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "MDU6SXNzdWUxMTEwNzk2NjU=",
      "title": "451 Editorial Feedback",
      "url": "https://github.com/httpwg/http-extensions/issues/102",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "451",
        "editorial"
      ],
      "body": "From Julian.\n### 1\n\n> Feedback should occur on the ietf-http-wg@w3.org mailing list.\n\n(This should go in the boilerplate, not the actual spec text; and yes, the RFC production center will catch it)\n### 2\n\nThe example should use the link header field.\n### 3\n\n> 1.  Security Considerations\n\n1) We don't need a nested subsection here. \n2) Avoid use of lowercased BCP14 terms...\n### 4\n\nWe'll need the IANA considerations for the new link relation as well.\n",
      "createdAt": "2015-10-13T00:29:52Z",
      "updatedAt": "2015-11-16T00:14:09Z",
      "closedAt": "2015-11-16T00:14:09Z",
      "comments": [
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#1 I'll leave for rfc-ed\n#2 added in -03\n#3.1/2 added in -03\n#4 added in -03\n",
          "createdAt": "2015-10-25T21:25:20Z",
          "updatedAt": "2015-10-25T21:25:20Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWUxMTEwODAwMjE=",
      "title": "\"Legal Demand\"",
      "url": "https://github.com/httpwg/http-extensions/issues/103",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [
        "timbray"
      ],
      "labels": [
        "451"
      ],
      "body": "Amos raises:\n\n\"for use when a server operator has a received a legal demand to deny\naccess to a resource\"\n\nThis is a lot more restrictive than what I understood was being agreed\nto. This phrasing implies that a specific-URL DMCA type notice is\nrequired before the status may be used.\n\nIt would be a lot more reasonable to also allow the status to be used\nwhen a blanket law requirement was levelled on the operator. For example\nschools following laws on porn fitering, or national level restrictions\non categories of traffic. In cases like these operators dont receive\nper-resource demands, they often receive a one-off notice \"law X applies\nto you\" and are then expected to censor proactively to the best of their\nability and face the court on overlooked URLs.\n\nProbably this can be resolved with s/legal demand/legal requirement/.\n\nThere are other \"legal demand\" phrase uses elsewhere to keep in sync.\n\nIf \"legal demand\" is being used with a meaning other than a specific\nwarrant DMCA takedown etc. Then that definitely needs to be explained.\n",
      "createdAt": "2015-10-13T00:32:34Z",
      "updatedAt": "2015-11-16T00:13:44Z",
      "closedAt": "2015-11-16T00:13:44Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Suggestion from Ted:\n\n\"for use whenever a server operator has received a legal demand to deny access to a resource or to a set of resources which includes the requested resource.\"\n",
          "createdAt": "2015-10-13T00:32:53Z",
          "updatedAt": "2015-10-13T00:32:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed on list, accept Ted's proposal.\n",
          "createdAt": "2015-10-14T00:26:45Z",
          "updatedAt": "2015-10-14T00:26:45Z"
        },
        {
          "author": "timbray",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added in -03\n",
          "createdAt": "2015-10-25T21:15:05Z",
          "updatedAt": "2015-10-25T21:15:05Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "MDU6SXNzdWUxMTIwNzMwNjE=",
      "title": "Support \"Or\" operator",
      "url": "https://github.com/httpwg/http-extensions/issues/104",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "key"
      ],
      "body": "See: \n  https://github.com/mnot/I-D/issues/21\n",
      "createdAt": "2015-10-19T05:13:24Z",
      "updatedAt": "2016-03-22T19:12:21Z",
      "closedAt": "2016-03-02T04:23:56Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My suggestion is to have OR semantics for key-values of the same type, but AND for key-values of different types.  That would solve most of the sorts of problem that Ilya identified without a need to create operators, which complicate the grammar and implementation considerably.\n\nSo `s=a;s=b` means \"a\" or \"b\", but `s=c;m=d` means \"c\" and \"d\".\n\ncc @igrigorik\n",
          "createdAt": "2015-11-02T05:08:53Z",
          "updatedAt": "2015-11-02T05:08:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@igrigorik please also have a look at discussion in #108. We need to figure out whether this hits the use cases, would appreciate your views.\n",
          "createdAt": "2015-11-12T00:02:53Z",
          "updatedAt": "2015-11-12T00:02:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hey @igrigorik - the problem with defining an operator like that is that it pushes a LOT of complexity into the algorithm and its implementation. Right now, each parameter results in a string that can be written into the secondary cache key, so its processing is very simple. \n\nIt's also not clear how some parameters would combine; e.g., what does `partition=20:30 and match=foo` mean? \n\nIt would really help if we had some **concrete** examples of what people would want to do with OR.\n",
          "createdAt": "2015-11-16T00:12:33Z",
          "updatedAt": "2015-11-16T00:12:33Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> It's also not clear how some parameters would combine; e.g., what does `partition=20:30` and `match=foo` mean?\n\nIf I understand the current semantics correctly, the above would yield <20, <20+foo, 20-30, 20-30+foo, >30, 30+foo buckets? Presumably, adding another match value in there would further extend the number of buckets by another factor of 2?\n\n> It would really help if we had some concrete examples of what people would want to do with OR.\n1. My original example of User-Agent matching is one: https://github.com/mnot/I-D/issues/21#issue-15143707. \n2. I can imagine Cookie use-cases with very similar semantics, where you can have multiple different values that you'd want to resolve to the same cache entry?\n\nPerhaps (1) can be addressed by looking at \"Mobi\" and other substrings.. there are edge cases here across all the various shipped browsers, but maybe that's OK. For (2), arguably the site controls the cookie so they can establish a stable key and use that.\n\nFor existing Client-Hints what we have already is probably enough: you'd use partition against `Width` hint to account for the DPR+resource width variants; or partition against `DPR` or `Viewport-Width`. When combined with Save-Data match you'd then double the number of buckets... there is no way to indicate that some buckets should be combined, but maybe that's ok? If anything that's a feature that could be added later?\n\n@yoavweiss can you think of any edge case here for CH?\n",
          "createdAt": "2015-11-16T20:15:07Z",
          "updatedAt": "2015-11-16T20:15:07Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Bleh. I meant `partition=20:30 OR match=foo`.\n\nI'm starting to suspect that this is primarily about `substr`; I can totally see the use cases there (in UA). For `param`, the major use case is cookies, and like you say, the server can emit those to suit. For `match`, the major use case is \"gzip\", so I don't see strong cases here (yet). For `div` and `partition`, OR doesn't make any sense at all.\n",
          "createdAt": "2015-11-16T23:56:53Z",
          "updatedAt": "2015-11-16T23:56:53Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> I'm starting to suspect that this is primarily about substr. \n\n_nod_. I think it makes sense to scope this discussion substr in particular.\n",
          "createdAt": "2015-11-17T06:02:00Z",
          "updatedAt": "2015-11-17T06:02:00Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK. If that's the case, does something like\n\n> `Key: User-Agent;substr=mobi|android`\n\ndo the trick?\n",
          "createdAt": "2015-11-19T01:35:08Z",
          "updatedAt": "2015-11-19T01:35:08Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Yeah.. Except, what if I have a `|` in my substring? :P\n",
          "createdAt": "2015-11-21T00:29:06Z",
          "updatedAt": "2015-11-21T00:29:06Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Well, we can either escape it, or we can say that we don't think it's likely that the headers that Key will be targeting will contain that character.\n\nI like the latter; IME developers often don't bother to implement escaping in performance-critical code.\n",
          "createdAt": "2015-11-21T01:10:05Z",
          "updatedAt": "2015-11-21T01:10:05Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One CH use case for OR would be \"serving low res version for both 1x as well as Save-Data users\", which would potentially involve `partition` (\"anything below 1.2x\") on `DPR` as well as `match` on `Save-Data`.\n",
          "createdAt": "2015-11-21T05:30:33Z",
          "updatedAt": "2015-11-21T05:30:33Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> `Key: DPR;partition=1.2, Save-Data;match=1`\n\nwould create four potential cache entries:\n1. `DPR` < 1.2, `Save-Data` = 1\n2. `DPR` < 1.2, `Save-Data` != 1\n3. `DPR` > 1.2, `Save-Data` = 1\n4. `DPR` > 1.2, `Save-Data` != 1\n\nIt sounds like you want to collapse 1,2 and 3 into one cache entry, correct?\n",
          "createdAt": "2015-11-23T23:46:56Z",
          "updatedAt": "2015-11-23T23:46:56Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That is correct\n",
          "createdAt": "2015-11-25T08:24:43Z",
          "updatedAt": "2015-11-25T08:24:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hm. It seems like that's going to be hard to do, because `partition` isn't a boolean; it can create an arbitrary number of cache entries. This is the problem I mentioned above, e.g.,\n\n> `Key: DPR;partition=1:2:3 OR Save-Data;match=1`\n\nEven if we did have something that evaluated to truth (e.g., `lessthan`, `greaterthan`), we'd have to pretty fundamentally change the parsing model for the header to something more complex, and there's been good implementer feedback about the simplicity of what we have now.\n\nSo, I wonder if this is nice-to-have, or critical-for-success? Obviously, it will result in more cache misses, but does that make it unusable / uninteresting?\n\nAlso, if it's critical, is that for this specific use case, or as a general facility?\n",
          "createdAt": "2015-11-26T00:06:36Z",
          "updatedAt": "2015-11-26T00:07:10Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd put this in the \"nice-to-have\" bucket. I don't think this is critical for success, and agree that it adds complexity.\n",
          "createdAt": "2015-11-26T08:02:40Z",
          "updatedAt": "2015-11-26T08:02:40Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Hmm, not sure if this is a deal breaker, but it's not a great outcome.. In effect, we're discouraging folks from reporting granular hints. With CH our goal is to get enable the UA/app to advertise any and all relevant hints to the server, each via its own header. However, with the model we have here, each and every key expands the cache space, with no ability to collapse it -- this, in effect, discourages use and deployment of new hints.\n",
          "createdAt": "2015-11-30T18:52:22Z",
          "updatedAt": "2015-11-30T18:52:22Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think that's correct, _when the hints aren't completely orthogonal_. We see the problem above because there's overlap between the effect of the semantics of `DPR` and `Save-Data`.\n\nAre there other examples where that might happen, or is it a one-off?\n",
          "createdAt": "2015-12-04T01:06:02Z",
          "updatedAt": "2015-12-04T01:06:02Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "In a world with ServiceWorkers, where it's easy to mint new headers based on various UA-reported and app/user specific preference, I don't think it's a one-off. \n\nThat said, I guess one solution to this is to have the client collapse some of those headers that interact with each other into a unique preference/header, or massagge reported values to effectively achieve the same grouping -- e.g. if Save-Data is present then override DPR header to always report 1.x, etc.\n\nWith that in mind, perhaps what we have here is sufficient?\n",
          "createdAt": "2015-12-07T20:43:26Z",
          "updatedAt": "2015-12-07T20:43:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thinking about this a bit more. We could introduce limited operators. E.g., we could specify when another header's portion of the key should be discarded.\n\nTaking the example above and adding the calculated secondary cache key:\n\n`Key: DPR;partition=1.2, Save-Data;match=1`\n- DPR < 1.2, Save-Data = 1  `0:1`\n- DPR < 1.2, Save-Data != 1 `0:0`\n- DPR > 1.2, Save-Data = 1  `1:1`\n- DPR > 1.2, Save-Data != 1 `1:0`\n\nWe could at least make 1 and three equivalent like this:\n\n`Key: DPR;partition=1.2, Save-Data;match=1;discard=1:DPR`\n- DPR < 1.2, Save-Data = 1  `:1`\n- DPR < 1.2, Save-Data != 1 `0:0`\n- DPR > 1.2, Save-Data = 1  `:1`\n- DPR > 1.2, Save-Data != 1 `1:0`\n\nbecause `discard=1:DPR` tells us to discard the `DPR` portion of the key if `Save-Data`'s post-processing value is `1`.\n\nThis would need some massaging, of course, and it wouldn't be able to express all of the interdependencies between headers (notice that the second case is still a distinct cache entry). However, it would help avoid a complete combinetric cache explosion.\n\nI'm torn as to whether this is a good idea; Ilya could be right that in complex situations, we'll just fiddle request header semantics and/or synthesise new headers with ServiceWorker (although it'd be a great pity to use SW just for that, I think). \n\nWDYT?\n",
          "createdAt": "2016-02-21T22:43:29Z",
          "updatedAt": "2016-02-21T22:43:29Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> DPR < 1.2, Save-Data = 1 :1\n> DPR < 1.2, Save-Data != 1 0:0\n> DPR > 1.2, Save-Data = 1 :1\n> DPR > 1.2, Save-Data != 1 1:0\n\nThat's better than before, but I suspect that for this use case the desired outcome is:\n- DPR < 1.2, Save-Data = 1: 1x\n- DPR < 1.2, Save-Data != 1: 1x\n- DPR > 1.2, Save-Data = 1: 1x\n- DPR > 1.2, Save-Data != 1: 2x\n\nSo, adding `discard` improves things and reduces unnecessary cache explosion, but doesn't eliminate it.\n",
          "createdAt": "2016-02-22T07:20:18Z",
          "updatedAt": "2016-02-22T07:20:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yep. I don't see a reasonable way to get to that without starting over from scratch, and making it significantly more complex. Happy if someone else can, though.\n",
          "createdAt": "2016-02-22T08:47:40Z",
          "updatedAt": "2016-02-22T08:47:40Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At least for this particular scenario, the browser is not likely to change DPR values, so the cache verbosity is likely to be at the cache servers. \n\nCache servers could avoid storing multiple instances of the same resource by having a 2-step lookup, where lookup-name=>content-hash=>resource-contents so that multiple lookup-names can lead to the same resource-contents if they have the same content-hash.\n\nSo, if this is the only example we can come up with, maybe we should punt this issue until we see more usage in the wild and/or come up with more use cases?\n",
          "createdAt": "2016-02-22T12:00:32Z",
          "updatedAt": "2016-02-22T12:00:32Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> So, if this is the only example we can come up with, maybe we should punt this issue until we see more usage in the wild and/or come up with more use cases?\n\nThat's what I'm leaning towards as well. While not without own set of problems, I think folks can also combine these things into own headers via SW... see https://github.com/httpwg/http-extensions/issues/104#issuecomment-162656089.\n",
          "createdAt": "2016-02-23T00:17:14Z",
          "updatedAt": "2016-02-23T00:17:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "That sounds reasonable to me, but I want to point out that if we punt on it and want to have another crack, we'll probably need to use another header name.\n",
          "createdAt": "2016-02-23T00:22:21Z",
          "updatedAt": "2016-02-23T00:22:21Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Yep. Let's cross that bridge when (and if) we get there.\n",
          "createdAt": "2016-02-23T00:31:35Z",
          "updatedAt": "2016-02-23T00:31:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing with no action (yet).\n",
          "createdAt": "2016-03-02T04:23:56Z",
          "updatedAt": "2016-03-02T04:23:56Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@mnot in https://github.com/httpwg/http-extensions/issues/104#issuecomment-187447282, I thought we were referring to the case of \"orthogonal hints\" (https://github.com/httpwg/http-extensions/issues/104#issuecomment-161842062). FWIW, I do think the earlier suggestion of substr (in https://github.com/httpwg/http-extensions/issues/104#issuecomment-157212831) is something we should support, as I've heard many requests for this -- e.g. the user-agent case, cookies, etc. That said, perhaps we should open a separate bug for that?\n",
          "createdAt": "2016-03-22T19:12:21Z",
          "updatedAt": "2016-03-22T19:12:21Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWUxMTIwNzMxOTA=",
      "title": "Case handling",
      "url": "https://github.com/httpwg/http-extensions/issues/105",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "key"
      ],
      "body": "See:\n  https://github.com/mnot/I-D/issues/67\n",
      "createdAt": "2015-10-19T05:14:23Z",
      "updatedAt": "2018-04-03T23:40:24Z",
      "closedAt": "2018-04-03T23:40:24Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Right now `match` and `substr` are case-sensitive. `param` matches parameter names case-insensitively, but the parameter values are case-sensitive in the cache key.\n",
          "createdAt": "2015-11-11T05:09:08Z",
          "updatedAt": "2015-11-11T05:09:08Z"
        }
      ]
    },
    {
      "number": 106,
      "id": "MDU6SXNzdWUxMTIwNzMzMTM=",
      "title": "Policy for Key parameter registry",
      "url": "https://github.com/httpwg/http-extensions/issues/106",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "key"
      ],
      "body": "See:\n  https://github.com/mnot/I-D/issues/130\n",
      "createdAt": "2015-10-19T05:15:22Z",
      "updatedAt": "2016-03-02T04:37:36Z",
      "closedAt": "2016-03-02T04:37:36Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Random thoughts:\n\nI know we usually try to keep the barrier low, but OTOH lots of uncoordinated extensions here means that cache hit rates could suffer (because unrecognised parameters means the entire header being keyed falls back to Vary behaviour).\n\nSo, IETF Review?\n",
          "createdAt": "2015-11-11T05:06:08Z",
          "updatedAt": "2015-11-11T05:06:08Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Standards Action even.\n",
          "createdAt": "2015-11-11T05:09:43Z",
          "updatedAt": "2015-11-11T05:09:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "SGTM. Will confirm on list.\n",
          "createdAt": "2015-11-12T00:00:17Z",
          "updatedAt": "2015-11-12T00:00:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think IETF Review is sufficient. Its purpose is \"that the document and proposed assignment will be reviewed by the IESG and appropriate IETF WGs (or experts, if suitable working groups no longer exist) to ensure that the proposed assignment will not negatively impact interoperability or otherwise extend IETF protocols in an inappropriate or damaging manner.\"\n\n... which sounds about right.\n",
          "createdAt": "2016-03-02T04:36:46Z",
          "updatedAt": "2016-03-02T04:36:46Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWUxMTIwNzMzNjk=",
      "title": "Whitespace requirement",
      "url": "https://github.com/httpwg/http-extensions/issues/107",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "key"
      ],
      "body": "See:\n  https://github.com/mnot/I-D/issues/131\n",
      "createdAt": "2015-10-19T05:16:10Z",
      "updatedAt": "2016-03-02T04:33:36Z",
      "closedAt": "2016-03-02T04:33:36Z",
      "comments": []
    },
    {
      "number": 108,
      "id": "MDU6SXNzdWUxMTIwNzM0NDY=",
      "title": "field-name cardinality",
      "url": "https://github.com/httpwg/http-extensions/issues/108",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "key"
      ],
      "body": "See:\n  https://github.com/mnot/I-D/issues/132\n",
      "createdAt": "2015-10-19T05:16:59Z",
      "updatedAt": "2015-11-24T00:34:50Z",
      "closedAt": "2015-11-24T00:34:50Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "My initial thought is that the difference in efficiency is going to be extremely minor, and it _might_ be useful to specify a header field name more than once (especially if we do something interesting WRT or in #104.\n\n@zwoop WDYT?\n",
          "createdAt": "2015-11-11T05:04:10Z",
          "updatedAt": "2015-11-11T05:04:10Z"
        },
        {
          "author": "zwoop",
          "authorAssociation": "NONE",
          "body": "It's implementation dependent. If you make a generic API for \"Key\", you'd likely have a callback function to access a header. You could cache this of course, but the naive solution would call multiple times, and that's where I think the inefficiencies could be.\n\nI'm ok with ditching this. But, maybe also consider allowing #104 such that you don't have to repeat the header name? It seems pretty heavy weight to have to say \n\n```\nUser-Agent=x; User-Agent=y; User-Agent=z\n```\n\ninstead of something like\n\n```\nUser-Agent=x|y|z\n```\n",
          "createdAt": "2015-11-11T16:53:31Z",
          "updatedAt": "2015-11-11T16:54:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The idea behind #104 is that `user-agent=(x|y|z)` is really easy to express:\n\n> User-Agent; substr=x; substr=y; substr=z\n\n... while `user-agent=(x|y) & z` is also reasonable:\n\n> User-Agent; substr=x; substr=y, User-Agent; substr=z\n\n... but note that `user-agent=(x&y) | z` is impossible with that syntax.\n\nSo, I think the question is whether this hits the use cases reasonably well; if not, we'll need to re-think.\n\n(And yes, this really belongs in #104).\n",
          "createdAt": "2015-11-11T23:59:27Z",
          "updatedAt": "2015-11-11T23:59:27Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "ping @martinthomson \n",
          "createdAt": "2015-11-11T23:59:52Z",
          "updatedAt": "2015-11-11T23:59:52Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that I'm happy with either outcome here.  I don't think that infinitely complex composition of logical is a goal we should be aiming for.  Overall, I think that I'd prefer to do:\n\n> User-Agent;s=x;s=y\n\nAs `UA=~/(x|y)/` and treat that as sufficient for use cases.\n\nThe question I have for @zwoop would be, what is easier to implement?\n1. reject duplicates\n2. match against all duplicates\n\nMy intuition is that matching all is likely to be easiest because it means that the handling of `Key` can be stateless, which is nice.\n",
          "createdAt": "2015-11-12T00:09:47Z",
          "updatedAt": "2015-11-12T00:09:47Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> I don't think that infinitely complex composition of logical is a goal we should be aiming for\n\n+1\n",
          "createdAt": "2015-11-12T00:25:19Z",
          "updatedAt": "2015-11-12T00:25:19Z"
        },
        {
          "author": "zwoop",
          "authorAssociation": "NONE",
          "body": "Yeah, just matching against all duplicates would be easier. It'd be nice'ish if people avoided it :).\n\nUser-Agent;s=x;s=y seems fine to me, and I definitely agree on not making this overly complex. But there is a real use case for the \"or's\", specially for headers like User-Agent.\n",
          "createdAt": "2015-11-12T22:58:21Z",
          "updatedAt": "2015-11-12T22:59:49Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "If it's genuinely needed, we could confine the complexity to one or two parameters (match, substr) rather than trying to make it generic.\n",
          "createdAt": "2015-11-13T00:18:42Z",
          "updatedAt": "2015-11-13T01:39:15Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "So, just to make sure I understand what we're proposing here...\n- `user-agent;s=x;s=y` - User-Agent =~ x | y.\n- `user-agent;s=x;s=y, user-agent;s=z` - User-Agent =~ (x | y) & z\n- `user-agent;s=x, cookie;s=y` - User-Agent =~ x & Cookie =~ y\n\nIs that right? Are there any other expressions that are possible via current syntax? Here's an [interesting edge case](http://googlewebmastercentral.blogspot.com/2012/11/giving-tablet-users-full-sized-web.html) that may be worth considering:\n\n> Although both Android smartphones and tablets will include the word \u201cAndroid\u201d in the user-agent string, only the user-agent of smartphones will include the word \u201cMobile\u201d. \n\nIn previous incarnation you could handle this with the `n` parameter: `Key: user-agent;s=android;n;s=mobi`. However, with current syntax I don't think it'd be possible to distinguish two entries, one for Android tablet vs smartphone?\n",
          "createdAt": "2015-11-13T00:44:24Z",
          "updatedAt": "2015-11-13T00:44:24Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Looking at the spec again, I think that currently we can't really use multiple instances of a parameter or a header as special syntax; it will complicate things too much. However, we _could_ put it in the parameter values themselves.\n\nE.g., right now, if you did:\n\n> Key: user-agent;substr=android;substr=mobi\n\nYou'll end up with four \"buckets\":\n1. UA contains both `android` and `mobi`\n2. UA contains `android` but not `mobi`\n3. UA contains `mobi` but not `android`\n4. UA contains neither `android` nor `mobi`\n\n... and it would behave the same way if you did:\n\n> Key: user-agent;substr=android, user-agent;substr=mobi\n\nSo, I think that gives you the behaviour you want. \n\nWe _could_ add syntax to `match` and `substr` to avoid creating all of the permutations of buckets, e.g.,\n\n> Key: user-agent;substr=\"android&mobi\"\n\nSo you'd end up with just:\n1. UA contains both `android` and `mobi`\n2. Everything else\n\n... but I very much wonder if that's worth the complexity. Thoughts?\n",
          "createdAt": "2015-11-13T02:00:57Z",
          "updatedAt": "2015-11-13T02:00:57Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "@mnot unless we could key on something horrible like `\"ipad\" or (\"android\" and not \"mobi\")` we'll never cover all the likely-to-be-requested use-cases; and the complexity for adding just a single operator is probably quite high (more operators \u21d2 even more complexity), so the cost-benefit for it isn't great.\n\nHaving the multiple buckets gets us there eventually anyway, it just means GalaxyTab and iPad users wouldn't benefit from each others' requests. It's still better than `Vary:User-Agent`, though. (With the added benefit that it (hopefully) makes server operators think a bit more about what resources they send to whom, and why, and how they're cached.)\n",
          "createdAt": "2015-11-13T03:14:59Z",
          "updatedAt": "2015-11-13T03:14:59Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that until we provide a Turing complete language, someone will always come up with a use case that cannot be met by this mechanism.  That leads either to accepting that this is a doomed effort, or embracing the fact that this has some limitations.  I think that the latter is the only approach where we get something better than what we have today.\n\nAs @mnot notes, the current scheme does allow someone to do a full search.  The only concern being that you have less reuse in cases where the same response covers multiple points in the space.  If you test for \"ipad\", \"android\" and \"mobi\", then you have an 8 point space, with many of those point receiving the same content.  The only disappointing part is that the cache can't reuse from different buckets.\n\nI think that the example @igrigorik described is a great one to look at.  If Chrome on the Nexus 7 and Safari on iPad were willing to change UA strings to include a clear piece of generic identification (like \"tablet\", just sayin'), then the situation improves because fewer buckets are needed to target content to particular devices (or classes of device).\n",
          "createdAt": "2015-11-13T03:56:59Z",
          "updatedAt": "2015-11-13T03:56:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Right. The goal of Key is not to entrench User-Agent sniffing; it's to enable better things like Client Hints, and make things like UA sniffing a bit more tolerable on the way to that.\n",
          "createdAt": "2015-11-13T08:01:07Z",
          "updatedAt": "2015-11-13T08:01:07Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "I don't know the background of why \"Tablet\" is omitted for those devices, but (personally) I agree that we probably should deliver that token in the UA string.. and that we don't have to burden Key with a turing complete language. That said, the \"OR\" use case applies well beyond UA-sniffing.. e.g. keying on cookie header values, which is a common task for many applications.\n\nre, https://github.com/httpwg/http-extensions/issues/108#issuecomment-156295114: interesting, I guess that approach covers most cases, but the fragmentation is painful. Instead of hijacking `&` inside of the value, would it make sense to define an operator that creates a composite key for all the sub-buckets? e.g. `Key: user-agent;substr=a;substr=b;xyz` where xyz is a token that indicates that all the buckets should resolve to same key? Although, I guess that reduces the whole space to an _and_...? Ugh.\n\n_p.s. to be honest, I guess I didn't read the spec close enough, because my interpretation of substr was that substr=a;substr=b would result in same key if `a | b`._\n",
          "createdAt": "2015-11-13T17:02:22Z",
          "updatedAt": "2015-11-13T17:02:22Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "(taking OR discussion back over to #104)\n",
          "createdAt": "2015-11-16T00:12:25Z",
          "updatedAt": "2015-11-16T00:12:25Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think we can close this with no action; make sense?\n",
          "createdAt": "2015-11-16T00:13:25Z",
          "updatedAt": "2015-11-16T00:13:25Z"
        },
        {
          "author": "zwoop",
          "authorAssociation": "NONE",
          "body": "+1. I think #104 covers the concerns here.\n",
          "createdAt": "2015-11-16T00:22:09Z",
          "updatedAt": "2015-11-16T00:22:09Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "MDU6SXNzdWUxMTIwNzM1MzA=",
      "title": "Generational Constant",
      "url": "https://github.com/httpwg/http-extensions/issues/109",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "key"
      ],
      "body": "See:\n  https://github.com/mnot/I-D/issues/133\n",
      "createdAt": "2015-10-19T05:17:40Z",
      "updatedAt": "2018-04-03T23:40:24Z",
      "closedAt": "2018-04-03T23:40:24Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It occurs to me that the secondary key could just include the header field name each time that one is specified in the `Key` header field.  Adding a bogus header field with no parameters would cause the secondary key to include that header field name.  Change the bogus header field and change the secondary key.\n",
          "createdAt": "2015-11-13T04:00:50Z",
          "updatedAt": "2015-11-13T04:00:50Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "MDU6SXNzdWUxMTIwNzM2NjA=",
      "title": "List Styles",
      "url": "https://github.com/httpwg/http-extensions/issues/110",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "key"
      ],
      "body": "from https://github.com/mnot/I-D/issues/135 :\n\nRoy points out that the lists look like section headers; should update when close to RFC editor.\n\nSee:\nhttps://www.rfc-editor.org/rfc-editor/xml2rfcFAQ.html#q_fancy_lists\n",
      "createdAt": "2015-10-19T05:18:48Z",
      "updatedAt": "2015-11-11T04:19:35Z",
      "closedAt": "2015-11-11T04:19:35Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Fixed before -00 submission.\n",
          "createdAt": "2015-11-11T04:19:33Z",
          "updatedAt": "2015-11-11T04:19:33Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "MDU6SXNzdWUxMTIwNzM3NTQ=",
      "title": "Splitting on ','",
      "url": "https://github.com/httpwg/http-extensions/issues/111",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "key"
      ],
      "body": "See:\n  https://github.com/mnot/I-D/issues/137\n",
      "createdAt": "2015-10-19T05:19:16Z",
      "updatedAt": "2015-11-11T06:34:10Z",
      "closedAt": "2015-11-11T06:34:10Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure that this is editorial; it's caused by the lack of standardized header field syntax.\n\nEven if the algorithm pays attention to quoted-string, it's still going to fail if the field syntax uses different quoting mechanisms, such as Link's coded-URL.\n",
          "createdAt": "2015-10-21T08:52:37Z",
          "updatedAt": "2015-10-21T08:52:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The original issue was regarding:\n\n> 1. Create \"key_list\" by splitting \"key_value\" on \",\" characters.\n\n... so this is limited to the Key response header itself, not the request headers its value is referring to.\n",
          "createdAt": "2015-11-11T05:15:17Z",
          "updatedAt": "2015-11-11T05:15:17Z"
        }
      ]
    },
    {
      "number": 112,
      "id": "MDU6SXNzdWUxMTIwNzM4Mzk=",
      "title": "Typo in escaping discussion",
      "url": "https://github.com/httpwg/http-extensions/issues/112",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "key"
      ],
      "body": "See:\n  https://github.com/mnot/I-D/issues/138\n",
      "createdAt": "2015-10-19T05:20:03Z",
      "updatedAt": "2015-11-11T04:48:40Z",
      "closedAt": "2015-11-11T04:48:40Z",
      "comments": []
    },
    {
      "number": 113,
      "id": "MDU6SXNzdWUxMTI1MzczNDE=",
      "title": "[Key] typo in first div example",
      "url": "https://github.com/httpwg/http-extensions/issues/113",
      "state": "CLOSED",
      "author": "waldbaerkoch",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "key"
      ],
      "body": "http://tools.ietf.org/html/draft-ietf-httpbis-key-00#section-2.3.1\n2.3.1. div first example\n...(because, divided by 5, they all result in 1)...\nI think they all result in 0.\n",
      "createdAt": "2015-10-21T08:38:02Z",
      "updatedAt": "2015-11-11T04:48:40Z",
      "closedAt": "2015-11-11T04:48:40Z",
      "comments": []
    },
    {
      "number": 114,
      "id": "MDU6SXNzdWUxMTQ1NTUzNzk=",
      "title": "Editorial AUTH48 changes for draft-ietf-httpbis-cice",
      "url": "https://github.com/httpwg/http-extensions/issues/114",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "cice",
        "editorial"
      ],
      "body": "",
      "createdAt": "2015-11-02T09:20:11Z",
      "updatedAt": "2015-11-04T07:30:48Z",
      "closedAt": "2015-11-04T07:30:48Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Now published as RFC 7694.\n",
          "createdAt": "2015-11-04T07:30:48Z",
          "updatedAt": "2015-11-04T07:30:48Z"
        }
      ]
    },
    {
      "number": 115,
      "id": "MDU6SXNzdWUxMTU2Njc4MzQ=",
      "title": "remove RFC 2616 dependencies",
      "url": "https://github.com/httpwg/http-extensions/issues/115",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "5987bis"
      ],
      "body": "The specification still refers to RFC 2616 when extending that spec's \"parameter\" production. This needs to be updated, in particular as there isn't really a generic \"parameter\" ABNF specs can rely on in HTTP.\n",
      "createdAt": "2015-11-07T13:47:16Z",
      "updatedAt": "2016-09-02T16:35:28Z",
      "closedAt": "2016-09-02T16:35:28Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed in draft 02.\n",
          "createdAt": "2016-09-02T16:35:28Z",
          "updatedAt": "2016-09-02T16:35:28Z"
        }
      ]
    },
    {
      "number": 116,
      "id": "MDU6SXNzdWUxMTU2Njc5MzU=",
      "title": "update usage guidelines to current best practices",
      "url": "https://github.com/httpwg/http-extensions/issues/116",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "5987bis",
        "editorial"
      ],
      "body": "In \"Guidelines for Usage in HTTP Header Field Definitions\":\n- use HTTPbis whitespace definitions\n- use HTTPbis header field ABNF conventions\n",
      "createdAt": "2015-11-07T13:49:30Z",
      "updatedAt": "2016-09-02T16:35:51Z",
      "closedAt": "2016-09-02T16:35:51Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed in draft 02.\n",
          "createdAt": "2016-09-02T16:35:51Z",
          "updatedAt": "2016-09-02T16:35:51Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "MDU6SXNzdWUxMTU5MTUxMjk=",
      "title": "Typo in alt-svc caching example",
      "url": "https://github.com/httpwg/http-extensions/issues/117",
      "state": "CLOSED",
      "author": "rjb1000",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-08#section-3.1\n\n```\nFor example, a response:\n\n HTTP/1.1 200 OK\n Content-Type: text/html\n Cache-Control: 600\n Age: 30\n Alt-Svc: h2c=\":8000\"; ma=60\n```\n\nMissing `max-age=` in `Cache-Control` header?\n",
      "createdAt": "2015-11-09T16:39:01Z",
      "updatedAt": "2015-11-09T17:15:39Z",
      "closedAt": "2015-11-09T17:15:39Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "good catch\n",
          "createdAt": "2015-11-09T17:08:29Z",
          "updatedAt": "2015-11-09T17:08:29Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "MDU6SXNzdWUxMTc5OTk0MDg=",
      "title": "alt-svc: consistency of alternative service(s) terminology and capitalisation",
      "url": "https://github.com/httpwg/http-extensions/issues/118",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc",
        "editorial"
      ],
      "body": "The document uses terminology such as \"Alternative Services\", \"alternative services\" and \"alternative service\". There seems to be a distinction between terms (albeit minor) based on the capitilisation and pluralisation but this is not completely clear to me.\n\nFor example:\n\nhttps://httpwg.github.io/http-extensions/alt-svc.html#rfc.abstract\n\n> This document specifies \"alternative services\" for HTTP,\n\nand  https://httpwg.github.io/http-extensions/alt-svc.html#introduction\n\n> This specification defines a new concept in HTTP, \"Alternative Services\"\n\nand https://httpwg.github.io/http-extensions/alt-svc.html#alternative\n\n> This specification defines a new concept in HTTP, the \"alternative service\".\n\nThe capilisation elsewhere looks ok based on context (titles, start of sentence) but perhaps that is leading to my uncertainty in the first place.\n",
      "createdAt": "2015-11-20T09:23:36Z",
      "updatedAt": "2015-11-22T15:24:57Z",
      "closedAt": "2015-11-22T15:24:57Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, this is not intentional. I'll make sure that the quoted forms are consistent.\n",
          "createdAt": "2015-11-22T15:20:32Z",
          "updatedAt": "2015-11-22T15:20:32Z"
        }
      ]
    },
    {
      "number": 119,
      "id": "MDU6SXNzdWUxMTgwMDA5NTU=",
      "title": "alt-svc: use of \"alternative-protocol\" term",
      "url": "https://github.com/httpwg/http-extensions/issues/119",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc",
        "editorial"
      ],
      "body": "https://httpwg.github.io/http-extensions/alt-svc.html#alternative\n\n>  Each origin maps to a set of these routes \u2014 the default route is derived from the origin itself and the other routes are introduced based on alternative-protocol information. \n\nThis looks like it may be a remnant from Alternate-Protocol. [Section 2.4](https://httpwg.github.io/http-extensions/alt-svc.html#switching) uses the phrase `alternative service protocol`, which seems a little clearer.\n",
      "createdAt": "2015-11-20T09:32:37Z",
      "updatedAt": "2015-11-22T20:35:27Z",
      "closedAt": "2015-11-22T20:35:27Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IMHO it really ought to be \"alternative-service information\".\n",
          "createdAt": "2015-11-22T20:19:13Z",
          "updatedAt": "2015-11-22T20:19:13Z"
        }
      ]
    },
    {
      "number": 120,
      "id": "MDU6SXNzdWUxMTgwMDE1NzE=",
      "title": "alt-svc: section 5 \"a Alt-Used\"",
      "url": "https://github.com/httpwg/http-extensions/issues/120",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc",
        "editorial"
      ],
      "body": "[Section 5](https://httpwg.github.io/http-extensions/alt-svc.html#indicator) \n\n> When using an alternative service, clients SHOULD include a Alt-Used header field in all requests. \n\nShould be `an Alt-Used`?\n",
      "createdAt": "2015-11-20T09:36:12Z",
      "updatedAt": "2015-11-21T08:43:32Z",
      "closedAt": "2015-11-21T08:43:32Z",
      "comments": []
    },
    {
      "number": 121,
      "id": "MDU6SXNzdWUxMTgwMDM0MTc=",
      "title": "alt-svc: Alt-Used security discussion",
      "url": "https://github.com/httpwg/http-extensions/issues/121",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc",
        "editorial"
      ],
      "body": "[Section 5](https://httpwg.github.io/http-extensions/alt-svc.html#indicator) foreshadows a discussion about privacy \n\n> As the Alt-Used header field might be used by the server for tracking the client, a client MAY choose not to include it in its requests for protecting its privacy (see Section 9.4). \n\nHowever, Section 9.4 doesn't contain any mention of Alt-Used. Maybe all the information contained in the document is enough but this just struck me as a little odd.\n",
      "createdAt": "2015-11-20T09:47:06Z",
      "updatedAt": "2015-12-07T07:07:42Z",
      "closedAt": "2015-12-07T07:07:42Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This inconsistency was caused by the fix for https://github.com/httpwg/http-extensions/issues/36.\n\nAFAIR, we made this change because the risk of tracking is there no matter whether Alt-Used is sent (see current Section 9.4). Thus, the simplest possible change would be to remove the whole sentence and the misleading forward reference.\n",
          "createdAt": "2015-11-28T16:57:26Z",
          "updatedAt": "2015-11-28T17:20:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "SGTM.\n",
          "createdAt": "2015-12-06T22:58:01Z",
          "updatedAt": "2015-12-06T22:58:01Z"
        }
      ]
    },
    {
      "number": 122,
      "id": "MDU6SXNzdWUxMTgwMDYxODA=",
      "title": "alt-svc: use of \"Alt-Svc header field\" term before it has been introduced",
      "url": "https://github.com/httpwg/http-extensions/issues/122",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc",
        "editorial"
      ],
      "body": "[Section 2.2](https://httpwg.github.io/http-extensions/alt-svc.html#caching) \n\n> Mechanisms for discovering alternative services also associate a freshness lifetime with them; for example, the Alt-Svc header field uses the \"ma\" parameter. \n\nThe term `Alt-Svc header field` has not been introduced at this stage. It is indicated in Section 2 `This document describes two such mechanisms: an HTTP header field...`, however it may help to name it explicitly there, or somewhere before Section 2.2.\n",
      "createdAt": "2015-11-20T09:59:09Z",
      "updatedAt": "2015-11-22T13:44:16Z",
      "closedAt": "2015-11-22T13:44:16Z",
      "comments": []
    },
    {
      "number": 123,
      "id": "MDU6SXNzdWUxMTk3NzI2NTE=",
      "title": "alt-svc: Question about parameters",
      "url": "https://github.com/httpwg/http-extensions/issues/123",
      "state": "CLOSED",
      "author": "rjb1000",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "alt-svc",
        "editorial"
      ],
      "body": "The Internet Draft specifies a syntax for parameters (Section 3), and an IANA registry to manage their name space (Section 7.3), but doesn't prescribe what parameters should be used for, except for the following fleeting reference:\n\n> ## 7.3.  Alt-Svc Parameter Registry\n> \n> The HTTP Alt-Svc Parameter Registry defines the name space for the cache directives. ...\n\nIs the intention that parameters should only be used as cache directives, as implied by the above sentence? The two parameters specified in the Draft (\"ma\" and \"persist\") are certainly of that flavour. Or is the intention that parameters could be used for other purposes as well?\n\nIf the latter, perhaps the language in section 7.3 could be softened, e.g.\n\n> The HTTP Alt-Svc Parameter Registry defines the name space for parameter names. ...\n\nThe text at Section 3 currently launches into the following with no preamble:\n\n> # 3.  The Alt-Svc HTTP Header Field\n> \n> ...\n> This specification defines two parameters: \"ma\" and \"persist\", defined in Section 3.1.  Unknown parameters MUST be ignored, that is the values (alt-value) they appear in MUST be processed as if the unknown parameter was not present.\n> New parameters can be defined in extension specifications (see Section 7.3 for registration details).\n> ...\n\nHow about inserting a sentence along the following lines:\n\n> Each \"alt-value\" MAY be followed by a semicolon-separated list of additional parameters, each such \"parameter\" comprising a name and a value. This specification defines two parameters...\n\nOr, if you want to constrain the use of parameters in any way, you could do that here.\n",
      "createdAt": "2015-12-01T17:55:15Z",
      "updatedAt": "2015-12-02T11:28:55Z",
      "closedAt": "2015-12-02T07:42:50Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good points.\n\n(The first problem is simply a result of copying and pasting from http://greenbytes.de/tech/webdav/rfc7234.html#cache.directive.registry)\n",
          "createdAt": "2015-12-02T07:22:44Z",
          "updatedAt": "2015-12-02T07:22:44Z"
        },
        {
          "author": "rjb1000",
          "authorAssociation": "NONE",
          "body": "Thanks. You worded it much better than I did :-)\n",
          "createdAt": "2015-12-02T11:28:55Z",
          "updatedAt": "2015-12-02T11:28:55Z"
        }
      ]
    },
    {
      "number": 125,
      "id": "MDU6SXNzdWUxMjE5MzA0NzM=",
      "title": "alternative of alternatives vs invalidation",
      "url": "https://github.com/httpwg/http-extensions/issues/125",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc",
        "editorial"
      ],
      "body": "From @hruellan in https://lists.w3.org/Archives/Public/ietf-http-wg/2015OctDec/0375.html:\n\nIn 2.4, the third paragraphs says that a client can become aware of \nmultiple alternative services, citing: \"or, an alternative service might \nitself advertise an alternative\".\n\nHowever, due to the invalidation rule, if an alternative service \nadvertise an alternative, this new alternative invalidates the previous \nlist of alternatives.\nSo if you have Origin -> alt1 -> alt2, then you keep only alt2 and don't \nhave a list.\nI therefore propose to remove the \"or, an alternative service might \nitself advertise an alternative\".\n",
      "createdAt": "2015-12-13T16:53:25Z",
      "updatedAt": "2015-12-13T17:18:39Z",
      "closedAt": "2015-12-13T17:18:39Z",
      "comments": []
    },
    {
      "number": 126,
      "id": "MDU6SXNzdWUxMjE5MzA2NDg=",
      "title": "clarify invalidation rules wrt altsvc frame",
      "url": "https://github.com/httpwg/http-extensions/issues/126",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc",
        "editorial"
      ],
      "body": "From @hruellan in https://lists.w3.org/Archives/Public/ietf-http-wg/2015OctDec/0375.html:\n\nSection 3.1 defines the rule for invalidation. However, in my sense it \nis not crystal clear that it applies also to alternatives discovered \nthrough the ALTSVC frame.\nI'd suggest adding that the ALTSVC frame is just another way of \ntransmitting an Alt-SVC header field, and therefore all the rules \napplying to the header field also apply to the frame.\nWe may want to go a step further and say the rules defined for the \nAlt-SVC header field apply to any other possibility of discovering \nalternative services (including those not supported).\n",
      "createdAt": "2015-12-13T16:58:18Z",
      "updatedAt": "2015-12-14T08:11:18Z",
      "closedAt": "2015-12-14T08:11:18Z",
      "comments": []
    },
    {
      "number": 130,
      "id": "MDU6SXNzdWUxMjQ0NjkzNDU=",
      "title": "Alt-Svc AD Review Feedback",
      "url": "https://github.com/httpwg/http-extensions/issues/130",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "See https://lists.w3.org/Archives/Public/ietf-http-wg/2015OctDec/0539.html\n",
      "createdAt": "2015-12-31T13:06:32Z",
      "updatedAt": "2016-02-03T13:06:13Z",
      "closedAt": "2016-02-03T13:06:13Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Opened #139 to track one remaining issue.\n",
          "createdAt": "2016-02-03T13:06:13Z",
          "updatedAt": "2016-02-03T13:06:13Z"
        }
      ]
    },
    {
      "number": 131,
      "id": "MDU6SXNzdWUxMjUwMjE1NjQ=",
      "title": "use RFC 7405 ABNF extension",
      "url": "https://github.com/httpwg/http-extensions/issues/131",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Barry in https://lists.w3.org/Archives/Public/ietf-http-wg/2015OctDec/0539.html:\n\n\"Please consider using RFC 7405 for the ABNF for \"clear\".\"\n",
      "createdAt": "2016-01-05T18:15:46Z",
      "updatedAt": "2016-01-05T18:42:50Z",
      "closedAt": "2016-01-05T18:42:50Z",
      "comments": []
    },
    {
      "number": 132,
      "id": "MDU6SXNzdWUxMjY3Njk3MTM=",
      "title": "Use Cases",
      "url": "https://github.com/httpwg/http-extensions/issues/132",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "encryption"
      ],
      "body": "Feedback from @hadleybeeman during TAG discussion: it would be great if use cases were explored a bit in this document, because \"encrypted content\" covers a lot of ground.\n",
      "createdAt": "2016-01-14T23:09:58Z",
      "updatedAt": "2016-06-02T07:33:54Z",
      "closedAt": "2016-06-02T07:33:54Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Use cases mentioned in Introduction.\n",
          "createdAt": "2016-06-02T07:33:54Z",
          "updatedAt": "2016-06-02T07:33:54Z"
        }
      ]
    },
    {
      "number": 133,
      "id": "MDU6SXNzdWUxMjY3NzE5Nzg=",
      "title": "Crypto",
      "url": "https://github.com/httpwg/http-extensions/issues/133",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "encryption"
      ],
      "body": "Get advice from CFRG on crypto choices.\n",
      "createdAt": "2016-01-14T23:24:24Z",
      "updatedAt": "2016-06-03T03:59:19Z",
      "closedAt": "2016-06-03T03:59:19Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson I take it you're comfortable with the amount of consultation done to this point? If so, please close (doubtless we'll get more in WGLC and beyond).\n",
          "createdAt": "2016-06-02T07:34:28Z",
          "updatedAt": "2016-06-02T07:34:28Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, this is not going to improve.  (Feedback was that ChaCha20-Poly1305 or 25519 were better, which might be true, but AES and P-256 were acceptable.)\n",
          "createdAt": "2016-06-03T03:59:19Z",
          "updatedAt": "2016-06-03T03:59:19Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "MDU6SXNzdWUxMjk0MzgzNzU=",
      "title": "encryption-encoding: use two octets to indicate record padding length",
      "url": "https://github.com/httpwg/http-extensions/issues/135",
      "state": "CLOSED",
      "author": "beverloo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "encryption"
      ],
      "body": "Each record currently includes between 1 and 256 octets of padding, while the default record size is set to 4096 octets. This is in many cases not sufficient, for example in the pad-to-next-power-of-two case.\n\nExtending the padding length to two octets will allow up to 65537 octets (65KB) of padding.\n\nI raised this on the ietf-http-wg list here:\n    https://lists.w3.org/Archives/Public/ietf-http-wg/2016JanMar/0171.html\n\nMartin [raises a good point](https://lists.w3.org/Archives/Public/ietf-http-wg/2016JanMar/0175.html) about an upgrade path for existing users. I'll reply on the mailing list to not split the discussion. \n",
      "createdAt": "2016-01-28T12:32:58Z",
      "updatedAt": "2016-04-04T19:22:44Z",
      "closedAt": "2016-04-04T19:22:44Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was fixed in #136 and #137.\n",
          "createdAt": "2016-04-04T19:22:44Z",
          "updatedAt": "2016-04-04T19:22:44Z"
        }
      ]
    },
    {
      "number": 138,
      "id": "MDU6SXNzdWUxMjk2MjYyNzU=",
      "title": "Documenting Refresh: HTTP header",
      "url": "https://github.com/httpwg/http-extensions/issues/138",
      "state": "CLOSED",
      "author": "karlcow",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Maybe @reschke \n\nIn [RFC7538](http://tools.ietf.org/html/rfc7538#section-4) there is a mention of `meta refresh` in HTML. I have seen instances online of a `Refresh` HTTP header. I haven't found any documentation about it in the past (or maybe I missed the appropriate RFC). I [met the header again yesterday](https://bugzilla.mozilla.org/show_bug.cgi?id=668275#c52) in an instance of gmail Web site.\n\nWhen requesting\n`\u2192 http --print hH https://mail.google.com/ 'User-Agent:Mozilla/5.0 (Android 4.4.4; Mobile; rv:44.0) Gecko/44.0 Firefox/44.0' 'Accept-Language:en-US,en;q=0.5'`\n\n``` http\nHTTP/1.1 200 OK\nAlt-Svc: quic=\":443\"; ma=604800; v=\"30,29,28,27,26,25\"\nAlternate-Protocol: 443:quic,p=1\nCache-Control: private, max-age=604800\nContent-Length: 306\nContent-Type: application/xhtml+xml; charset=ISO-8859-1\nDate: Thu, 28 Jan 2016 00:57:39 GMT\nExpires: Thu, 28 Jan 2016 00:57:39 GMT\nRefresh: 0;URL=https://mail.google.com/mail/\nServer: GSE\nX-Content-Type-Options: nosniff\nX-Frame-Options: SAMEORIGIN\nX-XSS-Protection: 1; mode=block\n```\n\nYou might not be able to reproduce gmail has tons of versions depending on the location, devices, headers, etc.\n\nI have started to [test a bit and write about it last year](http://www.otsukare.info/2015/03/26/refresh-http-header). It seems implemented uniformly, but that would require a bit more test. \n\nWhat would be the best course of actions for documenting it? Maybe I can give it a shot. \n",
      "createdAt": "2016-01-29T00:25:15Z",
      "updatedAt": "2019-05-06T21:21:03Z",
      "closedAt": "2016-04-04T16:17:12Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Data point: http://www.otsukare.info/2015/03/26/refresh-http-header\n",
          "createdAt": "2016-01-29T02:02:54Z",
          "updatedAt": "2016-01-29T02:02:54Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "A short Internet-Draft might do it. Would need to align with https://html.spec.whatwg.org/#attr-meta-http-equiv-refresh\n\n@annevk thoughts?\n",
          "createdAt": "2016-01-29T03:17:34Z",
          "updatedAt": "2016-01-29T03:17:34Z"
        },
        {
          "author": "karlcow",
          "authorAssociation": "NONE",
          "body": "Using a very dumb query on [Google BigQuery](https://bigquery.cloud.google.com/) on httparchive data (Maybe someone can do something better than me) just to have a hunch on what was out there.\n\n``` sql\nSELECT respOtherHeaders\nFROM [httparchive:runs.latest_requests] \nWHERE REGEXP_MATCH(respOtherHeaders, r'Refresh =') \nLIMIT 1000\n```\n\nThen cleaning a bit the data being returned.\n\nI see some patterns to be tested (not complete)\n0 and/or a number. 0 is more common.\n\n```\nRefresh: 0\nRefresh: \nRefresh: 1\nRefresh: 1.; url=http://example.com/\nRefresh: 1;\nRefresh: 1; http://example.com/\nRefresh: 1; URL='/'\nRefresh: 1; url=/somewhere\nRefresh: 1; url=http://example.com/\nRefresh: 1; URL=somewhere\nRefresh: 1; url=somewhere\nRefresh: 1;./somewhere\nRefresh: 1;/\nRefresh: 1;/somewhere\nRefresh: 1;url='http://example.com'\nRefresh: 1;URL=/somewhere\nRefresh: 1;URL=http://example.com\nRefresh: 1;url=https://example.com\nRefresh: 1;url=somewhere\nRefresh: ; http://example.com/\nRefresh: ; url=/somewhere\nRefresh: ; url=http://example.com/\nRefresh: Every 15 Minutes\nRefresh: true\n```\n\no_0 `Every 15 Minutes`.\n\nAnyway as usual sometimes a big mess but a subset will probably be interoperable.\n",
          "createdAt": "2016-01-29T06:04:36Z",
          "updatedAt": "2016-01-29T06:31:08Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I was thinking we'd just define this header in HTML directly at some point. Maybe @zcorpan is interested in doing that. He touched refresh last I believe.\n",
          "createdAt": "2016-01-29T14:10:09Z",
          "updatedAt": "2016-01-29T14:10:09Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "(Mainly because defining this properly requires tight integration with the navigation algorithm.)\n",
          "createdAt": "2016-01-29T14:10:39Z",
          "updatedAt": "2016-01-29T14:10:39Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Defining it there would imply that it only applies to browsers. Is this the case?\n",
          "createdAt": "2016-01-29T14:14:02Z",
          "updatedAt": "2016-01-29T14:14:02Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I don't see how that would imply that, but I also have not heard about non-browser support.\n",
          "createdAt": "2016-01-29T14:17:19Z",
          "updatedAt": "2016-01-29T14:17:19Z"
        },
        {
          "author": "zcorpan",
          "authorAssociation": "NONE",
          "body": "There's a bug about this at https://www.w3.org/Bugs/Public/show_bug.cgi?id=28339\n",
          "createdAt": "2016-01-30T03:30:49Z",
          "updatedAt": "2016-01-30T03:30:49Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I don't think it particularly matters where it's defined, as long as we make sure it's reviewed by the appropriate folks and registered. \n",
          "createdAt": "2016-01-30T04:51:16Z",
          "updatedAt": "2016-01-30T04:51:16Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing issue. If someone decides to submit an Internet-Draft, we'll take a look. If it gets done in HTML, give us a shout and we'll review.\n",
          "createdAt": "2016-04-04T16:17:11Z",
          "updatedAt": "2016-04-04T16:17:11Z"
        },
        {
          "author": "buro9",
          "authorAssociation": "NONE",
          "body": "Just a note and not a re-open request:\n\nThe HTML meta refresh is a `http-equiv`, the existence of meta refresh in HTML is to declare that the HTTP refresh header also exists. Every browser appears to treat it that way, to implement the HTML meta refresh they have all implemented the HTTP refresh.\n\nThe bug as it stands is that there is no standard documentation of a refresh header in HTTP (outside of HTML documentation).\n\nI have used the HTTP header at scale and the HTML spec for the header value format works as expected everywhere.\n\nI have also used it in JSON APIs where again it worked (except with primitive bots, which was what I was aiming for that time). I am not convinced the \"solve in the HTML spec\" approach is the right one as it does work outside of HTML.\n",
          "createdAt": "2016-04-04T16:34:02Z",
          "updatedAt": "2016-04-04T16:34:02Z"
        },
        {
          "author": "jsoref",
          "authorAssociation": "NONE",
          "body": "To close some loops, this was eventually addressed by whatwg/html#2892",
          "createdAt": "2019-05-06T21:21:03Z",
          "updatedAt": "2019-05-06T21:21:03Z"
        }
      ]
    },
    {
      "number": 139,
      "id": "MDU6SXNzdWUxMzEwMTkwOTQ=",
      "title": "security considerations wrt system ports",
      "url": "https://github.com/httpwg/http-extensions/issues/139",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "From https://lists.w3.org/Archives/Public/ietf-http-wg/2015OctDec/0539.html:\n\n-- Section 9.1 --\nThe third paragraph assumes that system ports are inherently more secure\nthan user ports, and, as discussion during the development of RFC 6335\nraised, that hasn't been the case for some time.  Many systems no longer\nmake a distinction, and no longet require root authority to listen on\nsystem ports.\n",
      "createdAt": "2016-02-03T13:05:12Z",
      "updatedAt": "2016-02-04T07:12:41Z",
      "closedAt": "2016-02-04T07:12:41Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This would be addressed by https://github.com/httpwg/http-extensions/pull/134\n",
          "createdAt": "2016-02-03T13:05:33Z",
          "updatedAt": "2016-02-03T13:05:33Z"
        }
      ]
    },
    {
      "number": 140,
      "id": "MDU6SXNzdWUxMzEyMDA5Njk=",
      "title": "\"Original-Content-Length\" to indicate data savings",
      "url": "https://github.com/httpwg/http-extensions/issues/140",
      "state": "CLOSED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "This is not CH specific but the desire for such thing has come up a few times...\n1. Client advertises some content/quality/etc preference to the server (e.g. `Save-Data`)\n2. Server responds with an alternate response based on advertised preference (e.g. a \"light\" version of the page, an image with higher compression ratio, etc). \n   - In addition to the `Content-Length` of the response, the server wants to advertise the \"Original content length\" of the response that would have been provided if the preference was not there.\n\nIn the context of `Save-Data` this is to enable user-reporting for amount of bytes saved - e.g. since you've enabled this mode, the browser fetched 100MB, which is 40% less than if you had this disabled.\n\nPopular proxies (e.g. Chrome's Data Saver) already do this via `X-Original-Content-Length`: the proxy reports the content length of before and after applying its optimization. Other popular proxy implementations offer similar functionality (Opera, Yandex, etc). It would be nice to have a standard way to do this, and to enable origins to report this as well. \n\nRelated discussions: \n- https://github.com/igrigorik/http-client-hints/pull/42\n- https://groups.google.com/a/chromium.org/forum/#!searchin/blink-dev/alternate/blink-dev/lj7wSXPBPWE/fE5UGl_2y1QJ\n",
      "createdAt": "2016-02-04T00:33:52Z",
      "updatedAt": "2016-03-22T00:34:59Z",
      "closedAt": "2016-03-22T00:34:59Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's a pretty long name.  Aren't you worried about negating the savings?\n",
          "createdAt": "2016-02-04T02:04:07Z",
          "updatedAt": "2016-02-04T02:04:07Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "![hmm](http://49.media.tumblr.com/tumblr_m161dvVeAQ1r4ghkoo1_500.gif)\n",
          "createdAt": "2016-02-04T02:12:45Z",
          "updatedAt": "2016-02-04T02:12:45Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Not hearing a strong demand for this. Closing. We can reopen if and when that changes.\n",
          "createdAt": "2016-03-22T00:34:59Z",
          "updatedAt": "2016-03-22T00:34:59Z"
        }
      ]
    },
    {
      "number": 141,
      "id": "MDU6SXNzdWUxMzEyMDIzODM=",
      "title": "Should CH headers be treated as simple headers?",
      "url": "https://github.com/httpwg/http-extensions/issues/141",
      "state": "CLOSED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Migrating https://github.com/igrigorik/http-client-hints/issues/68. A quick summary:\n1. CH headers should be seen by ServiceWorker\n2. CH headers should not trigger CORS preflight if...\n   1. Set by the UA and not modified by the developer? \n   2. Set by the UA _or_ the developer? That is, treat them as [simple headers](https://fetch.spec.whatwg.org/#simple-header).\n",
      "createdAt": "2016-02-04T00:44:27Z",
      "updatedAt": "2016-05-04T15:20:11Z",
      "closedAt": "2016-05-04T15:20:10Z",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Related Chromium issue for Save-Data: https://code.google.com/p/chromium/issues/detail?id=584889\n",
          "createdAt": "2016-02-16T22:26:53Z",
          "updatedAt": "2016-02-16T22:26:53Z"
        },
        {
          "author": "sicking",
          "authorAssociation": "NONE",
          "body": "I definitely agree with 1 and 2i. There's no reason to hide the header from SWs or to require preflight for UA-provided CH headers any more than UA-provided accept/user-agent/etc headers.\n\nRegarding 2ii, is it expected that websites will override the CH headers commonly? What is the use case?\n",
          "createdAt": "2016-03-08T23:36:56Z",
          "updatedAt": "2016-03-08T23:36:56Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I expect that some service workers might either request full versions of resources because they want to provide the full experience offline, or leaner versions so that they can save space.\n",
          "createdAt": "2016-03-08T23:47:32Z",
          "updatedAt": "2016-03-08T23:47:32Z"
        },
        {
          "author": "sicking",
          "authorAssociation": "NONE",
          "body": "Fair enough. Yeah, I think it's fine to treat them as simple headers.\n",
          "createdAt": "2016-03-08T23:52:30Z",
          "updatedAt": "2016-03-08T23:52:30Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "This was resolved in https://github.com/whatwg/fetch/commit/404dc3acfddb5e9870fdee333302f80ecff661dd, closing.\n",
          "createdAt": "2016-05-04T15:20:10Z",
          "updatedAt": "2016-05-04T15:20:10Z"
        }
      ]
    },
    {
      "number": 144,
      "id": "MDU6SXNzdWUxMzE4MDc5NzA=",
      "title": "Attacks from same host",
      "url": "https://github.com/httpwg/http-extensions/issues/144",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "When an attacker has the ability to:\n\n1) inject a HTTP header in any response from an origin\n2) listen to a port on the same host\n\nthey can effectively hijack the origin, for browsers that implement OppSec.\n\nE.g., someone on a shared Web host that also offers shell access.\n\nPreviously, Alt-Svc used the port number as a way to mitigate this; however, in #139 we dropped that, because on many systems this is no longer a meaningful way to segment privileged applications. \n\nIn discussion, it was suggested that the origin should opt into OppSec explicitly, e.g., with a `.well-known` file. \n",
      "createdAt": "2016-02-06T02:02:11Z",
      "updatedAt": "2016-03-17T01:06:28Z",
      "closedAt": "2016-03-17T01:06:28Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing as per on-list discussion; there doesn't seem to be much interest in solving this problem.\n",
          "createdAt": "2016-03-17T01:06:28Z",
          "updatedAt": "2016-03-17T01:06:28Z"
        }
      ]
    },
    {
      "number": 145,
      "id": "MDU6SXNzdWUxMzE4MDgwMjg=",
      "title": "Requiring Use of TLS",
      "url": "https://github.com/httpwg/http-extensions/issues/145",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "[Section 5](https://httpwg.github.io/http-extensions/encryption.html#http-tls) roughly sketches the `HTTP-TLS` header. \n\nWe need to decide if this should be included (is it implemented?).\n",
      "createdAt": "2016-02-06T02:03:31Z",
      "updatedAt": "2016-03-17T01:06:50Z",
      "closedAt": "2016-03-17T01:06:50Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Replaced by .well-known mechanism.\n",
          "createdAt": "2016-03-17T01:06:50Z",
          "updatedAt": "2016-03-17T01:06:50Z"
        }
      ]
    },
    {
      "number": 148,
      "id": "MDU6SXNzdWUxMzUwMjE1OTY=",
      "title": "Reasonable Assurances and H2C",
      "url": "https://github.com/httpwg/http-extensions/issues/148",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Brought up in LC, http://www.w3.org/mid/20160209182822.C37A959F@welho-filter2.welho.com.\n1. Examples contain h2c, although this document implies that's not allowed\n2. Examples should clarify that even on the same host, by default we don't allow h2c\n3. Do we need to define \"reasonable assurances\" more tightly, e.g., by requiring something to update this document?\n",
      "createdAt": "2016-02-20T02:13:18Z",
      "updatedAt": "2016-05-10T06:17:40Z",
      "closedAt": "2016-05-10T06:17:40Z",
      "comments": []
    },
    {
      "number": 153,
      "id": "MDU6SXNzdWUxMzk0MjQxNTA=",
      "title": "Network Information API needs citation",
      "url": "https://github.com/httpwg/http-extensions/issues/153",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints",
        "editorial"
      ],
      "body": "A normative one.\n",
      "createdAt": "2016-03-08T23:23:03Z",
      "updatedAt": "2016-03-22T05:04:17Z",
      "closedAt": "2016-03-22T05:04:17Z",
      "comments": []
    },
    {
      "number": 154,
      "id": "MDU6SXNzdWUxMzk0MjQ4Njc=",
      "title": "IANA considerations are a giant list",
      "url": "https://github.com/httpwg/http-extensions/issues/154",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints",
        "editorial"
      ],
      "body": "Which makes this section quite hard to follow.\n\nhttp://httpwg.org/http-extensions/client-hints.html#iana-considerations\n",
      "createdAt": "2016-03-08T23:26:11Z",
      "updatedAt": "2016-03-22T05:04:51Z",
      "closedAt": "2016-03-22T05:04:51Z",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Resolved via https://github.com/httpwg/http-extensions/commit/402717402939aa801d75da3383b0cc5c2693766f\n",
          "createdAt": "2016-03-22T05:04:51Z",
          "updatedAt": "2016-03-22T05:04:51Z"
        }
      ]
    },
    {
      "number": 155,
      "id": "MDU6SXNzdWUxNDAwOTY1MTA=",
      "title": "Define `Accept-CH` more precisely",
      "url": "https://github.com/httpwg/http-extensions/issues/155",
      "state": "CLOSED",
      "author": "sicking",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "The spec currently says that if a server sends `Accept-CH: DPR`, then the `DPR` header should be added \"to all subsequent requests\".\n\nHowever it is (as far as I can tell) completely undefined what a \"subsequent request\" is. Does it affect only future requests to the server which sent the `Accept-CH` header? If the header is sent with the response during a document load, does it affect all requests coming from that document, no matter which server the request goes to?\n\nGenerally speaking, if a CDN which servers images has to send a `Accept-CH: DPR` header before it will receive any `DPR` headers, that means that the first image will have to be served without DPR information. This seems unfortunate since ideally the first image that a page loads is the most important image.\n\nA better solution is that when a browser loads a \"document\" and receives a `Accept-CH` header in the response, that header would affect all the requests that are made from that document, no matter which server the request is going to. If desired, in the future we could add more complex syntax to `Accept-CH` which enables opting in to certain CH headers only for certain servers and/or only for certain resource types.\n\nWe could also add a header which enables a server to opt in to getting specific CH headers for all future requests to that same server. To for example allow an image server to opt in to certain headers even if the document-serving server has not yet adopted the `Accept-CH` header. But I'm not sure how popular such a solution would be given first-load the problem mentioned above.\n",
      "createdAt": "2016-03-11T05:55:18Z",
      "updatedAt": "2016-05-04T15:26:10Z",
      "closedAt": "2016-05-04T15:26:10Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@igrigorik, my understanding is that this is going to be addressed in Fetch and HTML (as discussed during B-A). Can this be closed from the perspective of our spec?\n",
          "createdAt": "2016-05-03T06:44:07Z",
          "updatedAt": "2016-05-03T06:44:07Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "We have ~1/2 of the solution in https://github.com/whatwg/fetch/commit/404dc3acfddb5e9870fdee333302f80ecff661dd#diff-1feda49b40370635faef8b655f144f64R1489. \n\nThe remaining bits are to define the \"parse the header\" algorithm (CH RFC, probably) and associate the policy with the environment settings object (HTML, probably.. see https://github.com/whatwg/fetch/commit/404dc3acfddb5e9870fdee333302f80ecff661dd#diff-1feda49b40370635faef8b655f144f64R900).\n\nI'll track progress for both of the above in https://github.com/httpwg/http-extensions/issues/156. Let's close this and continue there.\n",
          "createdAt": "2016-05-04T15:26:05Z",
          "updatedAt": "2016-05-04T15:26:05Z"
        }
      ]
    },
    {
      "number": 156,
      "id": "MDU6SXNzdWUxNDAxMDE0NTg=",
      "title": "Define more precisely which CH headers are sent by default",
      "url": "https://github.com/httpwg/http-extensions/issues/156",
      "state": "CLOSED",
      "author": "sicking",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "The spec currently says that clients should send CH headers \"based on their default settings, user configuration and/or preferences\". This needs to be more precisely defined in order to not cause interoperability problems between browsers.\n\nI know that there's a tension between not sending too much header data which is commonly not used by servers, thus wasting bandwidth, while also sending enough information that servers can optimize their responses. However leaving the decision out of the spec and up to clients, doesn't make the problem simpler, it just pushes it onto someone else.\n\nWhat I propose is the following:\nFor \"document\" loads, i.e. when browsers make the request during navigation, send the information which is typically needed for websites to determine what markup to serve. So things that let the server choose which version of a responsive-design page to serve first. I'd think this includes things like \"viewport-width\", \"downlink\" and \"save-data\". (We might also want to send other information like, is the device touch-enabled, but that's a separate discussion I think).\n\nFor non-\"document\" loads, serve no CH headers by default and instead let the \"document\" response opt in to which headers should be served for the non-\"document\" requests within that document. See also issue #155.\n",
      "createdAt": "2016-03-11T06:31:23Z",
      "updatedAt": "2016-08-19T04:59:35Z",
      "closedAt": "2016-08-19T04:59:35Z",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "One plausible plumbing approach, borrowing from [referrer policy](https://w3c.github.io/webappsec-referrer-policy/#referrer-policy):\n- Every [settings object](http://www.w3.org/TR/html5/webappapis.html#settings-object) has a **client hints policy** which governs the client hints information sent along with requests. The policy is null if no policy has been set.\n  - _note: we'll have to define how to parse and set it as part of CH draft, I guess._\n- In Fetch... \"A request has an associated client hints policy\".\n- In Fetch, as part of [HTTP-network-or-cache fetch](https://fetch.spec.whatwg.org/#concept-http-network-or-cache-fetch):\n  - If the request is a [navigation request](https://fetch.spec.whatwg.org/#navigation-request), send:\n    - `Downlink`, if known\n    - `Save-Data`, if enabled\n    - `DPR`\n    - `Viewport-Width`\n  - Otherwise, send client hints headers set by the client hints policy.\n\nWDYT? I think that would solve both #155 and #156. The one notable change here, compared to what we've already shipped in Chrome is the \"on by default\" policy for navigation requests for Downlink + Viewport-Width hints.\n\n/cc @annevk @yoavweiss\n",
          "createdAt": "2016-03-22T18:03:11Z",
          "updatedAt": "2016-03-22T20:37:57Z"
        },
        {
          "author": "sicking",
          "authorAssociation": "NONE",
          "body": "Yes, that seems like a good approach. And yes, CH needs to define how to parse and set the \"client hints policy\". Or at least some spec needs to before CH is implementable.\n",
          "createdAt": "2016-03-22T21:49:44Z",
          "updatedAt": "2016-03-22T21:49:44Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "So, Fetch gets updated every time a new hint is defined?\n",
          "createdAt": "2016-03-23T00:50:44Z",
          "updatedAt": "2016-03-23T00:50:44Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do we have an easy way of identifying them as hints so that it would be unnecessary to do that?\n",
          "createdAt": "2016-03-23T01:01:32Z",
          "updatedAt": "2016-03-23T01:01:32Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@mnot @martinthomson do you think that's a no-go? FWIW, I think the number of headers is relatively small and being explicit is OK in this instance.. I can imagine cases where we might want to define a header that's not automatically treated as \"simple header\". \n",
          "createdAt": "2016-03-23T02:29:47Z",
          "updatedAt": "2016-03-23T02:29:47Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think it's OK if every time we create a new hint, we update Fetch (based on the anticipated number / volume).\n",
          "createdAt": "2016-03-23T02:41:06Z",
          "updatedAt": "2016-03-23T02:41:06Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "In which case, the remaining question is: @annevk are you comfortable (re, https://github.com/whatwg/fetch/pull/258) with integrating this as part of Fetch? I'm happy to draft the update. Alternatively, I guess I can try and monkey patch it from CH spec, but that's far less appealing..\n",
          "createdAt": "2016-03-23T04:13:30Z",
          "updatedAt": "2016-03-23T04:13:30Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Yeah, I am. It seems @hsivonen still has concerns with this entire feature, but if Mozilla will ship regardless (?) it sounds like that would be a good way to define all the edge cases here.\n\nAnother way to do this would be to patch the HTML Standard to set these headers as appropriate. Though the HTML Standard, especially the navigate algorithm, still needs some work done so perhaps it's better to use Fetch (at least for now).\n",
          "createdAt": "2016-03-23T08:00:39Z",
          "updatedAt": "2016-03-23T08:00:39Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@hsivonen's [complaints](https://wiki.whatwg.org/wiki/Why_not_conneg) are pretty well grounded in hard experience with inconsistent implementation of these features and the consequences of that.  If it comes back to `User-Agent` scapulimancy because these aren't widely implemented (or implemented incorrectly), then he can say I-told-you-so and the web will rot further.\n\nIn this case, I think that the advantage of having this information available at the server before the client has even seen the first byte is a reasonable argument for the headers.\n",
          "createdAt": "2016-03-23T10:59:59Z",
          "updatedAt": "2016-03-23T10:59:59Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": ":+1: to suggested Fetch integration\n",
          "createdAt": "2016-03-24T13:39:28Z",
          "updatedAt": "2016-03-24T13:39:28Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "If anyone wants to follow along: https://github.com/whatwg/fetch/pull/258 -- initial run at integrating CH and Fetch.\n",
          "createdAt": "2016-03-30T23:10:49Z",
          "updatedAt": "2016-03-30T23:10:49Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "TODO from https://github.com/whatwg/fetch/pull/258#issuecomment-204977118:\n\n>  In your draft, should probably say they define the header field value. A header field consists of a name and a value. \n",
          "createdAt": "2016-04-04T17:43:00Z",
          "updatedAt": "2016-04-04T17:43:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Does anything else need to change in the client-hints spec for this, or can we close the issue?\n",
          "createdAt": "2016-06-07T06:38:38Z",
          "updatedAt": "2016-06-07T06:38:38Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@mnot we're still missing integration with HTML spec - see https://github.com/httpwg/http-extensions/issues/155#issuecomment-216901306. I was using this as a tracker for that work, perhaps we should rename this one?\n",
          "createdAt": "2016-06-07T15:36:28Z",
          "updatedAt": "2016-06-07T15:36:28Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "After discussing it some more.. The remaining integration work (https://github.com/httpwg/http-extensions/issues/155#issuecomment-216901306) is against the HTML spec, so I'll close this and open a tracking issue there. \n",
          "createdAt": "2016-08-19T04:59:35Z",
          "updatedAt": "2016-08-19T04:59:35Z"
        }
      ]
    },
    {
      "number": 159,
      "id": "MDU6SXNzdWUxNDA5ODg2NjU=",
      "title": "Allow cookies without key or value",
      "url": "https://github.com/httpwg/http-extensions/issues/159",
      "state": "CLOSED",
      "author": "inikulin",
      "authorAssociation": "NONE",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "As a part of discussion in whatwg/html#804 I've made a [research](http://inikulin.github.io/cookie-compat/) of the modern browsers compatibility with the RFC 6265. It appears that all browsers nowadays allows cookies without key or (in case of Safari) without value, thus making it de facto standard. However, it's debatable how cookies like `foo;` should be treated: as the cookie without value or without key. Thinking of cookie jar as some kind of key/value store makes it more logical to treat such cookie as cookies without value, but on the other hand, currently most implementers treats them as the cookies with the special empty key.\n",
      "createdAt": "2016-03-15T14:26:29Z",
      "updatedAt": "2020-01-10T07:44:07Z",
      "closedAt": "2020-01-10T07:44:07Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed at Berlin IETF; Julian points out that we should check previous discussion in cookie WG.\nMartin points out that we should talk to the implementation that has divergent behaviour.\n",
          "createdAt": "2016-07-22T08:38:49Z",
          "updatedAt": "2016-07-22T08:38:49Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Context: around https://mailarchive.ietf.org/arch/msg/http-state/7UX_L6HCNbMIyuI2Q9LQ3V7wDgk, ticket in https://trac.tools.ietf.org/wg/httpstate/trac/ticket/1\n",
          "createdAt": "2016-07-22T08:56:31Z",
          "updatedAt": "2016-07-22T08:56:31Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For clarity, are we saying Chrome, Firefox, and Edge treat such a cookie as key: \"\" and value \"foo\", and Safari treats it like key: \"foo\" and value: \"\"?",
          "createdAt": "2018-12-18T18:21:35Z",
          "updatedAt": "2018-12-18T18:21:35Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Per the table linked in OP Safari serializes input `foo` as `foo=` whereas others serialize as `foo`.\r\n\r\nFirefox attempted to be more strict on cookie setting lacking `=` and found it broke a router: https://bugzilla.mozilla.org/show_bug.cgi?id=1551729. \ud83d\ude1f",
          "createdAt": "2019-05-15T13:48:26Z",
          "updatedAt": "2019-05-15T13:48:26Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "https://wpt.fyi/results/cookies/http-state/general-tests.html?label=experimental&label=master&aligned is the relevant test, in particular the following subtests:\r\n\r\n* [0004](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/0004-test) sends `Set-Cookie: foo`. Chromium stores a cookie with an empty name and value of `foo`, serialized as `Cookie: foo`. Firefox does the same. Safari drops the cookie entirely. Given Firefox's experience with <https://bugzilla.mozilla.org/show_bug.cgi?id=1551729> and related bugs above, this seems like it might be baked into some user-visible sites that are unlikely to update. I'd suggest that we change this test expectation to `Cookie: foo`, and update the spec accordingly.\r\n\r\n* [0020](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/0020-test) sends `Set-Cookie: a=b`, `Set-Cookie: =`, and `Set-Cookie: c=d`. Chromium stores three cookies: `(\"a\", \"b\")`, `(\"\", \"\")`, and `(\"c\", \"d\")`, serialized as `Cookie: a=b; ; c=d`. Firefox and Safari store two cookies: `(\"a\", \"b\")` and `(\"c\", \"d\")`, serialized as `Cookie: a=b; c=d`. The latter is clearly correct and matches the spec; filed https://bugs.chromium.org/p/chromium/issues/detail?id=1037996 to change Chromium's behavior.\r\n\r\n* [0021](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/0021-test) sends `Set-Cookie: a=b`, `Set-Cookie: =x`, and `Set-Cookie: c=d`. Chromium stores three cookies: `(\"a\", \"b\")`, `(\"\", \"x\")`, and `(\"c\", \"d\")`, serialized as `Cookie: a=b; x; c=d`. Firefox does the same. Safari stores two cookies: `(\"a\", \"b\")` and `(\"c\", \"d\")`, serialized as `Cookie: a=b; c=d`. If we change 0004 above, then we'd update this test as well to match Chromium and Firefox.\r\n\r\n* [0022](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/0022-test) sends `Set-Cookie: a=b`, `Set-Cookie: x=`, and `Set-Cookie: c=d`. Chromium stores three cookies: `(\"a\", \"b\")`, `(\"x\", \"\")`, and `(\"c\", \"d\")`, serialized as `Cookie: a=b; x=; c=d`. Firefox does the same. Safari also stores the same three cookies, but serializes them as `Cookie: a=b; c=d; x=`. I think this ordering problem is similarly represented in [0016](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/0016-test) and [0017](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/0017-test), and is something that can be dealt with separately from this issue.\r\n\r\n* [0023](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/0023-test) sends `Set-Cookie: foo` and `Set-Cookie:`. Chromium stores `(\"\", \"foo\")`, and then overwrites it with `(\"\", \"\")`. Firefox stores `(\"\", \"foo\")` and ignores the empty cookie. Safari ignores both (as per 0004 and 0021 above). I think Firefox's behavior is most correct here as a logical consequence of the spec change to fix 0004, and I believe Chromium will match it once the bug filed for 0020 above is addressed.\r\n\r\n* [0027](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/0027-test) sends `Set-Cookie: foo` and `Set-Cookie: bar`. Chromium stores `(\"\", \"foo\")`, and then overwrites it with `(\"\", \"bar\")`. Firefox does the same. Safari ignores both. If we change 0004 as above, then Firefox and Chromium's behavior will match the spec, and the test should be updated.\r\n\r\nI'll put up a PR against the spec if folks are on board with the suggestions above.",
          "createdAt": "2019-12-27T08:20:40Z",
          "updatedAt": "2019-12-27T08:20:40Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Putting together a [fix for Chromium's 0020 behavior](https://chromium-review.googlesource.com/1982549), I ran into more excitement:\r\n\r\n0024 (`Set-Cookie: foo`, `Set-Cookie: =`), 0025 (`Set-Cookie: foo`, `Set-Cookie: ; bar`), and 0026 (`Set-Cookie: foo`, `Set-Cookie:    `) show that Firefox overwrites `(\"\", \"foo\")` with `(\"\", \"\")`, and serializes it as \"\". 0028 would show the same, but it's incorrect in the WPT repository; it should contain a tab character, and the expectations are simply wrong (also in the original repo).\r\n\r\nI'd suggest that this behavior doesn't make much sense, and that it would be better for browsers to align on requiring cookies to have _either_ a name _or_ a value, and to ignore `Set-Cookie` headers that parse with empty names and empty values.\r\n\r\nThat would change the expectations for these four tests to expect a serialization of \"Cookie: foo\".\r\n\r\nWDYT, @annevk, @johnwilander?",
          "createdAt": "2019-12-27T09:44:32Z",
          "updatedAt": "2019-12-27T09:55:56Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "For clarity: https://chromium-review.googlesource.com/1982551 shows the test expectations I'd suggest we end up with.",
          "createdAt": "2019-12-27T10:11:02Z",
          "updatedAt": "2019-12-27T10:11:02Z"
        },
        {
          "author": "chlily1",
          "authorAssociation": "NONE",
          "body": "Tl;dr: I think changing the spec to match current implementations for `Set-Cookie: foo` to produce `Cookie: foo` (i.e. 0004 case) makes sense. I think disallowing `Set-Cookie: =` (0020 case) and `Set-Cookie:` (0023 case) would make sense too, but that might break things.\r\n\r\nIn the 0004 case:\r\n\r\nWe've been parsing `Set-Cookie: foo` as an empty name with a non-empty value for a long time, afaict. Since Firefox seems to do the same thing, I think we should definitely update the spec to match the implementations (i.e. for a Set-Cookie line without a `=` but with a valid token, treat the token as the value and, for cookies without a name, don't put a `=` when serializing).\r\n\r\nIn the 0020 (`Set-Cookie: =`) and 0023 (empty `Set-Cookie`) cases:\r\n\r\nJudging by Chrome metrics for Cookie.HeaderLength, there is definitely non-zero usage of empty cookies, so I'm concerned that rejecting empty cookies would break things...\r\n\r\n(In the 0020 case, one could also argue that explicitly sending a Set-Cookie header of `=` indicates intent to create a cookie, even if it is empty.)\r\n\r\nI agree it's a bit silly to allow cookies with both empty name and empty value, though. I think that's a reasonable change to make to the spec, and maybe we don't care about potentially breaking things.",
          "createdAt": "2020-01-02T18:16:27Z",
          "updatedAt": "2020-01-02T18:16:27Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Thanks, @chlily1! I agree with you for the 0004 case. @johnwilander, would Apple be willing to change CFNetwork's behavior to match the suggestions above?\r\n\r\nFor 0020 and 0023:\r\n\r\n> Judging by Chrome metrics for `Cookie.HeaderLength`, there is definitely non-zero usage of empty cookies, so I'm concerned that rejecting empty cookies would break things...\r\n\r\nLooking at the stable channel on for the 28 days ending on Dec 31st, 0.0025% of `Cookie` headers were empty, spread over 0.12% of users. This is a pretty small number in total, and a pretty small number per user; certainly within the range of changes we've been successful with in the past. I wouldn't be surprised if it broke something (because _everything_ we do with cookies breaks something!), but I would be surprised if it broke anything critical enough to retain the behavior.\r\n\r\n> (In the 0020 case, one could also argue that explicitly sending a Set-Cookie header of = indicates intent to create a cookie, even if it is empty.)\r\n\r\nIt would signify an intent to create a cookie without a name and without a value. What would that intent mean? I'd like it to mean \"Don't create a cookie.\" :)",
          "createdAt": "2020-01-03T09:18:51Z",
          "updatedAt": "2020-01-03T09:18:51Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I'm okay with your proposed changes.\r\n\r\ncc @youennf @ddragana @rwlbuis",
          "createdAt": "2020-01-03T10:39:00Z",
          "updatedAt": "2020-01-06T09:11:31Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "https://github.com/httpwg/http-extensions/pull/1018 should cover the proposed changes above. (I kinda want to rewrite the whole parsing algorithm in terms of Infra to be a bit more precise, but that's a task for another patch. :) )",
          "createdAt": "2020-01-03T12:22:51Z",
          "updatedAt": "2020-01-03T12:22:51Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Thanks, @chlily1! I agree with you for the 0004 case. @johnwilander, would Apple be willing to change CFNetwork's behavior to match the suggestions above?\r\n\r\nI\u2019ve pinged the relevant folks to take a look at this thread. Like me, many won\u2019t be back until Monday.\r\n\r\n> \r\n> For 0020 and 0023:\r\n> \r\n> > Judging by Chrome metrics for `Cookie.HeaderLength`, there is definitely non-zero usage of empty cookies, so I'm concerned that rejecting empty cookies would break things...\r\n> \r\n> Looking at the stable channel on for the 28 days ending on Dec 31st, 0.0025% of `Cookie` headers were empty, spread over 0.12% of users. This is a pretty small number in total, and a pretty small number per user; certainly within the range of changes we've been successful with in the past. I wouldn't be surprised if it broke something (because _everything_ we do with cookies breaks something!), but I would be surprised if it broke anything critical enough to retain the behavior.\r\n> \r\n> > (In the 0020 case, one could also argue that explicitly sending a Set-Cookie header of = indicates intent to create a cookie, even if it is empty.)\r\n> \r\n> It would signify an intent to create a cookie without a name and without a value. What would that intent mean? I'd like it to mean \"Don't create a cookie.\" :)\r\n\r\n",
          "createdAt": "2020-01-03T14:56:14Z",
          "updatedAt": "2020-01-03T14:56:14Z"
        },
        {
          "author": "bazzadp",
          "authorAssociation": "NONE",
          "body": "> Looking at the stable channel on for the 28 days ending on Dec 31st, 0.0025% of `Cookie` headers were empty, spread over 0.12% of users. This is a pretty small number in total, and a pretty small number per user; certainly within the range of changes we've been successful with in the past. I wouldn't be surprised if it broke something (because _everything_ we do with cookies breaks something!), but I would be surprised if it broke anything critical enough to retain the behavior.\r\n\r\nNot sure if it's the same thing, but I've seen facebook send an empty `set-cookie:` header frequently.\r\n\r\nFor example visiting https://www.theguardian.com/international loads a 1 pixel gif with the following URL: https://www.facebook.com/tr?id=XXXXXXXXXXX&ev=PageView&noscript=1 (replacing XXXX with your unique tracking reference) with the following response headers (note the blank `set:cookie:` header, third from the bottom):\r\n\r\n```\r\nalt-svc: h3-24=\":443\"; ma=3600\r\ncache-control: no-cache, must-revalidate, max-age=0\r\ncontent-length: 44\r\ncontent-type: image/gif\r\ndate: Fri, 03 Jan 2020 15:43:17 GMT\r\nexpires: Fri, 03 Jan 2020 15:43:17 GMT\r\nlast-modified: Fri, 21 Dec 2012 00:00:01 GMT\r\nserver: proxygen\r\nset-cookie: \r\nstatus: 200\r\nstrict-transport-security: max-age=31536000; includeSubDomains\r\n```\r\n\r\nThis then gets set in the Chrome Cookie jar with the following:\r\n\r\n![image](https://user-images.githubusercontent.com/10931297/71732976-61b11000-2e40-11ea-8a18-c186a46e6f01.png)\r\n\r\nI can't seem to find this showing in Firefox's cookie jar (even when turning off the default Enhance Tracking Protection) nor in Safari.\r\n\r\nAnyway, I'm sure a good few of us wouldn't care if this \"cookie\" died a death, or if Chrome changed to ignore this \"cookie\", and not even sure if it DOES anything (it doesn't seem to be sent in follow up HTTP requests, but that's not to say it's not looked at by some local JavaScript). However, given the prevalence of Facebook tracking I'm really surprised these sorts of cookies are only seen by 0.12% of users so thought I'd comment to note this in case those estimates are not accurate? Perhaps the stats are not picking up these cases?\r\n\r\nI've seen this on many sites and only picked the Guardian as a well-known example and guessed first time it would be on there (news sites are good ones to pick when looking for tracking pixel examples!). https://www.wsj.com/ sets the same if you prefer something US based and https://www.theaustralian.com.au/ sets the same (but not on the main domain) for those of you in that side of the world.",
          "createdAt": "2020-01-03T16:11:13Z",
          "updatedAt": "2020-01-03T16:11:13Z"
        },
        {
          "author": "chlily1",
          "authorAssociation": "NONE",
          "body": "> Looking at the stable channel on for the 28 days ending on Dec 31st, 0.0025% of `Cookie` headers were empty, spread over 0.12% of users. This is a pretty small number in total, and a pretty small number per user; certainly within the range of changes we've been successful with in the past. I wouldn't be surprised if it broke something (because _everything_ we do with cookies breaks something!), but I would be surprised if it broke anything critical enough to retain the behavior.\r\n\r\nThe number of 0-byte Cookie headers is only a lower bound on how many no-name-no-value cookies are in use. If such a cookie were sent along with some other cookies, it would not be logged as a 0-byte header. I don't think we have any metrics on per-cookie length, just the total length of the Cookie header. So it might be worth collecting more data?\r\n\r\nAlso, that metric doesn't include cookies accessed via `document.cookie`.",
          "createdAt": "2020-01-03T18:31:10Z",
          "updatedAt": "2020-01-03T18:31:10Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Regarding @bazzadp's comments on Facebook; I pinged someone there who will forward this to the appropriate team. It sounds like a bug to me, and not something that I think should stop us from making a decision here on the underlying question of whether an empty cookie is a thing we should support.\r\n\r\n@chlily1: I read your comments above as generally approving of the change suggested in https://github.com/httpwg/http-extensions/pull/1018, but cautious about how to ship it in Chrome? That feels like an important part of an eventual \"Intent to Ship\", rather than a discussion of what we'd like the spec to say. If we decide to accept the suggestions above, then I'm pretty confident that we can work out how and when to ship it (especially given that there's no real agreement among browsers today, so the status quo is already trifurcated as per https://github.com/httpwg/http-extensions/issues/159#issuecomment-569233866 above).\r\n\r\n> The number of 0-byte Cookie headers is only a lower bound on how many no-name-no-value cookies are in use.\r\n\r\nIndeed! You're exactly right, and I should have been more clear. The 0.0025% is the number of requests (not page views, FWIW) for which we'd shift from sending an empty `Cookie` header to sending no header at all. That seems to me to be a change more likely to invalidate an application's expectations than shifting from `a=b; ; c=d` to `a=b; c=d`.\r\n\r\n> Also, that metric doesn't include cookies accessed via document.cookie.\r\n\r\nI think this is the easier case, actually, as the serialization of an empty cookie is indistinguishable from a empty cookie jar.",
          "createdAt": "2020-01-04T08:22:39Z",
          "updatedAt": "2020-01-04T08:22:39Z"
        },
        {
          "author": "bazzadp",
          "authorAssociation": "NONE",
          "body": "> Regarding @bazzadp's comments on Facebook; I pinged someone there who will forward this to the appropriate team. It sounds like a bug to me, and not something that I think should stop us from making a decision here on the underlying question of whether an empty cookie is a thing we should support.\r\n\r\nThanks for sending on @mikewest . I more meant it as a concern that the 0.12% of users figure sounds way too low to me given Facebooks prevalence. Note you don\u2019t need to be a Facebook user or visit a Facebook site to get this cookie - just a site that uses Facebook advertising pixels (of which there are many!). So I still have that concern that this figure sounds way too low to me. Which then begs the question as to whether there are more cases than we think there are?\r\n\r\nNow I agree that particular example sounds like a bug and I doubt this empty cookie is being used and so don\u2019t think blocking it off will cause a breakage, but still, I\u2019m uneasy that the stats seem wrong and that we are using this (potentially incorrect) stat to justify the low chance of breakage with this change. There might be other cookies on other sites that will cause breakage. To be clear, I don\u2019t actually think it will cause a lot of breakage, but would rather than was based on a stat we are comfortable to stand behind than one that we have potential concerns with.\r\n\r\nIs there any way to double check that 0.12% stat given this example?\r\n\r\nMaybe a lot less users than I think are getting this cookie but given I\u2019ve spotted it on 3 major news paper sites in 3 distinct countries, without having to look too far for these examples, makes me suspect that is not the case. [Other analysis](https://almanac.httparchive.org/en/2019/third-parties#fig-3) says Facebook assets are being used on 2.38% of the most used 5.7 million sites and I\u2019d guess they all come with some cookies for free. And that stat treats each of those 5.7 million sites equally when actual usage will be heavily skewed to the sites at the top end than the tail so usage will likely be more than that as top end sites are more likely to use Facebook advertising in my opinion. And again, I\u2019m not concerned with this Facebook example - but more that it seems to suggest the 0.12% stat feels wrong.\r\n\r\nOr maybe it\u2019s not being included since this empty cookie doesn\u2019t seem to be sent in follow up requests, and that\u2019s what that stat is measuring? If that\u2019s the reason, and we\u2019re comfortable with that explanation and the risks that entails (I am for what it\u2019s worth), then that\u2019s fine, but thought it worth asking the question.",
          "createdAt": "2020-01-04T09:51:47Z",
          "updatedAt": "2020-01-04T11:51:41Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "As @chlily1 notes above, we don't have statistics on cookie size generally; just aggregate numbers on `Cookie` header length. The \"0.12% of users\" statistic is the set of users who have ever sent an _empty_ `Cookie` header (e.g. the only cookie they have for a given request is empty). If nameless/valueless cookies are set for other sites, they'll be serialized as `...; ;...`, which we don't track specifically. I noted above that I'm less concerned about this case than I am about the \"We used to get a `Cookie` header, but now we don't get anything at all!\" case, but I'm honestly not terribly concerned about either given the existing diversity in the way browsers handle `Set-Cookie: =`.",
          "createdAt": "2020-01-04T11:29:02Z",
          "updatedAt": "2020-01-04T11:29:02Z"
        },
        {
          "author": "bazzadp",
          "authorAssociation": "NONE",
          "body": "OK makes sense. Thanks for answering.",
          "createdAt": "2020-01-04T11:54:30Z",
          "updatedAt": "2020-01-04T11:54:30Z"
        },
        {
          "author": "chlily1",
          "authorAssociation": "NONE",
          "body": "> @chlily1: I read your comments above as generally approving of the change suggested in #1018, but cautious about how to ship it in Chrome?\r\n\r\nYes, that's right.",
          "createdAt": "2020-01-06T16:32:03Z",
          "updatedAt": "2020-01-06T16:32:03Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The CFNetwork team approves of the change and is tracking the work in rdar://problem/58358759.",
          "createdAt": "2020-01-07T00:35:49Z",
          "updatedAt": "2020-01-07T00:35:49Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> The CFNetwork team approves of the change and is tracking the work in rdar://problem/58358759.\r\n\r\nGiven that, I'd suggest that we land something like https://github.com/httpwg/http-extensions/pull/1018 along with the tests from https://chromium-review.googlesource.com/c/chromium/src/+/1982551.\r\n\r\nThanks!",
          "createdAt": "2020-01-07T10:01:15Z",
          "updatedAt": "2020-01-07T10:01:15Z"
        }
      ]
    },
    {
      "number": 160,
      "id": "MDU6SXNzdWUxNDE3NDY1NTc=",
      "title": "Commit without same-host opt-in",
      "url": "https://github.com/httpwg/http-extensions/issues/160",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "Kari raises in WGLC:\n\nIn [5.1. Opportunistic Commitment](https://tools.ietf.org/html/draft-ietf-httpbis-http2-encryption-04#section-5.1):\n\n> An origin can reduce the risk of attacks on opportunistically secured connections by committing to provide an secured, authenticated alternative service.  This is done by including the optional \"commit\" member in the http-opportunistic well-known resource (see Section 6).\n\nThis does not make possible to specify \"commit\" without saying same time that  there is also reasonable assurance for alternative services for on same host which does not provide strong authentication.\n\nThere should be possible to give \"commit\" for authenticated alternatives WITHOUT giving also reasonable assurances for non-authenticated alternatives (on same host that origin).\n\n`/.well-known/http-opportunistic` SHOULD include separate indication that for reasonable assurances. My suggestion for that parameter is same than for \"Attacks from the same host\".\n",
      "createdAt": "2016-03-18T01:08:12Z",
      "updatedAt": "2016-06-02T07:37:53Z",
      "closedAt": "2016-06-02T07:37:53Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There's a fair bit of overlap with #161 -- likely the same ultimate text change to resolve -- but I think the points are slightly different.\n",
          "createdAt": "2016-03-18T22:35:54Z",
          "updatedAt": "2016-03-18T22:35:54Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Please review change above.\n",
          "createdAt": "2016-05-12T01:48:05Z",
          "updatedAt": "2016-05-12T01:48:05Z"
        }
      ]
    },
    {
      "number": 161,
      "id": "MDU6SXNzdWUxNDE5ODk2Njk=",
      "title": "Requirement to filter Alt-Svc header needs explicit normative text",
      "url": "https://github.com/httpwg/http-extensions/issues/161",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "The resolution to #144 implies that the client can trust Alt-Svc headers from the server after finding a .well-known/http-opportunistic resource, but doesn't explain why that should be.\n\nLogically, the attack described depended on the attacker's ability, from hosted content, to inject a value for the Alt-Svc header.  The original solution in the Alt-Svc draft, saying that servers just shouldn't allow this, placed a retroactive requirement on servers that don't support Alt-Svc.  This well-known URI represents a clear signal that the server _does_ support Alt-Svc.\n\nI suggest we add the requirement that servers which advertise the .well-known/http-opportunistic resource MUST prohibit setting the Alt-Svc from unprivileged content.  This is a reasonable implication from the current state of the text, but is not explicitly stated and could easily be missed by a server implementer.\n",
      "createdAt": "2016-03-18T22:07:06Z",
      "updatedAt": "2016-06-02T07:37:46Z",
      "closedAt": "2016-06-02T07:37:46Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in B-A; seemed uncontroversial.\n",
          "createdAt": "2016-05-03T06:29:51Z",
          "updatedAt": "2016-05-03T06:29:51Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@MikeBishop is this still necessary with 33041d7? I could see expanding the text a bit and suggesting it might be worth thinking about, but a MUST seems quite strong.\n",
          "createdAt": "2016-05-12T01:49:13Z",
          "updatedAt": "2016-05-12T01:49:13Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree -- this warrants a recommendation, but assuming that an individual user can't control the .well-known resource and can't convince the server admin to change the values advertised, there's less harm in allowing user-controlled Alt-Svc headers.  Basically, the content owner can make the browser do extra work, trying to use an alternative that isn't valid, but can't actually make a compliant browser go there.  SHOULD?\n",
          "createdAt": "2016-05-12T16:43:11Z",
          "updatedAt": "2016-05-12T16:43:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "When I try to write this, I'm having trouble justifying the SHOULD. Can you suggest some text (and where to put it)? Otherwise, I'm inclined to leave the text as-is.\n",
          "createdAt": "2016-05-26T04:29:53Z",
          "updatedAt": "2016-05-26T04:29:53Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On vacation through 6/1; I can give this a stab when I get back.  Off the top of my head, I\u2019d note in the Security Considerations something like \u201cBecause Alt-Svc is used to describe policies across an entire origin, servers SHOULD NOT permit user content to set or modify the value of this header.\u201d\n\nFrom: Mark Nottingham [mailto:notifications@github.com]\nSent: Thursday, May 26, 2016 12:30 AM\nTo: httpwg/http-extensions http-extensions@noreply.github.com\nCc: Mike Bishop Michael.Bishop@microsoft.com; Mention mention@noreply.github.com\nSubject: Re: [httpwg/http-extensions] Requirement to filter Alt-Svc header needs explicit normative text (#161)\n\nWhen I try to write this, I'm having trouble justifying the SHOULD. Can you suggest some text (and where to put it)? Otherwise, I'm inclined to leave the text as-is.\n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHubhttps://github.com/httpwg/http-extensions/issues/161#issuecomment-221774787\n",
          "createdAt": "2016-05-26T19:17:29Z",
          "updatedAt": "2016-05-26T19:17:29Z"
        }
      ]
    },
    {
      "number": 162,
      "id": "MDU6SXNzdWUxNDE5OTE1MDU=",
      "title": "Separate lifetime from commitment element",
      "url": "https://github.com/httpwg/http-extensions/issues/162",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "Kari has raised an interesting potential weakness with the dual use of .well-known/http-opportunistic.  The presence of the resource indicates support for cross-port Alt-Svc without strong authentication.  The presence of a commit member, however, indicates that only strongly-authenticated alternatives should be used (effectively, opting out of the weaker mode).\n\nHowever, since the commitment to strong auth has an explicitly stated lifetime, while the consent to cross-port doesn't, it's possible for the end result to be that a client believes the server has consented to weak cross-port alternatives after the commitment has expired.\n\nSeveral reasonable solutions exist:\n- Move the duration out to an explicit \"lifetime\" member which details the time for which the entire structure can be treated as valid; \"commit\" would effectively become a flag.\n- HTTP caching semantics might be used for the same purpose; \"commit\" still becomes a flag\n- Explicitly state a desired mode of behavior (strong-auth only, same-host only, same-host or strong auth, etc.) and optionally a lifetime.  This is harder to extend in the future, but may be the clearest today.\n",
      "createdAt": "2016-03-18T22:20:00Z",
      "updatedAt": "2016-07-18T13:07:19Z",
      "closedAt": "2016-07-18T13:07:19Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is a problem because the client might have a still-fresh copy of the http-opportunistic resource, but one that is now older than the `commit` field?  I actually think that is fine, but I would also be OK with the change to having an entry in the resource be more strongly typed (the first or third of your example solutions).\n\nTo eliminate one option, I don't think that caching semantics are something we want to tie too heavily into the semantics here.\n",
          "createdAt": "2016-03-21T00:22:21Z",
          "updatedAt": "2016-03-21T00:22:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "My sense from the discussion in B-A was that we wanted to make things in the .well-known explicit. \n\nE.g., add something like:\n\n```\n\"http-over-tls\": [443, 444]\n```\n\nto indicate that HTTP URIs can be used with TLS over ports 443 and 444.\n\nThis would also take care of #160.\n\nThoughts?\n",
          "createdAt": "2016-05-03T06:29:04Z",
          "updatedAt": "2016-05-03T06:29:04Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "ping @MikeBishop @martinthomson \n",
          "createdAt": "2016-05-10T07:05:54Z",
          "updatedAt": "2016-05-10T07:05:54Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Please review changes above.\n",
          "createdAt": "2016-05-12T01:48:20Z",
          "updatedAt": "2016-05-12T01:48:20Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure that change resolves this issue.  It makes the list of alternatives explicit, but the fact remains that the list of acceptable alternative ports (which may be unauthenticated) lives perpetually (or for the lifetime of the .well-known response), while the commitment lives for a time-limited period.\n\nI still think the cleanest solution here is a \"lifetime\" that applies to the whole response, and \"commit\" is a flag that remains true over the same lifetime.\n",
          "createdAt": "2016-05-12T16:58:48Z",
          "updatedAt": "2016-05-12T16:58:48Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That seems reasonable to me.\n",
          "createdAt": "2016-05-13T00:26:12Z",
          "updatedAt": "2016-05-13T00:26:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Remind me again - why are we not using freshness lifetime for this?\n\nAlso, I'm assuming that the change above is still a good thing (for #160)?\n",
          "createdAt": "2016-05-13T01:56:05Z",
          "updatedAt": "2016-05-13T01:56:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Straw-man:\n\n``` example\n{\n  \"http://example.com\": {\n    \"tls-ports\": [443]\n  },\n  \"http://www.example.com:81\": {\n    \"tls-ports\": [],\n    \"tls-commit\": 86400\n  }\n  \"http:/other.example.com\": {\n    \"tis-ports\": [443,8080],\n    \"tls-commit\": 3600\n  }\n}\n```\n\nThoughts?\n",
          "createdAt": "2016-05-26T04:37:35Z",
          "updatedAt": "2016-05-26T04:37:35Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That works.  Each origin is mapped to a set of ports, and an optional commitment.\n",
          "createdAt": "2016-05-27T02:53:18Z",
          "updatedAt": "2016-05-27T02:53:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Not sure we closed the original issue here - confirm?\n\nI think we need:\n\n```\n{\n  \"http://example.com\": {\n    \"tls-ports\": [443]\n  },\n  \"http://www.example.com:81\": {\n    \"tls-ports\": [],\n    \"tls-commit\": true\n  }\n  \"http:/other.example.com\": {\n    \"tis-ports\": [443,8080],\n    \"tls-commit\": true\n  }\n}\n```\n\nWith some sort of lifetime mechanism. That could be a `lifetime` member, or it could be HTTP caching freshness lifetime.\n\nIf we have a `lifetime` member, I think we have to either a) require it on EVERY origin, or b) fall back to HTTP caching freshness lifetime.\n\nI know my preference. @martinthomson?\n",
          "createdAt": "2016-06-07T04:16:10Z",
          "updatedAt": "2016-06-07T04:16:31Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh yeah, we lost the lifetime.  Can we just make tls-commit a time in seconds?\n",
          "createdAt": "2016-06-08T09:29:14Z",
          "updatedAt": "2016-06-08T09:29:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "That's what's currently in the spec; see straw-man I made before you said \"that works\".\n\nThe problem is that doing so doesn't seem to address the original issue here.\n",
          "createdAt": "2016-06-09T00:19:46Z",
          "updatedAt": "2016-06-09T00:19:46Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let me try to restate:\n\nThere is a possibility that we can have the following state:\n- no reasonable assurances, because the `/.well-known/http-opportunistic` resource does not exist, but\n- a commitment to strong authentication, which has been persisted from a previously-acquired resource.\n\nIt's tempting to say \"well don't do that then\".  The problem here is that the well-known resource is easy to block, which allows an attacker to force a client back to cleartext.  The point of creating the commitment is to make that attack impossible.\n\nThe freshness lifetime option is hazardous because it means that you potentially won't get queries for new copies on shorter timescales, though I guess you could require revalidation or something like that.\n\nA single `lifetime` member at the top level or a lifetime for every alternative is better, I think.  You then don't have to reach down into caching details to make your decisions.  The only risk there is that - outside of any commitment - it creates a situation where the alternative is valid on paper (the lifetime hasn't expired), but it isn't available, but I guess that's no different to advertising an alternative that doesn't exist.\n\nSo, in the interests of a less brittle solution:\n\n``` js\n{ \"http://example.com\": { \"tls-ports\": [443], \"tls-commit\": true, \"lifetime\": 1000 } }\n```\n",
          "createdAt": "2016-06-09T01:37:15Z",
          "updatedAt": "2016-06-09T01:37:15Z"
        }
      ]
    },
    {
      "number": 165,
      "id": "MDU6SXNzdWUxNDUzNDkwMTg=",
      "title": "AUTH48 changes for alt-svc",
      "url": "https://github.com/httpwg/http-extensions/issues/165",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc",
        "editorial"
      ],
      "body": "",
      "createdAt": "2016-04-02T08:00:12Z",
      "updatedAt": "2016-05-10T06:04:20Z",
      "closedAt": "2016-05-10T06:04:20Z",
      "comments": []
    },
    {
      "number": 166,
      "id": "MDU6SXNzdWUxNDU3NjM3NDA=",
      "title": "quoted-string handling  for param directive",
      "url": "https://github.com/httpwg/http-extensions/issues/166",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "key"
      ],
      "body": "It appears that the processing steps for \"param\" do not handle values with quoted-string syntax, wrt (a) not splitting on \",\", (b) unescaping (removing DQUOTE and undoing quoted-pair escaping).\n",
      "createdAt": "2016-04-04T18:19:03Z",
      "updatedAt": "2018-04-03T23:40:24Z",
      "closedAt": "2018-04-03T23:40:24Z",
      "comments": []
    },
    {
      "number": 167,
      "id": "MDU6SXNzdWUxNDU3ODAzMzM=",
      "title": "Confusion Regarding Request Scheme",
      "url": "https://github.com/httpwg/http-extensions/issues/167",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "See https://lists.w3.org/Archives/Public/ietf-http-wg/2016JanMar/0531.html:\n\nWith the latest changes, this now reads:\n\n\"Some HTTP/1.1 implementations use ambient signals to determine if a \nrequest is for an https resource. For example, implementations might \nlook for TLS on the stack or a port number of 443. This is necessary in \nmany cases because the most common form of an HTTP/1.1 request does not \ncarry an explicit indication of the URI scheme. An implementation that \nis serving an opportunistically secured request SHOULD suppress these \nsignals for http resources.\n\nHTTP/1.1 MUST NOT be used to serve opportunistically secured requests. \nHTTP/1.1 can be used to discover an opportunistically secured \nalternative service.\"\n\nThe problem remains that this is not really specific to HTTP/1.1; for \ninstance, code running inside Apache over HTTP/2 may have exactly the \nsame problem (Stefan E. to confirm); so it's more a matter of HTTP \nserver internal APIs, not the on-the-wire protocol.\n\nI believe this needs to be rephrased to better explain the actual \nproblem; and I also remain unconvinced that the conclusion wrt HTTP/1.1 \nmakes sense.\n",
      "createdAt": "2016-04-04T19:25:15Z",
      "updatedAt": "2016-06-02T07:36:47Z",
      "closedAt": "2016-06-02T07:36:47Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in B-A; seemed to be agreement with Julian's position.\n",
          "createdAt": "2016-05-03T06:31:15Z",
          "updatedAt": "2016-05-03T06:31:15Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Please review changes above.\n",
          "createdAt": "2016-05-10T05:22:43Z",
          "updatedAt": "2016-05-10T05:22:43Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep, looks good to me (and sorry for the late reply).\n",
          "createdAt": "2016-05-31T09:21:52Z",
          "updatedAt": "2016-05-31T09:21:52Z"
        }
      ]
    },
    {
      "number": 168,
      "id": "MDU6SXNzdWUxNDU3ODQxNzk=",
      "title": "save-data extensibility",
      "url": "https://github.com/httpwg/http-extensions/issues/168",
      "state": "CLOSED",
      "author": "hardie",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "I understand that the current method has the save-data aspect of client hints as a simple on/off switch.  I wonder, though, about the willingness to consider allowing for some extensibility.  Right now, someone saying \"save-data=on\" is signing up for pretty much anything.   Separating acceptance of data saving for different elements, e.g. agreeing to smaller video resources but not lower fidelity audio, seems like it may be useful.  I suggest that the working group consider making this an extensible field with \"save-date=all\" as the default, with semantics matching the current \"save-data=on\".  Then later extensions can be specified for more granular statements.\n",
      "createdAt": "2016-04-04T19:41:44Z",
      "updatedAt": "2016-06-01T21:29:38Z",
      "closedAt": "2016-05-31T14:43:46Z",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "I think we can already achieve this with current definition:\n- We can define other tokens\n- We can define parameters - e.g. \"on;video-only\", etc.\n\nChanging from \"on\" to \"all\" doesn't really change anything. Also, we already have both client and server implementations that are relying on \"on\". \n\n_p.s. some background: https://github.com/igrigorik/http-client-hints/pull/63/commits/e8bafcf5702e23a4052905137a741274e80d602b_\n",
          "createdAt": "2016-04-06T18:15:45Z",
          "updatedAt": "2016-04-06T18:15:45Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@hardie - any further comment? \n",
          "createdAt": "2016-05-03T06:46:10Z",
          "updatedAt": "2016-05-03T06:46:10Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "NONE",
          "body": "I think the parameter method would be quite useful, and if the doc describes that it would be useful.  I'm less sanguine about introducing parameters later, but I certainly wouldn't fall on any sharp objects if that were the decision of the WG.\n",
          "createdAt": "2016-05-03T15:45:10Z",
          "updatedAt": "2016-05-03T15:45:10Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "I guess we _should_ clarify that it is extensible and define \"on\" as one of its recognized values...\n\n```\nSave-Data = \"Save-Data\" \":\" save-data-token *( \";\" [ token ] )\n            save-data-token = \"on\"\n```\n\nDoes that make sense? I'm sure my ABNF is off.. :)\n",
          "createdAt": "2016-05-04T16:36:16Z",
          "updatedAt": "2016-05-04T16:36:16Z"
        },
        {
          "author": "hardie",
          "authorAssociation": "NONE",
          "body": "On Wed, May 4, 2016 at 9:36 AM, Ilya Grigorik notifications@github.com\nwrote:\n\n> I guess we _should_ clarify that it is extensible and define \"on\" as one\n> of its recognized values...\n> \n> Save-Data = \"Save-Data\" \":\" save-data-token *( \";\" [ token ] )\n>             save-data-token = \"on\"\n> \n> Does that make sense?\n> \n> That does make sense.  I think you need a way to define how someone gets a\n> token value created, and then register \"on\" as the first token value.\n\nregards,\n\nTed\n\n> I'm sure my ABNF is off.. :)\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly or view it on GitHub\n> https://github.com/httpwg/http-extensions/issues/168#issuecomment-216922587\n",
          "createdAt": "2016-05-04T18:22:57Z",
          "updatedAt": "2016-05-04T18:22:57Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Resolved via #179.\n",
          "createdAt": "2016-05-31T14:43:46Z",
          "updatedAt": "2016-05-31T14:43:46Z"
        },
        {
          "author": "vfaronov",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is there a reason to use semicolon here instead of the more typical comma?\n\nAlso, the grammar does seem off: it does not allow whitespace (because the \u201cimplied `*LWS`\u201d rule of RFC\u00a02616 no longer applies), and it uses `:` instead of `=`. Assuming you really want semicolons, I think it should be:\n\n```\n     Save-Data = sd-token *( OWS \";\" OWS [sd-token] )\n```\n\n(I can file a separate issue if you want)\n",
          "createdAt": "2016-05-31T16:19:08Z",
          "updatedAt": "2016-05-31T16:22:44Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wouldn't say comma is \"typical\" -- it depends a bit on the use case. For instance, alt-svc uses a list of comma-delimited directives, each of which can have semicolon delimited parameters.\n\nIn any case, if this does not use commas, the spec ought to state what happens when commas turn up in a field value, or if a field occurs multiple times in a messages (this is stated for the other client hints).\n",
          "createdAt": "2016-06-01T10:36:27Z",
          "updatedAt": "2016-06-01T10:36:27Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> I wouldn't say comma is \"typical\" -- it depends a bit on the use case. For instance, alt-svc uses a list of comma-delimited directives, each of which can have semicolon delimited parameters.\n\nThat, indeed, was the intent - e.g. \"on;video-only\". \n\nRe, OWS: good catch. Addressed in https://github.com/httpwg/http-extensions/pull/190.\n",
          "createdAt": "2016-06-01T21:29:38Z",
          "updatedAt": "2016-06-01T21:29:38Z"
        }
      ]
    },
    {
      "number": 169,
      "id": "MDU6SXNzdWUxNDYzNDA0NTI=",
      "title": "UA sniffing",
      "url": "https://github.com/httpwg/http-extensions/issues/169",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "key"
      ],
      "body": "In examples, the document shows how it can improve conneg when the server varies the response based on the \"User-Agent\" request header field. It would be good to insert a quick reminder that doing things like this is a last resort and ought to be avoided.\n",
      "createdAt": "2016-04-06T14:55:36Z",
      "updatedAt": "2018-04-03T23:40:24Z",
      "closedAt": "2018-04-03T23:40:24Z",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@reschke which spec is this for?\n",
          "createdAt": "2016-04-07T16:59:45Z",
          "updatedAt": "2016-04-07T16:59:45Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"key\" - sorry, forgot to label it.\n",
          "createdAt": "2016-04-07T17:22:14Z",
          "updatedAt": "2016-04-07T17:22:14Z"
        }
      ]
    },
    {
      "number": 170,
      "id": "MDU6SXNzdWUxNDY3NDA0MzQ=",
      "title": "Treat cookies that are set on http:// origins as ephemeral",
      "url": "https://github.com/httpwg/http-extensions/issues/170",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "Note that the definition and scope of \"ephemeral\" is somewhat challenging given session restore capabilities.\n\nSee https://bugzilla.mozilla.org/show_bug.cgi?id=1160368#c10\n\nAnd http://mzl.la/1S62L0s\n",
      "createdAt": "2016-04-07T21:00:57Z",
      "updatedAt": "2016-06-22T06:38:25Z",
      "closedAt": "2016-06-22T06:38:25Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Martin, could you write up a _short_ spec for this? I'm talking one-page I-D.\n\nPing @mikewest \n",
          "createdAt": "2016-05-10T06:07:22Z",
          "updatedAt": "2016-05-10T06:07:22Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have put it on the list.  Only five new drafts on the list this time around (if I actually write them).\n",
          "createdAt": "2016-05-10T06:10:04Z",
          "updatedAt": "2016-05-10T06:25:33Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing, as we have a separate draft for this now.\n",
          "createdAt": "2016-06-22T06:38:25Z",
          "updatedAt": "2016-06-22T06:38:25Z"
        }
      ]
    },
    {
      "number": 171,
      "id": "MDU6SXNzdWUxNDcxMzQ3NjA=",
      "title": "CACHE_DIGEST: clients should seed hash and send seed",
      "url": "https://github.com/httpwg/http-extensions/issues/171",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "To avoid hot-spots with collisions across many clients, it would be good for clients to use a random seed to seed their hashes and to send this along.\n\nConsiderations:\n- This makes things somewhat more expensive for servers who have to recompute the hashes\n- Care should be taken to make sure the seed isn't persisted in a scope that allows it to be used for tracking (or the seed should be small enough to make this less of an issue).\n",
      "createdAt": "2016-04-09T14:50:20Z",
      "updatedAt": "2016-05-10T06:02:27Z",
      "closedAt": "2016-05-10T06:02:27Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why not derive the seed somehow?  Even a small amount of connection-bound entropy should suffice to split things up.  Worst case, use a TLS exporter, but folding in source ip and port might be enough to avoid problems.\n",
          "createdAt": "2016-04-09T17:56:24Z",
          "updatedAt": "2016-04-09T17:56:24Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "This spec hasn't been adopted by the WG.\n",
          "createdAt": "2016-05-10T06:02:27Z",
          "updatedAt": "2016-05-10T06:02:27Z"
        }
      ]
    },
    {
      "number": 172,
      "id": "MDU6SXNzdWUxNDcxMzUwNDU=",
      "title": "CACHE_DIGEST: use a non-cryptographic hash",
      "url": "https://github.com/httpwg/http-extensions/issues/172",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Unless there are security problems with hash collisions, it would be better to use a non-cryptographic hash.  Not only is this much faster, but it removes a need to migrate when SHA256 becomes weak and needs to be retired.  If we stick with SHA256 due to security properties, a crypto hash negotiation scheme may be required in the frame.\n",
      "createdAt": "2016-04-09T14:52:44Z",
      "updatedAt": "2016-05-10T06:02:16Z",
      "closedAt": "2016-05-10T06:02:15Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "This spec hasn't been adopted by the WG.\n",
          "createdAt": "2016-05-10T06:02:15Z",
          "updatedAt": "2016-05-10T06:02:15Z"
        }
      ]
    },
    {
      "number": 174,
      "id": "MDU6SXNzdWUxNTAwODQyMTc=",
      "title": "HTTP/2 PUSH cache mechanism?",
      "url": "https://github.com/httpwg/http-extensions/issues/174",
      "state": "CLOSED",
      "author": "bmeck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Unsure if this is the right place to ask. Is there an existing effort to make a header for HTTP/2's PUSH promises able to sync dependency trees?\n\nConsider:\n\n``` html\n<!-- index.html -->\n<script type=\"module\" src=\"a\"></script>\n```\n\n``` js\n// a\nimport \"b\";\n```\n\n``` js\n// b\nimport \"c\";\n```\n\nAnd so on...\n\nRight now we can PUSH `a`, `b`, etc. when `index.html` is requested. However, when we receive an etag for `index.html` we are unsure what revision of dependencies are in the cache for `a`, `b`, etc.\n\nI saw CACHE_DIGEST, but was wondering if there was an effort to make dependency tree caching available to reduce chatter for PUSH of large/deep resources as are common in JS applications.\n",
      "createdAt": "2016-04-21T14:03:17Z",
      "updatedAt": "2016-04-26T02:58:20Z",
      "closedAt": "2016-04-26T02:58:20Z",
      "comments": [
        {
          "author": "gaperik",
          "authorAssociation": "NONE",
          "body": "Do you mean making it available to the http layer in the UA or Web  app, e.g. SW JS, or both?\n",
          "createdAt": "2016-04-21T14:05:20Z",
          "updatedAt": "2016-04-21T14:05:20Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "NONE",
          "body": "I was talking about a header the server can send back w/ PUSH to declare the dependency tree version / digest. Then the client sends it back along w/ Etag when requesting anything with PUSH dependencies like `index.html` in this example.\n",
          "createdAt": "2016-04-21T14:11:46Z",
          "updatedAt": "2016-04-21T14:11:46Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "NONE",
          "body": "So, no JS API.\n",
          "createdAt": "2016-04-21T14:11:56Z",
          "updatedAt": "2016-04-21T14:11:56Z"
        },
        {
          "author": "gaperik",
          "authorAssociation": "NONE",
          "body": "...and sorry, yes, this is the place and time to discuss this i believe. Just to make thing clear for us pondering browser clients; there is one cache in the HTTP layer of the UA and one in the SW...\n",
          "createdAt": "2016-04-21T14:12:05Z",
          "updatedAt": "2016-04-21T14:12:05Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "NONE",
          "body": "We had a thought of [a solution using `Vary: Cookie`](https://docs.google.com/presentation/d/17JX15-Kq_5DGd7ALoa2qqdbEAGSnuF7dsg_7kBKHJKY/edit?usp=sharing) but that is not going to work w/ CDNs.\n\nOur solution was less than optimal because cookies are applied once parsed and cannot be placed in the trailer to only be applied after a fully successful request (including PUSH promises). It did have some nice effects of doing delta based cache invalidation though.\n",
          "createdAt": "2016-04-21T14:15:48Z",
          "updatedAt": "2016-04-21T14:15:48Z"
        },
        {
          "author": "gaperik",
          "authorAssociation": "NONE",
          "body": "Ok, just saw your response; you are focusing on the http layer cache. \n\nyes, it's part of several discussions I would say. This was presented at Buenos Aires https://datatracker.ietf.org/doc/draft-kazuho-h2-cache-digest/. The use of Link header to inform a client about such stufff as an ODG has been mentioned. Expect it to be a piece of the puzzle here.\n",
          "createdAt": "2016-04-21T14:16:59Z",
          "updatedAt": "2016-04-21T14:16:59Z"
        }
      ]
    },
    {
      "number": 177,
      "id": "MDU6SXNzdWUxNTUzNjMxMzE=",
      "title": "ORIGIN:  Support deltas",
      "url": "https://github.com/httpwg/http-extensions/issues/177",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "origin-frame"
      ],
      "body": "During the discussion of the Secondary Certs work, Nick S. raised the point that it would be interesting to be able to inform the client about dependent domains which are also served by this server as the server returns content that references it.  In order to do this incrementally, an ORIGIN frame would need to be additive -- each successive frame augmenting the client's list of allowed domains.  However, we still need to support the original case, scoping it down.\n\nI'd suggest changing the semantics to be additive and defining a flag whose presence/absence means that the existing list (initially inferred from the certificate) be discarded before processing this frame.\n",
      "createdAt": "2016-05-17T21:12:28Z",
      "updatedAt": "2016-10-11T05:51:08Z",
      "closedAt": "2016-10-11T05:51:08Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that there is value in having the initial set be empty.  It avoids inference issues, particularly with wildcard certificates.\n",
          "createdAt": "2016-05-19T13:38:28Z",
          "updatedAt": "2016-05-19T13:38:28Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "In cache digests, we've just put in a `reset` flag (on the frame) with these semantics. Sound good?\n",
          "createdAt": "2016-05-31T05:14:05Z",
          "updatedAt": "2016-05-31T05:14:05Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Works for me.\n\nFrom: Mark Nottingham [mailto:notifications@github.com]\nSent: Monday, May 30, 2016 10:14 PM\nTo: httpwg/http-extensions http-extensions@noreply.github.com\nCc: Mike Bishop Michael.Bishop@microsoft.com; Author author@noreply.github.com\nSubject: Re: [httpwg/http-extensions] ORIGIN: Support deltas (#177)\n\nIn cache digests, we've just put in a reset flag (on the frame) with these semantics. Sound good?\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/httpwg/http-extensions/issues/177#issuecomment-222594090, or mute the threadhttps://github.com/notifications/unsubscribe/AEE2haxIcbMw_2w5K8kHfCUd880mrDeWks5qG8OggaJpZM4IgtSY.\n",
          "createdAt": "2016-06-02T03:17:05Z",
          "updatedAt": "2016-06-02T03:17:05Z"
        }
      ]
    },
    {
      "number": 178,
      "id": "MDU6SXNzdWUxNTU3Mzk2OTI=",
      "title": "Wildcard names",
      "url": "https://github.com/httpwg/http-extensions/issues/178",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "origin-frame"
      ],
      "body": "If an origin has a wildcard certificate, the origin frame allows it to narrow scope.  But if we accept #177, then there is the potential for the origin to lose any claim to wildcards without enumerating the entire space (at high cost and with a privacy risk).  One way to avoid that would be to support the use of a wildcard.  The rules in RFC2818 are probably appropriate.\n",
      "createdAt": "2016-05-19T13:42:14Z",
      "updatedAt": "2017-04-19T01:32:42Z",
      "closedAt": "2017-04-19T01:32:42Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thinking out loud, what about two new flags:\n- `INHERIT` - if true, we assume that all origins implied by the presented cert are usable on this connection.\n- `NOT` - if true, the origins in the frame are subtracted from the set of origins usable on this connection.\n\nIn conjunction, that would give more flexibility (and brevity) than wildcards, and be easier to process (is just strings). Would have to work out the interaction with the certs draft tho.\n",
          "createdAt": "2016-05-31T05:19:08Z",
          "updatedAt": "2016-05-31T05:19:08Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The implication being that if both were specified, you would be saying \"what is in my cert, except these things\".\n\nIf we do something like `NOT`, then the implication is that there is an existing understanding of the set of origins that are active.  That would need careful definition, and maybe a `RESET` flag so that you can incrementally modify the set in the common case, but set back to baseline as you see fit.\n",
          "createdAt": "2016-05-31T05:55:17Z",
          "updatedAt": "2016-05-31T05:55:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yup, pretty much.\n\nNOT also allows me to pare away origins in a long-lived connection (e.g., for load balancing).\n",
          "createdAt": "2016-05-31T06:00:35Z",
          "updatedAt": "2016-05-31T06:00:35Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh, that's devious, it's like alt-svc without the actual useful parts.\n",
          "createdAt": "2016-05-31T06:02:09Z",
          "updatedAt": "2016-05-31T06:02:09Z"
        },
        {
          "author": "equalsJeffH",
          "authorAssociation": "NONE",
          "body": "in terms of which spec to reference for wildcard-cert name matching, it ought to be RFC6125.\n",
          "createdAt": "2016-07-18T12:29:21Z",
          "updatedAt": "2016-07-18T12:29:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "See recent changes; they define the origin(s) that the connection is authoritative for as the starting Origin Set -- including wildcard certs.\n\nThis doesn't allow a wildcard cert to be added; e.g., if Mike's certs draft eventually allows you to add a wildcard cert to the connection, you'd have to enumerate each origin covered by the wildcard to get them into the origin set. \n\nSo, the remaining question is whether we want to allow wildcards into the origin syntax itself.\n",
          "createdAt": "2016-08-20T01:17:38Z",
          "updatedAt": "2016-08-20T01:17:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "This seems to be overtaken by events; pleas comment if you disagree.",
          "createdAt": "2017-04-19T01:32:42Z",
          "updatedAt": "2017-04-19T01:32:42Z"
        }
      ]
    },
    {
      "number": 182,
      "id": "MDU6SXNzdWUxNTc1ODU3NzY=",
      "title": "Need style for `<span class=tt>`",
      "url": "https://github.com/httpwg/http-extensions/issues/182",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "These are being displayed in proportional font on gh-pages.\n",
      "createdAt": "2016-05-31T04:02:22Z",
      "updatedAt": "2016-05-31T04:28:42Z",
      "closedAt": "2016-05-31T04:28:42Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "example?\n",
          "createdAt": "2016-05-31T04:03:40Z",
          "updatedAt": "2016-05-31T04:03:40Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Check out instances of \"the tls-commit member\" in op-sec.\n",
          "createdAt": "2016-05-31T04:04:06Z",
          "updatedAt": "2016-05-31T04:04:06Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Need to fix it in mnot/rfcbootstrap; @reschke has gone and updated the XSLTs again... \n",
          "createdAt": "2016-05-31T04:13:01Z",
          "updatedAt": "2016-05-31T04:13:01Z"
        }
      ]
    },
    {
      "number": 184,
      "id": "MDU6SXNzdWUxNTc3MzE4NjQ=",
      "title": "Client hints import unused ABNF rules",
      "url": "https://github.com/httpwg/http-extensions/issues/184",
      "state": "CLOSED",
      "author": "vfaronov",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints",
        "editorial"
      ],
      "body": "`draft-ietf-httpbis-client-hints.md`:\n\n> It includes by reference the DIGIT rule from {{RFC5234}}; the OWS, field-name and quoted-string rules from {{RFC7230}}; and the parameter rule from {{RFC7231}}.\n\nThe `quoted-string` and `parameter` rules are not used in the document.\n\nThe `OWS` rule is not used in the document, unless you accept [my comment on `Save-Data`](https://github.com/httpwg/http-extensions/issues/168#issuecomment-222740727).\n\nThe `field-name` rule is not used in the document, but I think it can be useful to clarify the definition of `Accept-CH`, i.e.:\n\n```\nAccept-CH = #field-name\n```\n",
      "createdAt": "2016-05-31T17:54:54Z",
      "updatedAt": "2016-06-07T06:36:09Z",
      "closedAt": "2016-06-07T06:36:09Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that using \"field-name\" over there makes this a bit clearer.\n",
          "createdAt": "2016-06-01T09:25:04Z",
          "updatedAt": "2016-06-01T09:25:04Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Addressed in: https://github.com/httpwg/http-extensions/pull/190\n",
          "createdAt": "2016-06-01T21:17:27Z",
          "updatedAt": "2016-06-01T21:17:27Z"
        }
      ]
    },
    {
      "number": 185,
      "id": "MDU6SXNzdWUxNTc3MzQyMzY=",
      "title": "Client hints: \u201clargest smallest\u201d",
      "url": "https://github.com/httpwg/http-extensions/issues/185",
      "state": "CLOSED",
      "author": "vfaronov",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints",
        "editorial"
      ],
      "body": "`draft-ietf-httpbis-client-hints.md`:\n\n> rounded to the largest smallest following integer\n",
      "createdAt": "2016-05-31T18:06:13Z",
      "updatedAt": "2016-06-07T06:36:27Z",
      "closedAt": "2016-06-07T06:36:27Z",
      "comments": []
    },
    {
      "number": 186,
      "id": "MDU6SXNzdWUxNTc3MzUxMzM=",
      "title": "Client hints: wording on Save-Data",
      "url": "https://github.com/httpwg/http-extensions/issues/186",
      "state": "CLOSED",
      "author": "vfaronov",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints",
        "editorial"
      ],
      "body": "`draft-ietf-httpbis-client-hints.md`:\n\n> The \"Save-Data\" request header field is a token that indicates\n\nshould be something like:\n\n> The \"Save-Data\" request header field is one or more tokens that indicate\n\nor maybe just:\n\n> The \"Save-Data\" request header field indicates\n",
      "createdAt": "2016-05-31T18:10:45Z",
      "updatedAt": "2016-06-07T06:36:51Z",
      "closedAt": "2016-06-07T06:36:51Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also: change \"request header field\" to \"....field _value_\".\n",
          "createdAt": "2016-06-01T09:26:08Z",
          "updatedAt": "2016-06-01T09:26:08Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@reschke all of the other definitions use \"X request header field is a Y that...\". If we change one we should change all the rest. Is this something we want or need to do?\n",
          "createdAt": "2016-06-01T21:25:13Z",
          "updatedAt": "2016-06-01T21:25:13Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You decide; maybe I am too pedantic...\n",
          "createdAt": "2016-06-02T05:46:48Z",
          "updatedAt": "2016-06-02T05:46:48Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Let's keep it as is for now. If this comes up again in other contexts, we can revisit.\n",
          "createdAt": "2016-06-02T14:43:24Z",
          "updatedAt": "2016-06-02T14:43:24Z"
        }
      ]
    },
    {
      "number": 187,
      "id": "MDU6SXNzdWUxNTc3NDkxMTI=",
      "title": "Lifetime of Key headers",
      "url": "https://github.com/httpwg/http-extensions/issues/187",
      "state": "CLOSED",
      "author": "zwoop",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "key"
      ],
      "body": "It could be better for some implementers if the lifetime of the Key headers is the same as the Cache-Control: from the response wherein the Key header was seen. The spec today says that the Key header used should be the last one seen, but this can cause some complex, and/or performance expensive issues for certain cache implementations.\n\nUnless the intent here is that I can purge old variants from the cache, that are still fresh, by changing the Key header for subsequent variants?\n",
      "createdAt": "2016-05-31T19:20:04Z",
      "updatedAt": "2018-04-03T23:40:25Z",
      "closedAt": "2018-04-03T23:40:25Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "You purge old `Key`s. It doesn't invalidate the cache, though.",
          "createdAt": "2017-02-07T05:25:23Z",
          "updatedAt": "2017-02-07T05:25:51Z"
        }
      ]
    },
    {
      "number": 188,
      "id": "MDU6SXNzdWUxNTc3ODI0OTQ=",
      "title": "Don't mix secure and insecure schemes on a connection",
      "url": "https://github.com/httpwg/http-extensions/issues/188",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "Using HTTP and HTTPS schemes on a single OppSec connection seems like asking for trouble, especially as the latter would be authenticated and the former might not.  We should explicitly prohibit this (clients MUST NOT) and servers SHOULD presumably respond with a 4xx (421?) if mixing of schemes is detected.  The exact vulnerabilities or ways to exploit are unclear, but mixing authenticated and unauthenticated (or secure and insecure) communications over a single TLS channel seems  dangerous.\n\nIt may be reasonable to allow a server to advertise mixing HTTP and HTTPS under a strongly authenticated /.well-known/http-opportunistic (similar to commit), but mixing schemes shouldn't be the default.\n",
      "createdAt": "2016-05-31T22:12:21Z",
      "updatedAt": "2016-07-08T01:03:35Z",
      "closedAt": "2016-07-08T01:03:35Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From @martinthomson on http-gw:\n\n> This is reasonable.  A boolean `mixed-scheme` member that has to be\n> true seems appropriate.  It's cheap enough to warrant doing.\n",
          "createdAt": "2016-06-02T16:56:50Z",
          "updatedAt": "2016-06-02T16:56:50Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "How about:\n\n> Because of the risk of server confusion about individual requests' schemes (see [ref to security considerations]), clients MUST NOT mix \"https\" and \"http\" requests on the same connection unless the http-opportunistic response's origin object [ref to http-opp section] has a \"mixed-scheme\" member whose value is \"true\".\n\n... with an example, incorporated into \"Interaction with \"https\" URIs\".\n\n?\n",
          "createdAt": "2016-06-07T04:05:01Z",
          "updatedAt": "2016-06-07T04:05:01Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM\n",
          "createdAt": "2016-06-21T03:03:55Z",
          "updatedAt": "2016-06-21T03:03:55Z"
        }
      ]
    },
    {
      "number": 189,
      "id": "MDU6SXNzdWUxNTc4Nzg4NjY=",
      "title": "Client Hints: Accept-CH html meta http-equiv",
      "url": "https://github.com/httpwg/http-extensions/issues/189",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "\"Servers can advertise support for Client Hints using the Accept-CH header field or an equivalent HTML meta element with http-equiv attribute ([W3C.REC-html5-20141028]).\"\n\nIn which case it should be added to https://wiki.whatwg.org/wiki/PragmaExtensions  (like it or not).\n\n\"When a client receives Accept-CH, it SHOULD append the Client Hint header fields that match the advertised field-values. For example, based on Accept-CH example above, the client would append DPR, Width, Viewport-Width, and Downlink header fields to all subsequent requests.\"\n\nQ: does the SHOULD also apply to the HTML http-equiv variant?\n",
      "createdAt": "2016-06-01T10:58:08Z",
      "updatedAt": "2016-06-07T06:38:09Z",
      "closedAt": "2016-06-07T06:38:09Z",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> Q: does the SHOULD also apply to the HTML http-equiv variant?\n\nYes. Is there a common term we can use here to refer to both the header field value and attribute value?\n",
          "createdAt": "2016-06-01T21:36:26Z",
          "updatedAt": "2016-06-01T21:36:26Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, that implies that every user agent SHOULD parse HTML and process <meta> elements. Is this a realistic requirement?\n",
          "createdAt": "2016-06-02T05:47:56Z",
          "updatedAt": "2016-06-02T05:47:56Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> The term \"user agent\" refers to any of the various client programs that initiate a request, including (but not limited to) browsers, spiders (web-based robots), command-line tools, custom applications, and mobile apps\n\nPerhaps not. \n\n> When a client receives Accept-CH, or if it is capable of processing the HTML response and finds an equivalent HTML meta element, it SHOULD append the Client-Hint header fields that match the advertised field-values. For example, based on Accept-CH example above, the client would append DPR, Width, Viewport-Width, and Downlink header fields to all subsequent requests.\n\nWarmer?\n",
          "createdAt": "2016-06-02T14:48:41Z",
          "updatedAt": "2016-06-02T14:48:41Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "From: https://lists.w3.org/Archives/Public/ietf-http-wg/2016AprJun/0322.html\n\n> This \"all subsequent requests\" is obviously intended to be qualified\n> somehow. It's not \"all requests to all servers ever\", is it? Should it\n> be \"all subsequent requests to the same origin\"? Should it be \"all\n> subsequent requests to this resource\"?\n> \n> Likewise, the \"SHOULD append\" phrase is unclear: append to what exactly?\n\nHow about...\n\n> When a client receives Accept-CH, or if it is capable of processing the HTML response and finds an equivalent HTML meta element, it SHOULD append the Client-Hint header fields that match the advertised field-values to the header list of all subsequent requests. For example, based on Accept-CH example above, a user agent could append DPR, Width, Viewport-Width, and Downlink header fields to all subresource requests initiated by the page constructed from the response. Alternatively, a client may remember the preference at origin level and advertise same header fields on all future requests initiated to and by the resources associated with that origin.\n\nIn other words, it's not the intent of this spec to spell out a specific behavior, we leave that to the client.\n",
          "createdAt": "2016-06-03T17:47:55Z",
          "updatedAt": "2016-06-03T17:47:55Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "SGTM, where \"may\" ought to be \"MAY\" or \"can\".\n",
          "createdAt": "2016-06-03T17:55:57Z",
          "updatedAt": "2016-06-03T17:55:57Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Thanks, updated in https://github.com/httpwg/http-extensions/pull/190. \n",
          "createdAt": "2016-06-03T18:22:04Z",
          "updatedAt": "2016-06-03T18:22:04Z"
        }
      ]
    },
    {
      "number": 191,
      "id": "MDU6SXNzdWUxNTgwNzc0OTY=",
      "title": "Strong Authentication and commit",
      "url": "https://github.com/httpwg/http-extensions/issues/191",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "Erik raises in post-WGLC:\n\nThe text is still a little unclear on whether commit then requires subsequent connections to use \"strong authentication\" or just \"authentication\".  In particular, Section 3 seems to add some confusion about whether \"reasonable assurances\" and \"server authentication\" are the same thing or not but then 5.2 sometimes uses \"authenticated without \"strongly authenticated\".  For example, this paragraph is not particularly crisp on what the requirements are (strong authentication or something else):\n\n```\nA commitment is not bound to a particular alternative service.\nClients are able to use alternative services that they become aware\nof.  However, once a valid and authenticated commitment has been\nreceived, clients SHOULD NOT use an unauthenticated alternative\nservice.  Where there is an active commitment, clients SHOULD ignore\nadvertisements for unsecured alternative services.  A client MAY send\nrequests to an unauthenticated origin in an attempt to discover\npotential alternative services, but these requests SHOULD be entirely\ngeneric and avoid including credentials.\n```\n",
      "createdAt": "2016-06-02T07:38:59Z",
      "updatedAt": "2016-06-21T02:31:51Z",
      "closedAt": "2016-06-21T02:31:51Z",
      "comments": []
    },
    {
      "number": 192,
      "id": "MDU6SXNzdWUxNTgxODk3NjY=",
      "title": "Prohibit client certs from being used with Opp-Sec",
      "url": "https://github.com/httpwg/http-extensions/issues/192",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "Another post-WGLC feedback item that came up from one of our security researchers which\nis not covered in the doc is client certs.  Do we need any guidance on them in the doc?\nShould we say that clients MUST NOT send them for connections being used for HTTP-scheme\nrequests?  Or only send them after an origin has opted-in with a .well-known/http-encryption response\nover a strongly authenticated connection?\n\nThe risk comes from an unauthenticated active adversary Alt-Svc'ing a client to a server\nto which the client is sending client certs for HTTPS but where the server is not\nmulti-scheme aware and hasn't opted in.  There is the potential for the server to\nhave a perception of HTTPS client-cert authenticated requests when the client may\nbe thinking it is making HTTP requests which may have had some cookies\nor other elements injected by the active MitM under the cleartext HTTP side.\n\nFrom @martinthomson on http-wg discussion:\n\n> I would be happy saying that you can't use client certs.  That is,\n> unless you were using them for HTTPS requests and the connection\n> happened to be shared.\n",
      "createdAt": "2016-06-02T16:55:47Z",
      "updatedAt": "2016-07-08T01:03:46Z",
      "closedAt": "2016-07-08T01:03:46Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "How about something like:\n\n> Client certificates are not meaningful for URLs with the \"http\" scheme, and therefore clients creating new TLS connections to alternative services for the purposes of this specification MUST NOT present them. Established connections with client certificates MAY be reused, however.\n",
          "createdAt": "2016-06-07T03:52:58Z",
          "updatedAt": "2016-06-07T03:52:58Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "WFM\n",
          "createdAt": "2016-06-08T09:27:40Z",
          "updatedAt": "2016-06-08T09:27:40Z"
        }
      ]
    },
    {
      "number": 194,
      "id": "MDU6SXNzdWUxNTg4ODE1OTU=",
      "title": "Missing OWS in encryption_params and crypto_key_params",
      "url": "https://github.com/httpwg/http-extensions/issues/194",
      "state": "CLOSED",
      "author": "vfaronov",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`draft-ietf-httpbis-encryption-encoding.md`:\n\n> ```\n>  encryption_params = [ parameter *( \";\" parameter ) ]\n> \n>  crypto_key_params = [ parameter *( \";\" parameter ) ]\n> ```\n\nThese rules do not permit whitespace between a semicolon and a parameter, which was probably intended (judging from the examples and from similar rules elsewhere in HTTP). They should be rewritten as follows:\n\n> ```\n>  encryption_params = [ parameter *( OWS \";\" OWS parameter ) ]\n> \n>  crypto_key_params = [ parameter *( OWS \";\" OWS parameter ) ]\n> ```\n\nand the import of the `OWS` rule from RFC\u00a07230 should be noted in the preceding text (\u201cThe \"Encryption\" header field uses the extended ABNF syntax .\u00a0.\u00a0.\u201d and similarly for `Crypto-Key`).\n",
      "createdAt": "2016-06-07T09:45:38Z",
      "updatedAt": "2016-06-22T06:28:40Z",
      "closedAt": "2016-06-22T06:28:40Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for picking this up.\n",
          "createdAt": "2016-06-08T09:32:41Z",
          "updatedAt": "2016-06-08T09:32:41Z"
        }
      ]
    },
    {
      "number": 195,
      "id": "MDU6SXNzdWUxNTg4ODE3Mzk=",
      "title": "Wrong registration of aesgcm",
      "url": "https://github.com/httpwg/http-extensions/issues/195",
      "state": "CLOSED",
      "author": "vfaronov",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`draft-ietf-httpbis-encryption-encoding.md`:\n\n> This memo registers the \"encrypted\" HTTP content-coding\n\nshould be:\n\n> This memo registers the \"aesgcm\" HTTP content-coding\n",
      "createdAt": "2016-06-07T09:46:23Z",
      "updatedAt": "2016-06-22T03:47:32Z",
      "closedAt": "2016-06-22T03:47:32Z",
      "comments": []
    },
    {
      "number": 199,
      "id": "MDU6SXNzdWUxNjAyNTgzNDQ=",
      "title": "Change definition of unique cookie to include host-only-flag to match browser behavior",
      "url": "https://github.com/httpwg/http-extensions/issues/199",
      "state": "CLOSED",
      "author": "macoxms",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "RFC 6265 section 5.3 defines a cookie by the name, domain, and path.  However, given these two headers in a response from a request to http://contoso.com/:\n\nSet-Cookie: mycookie=nothostonly; domain=contoso.com\nSet-Cookie: mycookie=hostonly\n\nMost browsers will have two cookies since they include host-only-flag in their definition of a unique cookie.  I'd like to update section 4.1.2 and 5.3 to reflect the behavior of modern browsers with regards to host-only-flag.\n",
      "createdAt": "2016-06-14T19:00:14Z",
      "updatedAt": "2018-08-31T06:48:04Z",
      "closedAt": "2018-08-31T06:48:04Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Berlin; seems reasonable. \n",
          "createdAt": "2016-07-22T08:40:28Z",
          "updatedAt": "2016-07-22T08:40:28Z"
        }
      ]
    },
    {
      "number": 200,
      "id": "MDU6SXNzdWUxNjEwMTQ2MjI=",
      "title": "normative reference to \"key\" spec",
      "url": "https://github.com/httpwg/http-extensions/issues/200",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "The reference to draft-ietf-httpbis-key-01 is currently marked \"normative, yet:\n\n\"FYI - I've marked the status of the Key draft as \"Parked.\"\n\nAs discussed in B-A, while we have a few small issues on this draft, we really need implementation experience and feedback to validate the design.\n\nIf you are implementing Key or plan to, please do bring your thoughts to the WG.\" -- https://lists.w3.org/Archives/Public/ietf-http-wg/2016AprJun/0295.html\n\nIf the reference stays normative, this spec will be hold up until the key spec is ready, too.\n",
      "createdAt": "2016-06-18T08:50:49Z",
      "updatedAt": "2016-08-19T04:57:36Z",
      "closedAt": "2016-08-19T04:57:36Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Good question. The most relevant text in CH is:\n\n> When doing so, and if the resource is cacheable, the server MUST also emit a Vary response header field (Section 7.1.4 of [RFC7231]), and optionally Key ([I-D.ietf-httpbis-key]), to indicate which hints can affect the selected response and whether the selected response is appropriate for a later request.\n\nLater:\n\n> Client Hints MAY be combined with Key ([I-D.ietf-httpbis-key]) to enable fine-grained control of the cache key for improved cache efficiency. For example, the server can return the following set of instructions\n\nThis feels more like informative than normative.\n",
          "createdAt": "2016-06-19T00:54:01Z",
          "updatedAt": "2016-06-19T00:54:01Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Right, I'd argue the text _is_ informative.. It's easy enough for me to change the reference to be marked as such. Is that sufficient?\n",
          "createdAt": "2016-08-03T23:53:53Z",
          "updatedAt": "2016-08-03T23:53:53Z"
        }
      ]
    },
    {
      "number": 201,
      "id": "MDU6SXNzdWUxNjEyMDk0OTE=",
      "title": "SameSite: Clarify user-triggered navigation behavior.",
      "url": "https://github.com/httpwg/http-extensions/issues/201",
      "state": "CLOSED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "If a user opens a new tab, and types in a URL, we ought to consider that same-site, as per step 1 of https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-2.1. That definition is pretty opaque, however; adding a note in to clarify would be helpful.\n",
      "createdAt": "2016-06-20T14:33:34Z",
      "updatedAt": "2017-08-07T13:09:17Z",
      "closedAt": "2017-08-07T13:08:54Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not sure if this is needs to be a design issue. @mikewest, feel free to switch to editorial if you are sure that you won't change anything substantial.\n",
          "createdAt": "2016-06-22T06:30:23Z",
          "updatedAt": "2016-06-22T06:30:23Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Will be addressed in the upcoming -02.",
          "createdAt": "2017-08-07T12:26:45Z",
          "updatedAt": "2017-08-07T12:26:45Z"
        }
      ]
    },
    {
      "number": 204,
      "id": "MDU6SXNzdWUxNjI3NTY1NjY=",
      "title": "enhance title of RFC6265 to include \"cookies\" term",
      "url": "https://github.com/httpwg/http-extensions/issues/204",
      "state": "CLOSED",
      "author": "equalsJeffH",
      "authorAssociation": "NONE",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "a suggestion for 6265bis' title such that the term \"cookies\" is included...\n\n```\nCookies: HTTP State Management Mechanism\n```\n",
      "createdAt": "2016-06-28T18:40:07Z",
      "updatedAt": "2017-08-07T13:09:17Z",
      "closedAt": "2017-08-07T13:08:54Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in berlin: +1\n",
          "createdAt": "2016-07-22T08:43:34Z",
          "updatedAt": "2016-07-22T08:43:34Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "HTTP State Management Mechanism: The Sequel\n",
          "createdAt": "2016-07-22T08:43:51Z",
          "updatedAt": "2016-07-22T08:43:51Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Marking this as editorial (much as we love a WG bike painting session).\n",
          "createdAt": "2016-09-28T02:32:33Z",
          "updatedAt": "2016-09-28T02:32:33Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Will be fixed in the upcoming -02.",
          "createdAt": "2017-08-07T11:57:28Z",
          "updatedAt": "2017-08-07T11:57:28Z"
        }
      ]
    },
    {
      "number": 208,
      "id": "MDU6SXNzdWUxNjMwNjQ3Nzg=",
      "title": "Warning from clear-for-DTD",
      "url": "https://github.com/httpwg/http-extensions/issues/208",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "reschke"
      ],
      "labels": [
        "meta"
      ],
      "body": "I get this warning.\n\n```\nWarning: at xsl:transform on line 42 column 2 of clean-for-DTD.xslt:\n  Running an XSLT 1.0 stylesheet with an XSLT 2.0 processor\n```\n\nDo we really need to use saxon here, or is `xsltproc` enough now?\n",
      "createdAt": "2016-06-30T01:51:56Z",
      "updatedAt": "2017-12-14T01:53:50Z",
      "closedAt": "2017-12-14T01:53:50Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's harmless. (Would be good if we could turn it off, though)\n",
          "createdAt": "2016-06-30T04:40:10Z",
          "updatedAt": "2016-06-30T04:40:10Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, xsltproc should work, but also Saxon apparently just got rid of the warning message.\n",
          "createdAt": "2016-11-17T09:40:22Z",
          "updatedAt": "2016-11-17T09:40:22Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OBE",
          "createdAt": "2017-12-14T01:53:50Z",
          "updatedAt": "2017-12-14T01:53:50Z"
        }
      ]
    },
    {
      "number": 212,
      "id": "MDU6SXNzdWUxNjU4NDk0NTA=",
      "title": "allow origin frame to expand not just contract set of origins",
      "url": "https://github.com/httpwg/http-extensions/issues/212",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "origin-frame"
      ],
      "body": "we debated this a bit in BA - but didn't come to a resolution that I recall. opening an issue\n\n\"   When received by a client, it can be used to inform HTTP/2 connection\n   coalescing (see [RFC7540], Section 9.1.1), but does not relax the\n   requirement there that the server is authoritative. \"\n\nessentially this means you can't advertise an origin that the client wouldn't have known to ask you for - doing so is obviously very powerful (in both good and scary ways).\n\nI think we want to allow it assuming the \"valid certificate for the origin\" logic is met. i.e. formally separate insecure routing from secure certificates. This dovetails with mike's secondary cert draft.\n",
      "createdAt": "2016-07-15T18:27:22Z",
      "updatedAt": "2016-10-11T05:51:22Z",
      "closedAt": "2016-10-11T05:51:22Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Today there are two layers of controls protecting against hijacking an HTTPS site:  the need to get a valid cert and the need to get users for an origin to go to a server presenting that cert (ie, either through DNS hijacking or man-in-the-middle).  Both expanding via the origin frame and secondary certs eliminate that second level of defense-in-defense.  While this may not matter as much for nation-state attacks or \"coffee-shop\", it does add a new vector to make phishing and ad-malware injection attacks much more powerful (when combined with cert compromise).\n",
          "createdAt": "2016-07-15T20:44:45Z",
          "updatedAt": "2016-07-15T20:44:45Z"
        }
      ]
    },
    {
      "number": 213,
      "id": "MDU6SXNzdWUxNjYwODA1MDM=",
      "title": "Expand on motivation for the encoding",
      "url": "https://github.com/httpwg/http-extensions/issues/213",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "5987bis",
        "editorial"
      ],
      "body": "Explain why you probably shouldn't just use UTF-8.\n",
      "createdAt": "2016-07-18T12:18:05Z",
      "updatedAt": "2016-11-17T00:46:03Z",
      "closedAt": "2016-11-17T00:46:03Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "...for new header fields?\n",
          "createdAt": "2016-09-02T16:39:08Z",
          "updatedAt": "2016-09-02T16:39:08Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Marking this as editorial, as I think it just means we need to point to 7230's restriction on header field values.\n",
          "createdAt": "2016-09-28T02:30:43Z",
          "updatedAt": "2016-09-28T02:30:43Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We already say:\n\n\"By default, header field values in HTTP messages ([RFC7230]) cannot directly carry characters outside the US-ASCII coded character set ([RFC0020]).\"\n\n...which hints at the fact that RFC 7230 puts non-ASCII octets into the \"obs-text\" production. I'll try to expand a bit on this.\n",
          "createdAt": "2016-10-05T15:19:45Z",
          "updatedAt": "2016-10-05T15:19:45Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe this can be closed with the changes in https://github.com/httpwg/http-extensions/commit/5ec7eed4fa2c941a34e868117ef2fb634d8d506e\n",
          "createdAt": "2016-11-14T00:57:59Z",
          "updatedAt": "2016-11-14T00:57:59Z"
        }
      ]
    },
    {
      "number": 214,
      "id": "MDU6SXNzdWUxNjYwODI1MjU=",
      "title": "Specify how origin frames interact with Altsvc",
      "url": "https://github.com/httpwg/http-extensions/issues/214",
      "state": "CLOSED",
      "author": "siyengar",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial",
        "origin-frame"
      ],
      "body": "It seems like we should filter against the original origin when using alt-svc and we should specify this in the origin frame draft\n",
      "createdAt": "2016-07-18T12:30:10Z",
      "updatedAt": "2017-04-22T13:31:28Z",
      "closedAt": "2017-04-20T02:38:50Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hey Subodh - could you expand upon this a bit more?\n",
          "createdAt": "2016-09-28T03:26:40Z",
          "updatedAt": "2016-09-28T03:26:40Z"
        },
        {
          "author": "siyengar",
          "authorAssociation": "NONE",
          "body": "Ya I was wondering if clarification was needed on the indented behavior origin frames with altsvc\n\nWith altsvc you can point origin1 -> origin2 as the transport layer. Should the filter on the origin frame apply to origin1 or origin2. My understanding is that intention is to apply it to origin1, but want to make sure that's correct. There might be misunderstandings since both origin and altsvc seem to act at the same layer (transport layer).\n",
          "createdAt": "2016-09-29T14:36:05Z",
          "updatedAt": "2016-09-29T14:37:19Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Ah. What you get in an alternate service is \"below\" what happens at the \"origin\" layer -- it isn't a new origin. I'll try to clarify, thanks.\n",
          "createdAt": "2016-09-30T00:25:11Z",
          "updatedAt": "2016-09-30T00:25:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Current draft has:\r\n\r\n> Finally, servers that allow alternative services {{?RFC7838}} will need to explicitly advertise\r\nthose origins when sending ORIGIN, because the default contents of the Origin Set (as per {{set}})\r\ndo not contain any Alternative Services, even if they have been used previously on the connection.\r\n\r\nI think this addresses the concern.",
          "createdAt": "2017-04-20T02:38:50Z",
          "updatedAt": "2017-04-20T02:38:50Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"those origins\" might be better stated as \"origins that have alternative services\"",
          "createdAt": "2017-04-20T03:02:57Z",
          "updatedAt": "2017-04-20T03:02:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I changed it to:\r\n\r\n> Finally, servers that host alternative services {{?RFC7838}} will need to explicitly advertise\r\ntheir origins when sending ORIGIN, because the default contents of the Origin Set (as per {{set}})\r\ndo not contain any Alternative Services' origins, even if they have been used previously on the\r\nconnection.\r\n\r\n... about five minutes ago. Good enough?",
          "createdAt": "2017-04-20T03:03:43Z",
          "updatedAt": "2017-04-20T03:03:43Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Absolutely!",
          "createdAt": "2017-04-20T03:04:29Z",
          "updatedAt": "2017-04-20T03:04:29Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure \"because the default contents of the Origin Set (as per {{set}}) do not contain any Alternative Services' origins\" is accurate.  Even with the current text, an Alt-Svc to a different server name but default port will be in the default set if it is what is used to establish the connection.  (ie, SNI is the Alt-Svc's origin and port is the default.)\r\n\r\nThe cases where this is relevant is when:\r\n\r\n* Connections are being coalesced  (i.e., the Alt-Svc server name shares an IP address and port with an origin).  This can happen in the reverse, still making the new text here somewhat misleading.  If the connection from the Alt-Svc is opened first and then another with origin hostname tries to coalesce onto it, the SNI will be from the Alt-Svc origin hostname.  In this case, the SNI would be origin1.\r\n* The weird issue with #331 and ports",
          "createdAt": "2017-04-22T13:31:28Z",
          "updatedAt": "2017-04-22T13:31:28Z"
        }
      ]
    },
    {
      "number": 215,
      "id": "MDU6SXNzdWUxNjYwODQ2Nzg=",
      "title": "security considerations regarding tracking",
      "url": "https://github.com/httpwg/http-extensions/issues/215",
      "state": "CLOSED",
      "author": "royfielding",
      "authorAssociation": "MEMBER",
      "assignees": [
        "igrigorik"
      ],
      "labels": [
        "client-hints"
      ],
      "body": "I think the security considerations in draft 01 are not adequate. Client hints are presumably sent on all requests, not just within contexts that currently allow execution of javascript via UA or site-specific policies. Hence, a site that does not allow javascript within certain frames (e.g., third party ads) will have no ability to similarly constrain the sending of client hints.\n\nIn short, the section should seriously discuss the privacy concerns rather than make a rather flippant comparison to existing problems with javascript fingerprinting. Assume, for example, that the user has already configured their browser to prevent fingerprinting via other means and teach what ought to be done for CH to do the same.\n",
      "createdAt": "2016-07-18T12:42:52Z",
      "updatedAt": "2016-10-04T18:25:52Z",
      "closedAt": "2016-10-04T18:25:52Z",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Good points on JS.. However, note that you can still obtain the same data (DPR, viewport width, ...) via CSS as well (e.g. combination of media queries that trigger different requests) and that cannot be disabled by any policy. As such, I think the current spec language is correct (and not meant to be flippant :)) but we should mention CSS in that first paragraph...\n\nDoes that sound reasonable?\n",
          "createdAt": "2016-08-04T00:04:02Z",
          "updatedAt": "2016-08-04T00:04:02Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "Sorry, I missed that response. A third-party inserting CSS media queries within an HTML page to fingerprint a specific user is a lot more difficult (and public) than simply recording the numbers received in an HTTP request header field. In any case, \"no worse than other peoples' problems\" is not something we put in HTTP specs, because these specs usually outlive other problems.\n\nThe section should say that sending the CH header field can increase the passive fingerprint of a browser request if the field values are not limited to values common across a range of users. For example, sending the exact viewport-width and downlink bandwidth can easily identify a specific user across multiple unrelated sites, whereas sending DPR is less likely to identify a specific user because such ratios tend to be common to many users. Restricting field values to an enumerated range, where the user agent picks an enumerated value that is close enough to its current state, might lessen the risk of fingerprinting. Likewise, a user agent might reduce such risk by only sending the field on same-site subrequests, in requests for which identifying information is already being sent in the form of authentication or persistent cookies, or in requests to sites that have been previously whitelisted.\n\nI think that would be sufficient. We just need to explain the risk.\n",
          "createdAt": "2016-09-13T23:05:42Z",
          "updatedAt": "2016-09-13T23:05:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I tend to agree with Roy -- this is the difference between \"active\" and \"passive\" fingerprinting. See: https://w3c.github.io/fingerprinting-guidance/\n",
          "createdAt": "2016-09-28T06:27:08Z",
          "updatedAt": "2016-09-28T06:27:08Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@royfielding @mnot thanks, great feedback. Took a run at incorporating what you've outlined: https://github.com/httpwg/http-extensions/commit/2ba199856ae926284fe868de7c257009f01fe3b8 - how does that look?\n",
          "createdAt": "2016-09-30T21:11:12Z",
          "updatedAt": "2016-09-30T21:11:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "LGTM, modulo that em dash :)\n\nLet's publish a new draft and get wider review.\n",
          "createdAt": "2016-10-04T01:51:34Z",
          "updatedAt": "2016-10-04T01:51:34Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Landed https://github.com/httpwg/http-extensions/commit/bf9d6e7943991e45e792769b5e710aa475fb9632. 02 draft is live @ https://tools.ietf.org/html/draft-ietf-httpbis-client-hints-02\n",
          "createdAt": "2016-10-04T18:25:52Z",
          "updatedAt": "2016-10-04T18:25:52Z"
        }
      ]
    },
    {
      "number": 216,
      "id": "MDU6SXNzdWUxNjc1NDA3NTQ=",
      "title": "Cache digest and scoping",
      "url": "https://github.com/httpwg/http-extensions/issues/216",
      "state": "CLOSED",
      "author": "bryancall",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "In the draft it is unclear what the scope the digest will cover.  Is it scoped to the hostname of the stream (authority header)?  Is the scope limited to the resources referenced in the stream and the client would have to keep a data structure around for every page?\n\nThere are a few cases where I can see issues with scoping on hostnames:\n1. If a user goes to www.example.com, you might want to expand the cache digest to all of the resources for example.com.\n2. The first point doesn't make sense for a site like Tumblr where there are many blogs for *.tumblr.com and creating a digest might become large.  Having a limit on the number of items in the digest and having the most used items in the cache digest might help.\n3. There are also issues for sites where there are multiple domain names referenced by the stream and being served by the same connection.  This will happen with finance.yahoo.com where it has s.yimg.com resources and they are served by the same server.\n\nFor reference:\n\"A CACHE_DIGEST frame can be sent from a client to a server on any stream in the \"open\" state, and conveys a digest of the contents of the client's cache for associated stream.\"\n",
      "createdAt": "2016-07-26T07:41:31Z",
      "updatedAt": "2017-06-20T00:00:54Z",
      "closedAt": "2017-06-20T00:00:54Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for your comment.\n\n> In the draft it is unclear what the scope the digest will cover. Is it scoped to the hostname of the stream (authority header)?\n\nIn the current draft, the scope is defined in terms of _origin_, as:\n\n```\n   o  *COMPLETE* (0x2): When set, indicates that the currently valid set\n      of cache digests held by the server constitutes a complete\n      representation of the cache's state regarding that origin\n(snip)\n   When generating CACHE_DIGEST, a client MUST NOT include cached\n   responses whose URLs do not share origins [RFC6454] with the request\n   of the stream that the frame is sent upon.\n```\n\n> Is the scope limited to the resources referenced in the stream and the client would have to keep a data structure around for every page?\n\nNo. The server is expected to retain the digests sent by the client for the lifetime of the connection (or until it receives a `CACHE_DIGEST` frame with `RESET` flag set).\n\n> There are a few cases where I can see issues with scoping on hostnames:\n\nI think your examples illustrate a very good use-case that we might better cover.\n\nThe specifications in current draft forbids sending a digest of a _different_ origin than that specified in the `:authority` header.\n\nIt _might_ be a good idea to add a optional field to the frame that could be used to store the scope (in terms of origin) of the digests. Clients can decide whether or not to send digests covering multiple origins, depending on how the digest would become.\n",
          "createdAt": "2016-07-27T07:13:30Z",
          "updatedAt": "2016-07-27T07:13:30Z"
        },
        {
          "author": "bryancall",
          "authorAssociation": "NONE",
          "body": "Just to rephrase to make sure I am understanding this correctly.  If a request is made on a stream with the header `:authority: www.yahoo.com`, then only the resources in the cache digest would be from the hostname www.yahoo.com.  Is this understanding correct?\n",
          "createdAt": "2016-07-27T12:04:37Z",
          "updatedAt": "2016-07-27T12:48:13Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that you don't lose anything by including resources for `google.com` in the same cache-digest, but you do lose efficiency.\n",
          "createdAt": "2016-07-27T12:35:01Z",
          "updatedAt": "2016-07-27T12:35:01Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bryancall \n\n> If a request is made on a stream with the header `:authority: www.yahoo.com`, then only the resources in the cache digest would be from the hostname www.yahoo.com. Is this understanding correct?\n\nYes. That is what the current draft states (or tries to state).\n",
          "createdAt": "2016-07-27T13:58:01Z",
          "updatedAt": "2016-07-27T13:58:01Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "> When generating CACHE_DIGEST, a client MUST NOT include cached responses whose URLs do not share origins [RFC6454] with the request of the stream that the frame is sent upon.\n\nI'm curious, is there an explanation somewhere why this design was chosen? There seems to be a trade-off between _coverage_ (maximizing the amount of useful URLs in the digest) and _privacy_ (minimizing the privacy leakages relative to HTTP/2 as it stands currently). As @bryancall points out, the current proposal has suboptimal coverage. To illustrate, here are two alternate strategies:\n\n_Include all URLs for which the server is authoritative_: This is suggested by @bryancall. I believe this strategy maximizes coverage: a server can push any URL for which it is authoritative, and this strategy includes all such URLs in the digest. However, there is an increased chance for privacy leakage. Say a server is authoritative on a.com and b.com, and some user makes requests for a.com. If the cache digest includes URLs from b.com, the server can learn of those URLs even if the client never makes any requests for b.com.\n\n_Tie the digest to cookies_: This idea is inspired by @kazuho's [H2O](https://h2o.examp1e.net/configure/http2_directives.html#http2-casper), which puts the cache digest in cookies. We can't actually store the digest in cookies (it's too inefficient), but if we designed the digest in such a way that it _could_ be stored in cookies, at least in theory, then we could argue that cache digests do not increase the chance for privacy leakage relative to current H2. For example, suppose a URL can be included in a cache digest only if the following conditions hold:\n- The server is authoritative for that URL.\n- The client is making a request for origin https:x.y.foo.com, the URL's origin is X, and the client has a cookie that could be sent with requests for https:x.y.foo.com _and_ with requests for X.\n\nI believe this is roughly equivalent to the current proposal if the client does not have any domain-level cookies. However, if the client has a cookie for \".example.com\" and the client makes a request for \"www.example.com\", the cache digest can include URLs from \"cdn.example.com\". Note that example 3 from @bryancall's initial comment would not work: on a request for \"finance.yahoo.com\", the digest would not include URLs from \"s.yimg.com\", although if the server is authoritative for both domains, the client may later make requests for \"s.yimg.com\", at which point the cache digest could be updated to include URLs on that origin as well.\n\n> CACHE_DIGEST allows such cache-based fingerprinting to become passive, since it allows the server to discover the state of the client's cache without any visible change in server behaviour. As a result, clients MUST mitigate for this threat when the user attempts to remove identifiers (e.g., \"clearing cookies\").  This could be achieved in a number of ways; for example: by clearing the cache, ...\n\nExpanding on the above design, we could view the cache digest as an internally-maintained cookie. When the browser makes a request to origin X, the browser creates a cookie with the domain set to host(X). If X is https, the cookie is Secure, otherwise it is HttpOnly. From this point forward, each time the browser caches a URL from origin X, it adds that URL to X's cache digest cookie. If a URL is evicted from the cache, it is removed from the cache digest cookie. If a page from origin X sets a cookie on domain(X), then cache cookies for all hosts Y where domain(Y) = domain(X) are linked, as it may be possible to send union(cookie(X),cookie(Y)) when an H2 connection is opened to either host. Note that the cache cookies for X and Y are linked _but not merged_ as the external server may not be authoritative for both hosts -- this needs to be checked for each H2 connection.\n\nExcept for being created automatically, and being sent in CACHE_DIGEST rather than Cookie, cache digest cookies behave exactly like other cookies. They are cleared when the user asks for cookies to be cleared. They are disabled when the user disables cookies. They are cleared when the browser is closed if the browser was opened in Incognito mode.\n\nThere may be concerns about the following case. Suppose all hosts under `.aws.com` are served by the same cloud frontend, which terminates the H2 connection, but each host on this domain is served by a separate backend server. Now suppose `evil.aws.com` sets a cookie for `.aws.com`. Can `evil.aws.com` can spy on a user's from `alice.aws.com`? The answer is yes if the client sends a single cache digest that covers both hosts. I see two ways to prevent this:\n1. Although a client may proactively send multiple cache digests, following the above rules, each digest summarizes URLs for a single origin only. (The cloud frontend would be trusted to not forward the digest for `alice.aws.com` to `evil.aws.com` -- this doesn't seem like a problem, since the frontend is already trusted to partition their traffic.) This may use extra bytes by requiring separate-origin digests to be sent in separate CACHE_DIGEST frames.\n2. Cache digests from multiple origins can be merged, but the client will merge digests for `evil.aws.com` and `alice.aws.com` only if _both_ origins have set a domain cookie for `.aws.com`. This potentially saves bytes by allowing one cache digest to cover the entire connection.\n\nWDYT?\n\n> When generating CACHE_DIGEST ... with the request of the stream that the frame is sent upon.\n\nRelatedly, I'm a bit confused with the last part of that sentence. I would expect CACHE_DIGEST to apply to the entire connection (StreamID = 0x0) rather than an individual stream. Why not send CACHE_DIGESTS on stream 0x0 and include an explicit scope (authority) in the CACHE_DIGEST frame? This costs a few extra bytes but will (a) eliminate a race between receiving the first request and the digest, and (b) make it more obvious _which_ authority the digest applies to.\n",
          "createdAt": "2016-08-04T15:31:51Z",
          "updatedAt": "2016-08-04T16:29:12Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "tl;dr of the above comment: There is a trade-off between coverage and privacy. Cache digests should not worsen the privacy problem compared to current H2. If cache digests are reducible to cookies, and managed as cookies, then we can argue that the privacy problem hasn't worsened. Further, if cookies are shared across hosts on the same domain, then cache digests can also be shared on the same domain, improving coverage.\n",
          "createdAt": "2016-08-04T16:50:38Z",
          "updatedAt": "2016-08-04T16:50:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@bryancall - the scope is the origin, which is a bit more than the `:authority` -- it's the tuple of `(scheme, hostname, port)`.\n\n@tombergan and @bryancall - I think that tying cache digest to cookie scopes would be a very hard sell. All new mechanisms in the Web use origins as a default administrative boundary, and doing anything scoped bigger than that is going to invite a lot of attention and controversy.\n\nHaving said that, there's nothing that stops a client from sending multiple cache digests on a connection, one for each origin that the connection is authoritative for. If this needs to be clarified in the draft we can certainly do that.\n",
          "createdAt": "2016-08-20T01:06:16Z",
          "updatedAt": "2016-08-20T01:06:16Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot \n\n> Having said that, there's nothing that stops a client from sending multiple cache digests on a connection, one for each origin that the connection is authoritative for. If this needs to be clarified in the draft we can certainly do that.\n\nI think CACHE_DIGEST frame should designate its scope explicitly, considering the fact that drafts that changes the scope of the authority exist (e.g. ORIGIN frame , secondary certificates), and that we have `COMPLETE` flag (that indicates a digest covering all the authorties have been sent).\n\nOtherwise, there'd be a race condition.\n",
          "createdAt": "2016-08-20T20:53:04Z",
          "updatedAt": "2016-08-20T20:53:18Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "@mnot\n\n> I think that tying cache digest to cookie scopes would be a very hard sell\n\nFWIW, Section 4 recognizes the potential privacy concerns and tries to alleviate these concerns by tying cache digests to cookies, but in a weak way:\n\n> As a result, clients MUST mitigate for this threat when the user attempts to remove identifiers (e.g., \"clearing cookies\") ... TODO: discuss how effective the suggested mitigations actually would be.\n\nThere were two parts to my suggestion (I didn't explain that well, sorry). The main suggestion: I think you can alleviate privacy concerns by showing that a server can already implement cache digests using cookies. For example, a server could send the following cookie with every response:\n\n``` plain\nName:    (URL, Validator)\nValue:   \"1\"\nPath:    \"/\"\nDomain:  hostip(URL)                 // but see below\nExpires: never                       // but see below\nSecure:  true if scheme(URL)=\"https\" // always true when H2 is https only\n```\n\nThe RFC could say that the client should automatically create the above cookie for every response it receives from an origin. This cookie is treated exactly like every other cookie except that: (1) it is created automatically, (2) it expires when the response is evicted from cache, (3) it is sent in a cache digest, rather than the Cookie header field, (4) it is an internal cookie not available via the normal APIs (such as JS), (5) it does not count towards browser cookie limits, and (6) the Domain field is an exact-match (as in same-origin checking) rather than a suffix match as for normal cookies.\n\nThis exposition makes it obvious exactly where the privacy concerns are -- there are privacy concerns whenever cache digest cookies are treated differently than normal cookies. I don't think any of the above six differences are significant from a privacy perspective. (The only difference that might be significant is (5), but we could argue that a server could work around these limits in various ways, e.g., by using JS code to merge multiple cookies into a digest.) Some of the differences, like (6), are actually _stronger_ from a privacy perspective.\n\nThis exposition also makes it obvious where implementations might accidentally introduce privacy concerns. For example, if a browser is configured to reject third-party cookies, then it should _also_ reject third-party cache digest cookies, such as when an image from `foo.com` is used on a page from `bar.com`. Another example: if a browser partitions \"incognito mode\" cookies into a separate cookie store, it should do the same for cache digest cookies.\n\nLastly, my second (more controversial) suggestion is that the above exposition provides a path towards solving some of the problems raised by @bryancall. Namely, if `www.foo.com` has already stated willingness to share cookies with `foo.com`, then it _may_ be reasonable for `www.foo.com` to share cache digest cookies with `foo.com`. Though, on second thought, it's probably more reasonable to have an explicit signaling mechanism, rather than an implicit signaling mechanism. A Cache-Control extension may do the trick, as suggested in [this thread](https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/0520.html).\n",
          "createdAt": "2016-08-24T18:45:40Z",
          "updatedAt": "2016-08-24T18:45:40Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tombergan \r\n> Cache digests should not worsen the privacy problem compared to current H2. If cache digests are reducible to cookies, and managed as cookies, then we can argue that the privacy problem hasn't worsened.\r\n\r\nI agree that cache digests should not worsen the privacy problem.\r\n\r\nHowever, I will also argue that cache digests _in current form_ does not worsen the privacy problem since it is something that can be and is implemented using existing technology (stated below), and that there is no need to try to adopt the cookie model which would have issues as @mnot points out.\r\n\r\nCache digest can be (and already is) implemented using Service Worker. The only differences between a Service Worker-based implementation and the HTTP/2 frame-based implementation is that the frame-based implementation is more efficient (in HTTP/2 frame-based approach, the digest needs to be sent only once per connection, whereas for Service Worker-based or cookie-based implementation, a client needs to send a digest per every request), and that the digest more accurately reflects the state of the cache (Service Worker cache is located in front of the web browser cache, so a digest of Service Worker cache does not reflect what exists in the browser's cache).",
          "createdAt": "2017-03-30T20:56:34Z",
          "updatedAt": "2017-03-30T20:56:34Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "We mostly agree. I was making a writing suggestion: if you can write the RFC in such a way that it's obvious that the proposed cache digest frame is equivalent to cookies, then you can more easily argue that you're not introducing any privacy concerns. [1] My specific suggestion is for the browser to create a \"cookie\" each time it caches a response, where that cookie is treated like any other cookie with a few small changes (see the list of six items in my prior comment).\r\n\r\nRephrasing the explanation in terms of cookies also makes it obvious where privacy holes may arise. For example, if a browser supports \"normal\" and \"incognito\" modes that use different cookie jars but the same cache, the browser needs to attach the \"cache cookies\" to the appropriate cookie jar rather than to the cache, otherwise there may be information leakage across browser modes.\r\n\r\nDoes that sound reasonable? Contrast this to [Section 4](https://tools.ietf.org/html/draft-ietf-httpbis-cache-digest-01#section-4), which is currently kind of hand-wavy. One example: Section 4 tries to address the incognito problem by saying \"User Agents SHOULD NOT send CACHE_DIGEST when in 'privacy mode'\", but that doesn't solve the problem, since there can still be leakage from incognito mode to normal mode when both modes share a cache. This sort of problem becomes more obvious when you express digests in terms of cookies.\r\n\r\nI realize cookies are kind of weird because they don't exactly follow the same-origin policy. Maybe a better analogy would be local storage?\r\n\r\n[1] Even if you rephrase the explanation in terms of cookies, privacy concerns are still likely to arise since the cookies are created automatically by the browser rather than manually by the server, but that is a separate issue.",
          "createdAt": "2017-03-31T00:26:35Z",
          "updatedAt": "2017-03-31T00:38:18Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tombergan \r\n> I realize cookies are kind of weird because they don't exactly follow the same-origin policy. Maybe a better analogy would be local storage?\r\n\r\nThank you for the suggestion.\r\n\r\nI agree that it would be worthwhile to suggest similarity to existing mechanism in Security Considerations. Having that would help the readers understand the issues.\r\n\r\nI assume that the existing mechanism we would refer to to be Service Worker (and its cache). That is natural since we are likely to have an appendix explaining how to implement Cache Digests using Service Workers (see #256).",
          "createdAt": "2017-03-31T11:57:41Z",
          "updatedAt": "2017-03-31T11:57:41Z"
        }
      ]
    },
    {
      "number": 217,
      "id": "MDU6SXNzdWUxNjg3NjM0Njg=",
      "title": "Terminology in draft-ietf-httpbis-encryption-encoding",
      "url": "https://github.com/httpwg/http-extensions/issues/217",
      "state": "CLOSED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "encryption"
      ],
      "body": "minor editorial issue: draft-ietf-httpbis-encryption-encoding seems to be using \"Content Encoding\" and \"Content Coding\" and \"Content-Coding\" synonymously. maybe settle on one of those terms? \"Content Coding\" might be best because that's what RFC 7231 uses.\n",
      "createdAt": "2016-08-01T23:12:16Z",
      "updatedAt": "2016-09-28T06:58:18Z",
      "closedAt": "2016-09-28T06:58:18Z",
      "comments": []
    },
    {
      "number": 219,
      "id": "MDU6SXNzdWUxNjk4NzIyNjU=",
      "title": "One repo per extension?",
      "url": "https://github.com/httpwg/http-extensions/issues/219",
      "state": "OPEN",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "meta"
      ],
      "body": "That would make it easier to watch and participate in just what is of interest to you.\n",
      "createdAt": "2016-08-08T08:49:14Z",
      "updatedAt": "2018-03-27T12:33:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "![Watch it burn](http://memedad.com/create/thumbnails/54.jpg)\n\n(FWIW, I would prefer this too.  Though closely-related stuff might be best kept together, I don't see much of that right now.)\n",
          "createdAt": "2016-08-08T11:07:57Z",
          "updatedAt": "2016-08-08T11:07:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson's feelings are well-known, as are (probably) mine.\n\nIt's a pity you can't subscribe to a label, rather than just a whole repo. I do agree that as this repo gets more active, it becomes more difficult for casual or selective participation. \n\n@mcmanus any thoughts?\n",
          "createdAt": "2016-08-08T11:30:09Z",
          "updatedAt": "2016-08-08T11:30:09Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I still think this would be good. Perhaps require it for new proposals as a start?",
          "createdAt": "2018-03-27T12:33:53Z",
          "updatedAt": "2018-03-27T12:33:53Z"
        }
      ]
    },
    {
      "number": 220,
      "id": "MDU6SXNzdWUxNjk4NzI0MDc=",
      "title": "Module workers can be fetched across origins",
      "url": "https://github.com/httpwg/http-extensions/issues/220",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site needs to account for that somehow.\n",
      "createdAt": "2016-08-08T08:49:53Z",
      "updatedAt": "2020-01-30T11:40:39Z",
      "closedAt": "2020-01-30T11:40:39Z",
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Note that we're reconsidering this in https://github.com/whatwg/html/issues/3109.",
          "createdAt": "2018-03-28T07:55:10Z",
          "updatedAt": "2018-03-28T07:55:10Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Module workers can no longer be loaded cross-origin, as of https://github.com/whatwg/html/pull/3656/files.\r\n\r\nAccording to https://html.spec.whatwg.org/multipage/webappapis.html#fetch-a-single-module-script, it looks like this is still the case, so we can safely close this out.",
          "createdAt": "2020-01-30T11:40:39Z",
          "updatedAt": "2020-01-30T11:40:39Z"
        }
      ]
    },
    {
      "number": 222,
      "id": "MDU6SXNzdWUxNzAyMTY5MjA=",
      "title": "Host cookie-prefix requires Path attribute",
      "url": "https://github.com/httpwg/http-extensions/issues/222",
      "state": "CLOSED",
      "author": "ericlaw1979",
      "authorAssociation": "NONE",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "https://github.com/httpwg/http-extensions/blob/master/draft-ietf-httpbis-cookie-prefixes.md contains the following text:\n\n```\n4. Sent to every request for a host. That is, a cookie named \"__Host-cookie1\" \n    MUST contain a Path attribute with a value of \"/\".\n\nThe following cookies would always be rejected:\n\nSet-Cookie: __Host-SID=12345\nSet-Cookie: __Host-SID=12345; Secure\n```\n\nThe start of the sentence \"That is,\" implies that the only way to ensure a cookie is sent to every path is to explicitly include `Path=/` but this isn't the case; the cookie `Set-Cookie: __Host-SID=12345; Secure` will be sent to every path **if** the page containing this response header is served from the root of the server.\n\nLooking at [Chrome's code](https://cs.chromium.org/chromium/src/net/cookies/canonical_cookie.cc?sq=package:chromium&dr=C&rcl=1470626560&l=519), it appears that we explicitly _require_ the path attribute be present with a value of `Path=/`\n\nSo, proposed change (also optionally cleaning up parallelism for point 3):\n\n```\n3. Set without a Domain attribute. That is, a cookie set from https://example.com will therefore be sent only to example.com, and not to subdomain.example.com.\n\n4. Set with an explicit Path attribute with a value of \"/\".\n\nThe following cookies would always be rejected:\n\nSet-Cookie: __Host-SID=12345\nSet-Cookie: __Host-SID=12345; Secure\n```\n",
      "createdAt": "2016-08-09T16:53:35Z",
      "updatedAt": "2017-08-07T13:09:17Z",
      "closedAt": "2017-08-07T13:08:54Z",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Poked at the algorithm in the upcoming -02 draft of RFC6265bis.",
          "createdAt": "2017-08-07T12:03:38Z",
          "updatedAt": "2017-08-07T12:03:38Z"
        }
      ]
    },
    {
      "number": 223,
      "id": "MDU6SXNzdWUxNzAzMTQ5OTc=",
      "title": "httpbis-cookie-alone breaks backwards compat",
      "url": "https://github.com/httpwg/http-extensions/issues/223",
      "state": "CLOSED",
      "author": "dvdckl",
      "authorAssociation": "NONE",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "In [section 3](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-alone-00#section-3), after the line \"Before step 11, execute the following step\", the new step intentionally ignores the path.  A note says that \"The intent is to allow the 'secure' flag to supercede the 'path' restrictions to protect sites against cookie fixing attacks.\"  However this change breaks backwards compatibility in the following common scenario:\n1. https://example.com/login/ sets a Secure cookie named SESSIONID with the path /login/.\n2. http://example.com/foo/ sets a non-secure cookie named SESSIONID with the path /foo/, which will be ignored.\n\nThis is the cause of https://bugs.chromium.org/p/chromium/issues/detail?id=580770.  If the draft is adopted as currently written, it will effectively force any website that hosts secure and insecure applications under the same host name to rename cookies in each application to avoid conflicts.  To date, using path provided sufficient scoping to avoid cross-application conflicts.\n\nEven if the second cookie was allowed to be set in the scenario above, it would not have resulted in a fixation vulnerability because one path was not a path-match of the other.  It might be possible to fine-tune the algorithm to only block non-secure cookies if and only if a secure cookie already exists that is a [path-match](https://tools.ietf.org/html/rfc6265#section-5.1.4) of the insecure cookie.  However, that assumes that the cookie order algorithm in https://tools.ietf.org/html/rfc6265#section-5.4 is changed from SHOULD to MUST, and that servers only trust the first cookie.  It also wouldn't help improve backwards compatibility in this scenario:\n1. https://example.com/ sets a Secure cookie named SESSIONID with the path /.\n2. http://example.com/foo/ sets a non-secure cookie named SESSIONID with the path /foo/, which will be ignored.\n\nBoth the draft as written, and the path-match variant proposed above suffer from fixation attacks when an HTTP resource is visited first.  There are other ways that these types of attacks can be mitigated without breaking backwards compatibility, and cover more attack scenarios, at the expense of being opt-in by the server.  These might include the __Secure- prefix (assuming no one is using this in the wild), or introducing a new cookie header, like Cookie-Attributes, that servers could inspect to determine whether or not to trust a cookie.\n",
      "createdAt": "2016-08-10T02:35:50Z",
      "updatedAt": "2016-09-08T09:37:13Z",
      "closedAt": "2016-09-08T09:37:13Z",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> However this change breaks backwards compatibility in the following common scenario\n\nThank you for spelling this out, it's helpful!\n\n>  It might be possible to fine-tune the algorithm to only block non-secure cookies if and only if a secure cookie already exists that is a path-match of the insecure cookie.\n\nThis seems like a reasonable compromise. It would prevent a session fixation attack via a maliciously injected cookie on `us.battle.net` with a path of `/login/en/`, for instance, which seems like a valuable thing to maintain.\n\nFor clarity, I think we're talking about changing the text in [section 3](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-alone-00#section-3) to something like:\n\n> 1.  Before step 11, execute the following step:\n>    1.  If the newly created cookie's \"secure-only-flag\" is not set,\n>         and the \"scheme\" component of the \"request-uri\" does not\n>         denote a \"secure\" protocol, then abort these steps and ignore\n>         the newly created cookie entirely if the cookie store\n>         contains one or more cookies that meet all of the following\n>         criteria:\n>       1.  Their \"name\" matches the \"name\" of the newly created\n>            cookie.\n>       2.  Their \"secure-only-flag\" is set.\n>       3.  Their \"domain\" domain-matches the \"domain\" of the newly\n>            created cookie, or vice-versa.\n>       4.  The \"path\" of the newly created cookie path-matches the \"path\"\n>            of the existing cookie.\n\nChanging 4 to include \"or vice-versa\" might also be reasonable; it would allow the initial example of two distinct cookies in two distinct root-level paths, but would disallow cookies with the same name but different `secure` settings inside a path (e.g. `/`, `/login/`, and `/login/en/`). That is, I think it is desirable to break backwards compatibility with the final example you provide.\n\n> Both the draft as written, and the path-match variant proposed above suffer from fixation attacks when an HTTP resource is visited first.\n\nIndeed. I think that's noted explicitly in [Section 4](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-alone-00#section-4), along with the prefix-based mitigation.\n\n> introducing a new cookie header, like Cookie-Attributes, that servers could inspect to determine whether or not to trust a cookie.\n\nFolks in the working group seemed generally opposed to adding new headers. This was explicit in the discussion of [Origin Cookies](https://tools.ietf.org/html/draft-west-origin-cookies-01), and implicit in the general tone of discussion around cookie changes in general. @mnot might have a different opinion as chair of the group, but my feeling is that anything more complicated that the current proposal is unlikely to garner much support.\n",
          "createdAt": "2016-08-16T15:23:18Z",
          "updatedAt": "2016-08-16T15:23:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'd agree there seems to be a reluctance to make big changes like that, but we can always ask. \n\nThinking out loud -- AIUI one of the objections was the bandwidth overhead; perhaps this could be reduced by doing something like:\n\n```\nCookie-A: s;h;;sh\n```\n\nwhere each member corresponds to a cookie in the lexical order of the `Cookie` header, and the letters are for `secure`, `httpOnly`, etc.\n\n(Adding @mcmanus as co-chair for his thoughts)\n",
          "createdAt": "2016-08-17T02:45:48Z",
          "updatedAt": "2016-08-17T02:45:48Z"
        },
        {
          "author": "dvdckl",
          "authorAssociation": "NONE",
          "body": "@mnot yeah, the order matching was what I had in mind.  I have mixed feelings on abbreviation though.  Part of P3P's challenges were due to it being cryptic.  Other specs like CSP are not abbreviating too much.  But DNT/TSV are.  Would it be better to assume widespread HTTP/2 adoption and count on header compression?\n",
          "createdAt": "2016-08-17T21:04:43Z",
          "updatedAt": "2016-08-17T21:04:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The problem with relying upon header compression is that the dynamic table has a default of 4K, and it can quickly get filled with cookies, UAs, referers, etc. It's not a license to create big new headers.\n",
          "createdAt": "2016-08-18T01:36:15Z",
          "updatedAt": "2016-08-18T01:36:15Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have heard some anecdotes about pressure on the 4K table - not a lot of data yet but I think people are more comfortable with less human readable syntaxes than in the past. Mark's arrangement seems sensible.. but by all means ask the list.\n",
          "createdAt": "2016-08-18T01:58:17Z",
          "updatedAt": "2016-08-18T01:58:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "SGTM. Who's taking it to the list?\n",
          "createdAt": "2016-08-18T08:26:59Z",
          "updatedAt": "2016-08-18T08:26:59Z"
        },
        {
          "author": "dveditz",
          "authorAssociation": "NONE",
          "body": "I too, have concerns about the non-exact path matching and the asymmetry of the results depending on the order in which differing-path cookies are set.\n\nA similar concern about symmetry: why should secure sites get a free pass to downgrade a secure cookie to insecure? That's not \"leaving secure cookies alone\". Such an attempt might actually just be a site bug.\n",
          "createdAt": "2016-08-20T00:08:27Z",
          "updatedAt": "2016-08-20T00:08:27Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Hi! Sorry, I've been OOO for a little while. Starting at the bottom:\n\n@dveditz \n\n> why should secure sites get a free pass to downgrade a secure cookie to insecure?\n1.  Because they're delivered securely, so we ~know that the `Set-Cookie` header reflects the site's intent, and not the intent of a MitM.\n2.  To prevent sites from downgrading `secure` cookies, we'd also have to prevent them from deleting `secure` cookies. That doesn't seem like something we should do, for the same reason that we wouldn't prevent a site from removing data from `localStorage`, et al.\n\n> Such an attempt might actually just be a site bug.\n\nI don't think site bugs are the threat we're concerned about. Sites certainly have bugs, but they can fix them. They can't fix the kinds of issues outlined in \"Cookies Lack Integrity\" and elsewhere. That's what I'm interested in addressing.\n\n@mnot, @dvdckl \n\n> `Cookie-A: s;h;;sh`\n\nSomething like this syntax seems fine (though, does `s` map to `Secure` or `SameSite`? :) ).\n\nI guess this kind of header seems reasonable to me. My concern is that it's (yet another) opt-in mechanism that developers need to know about in order to keep themselves safe (and, really, needs to be built into various frameworks to be useful at all). I think I'd be interested in exploring it in addition to the restrictions on `secure` proposed in the draft we're discussing. I don't think it's a suitable replacement.\n\n> Who's taking it to the list?\n\nSkimming the list, it doesn't look like anyone raised the notion in my absence. @dvdckl, would you be interested in sending a brief proposal for discussion, or shall I write something up?\n",
          "createdAt": "2016-09-01T11:28:10Z",
          "updatedAt": "2016-09-01T11:28:10Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "@dvdckl: The patch in https://github.com/httpwg/http-extensions/commit/3f58813b120dbedcf78d0df899b5a74e095fd068 aims to address the central objection you raised above. Are you happy with that change, or do you think it needs more work?\n",
          "createdAt": "2016-09-01T11:48:04Z",
          "updatedAt": "2016-09-01T11:48:04Z"
        },
        {
          "author": "dvdckl",
          "authorAssociation": "NONE",
          "body": "@mikewest the patch addresses most of my concern, but it's still going to cause problems on sites that have HTTP webapps on a path that's a descendant of an HTTPS webapp (I'm not aware of this case in our ecosystem, but I'm assuming that it exists in the wild).  Copying the second example in my first comment:\n1. https://example.com/ sets a Secure cookie named SESSIONID with the path /.\n2. http://example.com/foo/ sets a non-secure cookie named SESSIONID with the path /foo/, which will be ignored.\n\nYes the RFC would plug the cookie fixation hole quickly, but it effectively forces servers that write cookies to the current path to do one of two things: 1) never serve HTTP content on a path that is a descendant of an HTTPS resource, or 2) coordinate cookie naming conventions between potentially unrelated resources (and maybe unrelated development teams).  If I had to deal with that scenario, I'd probably just focus more on HSTS instead to avoid those cookie related headaches.\n\nMike, you [said yourself ](https://discourse.wicg.io/t/proposal-set-origin-wide-policies-via-a-manifest/1617/4) that you feel like path-level distinctions in cookies was a historical mistake, so wouldn't opt-in mechanisms (HSTS, Cookie-Attributes, [Suborigins](https://w3c.github.io/webappsec-suborigins/), etc) be better long-term than allowing the cookie path-match algorithm to further dictate how servers organize content?\n\nI'll send the Cookie-Attribute header proposal to the mailing list (ietf-http-wg at w3.org, right?)\n",
          "createdAt": "2016-09-01T20:00:47Z",
          "updatedAt": "2016-09-01T20:00:47Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> If I had to deal with that scenario, I'd probably just focus more on HSTS instead to avoid those cookie related headaches.\n\nDoesn't that seem like a good outcome?\n\n> Mike, you said yourself that you feel like path-level distinctions in cookies was a historical mistake,\n\nThe fact that I consider path-level distinctions for cookies to be a mistake (and I do) doesn't mean that I can pretend they don't exist. I'm doing my best to work within the constraints they create to incrementally raise the platform's baseline. _shrug_\n\n> so wouldn't opt-in mechanisms (HSTS, Cookie-Attributes, Suborigins, etc) be better long-term than allowing the cookie path-match algorithm to further dictate how servers organize content?\n\nYes. When we can create opt-in mechanisms that allow sites to lock themselves down further than we can lock down the platform at large, we should.\n\nHowever, relying strictly upon those mechanisms is unlikely to produce actual change in the ecosystem. For instance, despite fairly broad outreach and understanding, something like ~4% of the cookies Chrome users set in the last month have the `Secure` attribute. ~7% have `HttpOnly`. I think it's pretty clear that, in an ideal world, those numbers would be an order of magnitude higher.\n\nIt seems unlikely than an opt-in approach would buy us much in terms of protection, especially when the opt-in is fairly complicated, as `Cookie-Attributes` would be.\n",
          "createdAt": "2016-09-05T07:38:28Z",
          "updatedAt": "2016-09-05T07:38:28Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Uploaded the updated document as https://tools.ietf.org/html/draft-ietf-httpbis-cookie-alone-01.\n",
          "createdAt": "2016-09-05T08:18:10Z",
          "updatedAt": "2016-09-05T08:18:10Z"
        },
        {
          "author": "dvdckl",
          "authorAssociation": "NONE",
          "body": "The data helps provide context, thanks.  Are stats like that and the results of Chrome experiments public somewhere?  Will stats be collected on how many cookies were blocked as a result of this draft RFC?\n\nI'm biased by working in an environment where we're eager to opt in to new security mechanisms and have a strong aversion to breaking backwards compat.  But I understand that the number of sites that would have a backwards compat issue with the latest draft is probably low, and the pain experienced by a few devs is probably worth eliminating an attack vector that affects everyone that hasn't adopted HSTS yet.\n\nThanks for acknowledging all of my feedback.\n",
          "createdAt": "2016-09-05T08:51:35Z",
          "updatedAt": "2016-09-05T08:51:35Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> The data helps provide context, thanks. Are stats like that and the results of Chrome experiments public somewhere?\n\nMetrics we collect in Blink are publicized at https://www.chromestatus.com/metrics/feature/popularity. We unfortunately don't have a similar pipeline for metrics we collect from the network stack. I wish we did. :(\n\n> Will stats be collected on how many cookies were blocked as a result of this draft RFC?\n\nYes. Currently, that's trending at ~0.05% of cookies over the last month, which is a lot of cookies. We're keeping an eye on it, and that's the main reason that the rollout has been so slow.\n\n> I'm biased by working in an environment where we're eager to opt in to new security mechanisms and have a strong aversion to breaking backwards compat.\n1. I love hearing that! I would like you to be my guinea pig for everything!\n2. Most developers don't care until something happens that makes them wish they had cared. :(\n\n> Thanks for acknowledging all of my feedback.\n\nThanks for feeding back!\n",
          "createdAt": "2016-09-05T09:30:09Z",
          "updatedAt": "2016-09-05T09:30:09Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "With the -01 draft published, and Chrome updated (in https://github.com/dstockwell/chromium/commit/2c857fb16cdef9783ba3caeb586b9a3648114b17), I think it's reasonable to close this out. We can continue the discussion of the other proposed paths forward (`Cookie-Attributes`, etc) on the list.\n\nThanks again for your feedback, @dvdckl!\n",
          "createdAt": "2016-09-08T09:37:13Z",
          "updatedAt": "2016-09-08T09:37:13Z"
        }
      ]
    },
    {
      "number": 224,
      "id": "MDU6SXNzdWUxNzAzMjM0ODc=",
      "title": "Experimental",
      "url": "https://github.com/httpwg/http-extensions/issues/224",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Discuss taking CH to Experimental.\n",
      "createdAt": "2016-08-10T04:05:44Z",
      "updatedAt": "2016-08-18T00:04:00Z",
      "closedAt": "2016-08-18T00:04:00Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Do it.\n",
          "createdAt": "2016-08-18T00:04:00Z",
          "updatedAt": "2016-08-18T00:04:00Z"
        }
      ]
    },
    {
      "number": 225,
      "id": "MDU6SXNzdWUxNzA1Mzc0NjE=",
      "title": "JFV + ECMA-262",
      "url": "https://github.com/httpwg/http-extensions/issues/225",
      "state": "CLOSED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "jfv"
      ],
      "body": "Based on the various discussion at [IETF](https://github.com/httpwg/wg-materials/blob/gh-pages/ietf96/minutes.md#jfv), HTTP Workshop, and [mailing lists](https://www.ietf.org/mail-archive/web/httpbisa/current/msg26788.html), JFV may not be the right long-term \"replacement\" header encoding format. However, while [sketches are being pushed around](https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/thread.html#msg292), it's not clear if and when such a format will come either\u2026 In the meantime, I believe we can shape JFV (with minor modifications) into a format that is immediately useful and addresses many of the current pain points for **new** header fields. Specifically: \n- UA's want a reusable and tested parser. Today we end up hand-rolling parsers for most every field (due to ABNF quirks, past implementation mistakes, etc), which leads to interop problems, security issues, and so on. Also, this is not a Chrome specific problem, all major UA's have the same pain points, and we all need to do better.\n- At the same time, all UA's have well-tested JSON parsers. Reusing existing code helps cut down on attack surface area, helps with interop, etc. As such, JFV format is a strong plus.\n- JSON parsers are easy to come by on the server side and all the same benefits and motivation is just as applicable.\n\nThat said, as others have already pointed out, we do need additional restrictions on JFV beyond what is currently in the spec. Also, it just so happens that browsers already follow the [ECMA-262 spec](http://www.ecma-international.org/ecma-262/6.0/index.html), which addresses most of the  raised concerns:\n- Specify how to deal with repeated fields:\n  - [InternalizeJSONProperty(holder, \n    name)](http://www.ecma-international.org/ecma-262/6.0/#sec-internalizejsonproperty): \n    _\"In the case where there are duplicate name Strings within an object, \n    lexically preceding values for the same key shall be overwritten.\"_ All \n    browsers already do this.\n- Specify number encoding format\n  - [4.3.20 Number \n    value](http://www.ecma-international.org/ecma-262/6.0/#sec-terms-and-definitions-number-value): \n    Number value is primitive value corresponding to a double-precision 64-bit \n    binary format IEEE 754-2008 value.\n  - [11.8.3 Numeric \n    Literals](http://www.ecma-international.org/ecma-262/6.0/#sec-literals-numeric-literals)\n- Specify date encoding format\n  - [20.3.1.16 Date Time String \n    Format](http://www.ecma-international.org/ecma-262/6.0/#sec-date-time-string-format), \n    [Date.parse()](http://www.ecma-international.org/ecma-262/6.0/#sec-date.parse)\n    - We can require ISO 8601 Extended format.\n- Specify character encoding\n  - UTF-8 [[RFC3629](https://tools.ietf.org/html/rfc3629)]\n\nAre there other issues that were brought up that are not addressed above? \n\nMy proposal is that we update JFV to spec above ECMA-262 restrictions and requirements. Doing so would enable UA's to adopt JFV with minimal work.\n\n_p.s. in progress specs and browser features that plan on leveraging JFV: [Clear-Site-Data](https://www.w3.org/TR/clear-site-data/), [Feature Policy](http://wicg.github.io/feature-policy/), [Reporting](http://w3c.github.io/reporting/), [Network Error Logging](http://w3c.github.io/network-error-logging/), \u2026 and I'm sure we'll see more soon._\n\n/cc @reschke @mnot @mcmanus \n",
      "createdAt": "2016-08-10T22:52:39Z",
      "updatedAt": "2016-12-25T17:19:55Z",
      "closedAt": "2016-12-25T17:19:55Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hmm. The number issues are around parsing, not generation, AIUI. So, your solution is good for response headers, but not request headers -- because the browsers haven't _yet_ taken over the server side implementations.\n",
          "createdAt": "2016-08-11T00:45:22Z",
          "updatedAt": "2016-08-11T00:45:22Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The pointer to 11.8.3 was intended to tackle parsing; 11.8.3.1 defines the parsing algorithm for numeric literals (precisely, down to potentially rounding in the 20th significant digit). The examples where actually significant digits get ignored would indicate a bug in parsing, according to the ES spec.\n",
          "createdAt": "2016-08-11T03:33:10Z",
          "updatedAt": "2016-08-11T03:33:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Right. The pushback against doing something like this that I've heard is that no matter what we say in the spec, people are going to just point the JSON parser they have at hand at the header field value, and trust what it gives them. \n\nAs such, using JSON is a bit of an attractive nuisance.\n\nIt may be that we can specify a profile of JSON that is safe to use, **and** create a set of easy-to-use libraries and get them into the relevant server-side platforms, but that's a substantial amount of effort (any volunteers?), and the natural lag of many distros/platforms means that they might not be available for some time (leading people to use plain JSON parsers).\n\nThe most serious issue is undoubtedly the number format. Perhaps cautioning against minting headers that use non-integer numbers would be a workable stopgap (although the temptation might be quite strong in some use cases).\n",
          "createdAt": "2016-08-11T03:43:14Z",
          "updatedAt": "2016-08-11T03:43:14Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Well, the alternatives are: hand-rolled ABNF parsers with buggy substring matches (because that seems to be preferred \"optimized\" way of doing things); or completely new parses for each platform for some yet-to-be-defined format... _shrug_, pick your poison. \n\nUA's can enforce the JSON subset (\"strict mode\") we define here, which will nudge all the other parties in the right direction.\n",
          "createdAt": "2016-08-11T04:13:27Z",
          "updatedAt": "2016-08-11T04:13:27Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I do agree that not inventing something new is pretty attractive. How you feel about disallowing (or just strongly warning) against non-integer numbers in request headers?\n",
          "createdAt": "2016-08-11T04:52:19Z",
          "updatedAt": "2016-08-11T04:52:19Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Strongly warning seems reasonable. I'm not aware of any existing efforts that are planning to use non-integer values + JFV, but making that a requirement doesn't feel right either.\n",
          "createdAt": "2016-08-11T04:54:58Z",
          "updatedAt": "2016-08-11T04:54:58Z"
        },
        {
          "author": "rousskov",
          "authorAssociation": "NONE",
          "body": "A JSON profile, strict modes, wrapper API suggestions, and/or strong warnings simply document attack vectors without solving the underlying problem. If JSON is the answer, then it comes with a \"fuzzy numbers\" problem that does not have reliable solutions. You can sugar-coat it or hope that it will go away in 20 years, but you cannot solve it.\n",
          "createdAt": "2016-08-11T18:32:32Z",
          "updatedAt": "2016-08-11T18:32:32Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@igrigorik @mnot \nIf we are to going to use a modified variant of JSON, I strongly support disallowing non-integer numbers.\n\nUsing ECMA262's definition of number would not help us, neither in terms of the definition or the ease of implementation.\n\nRegarding the definition, my understanding is that ECMA262 merely specifies how the numbers should look like as strings, but does _not_ specify _how_ the strings should be converted to IEEE754 numbers. Lack of a formal definition of such procedure is what leads us to disagreements between the implementation (that in turn becomes a cradle of vulnerabilities).\n\nRegarding the ease of implementation, ECMA262 is a _superset_ of JSON in terms of how numbers can be represented (i.e. binary, octal and hexadecimal representations), which seems unnecessary complex to me.\n\n@mnot \n\n> It may be that we can specify a profile of JSON that is safe to use, and create a set of easy-to-use libraries and get them into the relevant server-side platforms, but that's a substantial amount of effort (any volunteers?)\n\nIt _might_ be possible to filter out JSON containing floating point representations _before_ applying a JSON parser, and in that regard, using [json2.js](https://github.com/douglascrockford/JSON-js) (that uses `eval` to parse JSON after filtering out dangerous strings) as a basis might be worth considering. I anticipate that just modifying the number representation in [this regexp](https://github.com/douglascrockford/JSON-js/blob/master/json2.js#L163) would be sufficient for the matter.\n",
          "createdAt": "2016-08-12T00:37:18Z",
          "updatedAt": "2016-08-12T00:37:18Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Parallel thread: https://lists.w3.org/Archives/Public/ietf-http-wg/2016JulSep/thread.html#msg436\n\n@rousskov I appreciate where you're coming from, but (personally, at least) I think that paints an overly black and white prognosis. I think we _could_ make reasonable progress here with a restricted set + browsers enforcement.\n\n@kazuho @mnot I can't shake the feeling that restricting to integer values will come back to bite us, but if you think otherwise.. _shrug_, we can give it a shot.\n",
          "createdAt": "2016-08-16T00:26:00Z",
          "updatedAt": "2016-08-16T00:26:00Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Presumably, we'll also have to restrict the range of integers to `Number.MIN_SAFE_INTEGER <= n <= Number.MAX_SAFE_INTEGER`, to be sure that the value parsed is the same as the number presented in the JSON.\n",
          "createdAt": "2016-08-16T02:54:38Z",
          "updatedAt": "2016-08-16T02:54:38Z"
        },
        {
          "author": "rousskov",
          "authorAssociation": "NONE",
          "body": "@igrigorik I agree -- _reasonable progress_ is very possible, for some definition of reasonable, especially if your primary focus is \"browsers\". That reasonable progress will not solve the problem -- fuzzy JSON numbers will cause CVEs. If reasonable progress [with browsers] is good enough, and a few design-triggered CVEs are not important enough, then this JSON problem is not a big deal at all.\n",
          "createdAt": "2016-08-16T18:06:25Z",
          "updatedAt": "2016-08-16T18:06:25Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, another plausible thing to do would be to require conformance to the I-JSON profile (see https://tools.ietf.org/html/rfc7493).\n\n@igrigorik -- is that something you would consider implementing (essentially adding a stricter mode to the existing JSON parser?)\n",
          "createdAt": "2016-10-07T14:04:52Z",
          "updatedAt": "2016-10-07T14:04:52Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> FWIW, another plausible thing to do would be to require conformance to the I-JSON profile (see https://tools.ietf.org/html/rfc7493).\n\n@reschke that's effectively what we proposed above.. ECMA-262 and I-JSON dictate same rules for number encoding?\n\n---\n\n@clelland @esprehn fyi... phk put together a rough draft of his (alternative) proposal: \n- https://lists.w3.org/Archives/Public/ietf-http-wg/2016OctDec/0099.html\n- https://datatracker.ietf.org/doc/draft-kamp-httpbis-structure/ \n",
          "createdAt": "2016-10-12T16:41:55Z",
          "updatedAt": "2016-10-12T16:41:55Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@igrigorik it's different with respect to duplicate keys...\n",
          "createdAt": "2016-10-12T19:52:27Z",
          "updatedAt": "2016-10-12T19:52:27Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@reschke true, but what's the benefit of I-JSON over the existing ECMA-262 behavior in browsers?\n",
          "createdAt": "2016-10-13T01:54:15Z",
          "updatedAt": "2016-10-13T01:54:15Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "easier to specify from an IETF spec :-).\n\nAt the end of the day, we'll forbid sending duplicate keys anyway, right? The difference is just how the recipient handles those (complain vs last wins)\n",
          "createdAt": "2016-10-13T05:23:38Z",
          "updatedAt": "2016-10-13T05:23:38Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> At the end of the day, we'll forbid sending duplicate keys anyway, right? The difference is just how the recipient handles those (complain vs last wins)\n\nRight. I got internal pushback earlier on special-casing this in our JSON parser (to ignore+complain).. last-wins is simple and consistent with the rest of the (browser) platform.\n",
          "createdAt": "2016-10-13T15:29:03Z",
          "updatedAt": "2016-10-13T15:29:03Z"
        },
        {
          "author": "esprehn",
          "authorAssociation": "NONE",
          "body": "Yeah we don't want to have two versions of the JSON parser. So whatever this spec says should agree with 262.\n",
          "createdAt": "2016-10-17T20:53:07Z",
          "updatedAt": "2016-10-17T20:53:07Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@igrigorik - would something like https://github.com/httpwg/http-extensions/commit/9928ebd187ce272f21f999b26fe656a281defccb work for you?\n",
          "createdAt": "2016-10-20T16:07:51Z",
          "updatedAt": "2016-10-20T16:07:51Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@reschke yes, I think that looks reasonable. \n\n> Furthermore, ordering of object members is not significant and can not be relied upon.\n\nPaging @clelland @esprehn for sanity check.. \n",
          "createdAt": "2016-10-21T23:49:34Z",
          "updatedAt": "2016-10-21T23:49:34Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing, since the WG has abandoned JFV in favour of PHK's proposal.",
          "createdAt": "2016-12-25T17:19:55Z",
          "updatedAt": "2016-12-25T17:19:55Z"
        }
      ]
    },
    {
      "number": 226,
      "id": "MDU6SXNzdWUxNzEyMzcwNzU=",
      "title": "Lax same-site cookies should allow <a target=\"_blank\">",
      "url": "https://github.com/httpwg/http-extensions/issues/226",
      "state": "CLOSED",
      "author": "jakearchibald",
      "authorAssociation": "NONE",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis",
        "samesite"
      ],
      "body": "Unless I'm misreading the spec, it seems like lax same-site cookies will only be sent for top-level browsing contexts. `<a href=\"\u2026\" target=\"_blank\">` creates an auxiliary context.\n\nAs far as I know, the initiator doesn't get any additional information from a `_blank` link, so this restriction seems unnecessary.\n\n+@mikewest \n",
      "createdAt": "2016-08-15T18:59:37Z",
      "updatedAt": "2020-02-05T08:15:53Z",
      "closedAt": "2020-02-05T08:15:52Z",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Auxiliary browsing contexts are top-level browsing contexts (see https://html.spec.whatwg.org/#auxiliary-browsing-context). Given that, my understanding is that the algorithm in https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00#section-4.3 includes them for `lax` same-site cookies.\n",
          "createdAt": "2016-08-16T10:24:57Z",
          "updatedAt": "2016-08-16T10:24:57Z"
        },
        {
          "author": "jakearchibald",
          "authorAssociation": "NONE",
          "body": "Ughhh, you're right, I missed that detail.\n\nThat means lax cookies will be sent on a `window.open` load, which will leak some timing through the window proxy. It's it worth tweaking to avoid that?\n\nI'm looking for ways to allow cookies on top level navigations unless another origin has access to the window proxy (`window.open`, iframes).\n",
          "createdAt": "2016-08-16T10:36:40Z",
          "updatedAt": "2016-08-16T10:36:40Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> That means lax cookies will be sent on a window.open load, which will leak some timing through the window proxy. It's it worth tweaking to avoid that?\n\nUse `SameSite=strict`? I'm not sure I see the value of complicating this even further with `Lax`, `SomewhatLessLax`, and `Strict`.\n\nWhat timing detail leaks through `window.open`? I'm not familiar enough with the various holes we've bored into things at this point...\n\n> I'm looking for ways to allow cookies on top level navigations unless another origin has access to the window proxy (window.open, iframes).\n\n`Lax` takes care of the latter, as I'm sure you're aware.\n",
          "createdAt": "2016-08-16T11:00:09Z",
          "updatedAt": "2016-08-16T11:00:09Z"
        },
        {
          "author": "jakearchibald",
          "authorAssociation": "NONE",
          "body": "A window proxy gives you a load event for the window.\n\nWe've been throwing ideas around in https://github.com/w3c/resource-timing/issues/64 and have come to the conclusion that allowing (and recommending) developers to prevent cross-origin credentialed requests is the answer.\n\nSame-site cookies look like the answer (except for intranet and http auth cases), but losing cookies on navigation seems harsh and breaking.\n\nHow widely deployed are same-site cookies? Is it too late to tweak the lax behaviour?\n",
          "createdAt": "2016-08-16T11:10:21Z",
          "updatedAt": "2016-08-16T11:10:21Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I guess I don't understand how \"allowing developers to prevent cross-origin credentialed requests\" can be the answer, while at the same time \"losing cookies on navigation seems harsh and breaking\".\n\n> How widely deployed are same-site cookies? Is it too late to tweak the lax behaviour?\n\nWhat is it that you'd like to change? If we're going to make changes, now seems like the right time.\n\n(FWIW: It looks like ~0.003% of cookies set in the last month were same-site (with all the usual caveats about audience, opt-ins, etc). We don't have a breakdown between `Lax` and `Strict`, unfortunately.)\n",
          "createdAt": "2016-08-16T11:17:21Z",
          "updatedAt": "2016-08-16T11:21:49Z"
        },
        {
          "author": "jakearchibald",
          "authorAssociation": "NONE",
          "body": "> I guess I don't understand how \"allowing developers to prevent cross-origin credentialed requests\" can be the answer, while at the same time \"losing cookies on navigation seems harsh and breaking\".\n\nAh yeah, I wasn't clear. The (non-strict) problem is not so much about being able to make the request, but being able to learn something from the response. `.open` gives the initiator a load event.\n\nIf I'm right (which isn't often), \"lax\" same-site only gives the initiator control over the new credentialed top level window in the case of `window.open`, and my proposal is that it shouldn't. Cookies should only be sent if the initiator has no handle to the new cross-origin window.\n",
          "createdAt": "2016-08-16T11:30:54Z",
          "updatedAt": "2016-08-16T11:30:54Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> `.open` gives the initiator a load event.\n\nAlternatively, can we stop doing this? :)\n",
          "createdAt": "2016-08-16T11:34:49Z",
          "updatedAt": "2016-08-16T11:34:49Z"
        },
        {
          "author": "jakearchibald",
          "authorAssociation": "NONE",
          "body": "We were discussing stuff like that (and padding load times etc), but the worry is it's a hacky patch, and the information will be leaked somewhere else.\n\nEven if we can drop the load event, the initiator can still scroll the page by changing the fragment of the URL whenever it wants.\n\nThe alternative is to send headers that indicate the requesting origin (which could be the `Origin` header if we can tweak its behaviour) & the way it's being loaded (subresource, frame, top level with window proxy, full top level etc). Then server middleware can either serve an error or ignore cookies.\n",
          "createdAt": "2016-08-16T11:45:36Z",
          "updatedAt": "2016-08-16T11:45:36Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> We were discussing stuff like that (and padding load times etc), but the worry is it's a hacky patch, and the information will be leaked somewhere else.\n\nWith the understanding that this is the wrong bug for this discussion: if we feel like this is data that shouldn't be exposed cross-origin, then it seems like a better idea to find and plug the holes rather than creating an opt-in mechanism that folks who know what they're doing can use to protect themselves from things that shouldn't be possible in the first place.\n\nThat is, ideally, we'd make the leak opt-in, not the seal.\n\nAll that said, from a practical perspective we can probably change `Lax`'s behavior to exclude navigations caused by `window.open()` (and `clients.openWindow()`?). I'm a little concerned about both the layering and general confusion along the lines of \"Hey, why am I not signed in?\", though.\n\nHow do you expect this to interact with `noopener`? Is it too confusing that the `disown-opener` directive is available only after the request is sent?\n",
          "createdAt": "2016-08-16T12:03:37Z",
          "updatedAt": "2016-08-16T12:03:37Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Also, +@annevk, as it seems like we should probably define something at the Fetch level regarding whether or not a given `request` exposes a handle if we're going to go this route.\n",
          "createdAt": "2016-08-16T12:05:50Z",
          "updatedAt": "2016-08-16T12:06:30Z"
        },
        {
          "author": "jakearchibald",
          "authorAssociation": "NONE",
          "body": "`clients.openWindow()` doesn't give you a handle to a cross-origin client, so cookies can be sent.\n\nIt'd be great if the `noopener` option on `window.open` would allow cookies (you don't get load events then do you?).\n\nWe've been encouraged to move away from \"bandaid\" solutions by @sleevi https://github.com/w3c/resource-timing/issues/64#issuecomment-237899767, which is why we're looking at opt-ins that tackle the root of the problem.\n",
          "createdAt": "2016-08-16T12:10:46Z",
          "updatedAt": "2016-08-16T12:10:46Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> `clients.openWindow()` doesn't give you a handle to a cross-origin client, so cookies can be sent.\n\nI see.\n\n> It'd be great if the noopener option on window.open would allow cookies (you don't get load events then do you?).\n\nYou don't get a handle to the window (`window.open` returns `null`: https://html.spec.whatwg.org/multipage/browsers.html#dom-open).\n\n> We've been encouraged to move away from \"bandaid\" solutions by @sleevi\n\nI think Ryan would agree that it would be better to stop cutting ourselves in the first place by removing features from the default set of things that we offer to developers if we can't build them safely.\n\n> which is why we're looking at opt-ins that tackle the root of the problem.\n\nHrm. I think I disagree that opt-ins \"tackle the root of the problem\". They give developers who pay attention the ability to mitigate the effects of problems. That seems fundamentally different than making the platform sane in the first place. For instance, X years after introduction, ~52% of cookies are set over secure transport, but only 6% of cookies use the `secure` attribute (with all the same measurement caveats as above). I'd suggest that that attribute is rather heavily documented as a best-practice that folks should use unless they have a good reason not to.\n\nIf solving timing attacks is actually important, then it seems like we're going to have to do significantly better than `secure` did to have any meaningful effect with an opt-in. Is that likely?\n\nWe can't be aggressive enough about `SameSite` to make it opt-out without actually breaking the internet. I'm not sure that's the case with the various events and resource timing APIs we expose.\n\nI should probably be typing this on the other bug.\n",
          "createdAt": "2016-08-16T12:48:09Z",
          "updatedAt": "2016-08-16T12:48:09Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "The side-channel attacks via `window.open` will, I hope, be sufficiently addressed via the currently-ongoing work to define and ship `Cross-Origin-Opener-Policy`. @jakearchibald does that mechanism generally address the kinds of concerns you had in mind above?",
          "createdAt": "2020-01-30T11:42:17Z",
          "updatedAt": "2020-01-30T11:42:17Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I'm closing this out, as I'm pretty sure COOP is what we're going to rely on. If I've misunderstood, reopen? :)",
          "createdAt": "2020-02-05T08:15:52Z",
          "updatedAt": "2020-02-05T08:15:52Z"
        }
      ]
    },
    {
      "number": 227,
      "id": "MDU6SXNzdWUxNzE4MzgwMjE=",
      "title": "Advice for new parameters / headers",
      "url": "https://github.com/httpwg/http-extensions/issues/227",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "5987bis"
      ],
      "body": "As per recent discussion, this draft should advise readers about whether or not it should be used for new headers, or new parameters on existing headers.\n\nStraw-man:\n- Change the Abstract to:\n\n> RFC5987 defines an encoding for non-ASCII payloads in HTTP header field value parameters, based upon the encoding defined in RFC2231. This document updates that definition and describes how it should (and should not) be used.\n- Change the first paragraph of Introduction to:\n\n> By default, header field values in HTTP messages ([RFC7230]) cannot directly carry characters outside the US-ASCII coded character set ([RFC0020]). RFC 2231 ([RFC2231]) defines an encoding mechanism for use in MIME headers. This specification documents a subset of that encoding that has been used in some HTTP header fields. Its use in new header fields, or new parameters on existing header fields, is NOT RECOMMENDED.\n- Remove section 4 contents (and subsections), replace with:\n\n> The convention defined by this specification allows a parameter fields that have two possible encodings (ASCII without the `*`, UTF-8 with it). This causes considerable complication in the use and implementation of those parameters, since they now have to handle both, and all of the possible permutations and edge conditions implied by this (e.g., how a header field value with both ought to be handled).\n> Furthermore, this encoding can only be used in parameter values, not in other parts of header field values.\n> As a result, use of this encoding is only RECOMMENDED where already defined; new header fields, as well as new parameters on existing header fields, SHOULD NOT use it when non-ASCII content is anticipated. Instead, they SHOULD mandate a character encoding of UTF-8, combined with escaping of non-ASCII characters using a well-defined convention (e.g., percent encoding, as per [RFC3986).\n- Optionally, move the existing contents of section 4 into an appendix, but clarify that they're there merely for the benefit of existing uses.\n",
      "createdAt": "2016-08-18T07:47:11Z",
      "updatedAt": "2016-10-11T05:46:38Z",
      "closedAt": "2016-10-11T05:46:38Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I disagree with the proposed change; in particular for header fields that already use this syntax.\n\nWe could make a recommendation for new header fields, but what you propose is yet another new format, so I just do not see the benefit over that we have right now.\n",
          "createdAt": "2016-09-02T16:45:58Z",
          "updatedAt": "2016-09-02T16:45:58Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Right now, do headers that use this convention define it to be used for _all_ parameters, or only nominated ones? My understanding is that it's usually the latter (i.e., a case-by-case basis).\n\nI'd argue that discouraging its use for new parameters on existing headers avoids the problem found in https://github.com/mnot/I-D/issues/180; indeed, that's what I plan to do there. \n\nI.e., having two possible encodings for the same parameter, and switching the encoding on the parameter name, is an anti-pattern, and should be discouraged. \n\nThat being the case, the benefit is clear (at least to me, after going through that issue).\n",
          "createdAt": "2016-09-05T02:29:04Z",
          "updatedAt": "2016-09-05T02:29:04Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The concern is that we do not really have an alternative that we can recommend instead.\n",
          "createdAt": "2016-09-05T05:21:23Z",
          "updatedAt": "2016-09-05T05:21:23Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We could give an example, e.g., percent-encoding over utf-8 (which is already specified elsewhere).\n",
          "createdAt": "2016-09-05T06:13:19Z",
          "updatedAt": "2016-09-05T06:13:19Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A format that has a single mode _and_ supports non-ASCII (over HTTP/1.1) will need an escape character (such as %). This is a new format (if we don't count the Slug header field in atompub). It also means that senders always will have to escape (so that \"%\" isn't ambiguous).\n\nYes, we can specify that somewhere, but until we do so we can't recommend something like that. At the end of the day it's not clear to me at all whether yet another format improves the situation.\n",
          "createdAt": "2016-09-05T06:52:35Z",
          "updatedAt": "2016-09-05T06:52:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed on list; closing with no action.\n",
          "createdAt": "2016-10-11T05:46:38Z",
          "updatedAt": "2016-10-11T05:46:38Z"
        }
      ]
    },
    {
      "number": 228,
      "id": "MDU6SXNzdWUxNzIyNDQ5ODM=",
      "title": "Digest algorithm",
      "url": "https://github.com/httpwg/http-extensions/issues/228",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "A few people have noted that SHA-1 is probably overkill.\n",
      "createdAt": "2016-08-20T01:01:13Z",
      "updatedAt": "2017-02-07T05:06:38Z",
      "closedAt": "2017-02-07T05:06:38Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "EKR points out:\n  http://aras-p.info/blog/2016/08/09/More-Hash-Function-Tests/\n",
          "createdAt": "2016-08-23T05:27:38Z",
          "updatedAt": "2016-08-23T05:27:38Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Considering the fact that N and P are both defined to be 5 bits, it would be preferable to use a hash function that emits a 62-bit or longer value.\n",
          "createdAt": "2016-09-12T08:50:38Z",
          "updatedAt": "2016-09-12T08:50:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "xxHash seems good, but see https://github.com/Cyan4973/xxHash/issues/49.\n\nLikewise, the other ones mentioned there are also defined by their source.\n\nI think our options are:\n1. Specify one of these as a normative reference and hope we can get that through the process (not likely)\n2. Write the spec for one of these (ouch)\n3. Wait for someone else to write the spec for one of these (may be some time)\n4. Continue using a specified algorithm. \n\nI'm kind of leaning towards (4), possibly leaving extensibility for other hash algorithms (although, as discussed before, it's not clear how we'd negotiate for that; maybe #22 could help).\n\nThoughts?\n",
          "createdAt": "2016-09-28T04:49:12Z",
          "updatedAt": "2016-09-28T04:49:12Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Don't know what the relevance of #22 is.\n\nI would say that this seems like a good basis for 2: https://github.com/aappleby/smhasher/wiki/MurmurHash3  These are necessarily very simple programs to specify.  A draft shouldn't be hard to write if that's necessary.  Of course, I'm lazy just like you.\n",
          "createdAt": "2016-09-28T06:42:08Z",
          "updatedAt": "2016-09-28T06:42:08Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Sorry, #229.\n\nI take it you're volunteering, then...\n",
          "createdAt": "2016-09-28T06:44:25Z",
          "updatedAt": "2016-09-28T06:44:25Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"Internet-Draft seeks editor, must like long walks on the beach, sunsets and have poor impulse control.\"\n",
          "createdAt": "2016-09-28T07:02:23Z",
          "updatedAt": "2016-09-28T07:02:23Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fat fingers, bah.\n",
          "createdAt": "2016-09-28T07:02:46Z",
          "updatedAt": "2016-09-28T07:02:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My tendency goes to 4.\n\nIf we are to actually choose a simpler algorithm than SHA, I think the choice should better be made based on the popularity and the quality of the hash function.\n\nAnd for that respect, SipHash 2-4 might be a good candidate. It is known to be fairly fast, and is used as a basis by many hash table implementations (thanks to its resistance to collision).\n\nI am not sure how collisions can be used to attack Cache Digests, but it might still be a good idea to have resistance considering the fact that an attacker can insert a digest (by controlling the victim's browser to access a specific resource on the target's website (by using IMG links, etc.).\n",
          "createdAt": "2016-09-28T07:06:18Z",
          "updatedAt": "2016-09-28T07:06:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Any attack on cache digests is likely to be an advance on cache-timing attacks where the attacker tries to learn whether a particular resource is in the cache.\n\nSay that we have a secret in a URI path and the attacker wants to learn that secret.  If the resource is ordinarily pushed alongside a parent document AND neither the parent document nor the secret resource are cacheable you have a way to exploit things AND the 404 page on the site IS cacheable then you have a situation that can be exploited.\n\nThe attacker includes the parent document in an iframe and measures the time to load the document when the secret is pushed.  The attacker then iteratively tests different URIs by forcing a load of a non-existent, but potentially colliding resource then reloading the iframe.  A collision will be apparent when the iframe load takes significantly longer (one round trip).  At that point, the attacker need only generate hash pre-images (since none of the fast hashes claims to have pre-image resistance, this isn't that difficult given sufficient constraints on the shape of the secret) until it finds the secret.\n\nThis has a false positive rate that would have to be corrected by a more rigorous test on potential candidates, but it seems like it could be feasible given enough time.  Everyone give thanks to @w3c/hr-time for making this possible!\n\nSimilarly, if the pushed resource is cached, then the attacker might find a way for the server to server and conditionally push it resources with a URI component that is attacker controlled.  That would enable a faster attack too.\n\nThis attack might be used to recover whose twitter feed someone has viewed.  Even though user images are bucketed in size to resist traffic analysis, this sort of attack relies on a different side channel that I doubt has been properly safeguarded.\n\nThis is rendered less effective by choosing a hash with pre-image resistance.  It's still relatively easy to engineer a collision (particularly since cache digests are necessarily very narrow), but the hash can't be reversed to find the URL.  It could still be used as a confirmation step.  While the space of potential twitter image URLs is obscenely large, the set accounts that are interesting to an attacker might be easily enumerable (if not all accounts if it comes to certain resourceful attackers).\n",
          "createdAt": "2016-09-28T07:59:40Z",
          "updatedAt": "2016-09-28T07:59:40Z"
        },
        {
          "author": "sebdeckers",
          "authorAssociation": "NONE",
          "body": "When using small values, 50-100 bytes of a typical URL (w/o origin), I do not see significant performance difference between sha256 and xxhash64 using pure JavaScript implementations in the browser. YMMV.\n\nCode & results:\nhttps://gitlab.com/sebdeckers/fingerprinting-benchmarks\n",
          "createdAt": "2016-11-14T08:24:36Z",
          "updatedAt": "2016-11-14T08:24:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "That's very helpful, thanks. Given that, I think we can close this issue with no action (reopening if we learn something new, of course).",
          "createdAt": "2017-02-07T05:06:38Z",
          "updatedAt": "2017-02-07T05:06:38Z"
        }
      ]
    },
    {
      "number": 229,
      "id": "MDU6SXNzdWUxNzIyNDUwMTU=",
      "title": "Server opt-in",
      "url": "https://github.com/httpwg/http-extensions/issues/229",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "Some mechanism to note that the server wants CD would be good.\n",
      "createdAt": "2016-08-20T01:01:47Z",
      "updatedAt": "2017-05-25T07:29:58Z",
      "closedAt": "2017-05-25T07:29:58Z",
      "comments": []
    },
    {
      "number": 230,
      "id": "MDU6SXNzdWUxNzI4NzcwOTc=",
      "title": "Make Rice paper reference more prominent",
      "url": "https://github.com/httpwg/http-extensions/issues/230",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "cache-digest",
        "editorial"
      ],
      "body": "as per @martinthomson \n",
      "createdAt": "2016-08-24T06:49:22Z",
      "updatedAt": "2016-10-31T23:40:14Z",
      "closedAt": "2016-10-31T23:40:14Z",
      "comments": []
    },
    {
      "number": 231,
      "id": "MDU6SXNzdWUxNzI4ODA2MTQ=",
      "title": "Allow alternation in substr",
      "url": "https://github.com/httpwg/http-extensions/issues/231",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "key"
      ],
      "body": "E.g., \n\n> substr=foo|bar\n",
      "createdAt": "2016-08-24T07:13:37Z",
      "updatedAt": "2018-04-03T23:40:25Z",
      "closedAt": "2018-04-03T23:40:25Z",
      "comments": []
    },
    {
      "number": 232,
      "id": "MDU6SXNzdWUxNzI4ODA3ODc=",
      "title": "Short Circuit",
      "url": "https://github.com/httpwg/http-extensions/issues/232",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "key"
      ],
      "body": "Some sort of syntax to denote that if a match is made, stop processing, to allow control over permutations.\n",
      "createdAt": "2016-08-24T07:14:45Z",
      "updatedAt": "2018-04-03T23:40:25Z",
      "closedAt": "2018-04-03T23:40:25Z",
      "comments": [
        {
          "author": "triblondon",
          "authorAssociation": "NONE",
          "body": "I like this idea because it allows for what I've typically called 'branched vary logic', ie. multiple variations for a URL do not all have to share the same Vary header.  This use case is [described in detail in a post I made](https://www.fastly.com/blog/getting-most-out-vary-fastly) on the Fastly engineering blog today under the heading \"Reducing granularity with variable Vary values for the same URL\"\r\n\r\nWith Key, there's a baked in requirement for all variations to have the same key recipe, which simplifies implementation and allows for higher performance at scale, but appears to scupper the potential for branched logic.  However, Key could have a mechanism that halts the construction of the key at the current rule if some condition is met.   Straw man syntax proposal:\r\n\r\n```\r\nKey: AcmeCo-Auth-State; param=role; end-on-match=\"anon\", AcmeCo-ABTestFlags\r\n```\r\n\r\nThis says vary on the `role` subfield of the `AcmeCo-Auth-State` header, and if that value is *not* \"anon\", also vary on `AcmeCo-ABTestFlags`.",
          "createdAt": "2017-08-22T17:46:30Z",
          "updatedAt": "2017-08-22T17:46:30Z"
        }
      ]
    },
    {
      "number": 233,
      "id": "MDU6SXNzdWUxNzI4ODA4ODQ=",
      "title": "Integers",
      "url": "https://github.com/httpwg/http-extensions/issues/233",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "key"
      ],
      "body": "Define maximums; e.g., uint64_t? for DIV, PARTITION\n",
      "createdAt": "2016-08-24T07:15:20Z",
      "updatedAt": "2018-04-03T23:40:25Z",
      "closedAt": "2018-04-03T23:40:25Z",
      "comments": []
    },
    {
      "number": 234,
      "id": "MDU6SXNzdWUxNzU2MDEzNzE=",
      "title": "require tls auth",
      "url": "https://github.com/httpwg/http-extensions/issues/234",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "1] opportunistic security should require TLS authentication. Any other approach undermines the opt-in mechanism of .wk. As the PKI market has matured to allow truly free and automated certs certificate availability is no longer the chief barrier to https, and so opportunistic security should feel comfortable requiring real authentication. (THERE IS NO PROPOSED CHANGE IN THE SECURITY MODEL - HTTP:// IS STILL HTTP:// AND NOT GRANTED HTTPS:// STATUS AT ALL). The biggest barrier to https:// at this point seems to be mixed content.\n",
      "createdAt": "2016-09-07T20:43:13Z",
      "updatedAt": "2016-11-21T02:13:14Z",
      "closedAt": "2016-11-21T02:13:14Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not convinced, in particular because it's a rather drastic change at this point. If authentication is OK, isn't it much easier just to redirect the client to the HTTPS port? Wouldn't we remove the main reason why this was specced in the first place? \n",
          "createdAt": "2016-09-08T05:53:44Z",
          "updatedAt": "2016-09-08T05:53:44Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure what you mean by https _port_ - which is indeed what this will\noften accomplish by using TLS over 443. It will however not redirect them\nto an https scheme (use 3xx for that).\n\nThe main reason for this spec would be for improving the use of http\nschemed content that needs to remain that way for legacy reasons (chiefly\nmixed content restrictions). https is going to be superior and you should\nrun it if you can. easy and free DV authentication has proven itself at\nthis point.\n\nas for drastic at this point -there is no point in moving the document\nalong just for the sake of moving the document along if it doesn't reflect\nthe experiment. And what we found was that in order to take the opt in of\n.wk seriously it needed to be authenticated.\n\nOn Thu, Sep 8, 2016 at 1:53 AM, Julian Reschke notifications@github.com\nwrote:\n\n> Not convinced, in particular because it's a rather drastic change at this\n> point. If authentication is OK, isn't it much easier just to redirect the\n> client to the HTTPS port? Wouldn't we remove the main reason why this was\n> specced in the first place?\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> https://github.com/httpwg/http-extensions/issues/234#issuecomment-245500724,\n> or mute the thread\n> https://github.com/notifications/unsubscribe-auth/AAP5swMLfvCsvwXrrk9eoWpbsR8_uXENks5qn6LpgaJpZM4J3Ved\n> .\n",
          "createdAt": "2016-09-08T14:15:38Z",
          "updatedAt": "2016-09-08T14:15:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Question: is the intent to retain the requirement that the alternative service be on the same host?\n",
          "createdAt": "2016-09-28T02:57:09Z",
          "updatedAt": "2016-09-28T02:57:09Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot  [_Question: is the intent to retain the requirement that the alternative service be on the same host?_]\n\nno such requirement now that we have auth and .wk\n",
          "createdAt": "2016-09-28T12:39:45Z",
          "updatedAt": "2016-09-28T12:39:45Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Resolved in the latest.",
          "createdAt": "2016-11-21T02:13:14Z",
          "updatedAt": "2016-11-21T02:13:14Z"
        }
      ]
    },
    {
      "number": 235,
      "id": "MDU6SXNzdWUxNzU2MDE2MDg=",
      "title": "require .well-known/http-opportunistic",
      "url": "https://github.com/httpwg/http-extensions/issues/235",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "2] /.well-known/http-opportunistic should always be required. The current doc is actually a little fuzzy on this, I think by accident. It refers to this as an \"additional mechanism\" in addition to authentication. But .wk does not really play the same role - it allows the server to opt-in to being an alternate for specific origins on specific ports. So if we're going to use it - we should always use it. (This has no bearing on https:// alt-svc, this is just about http:// as that is all this doc governs).\n\n[There is further discussion of this on list]\n",
      "createdAt": "2016-09-07T20:44:20Z",
      "updatedAt": "2016-11-21T21:44:32Z",
      "closedAt": "2016-11-21T02:13:00Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mcmanus let me know if this isn't clear in the latest version.  I think that we're OK.",
          "createdAt": "2016-11-21T02:13:00Z",
          "updatedAt": "2016-11-21T02:13:00Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "lgtm; thanks",
          "createdAt": "2016-11-21T21:44:32Z",
          "updatedAt": "2016-11-21T21:44:32Z"
        }
      ]
    },
    {
      "number": 236,
      "id": "MDU6SXNzdWUxNzU2MDE3NDU=",
      "title": "remove tls-commit",
      "url": "https://github.com/httpwg/http-extensions/issues/236",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "3] get rid of tls-commit (i.e. the latch to opp sec) as this plays very poorly with alt-svc. The notion of alt-svc has always been that it is a shortcut route (or dns name if your prefer) for the same content as supplied at the default origin. If for any reason you cannot get there, you can always go back to the default origin. All of the machinery around this (validating alternates, etc) can happen transparently and asynchronously in the background until they are ready to be used. A mechanism that requires a characteristic of a route (auth'd TLS) but not the route itself doesn't play well - its far too easy to brick your site for an extended period of time and really ceases to be opportunistic in any meaningful sense. If you're up to managing this, then you're probably up to the fight of running https:// and using HSTS which at least has the benefit of not bringing a whole second technology (alt-svc) into play.\n\n[there is further discussion on list]\n",
      "createdAt": "2016-09-07T20:44:53Z",
      "updatedAt": "2016-09-28T03:09:05Z",
      "closedAt": "2016-09-28T03:09:05Z",
      "comments": []
    },
    {
      "number": 238,
      "id": "MDU6SXNzdWUxODEwNzQwODc=",
      "title": "Cookies set with or without leading dot in domain attribute",
      "url": "https://github.com/httpwg/http-extensions/issues/238",
      "state": "CLOSED",
      "author": "bagder",
      "authorAssociation": "NONE",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "... are they two distinct cookies and in which order should they be sent?\n\n[on the list](https://lists.w3.org/Archives/Public/ietf-http-wg/2016OctDec/0046.html)\n",
      "createdAt": "2016-10-05T06:24:35Z",
      "updatedAt": "2020-01-10T07:40:23Z",
      "closedAt": "2020-01-10T07:40:22Z",
      "comments": [
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Reading this old mailing list discussion, you mention that Firefox and Chrome agree on how to handle this but Safari and Edge do it differently. You don't happen to have those three behaviors documented, do you? If not, can we at least get the Chrome+Firefox behavior stated here? Thanks!",
          "createdAt": "2018-12-18T18:15:50Z",
          "updatedAt": "2018-12-18T18:15:50Z"
        },
        {
          "author": "bagder",
          "authorAssociation": "NONE",
          "body": "Clearly I didn't use enough details when I wrote about it back then, and now I can't remember the specifics anymore. I suppose someone would have to do another similar experiment to figure it out again... sorry! :disappointed: ",
          "createdAt": "2018-12-18T21:20:10Z",
          "updatedAt": "2018-12-18T21:20:10Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "We now have https://wpt.fyi/results/cookies/http-state/domain-tests.html?label=experimental&label=master&aligned copied over from Adam's old test repository, and several of those tests do exercise leading `.`s. Unfortunately we did a bad job of aligning the domain tests with the WPT framework (`home.example.com` is hard-coded). I'll poke at them to see if it's possible to rework the test data to match WPT's domain structure.",
          "createdAt": "2019-12-29T09:43:04Z",
          "updatedAt": "2019-12-29T09:43:04Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "It's a bigger problem than I have time for at the moment. Basically, we did a bad job porting the domain tests, and none work the way they're supposed to. We need to rewrite them.",
          "createdAt": "2019-12-29T10:00:35Z",
          "updatedAt": "2019-12-29T10:00:35Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I put together [quick tests](https://github.com/web-platform-tests/wpt/pull/20934) for the specific thing this bug is asking about, and Chromium and Firefox both interpret `Set-Cookie: a=b; Domain=.web-platform.test` as `Set-Cookie: a=b; Domain=web-platform.test` (stripping the leading `.`), while Safari appears to treat it as `Set-Cookie: a=b` (e.g. ignoring the `Domain` attribute).\r\n\r\nhttps://tools.ietf.org/html/rfc6265#section-5.2.3 suggests that Chromium/Firefox's behavior is expected. The leading `.` should be stripped, and therefore only one cookie is set as the two declarations are exactly the same. Given that we have some agreement between two engines and the spec, I'd prefer to close this out after the tests land, and treat the disagreement as a bug in WebKit/CFNetwork.",
          "createdAt": "2019-12-29T14:33:49Z",
          "updatedAt": "2019-12-29T14:33:49Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I put together [quick tests](https://github.com/web-platform-tests/wpt/pull/20934) for the specific thing this bug is asking about, and Chromium and Firefox both interpret `Set-Cookie: a=b; Domain=.web-platform.test` as `Set-Cookie: a=b; Domain=web-platform.test` (stripping the leading `.`), while Safari appears to treat it as `Set-Cookie: a=b` (e.g. ignoring the `Domain` attribute).\r\n> \r\n> https://tools.ietf.org/html/rfc6265#section-5.2.3 suggests that Chromium/Firefox's behavior is expected. The leading `.` should be stripped, and therefore only one cookie is set as the two declarations are exactly the same. Given that we have some agreement between two engines and the spec, I'd prefer to close this out after the tests land, and treat the disagreement as a bug in WebKit/CFNetwork.\r\n\r\nSounds like the right thing to do. I\u2019ll put on my todo list to file the CFNetwork bug.",
          "createdAt": "2019-12-29T15:07:10Z",
          "updatedAt": "2019-12-29T15:07:10Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Tests landed in https://github.com/web-platform-tests/wpt/pull/20934, no spec update necessary. Closing this out.",
          "createdAt": "2020-01-10T07:40:22Z",
          "updatedAt": "2020-01-10T07:40:22Z"
        }
      ]
    },
    {
      "number": 243,
      "id": "MDU6SXNzdWUxODIxNzUxNjc=",
      "title": "List nesting",
      "url": "https://github.com/httpwg/http-extensions/issues/243",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "From Kari on-list:\n\n5.1.3.  Domain Matching\nhttps://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-00#section-5.1.3\n\nThere is some nested lists lost.\n\n|   o  The domain string and the string are identical.  (Note that both\n|      the domain string and the string will have been canonicalized to\n|      lower case at this point.)\n|   o  All of the following conditions hold:\n|   o  The domain string is a suffix of the string.\n|   o  The last character of the string that is not included in the\n|      domain string is a %x2E (\".\") character.\n|   o  The string is a host name (i.e., not an IP address\n\nThese should be on nested list, I think:\n\n|   o  The domain string is a suffix of the string.\n|   o  The last character of the string that is not included in the\n|      domain string is a %x2E (\".\") character.\n|   o  The string is a host name (i.e., not an IP address\n\nRFC 6265 was\n\n5.1.3.  Domain Matching\nhttps://tools.ietf.org/html/rfc6265#section-5.1.3\n\n|   o  The domain string and the string are identical.  (Note that both\n|      the domain string and the string will have been canonicalized to\n|      lower case at this point.)\n|\n|   o  All of the following conditions hold:\n|\n|      \\*  The domain string is a suffix of the string.\n|\n|      \\*  The last character of the string that is not included in the\n|         domain string is a %x2E (\".\") character.\n|\n|      \\*  The string is a host name (i.e., not an IP address).\n",
      "createdAt": "2016-10-11T05:10:00Z",
      "updatedAt": "2016-10-11T08:23:28Z",
      "closedAt": "2016-10-11T08:22:56Z",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Thanks! This will be taken care of in a -01 (but I'll wait to publish that, as I assume we'll find more of these porting mistakes over the next week or so).\n",
          "createdAt": "2016-10-11T08:23:28Z",
          "updatedAt": "2016-10-11T08:23:28Z"
        }
      ]
    },
    {
      "number": 245,
      "id": "MDU6SXNzdWUxODIyMjA0MDI=",
      "title": "document needs a \"Changes from RFC 6265\" appendix.",
      "url": "https://github.com/httpwg/http-extensions/issues/245",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "",
      "createdAt": "2016-10-11T09:46:13Z",
      "updatedAt": "2017-08-07T11:58:30Z",
      "closedAt": "2017-08-07T11:58:30Z",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Added in -01: https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-01#appendix-A.",
          "createdAt": "2017-08-07T11:58:30Z",
          "updatedAt": "2017-08-07T11:58:30Z"
        }
      ]
    },
    {
      "number": 246,
      "id": "MDU6SXNzdWUxODIyMjA1NDU=",
      "title": "broken ABNF",
      "url": "https://github.com/httpwg/http-extensions/issues/246",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "FWIW, I believe this change:\n\nOld:\n\n  token = <token, defined in [RFC2616], Section 2.2>\n\nNew:\n\n  token = token\n            ; defined in [RFC2616], Section 2.2\n\nis a bad idea; it makes the ABNF invalid.\n\n(similar changes have been made to other imports)\n",
      "createdAt": "2016-10-11T09:46:52Z",
      "updatedAt": "2016-10-12T07:53:14Z",
      "closedAt": "2016-10-12T07:53:14Z",
      "comments": []
    },
    {
      "number": 247,
      "id": "MDU6SXNzdWUxODIyMjIwODU=",
      "title": "need to update IANA section",
      "url": "https://github.com/httpwg/http-extensions/issues/247",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "1) \"The permanent message header field registry (see [RFC3864]) has been updated with the following registrations.\" -> \"The permanent message header field registry (see [RFC3864]) needs to be updated with the following registrations.\"\n\n2) Remove the entries related to Set-Cookie2.\n",
      "createdAt": "2016-10-11T09:53:34Z",
      "updatedAt": "2016-10-12T07:53:14Z",
      "closedAt": "2016-10-12T07:53:14Z",
      "comments": []
    },
    {
      "number": 248,
      "id": "MDU6SXNzdWUxODI0NDAxODQ=",
      "title": "[6265bis] Add double-keying policy example to \"Third-party cookies\" section",
      "url": "https://github.com/httpwg/http-extensions/issues/248",
      "state": "CLOSED",
      "author": "arthuredelstein",
      "authorAssociation": "NONE",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "Firefox and Tor Browser are introducing an [option](https://www.torproject.org/projects/torbrowser/design/#idp55056352) to \"double-key\" cookies by (origin-domain|first-party-domain). (The first-party domain is defined as domain of the top-level document, visible to the user as the domain in the URL bar at the top of the browser.)\n\nWith double keying, it is possible for third-party cookies to be stored and retrieved, these third-party cookies cannot be used for tracking across websites.\n\nI think this policy is notable in that it keeps third-party cookies enabled but also prevents tracking. Thus third-party cookies function properly for many use cases. I would like to suggest adding this policy to the discussion of examples in RFC6265 section 7.1, \"Third-party cookies.\" After the sentence, \n\n> Others refuse to process the Set-Cookie header in responses to third-party requests.\n\nit might be of helpful to add something like\n\n> Still others store third-party cookies loaded by different first-party domains into separate cookie databases, to prevent cross-site tracking.\n",
      "createdAt": "2016-10-12T05:41:53Z",
      "updatedAt": "2017-08-07T17:54:22Z",
      "closedAt": "2017-08-07T13:08:55Z",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Thanks!\n",
          "createdAt": "2016-10-12T05:46:39Z",
          "updatedAt": "2016-10-12T05:46:39Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Better than that, in Firefox we have the ability to segment/compartmentalize based on user categorization of tabs (which uses the same underlying mechanism, which we call origin attributes; \"extended origin\" was already taken).\n\nThat means that there are multiple criteria that we might use to partition cookies: primary origin, top-level browsing context origin, \"container\", user profile, etc...  Maybe this needs to be a even more generic:\n\n> Clients might refuse to process cookies or segregate cookies based on context.  This might be done to prevent correlation of requests between separate contexts.  For instance, cookies sent to a browser in a third-party context might be separated based on the first-party context.\n\n(Your words are likely to be better here.)\n",
          "createdAt": "2016-10-12T11:49:52Z",
          "updatedAt": "2016-10-12T11:49:52Z"
        },
        {
          "author": "michael-oneill",
          "authorAssociation": "NONE",
          "body": "It would be useful to have an attribute in the Set-Cookie header so origins can specify double keying if the user agent supports it.\r\n\r\nSet-Cookie: {name}={value};doubleKeyed;hhpOnly etc....",
          "createdAt": "2016-11-22T13:51:42Z",
          "updatedAt": "2016-11-22T13:51:42Z"
        },
        {
          "author": "michael-oneill",
          "authorAssociation": "NONE",
          "body": "Woops\r\n\r\nSet-Cookie: {name}={value};doubleKeyed;httpOnly;secure etc....",
          "createdAt": "2016-11-22T13:54:00Z",
          "updatedAt": "2016-11-22T13:54:00Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Isn't that effectively what SameSite is?\r\n\r\nhttp://httpwg.org/http-extensions/draft-ietf-httpbis-cookie-same-site.html",
          "createdAt": "2016-11-23T02:21:07Z",
          "updatedAt": "2016-11-23T02:21:07Z"
        },
        {
          "author": "michael-oneill",
          "authorAssociation": "NONE",
          "body": "Actually, after thinking about it, it's not the same. \r\n\r\nThe SameSite attribute says only send this cookie in a request when it is same origin as the top-level browsing context - effectively the server is asking for a \"third-party cookie block\" for this cookie.\r\n\r\nI was thinking of the doubleKeyed cookie idea where there is a separate cookie store for the parent contexts, which would allow a lot of functionality but mitigate cross-origin tracking. If this supported as a user option in the UA why not extend it as a server option also allowing sites to help protect user's privacy.\r\n\r\nMaybe there is a halfway house where you could constrain sending back cookies to same context i.e. the chain of descendent origins is the same as when the cookie was stored \r\n\r\ntoplevel.com->widgit.com->cookiedwidgit.com\r\nis not \"same context\" as\r\nother-toplevel.com->cookiedwidgit.com etc.\r\n\r\n\r\n",
          "createdAt": "2016-11-24T19:36:06Z",
          "updatedAt": "2016-11-24T19:36:06Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I'll add in the editorial note discussed above in an upcoming -02 draft.\r\n\r\n@michael-oneill: I don't intend to define a `DoubleKeyed` attribute in this round of edits, as it's not clear to me what value it would actually provide for developers. If you think it's something we ought to implement, I'd suggest sketching out an explainer document in a little more detail so we have a concrete problem we can discuss. :)",
          "createdAt": "2017-08-07T12:45:05Z",
          "updatedAt": "2017-08-07T12:45:05Z"
        },
        {
          "author": "arthuredelstein",
          "authorAssociation": "NONE",
          "body": "Looks great. Thanks!",
          "createdAt": "2017-08-07T17:54:22Z",
          "updatedAt": "2017-08-07T17:54:22Z"
        }
      ]
    },
    {
      "number": 251,
      "id": "MDU6SXNzdWUxODU2MTkyMTg=",
      "title": "sender requirements for JSON need to address control characters in strings",
      "url": "https://github.com/httpwg/http-extensions/issues/251",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "jfv"
      ],
      "body": "",
      "createdAt": "2016-10-27T09:37:19Z",
      "updatedAt": "2016-10-27T10:32:41Z",
      "closedAt": "2016-10-27T10:32:41Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not a problem, as control characters in strings must be escaped anyway.\n",
          "createdAt": "2016-10-27T10:32:41Z",
          "updatedAt": "2016-10-27T10:32:41Z"
        }
      ]
    },
    {
      "number": 253,
      "id": "MDU6SXNzdWUxODYxNjUwOTQ=",
      "title": "Update acknowledgments",
      "url": "https://github.com/httpwg/http-extensions/issues/253",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "encryption"
      ],
      "body": "Just a reminder to update the list since we've had a fair bit of new input on this recently.\n",
      "createdAt": "2016-10-30T21:19:01Z",
      "updatedAt": "2016-10-30T23:57:27Z",
      "closedAt": "2016-10-30T23:57:27Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "4a819685d7afcdb7930e69f8198a9bdb1e3c3c6b\n",
          "createdAt": "2016-10-30T23:57:27Z",
          "updatedAt": "2016-10-30T23:57:27Z"
        }
      ]
    },
    {
      "number": 255,
      "id": "MDU6SXNzdWUxODY0Mjc1OTU=",
      "title": "Flags",
      "url": "https://github.com/httpwg/http-extensions/issues/255",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "We need to evaluate and possibly pare down / adjust the flags in the frame, based upon real-world use cases.\r\n\r\nSee Kazuho's evaluation:\r\n  https://github.com/HTTPWorkshop/workshop2016/blob/master/talks/cache-digests.pdf",
      "createdAt": "2016-10-31T23:26:57Z",
      "updatedAt": "2017-06-20T00:00:14Z",
      "closedAt": "2017-06-20T00:00:13Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree the need for evaluation. OTOH, I do not think we should pare down / adjust flags, since real-world use cases could change as time evolves.\r\n\r\nThe way it is defined now represents the cache state as-is and I believe that it would be most resilient in the long term.",
          "createdAt": "2017-04-22T22:28:39Z",
          "updatedAt": "2017-04-22T22:28:39Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK. ",
          "createdAt": "2017-06-20T00:00:13Z",
          "updatedAt": "2017-06-20T00:00:13Z"
        }
      ]
    },
    {
      "number": 256,
      "id": "MDU6SXNzdWUxODY0MzA5NDg=",
      "title": "Advice for ServiceWorker implementation",
      "url": "https://github.com/httpwg/http-extensions/issues/256",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "Perhaps we should add an appendix to help people do this?",
      "createdAt": "2016-10-31T23:50:02Z",
      "updatedAt": "2017-06-19T23:59:38Z",
      "closedAt": "2017-06-19T23:59:38Z",
      "comments": [
        {
          "author": "sebdeckers",
          "authorAssociation": "NONE",
          "body": "FYI/FWIW I've just implemented this spec via a service worker.\n- NPM: https://www.npmjs.com/package/cache-digest-immutable\n- Code: https://gitlab.com/sebdeckers/cache-digest-immutable\n\nIt would be nice if the spec clarified and defined the following. (I deduced it from @kazuho 's server and serviceworker implementations.)\n- HTTP header is called `cache-digest`. This is a very handy alternative to the HTTP2 frame which service workers can't access currently.\n- Base64 encoding must not be padded with `=` trailing.\n- String equivalent of the `COMPLETE` (0x2) flag for the HTTP header is `complete` and appended as `... base64 ...; complete` (note the semicolon and white space)\n\nAdditionally more examples would be welcome, to aid implementors in validating their support. In particular the etags concatenation is unclear to me from the referenced spec.\n",
          "createdAt": "2016-11-13T15:37:34Z",
          "updatedAt": "2016-11-13T15:37:34Z"
        }
      ]
    },
    {
      "number": 260,
      "id": "MDU6SXNzdWUxODY3MDI1MzE=",
      "title": "padding is hard",
      "url": "https://github.com/httpwg/http-extensions/issues/260",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "encryption"
      ],
      "body": "We should provide some advice, along the lines of:\r\n\r\n1. padding is hard\r\n2. padding doesn't stop side channels from processing data\r\n3. should pad the entire message\r\n4. might want to distribute padding evenly",
      "createdAt": "2016-11-02T03:16:13Z",
      "updatedAt": "2016-12-22T03:36:36Z",
      "closedAt": "2016-12-22T03:36:36Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by #272.",
          "createdAt": "2016-12-22T03:36:36Z",
          "updatedAt": "2016-12-22T03:36:36Z"
        }
      ]
    },
    {
      "number": 263,
      "id": "MDU6SXNzdWUxODc5MjcxNTc=",
      "title": "Client hints: add support for hinting Display Gamut / Color Profile",
      "url": "https://github.com/httpwg/http-extensions/issues/263",
      "state": "CLOSED",
      "author": "gunta",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Add Client hints support for the following:\r\n\r\n`Viewport-Color-Gamut`\r\nhttps://drafts.csswg.org/mediaqueries-4/#color-gamut\r\n\r\n`Viewport-Color-Profile`\r\nhttps://www.w3.org/TR/css-color-4/#at-ruledef-profile",
      "createdAt": "2016-11-08T08:12:09Z",
      "updatedAt": "2017-09-20T08:48:02Z",
      "closedAt": "2016-12-25T17:19:07Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The spec is past WGLC, so adding new hints right now might be bad timing.\n",
          "createdAt": "2016-11-08T08:29:49Z",
          "updatedAt": "2016-11-08T08:29:49Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@gunta can you elaborate on the use cases and motivation for sending this data as a request header?\n",
          "createdAt": "2016-11-08T16:23:52Z",
          "updatedAt": "2016-11-08T16:23:52Z"
        },
        {
          "author": "gunta",
          "authorAssociation": "NONE",
          "body": "@igrigorik Yes, definitely.\n\nThe reason for this request is that recently, there has been a huge market increase in Displays that are non-sRGB (In particular DCI-P3 and AdobeRGB displays).\n\nAs an example: iPhone 7, Galaxy S7, MacBook Pro, Surface Studio, all of them support DCI-P3 wide color.\n\nHowever since the **color-gamut** it\u2019s a display thing the only way to detect for `wide-color` support from server side would be `Client Hints` since its not even possible with `UA-sniffing`.\n\nThe motivation behind is, we are building an image optimisation service for Automating Resource Selection, based on DPR, supported file format, and display wide color support, among other variables.\n\nFor example, [Apple is recommending now](http://devstreaming.apple.com/videos/wwdc/2016/712ugi7vg8jznn3pc3u/712/712_working_with_wide_color.pdf) to create 2 separate assets for Normal and Wide Color images, as in Retina vs. Non-Retina images.\n\n> The best solution is to serve a wide-gamut image when the user is on a wide-gamut display, and an `sRGB` image when the user is not on a `wide-gamut` display. This is just another case of responsive images, and is exactly what the element and media queries were designed to handle.\n\nThis is also why [Safari has added `color-gamut` media query](https://webkit.org/blog/6682/improving-color-on-the-web/) to `CSS Color Level 4`.\n\nSo the reason of making this as a `Request Header` is exactly the same logic to `DPR`: \nWe should send this info between Browser and Server, so the developer doesn't have to do it by hand, solving the problem more elegantly.\n\n### Current Problem\n\n``` html\n<picture>\n  <source media=\"(color-gamut: p3)\" srcset=\"photo-wide.jpg\">\n  <img src=\"photo-srgb.jpg\">\n</picture>\n```\n\n### Proposed Solution\n\n``` html\n<picture>\n  <img src=\"photo.jpg\">\n</picture>\n```\n\n**Browser Request Header**\n\n``` yml\nColor-Gamut: p3\n```\n\n**Server response**\n\n``` yml\nHTTP/1.1 200 OK\nContent-Color-Gamut: p3\n```\n\n**Result: Server returns a `8 bit sRGB` or `16 bit Display wide-color` image in a responsive way**\n\nThe core use case behind `Color-Gamut` hint is to enable automatic resource selection for image assets based on display type. This will enable delivery of optimal image variant without any changes in markup.\n",
          "createdAt": "2016-11-09T09:24:39Z",
          "updatedAt": "2016-11-09T09:24:39Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@gunta thanks, this is really helpful. Also, take this with a grain of salt, but some [polling numbers](https://twitter.com/igrigorik/status/799304405396824064)...\n\n![image](https://cloud.githubusercontent.com/assets/10652/20449131/63713528-ad9c-11e6-9851-5e4d395a24fc.png)\n\nTo be honest, the number of deployed+roadmap responses is much higher than I would have guessed! Stepping back, I think this does make sense to provide in CH; it's consistent with other image specific variables that affect which response should be served, and automation is definitely warranted here.\n- `Color-Gamut` + `Content-Color-Gamut`: I think this makes sense.\n- `@color-profile`.. I'm still trying to grok. From what I can tell right now, it accepts a URL to a profile, plus a rendering intent. Do we have some concrete examples of how we expect developers to use this?\n\n> The spec is past WGLC, so adding new hints right now might be bad timing.\n\nDoes this prevent us from publishing a new \"replacement\" draft? How do we advance these things forward? \n",
          "createdAt": "2016-11-18T22:48:28Z",
          "updatedAt": "2016-11-18T22:48:28Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Does this prevent us from publishing a new \"replacement\" draft? How do we advance these things forward? \n\nThe draft was supposed to go to IETF LC next. If you want to put in new stuff, you can do that (after negotiating with the WG), but then it'll require a new Working Group Last Call.\n",
          "createdAt": "2016-11-19T08:06:51Z",
          "updatedAt": "2016-11-19T08:06:51Z"
        },
        {
          "author": "gunta",
          "authorAssociation": "NONE",
          "body": "@igrigorik Exactly. \r\nStill the poll numbers are not high but we can expect them to go wild next year since most manufactured displays are now wide-color. We can expect something alike to the Retina/Non-Retina race rush. \r\n\r\n> Color-Gamut + Content-Color-Gamut: I think this makes sense.\r\n\r\nYes, this would cover 95% of use cases, and spec-wise it should be simple enough. \r\n\r\nSo, even for simple cases, this CH spec addition is close to a `MUST` for responsive color optimisation. Why? Because `wide-gamut` is one of things those things that cannot even be guessed by *User Agent*: there is no info about the display on the string. So this spec is gonna be the only way to advertise to the server in an automated way.\r\n\r\n> @color-profile.. I'm still trying to grok. From what I can tell right now, it accepts a URL to a profile, plus a rendering intent. Do we have some concrete examples of how we expect developers to use this?\r\nYes, I agree the use cases for `color-profile` are few, thus I don't see this one as `MUST`, however a `nice to have` one.\r\n\r\nThe use cases I see for this are minor but:\r\n1) To override a photo ICC profile (ie. it was wrong in the first place)\r\n2) To specify a ICC profile for a photo that had ICC stripped - or didn't had one in the first place (ie. it was removed by some \"optimisation\" tool like [jpegoptim](http://www.kokkonen.net/tjko/src/man/jpegoptim.txt) or [ImageOptim](https://imageoptim.com/color-profiles.html))\r\n\r\nSo yeah I can guess mostly photographer / design websites would make use of this one.\r\nNote that, at least [CSS Level 4](https://www.w3.org/TR/css-color-4/#at-ruledef-profile), doesn't need to include the URL for the profile since its predefined in two cases: `DCI-P3` and `Rec.2020`.\r\n\r\n> Does this prevent us from publishing a new \"replacement\" draft? How do we advance these things forward?\r\n\r\nI don't know about this *WG particular timing interests*,\r\nhowever having `Color-Gamut + Content-Color-Gamut` in the spec as soon as possible would give Browser vendors enough time and pave the way to implement it smoothly. \r\nBe either an addition to CH or a different spec. For **consistency** it does makes sense to be a part of the CH spec though, just like `DPR`.\r\n\r\nI can understand well why some don't see the *urge for it*: \r\nyou need to have a `wide-color` hardware first to *see* the need, \r\nbut we can be sure that almost **any smartphone or computer display that you get in 2017 is gonna be a `wide-color` one**.",
          "createdAt": "2016-11-21T08:43:08Z",
          "updatedAt": "2016-11-21T08:45:08Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@gunta thanks for the context, once again. I agree that these are high value targets worth pursuing.. \r\n\r\nBased on discussion on http-wg, it sounds like a separate draft is the best way forward. Would you be up for driving that work? I can assist if/where needed.",
          "createdAt": "2016-11-21T19:12:43Z",
          "updatedAt": "2016-11-21T19:12:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Just to be clear -- there's no guarantee that the WG will adopt such a document; it depends on getting consensus to adopt, which in turn often depends on implementer interest. That's not to dissuade you from writing a document; however, the next logical step would be to engage with implementers (probably, Chrome) to see if they want to support it, not to create a standard in hopes of getting it implemented.",
          "createdAt": "2016-11-21T22:15:32Z",
          "updatedAt": "2016-11-21T22:15:32Z"
        },
        {
          "author": "grorg",
          "authorAssociation": "NONE",
          "body": "I have no opinion on the client hint proposal, but I'll comment on the poll.\r\n\r\nI expect commerce sites to be the first to care about accurate color. They'll want to make sure they show you a picture of the bright red shoes that matches what will turn up on the doorstep. Then I predict art/photography etc content. And before long, so many people will have extended displays that designers will just want their content to look more awesome.\r\n\r\nAlso, it's not the kind of thing you care about until you see the improvement in person. It would be interesting to see the poll result in 12-24 months.\r\n\r\n(Note that while Apple has done the work to support extended colors in WebKit, we're still missing pieces. Implementing it within other browsers might take more effort. Last time I checked they didn't even color match to sRGB.)",
          "createdAt": "2016-12-09T22:21:43Z",
          "updatedAt": "2016-12-09T22:21:43Z"
        },
        {
          "author": "njdoyle",
          "authorAssociation": "NONE",
          "body": "I'm a little fuzzy on some of the implications of `Content-Color-Gamut`. While I definitely see the savings that can be had by being able to specify a pre-understood named colour profile (or some reusable cached ICC profile) instead of embedding the profile in its entirety in each image, I feel a little uncomfortable about the separation of the image asset from instructions that are absolutely necessary for rendering it.\r\n\r\nWhat this means is that information that is necessary for rendering the image will be in HTTP headers instead of the image content itself. If you save that image, it will essentially be incomplete (unless the browser rewrites the data or something).\r\n\r\nIn a perfect world, I would have common colour profiles be available in some shorthand in the image file itself. Basically just like the sRGB chunk in PNG just generalized for other common colour profiles. I feel that HTTP headers aren't the right place to solve this problem.",
          "createdAt": "2016-12-13T21:38:54Z",
          "updatedAt": "2016-12-13T21:38:54Z"
        },
        {
          "author": "njdoyle",
          "authorAssociation": "NONE",
          "body": "Just to clarify, because there may have been some confusion:\r\n\r\nOf the two headers, I am okay with `Color-Gamut` (when the client sends the server the gamut of the client's display). My previous comment is referring to `Content-Color-Gamut` where the server sends the gamut of an image to the client as an HTTP header. I feel like this information is necessary to rendering an image and should be included in image data and not as an HTTP header. Rendering the image without this information is impossible to do correctly.",
          "createdAt": "2016-12-14T15:24:55Z",
          "updatedAt": "2016-12-14T15:24:55Z"
        },
        {
          "author": "colinbendell",
          "authorAssociation": "NONE",
          "body": "This is probably implicit in the discussion, but for posterity I want to enumerate the decision matrix that `Color-Gamut` would help address:\r\n* Maximize the experience: A server has 10bit/channel images and client can display wide gamut (aka serve P3 to P3)\r\n    * If client supports jp2/jpegxr then use; \r\n    * If bandwidth permits, use png. \r\n    * Otherwise reduce color space to 8bit/channel and add p3 icc and serve webp/jpg.\r\n* Preserve the experience: A server has 10bit/channel images but client is only sRGB. Sending 8bit/channel P3 to sRGB has poor effects and will result in banding and clamping therefore we want to reduce to 8bit/channel, color correcting to sRGB.\r\n* Balance experience and performance: A server wants to reduce bytes by stripping icc metadata. BUT doing this today has inconsistent experiences with different browsers. Notably, browsers that incorrectly assume the attached display is also sRGB and don't color correct (Chrome/FF). The very presence of this CH is a legacy v. modern color-correcting indicator. (this is assuming that [667431](https://bugs.chromium.org/p/chromium/issues/detail?id=667431) ships ahead of CH)\r\n",
          "createdAt": "2016-12-14T16:24:59Z",
          "updatedAt": "2016-12-14T16:30:54Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@colinbendell @njdoyle thanks a lot for the great feedback.\r\n\r\nTo echo @mnot's suggestion: \r\n - formalize above use cases and rough proposal via an ~explainer doc\r\n - publish explainer on WICG, engage vendors in discussion\r\n - ... \r\n - write down spec once we have implementation's underway\r\n\r\n@gunta @colinbendell @njdoyle perhaps something you could drive/own together? ",
          "createdAt": "2016-12-21T16:20:18Z",
          "updatedAt": "2016-12-21T16:20:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'm going to close this, as we're going to ship CH without this hint, but please do continue to discuss (here if necessary to coordinate).",
          "createdAt": "2016-12-25T17:19:07Z",
          "updatedAt": "2016-12-25T17:19:07Z"
        },
        {
          "author": "gunta",
          "authorAssociation": "NONE",
          "body": "@igrigorik I'll try to formalize the use cases I have at the current project I'm working in which is a Responsive Images as Service.",
          "createdAt": "2017-09-20T08:48:01Z",
          "updatedAt": "2017-09-20T08:48:01Z"
        }
      ]
    },
    {
      "number": 264,
      "id": "MDU6SXNzdWUxODg5NzY2NzA=",
      "title": "Overhead in cache digest algorithm",
      "url": "https://github.com/httpwg/http-extensions/issues/264",
      "state": "CLOSED",
      "author": "sebdeckers",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "(Originally misfiled at https://github.com/mnot/I-D/issues/204)\r\n\r\nI believe the algorithm may be improved to increase speed and reduce digest size.\r\n\r\n#### De-dupe URLs before hashing them\r\n\r\nWastes time sorting and skipping through the list in a later stage.\r\nInflates value of N, needlessly increasing size of the entire digest.\r\n\r\n#### Trim URL origin\r\n\r\nEvery URL has identical origin. Hashing this repetitive data is wasted effort.",
      "createdAt": "2016-11-13T15:40:28Z",
      "updatedAt": "2017-04-26T03:29:24Z",
      "closedAt": "2017-04-26T03:29:24Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for your suggestions.\n\n> **De-dupe URLs before hashing them**\n\nIs it likely that there'd be lot of freshly-cached (or stale-cached) responses sharing the same URL?\n\nMy assumption is that the answer is no, and that we do not need to recommend deduping the URLs before hashing (note: deduplication after hashing and truncating would still be necessary even if you dedupe the URLs beforehand).\n\nIf the answer is yes, then we should consider including additional keys into the hash context so that the server can more correctly identify what is being cached.\n\n> **Trim URL origin**\n\nI agree that we can trim the origin part of the URL, since in the latest draft we have an origin field for every CACHE_DIGEST frame.\n",
          "createdAt": "2016-11-14T01:56:46Z",
          "updatedAt": "2016-11-14T01:56:46Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "My .02 --\r\n\r\nDe-duping the URLs is an implementation optimisation; it's not necessary to specify it (but it doesn't hurt if we really want to).\r\n\r\nTrimming the URL origin makes me nervous; it's defence-in-depth against implementation errors. ",
          "createdAt": "2017-04-26T02:21:03Z",
          "updatedAt": "2017-04-26T02:21:03Z"
        },
        {
          "author": "sebdeckers",
          "authorAssociation": "NONE",
          "body": "@mnot Agreed on both points. \ud83d\udc4d\r\n\r\nTrimming origins would be tricky with coalesced connections and cross origin PUSH.",
          "createdAt": "2017-04-26T03:29:24Z",
          "updatedAt": "2017-04-26T03:29:24Z"
        }
      ]
    },
    {
      "number": 265,
      "id": "MDU6SXNzdWUxODkyOTg3ODI=",
      "title": "Remove Crypto-Key",
      "url": "https://github.com/httpwg/http-extensions/issues/265",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "encryption"
      ],
      "body": "@ekr suggests that we remove this.  This is probably justified by recent developments.  Simplicity suggests that it is worth cutting as well.",
      "createdAt": "2016-11-15T04:43:29Z",
      "updatedAt": "2016-12-22T03:31:38Z",
      "closedAt": "2016-12-22T03:31:38Z",
      "comments": []
    },
    {
      "number": 266,
      "id": "MDU6SXNzdWUxODk2MDU4MTE=",
      "title": "'parmname'",
      "url": "https://github.com/httpwg/http-extensions/issues/266",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "5987bis",
        "editorial"
      ],
      "body": "... occurs twice in the current draft, without much context. Should it be removed?",
      "createdAt": "2016-11-16T06:33:04Z",
      "updatedAt": "2016-11-17T00:43:40Z",
      "closedAt": "2016-11-17T00:43:40Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good catch; it refers to a now removed ABNF term. Needs to be rephrased.\n",
          "createdAt": "2016-11-16T06:38:10Z",
          "updatedAt": "2016-11-16T06:38:10Z"
        }
      ]
    },
    {
      "number": 267,
      "id": "MDU6SXNzdWUxODk2MDcyMDQ=",
      "title": "Give us something to hang onto",
      "url": "https://github.com/httpwg/http-extensions/issues/267",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "5987bis",
        "editorial"
      ],
      "body": "In working on RFC5988bis, I'm referring to this spec, and finding it's difficult to talk about the concepts, because so much has been pared back.\r\n\r\nIn particular:\r\n\r\n* [ ] There isn't any prose reference to the \"*\" form of the attribute name; it only occurs in examples. One would assume that this is the normative way to invoke this encoding, but it isn't specified.\r\n* [ ] A distinct name for the encoding would help; right now, the best I can do is \"the encoding specified in RFC5987bis\".\r\n* [ ] The examples of how to use this in header specifications needs to be deeper.",
      "createdAt": "2016-11-16T06:40:41Z",
      "updatedAt": "2017-03-03T04:09:29Z",
      "closedAt": "2017-03-03T04:09:29Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Any name suggestions?\n",
          "createdAt": "2016-11-16T06:47:21Z",
          "updatedAt": "2016-11-16T06:47:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hmm. \"i18nPE\" (Internationalisation Parameter Encoding)?\n",
          "createdAt": "2016-11-16T07:16:05Z",
          "updatedAt": "2016-11-16T07:16:05Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"nape\"? (non-ASCII P. E.)\n",
          "createdAt": "2016-11-16T10:19:40Z",
          "updatedAt": "2016-11-16T10:19:40Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Nape is an English word, a bit odd to use as a name. IPE?\n",
          "createdAt": "2016-11-17T06:27:52Z",
          "updatedAt": "2016-11-17T06:27:52Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "sgtm\n\nI  should use that everywhere then, including the title, right?\n",
          "createdAt": "2016-11-17T06:29:09Z",
          "updatedAt": "2016-11-17T06:29:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Think so.\n",
          "createdAt": "2016-11-17T06:30:08Z",
          "updatedAt": "2016-11-17T06:30:08Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On the other hand, given the fact that just a few weeks ago you wanted to deprecate the encoding, you are now asking for a way to make it _easier_ to reference? Maybe \"the encoding defined in RFC xxxx\" or \"RFC xxxx encoding\" really is good enough.\n",
          "createdAt": "2016-11-17T09:42:55Z",
          "updatedAt": "2016-11-17T09:42:55Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  There isn't any prose reference to the \"*\" form of the attribute name; it only occurs in examples. One would assume that this is the normative way to invoke this encoding, but it isn't specified.\n\nActually, this spec can't (or doesn't want to) make a normative requirement for this. The syntax of the parameter names is supposed to be under the control of the specification using them.\n\nThat said, I can try to make this clearer in the prose.\n\nNote that it already says:\n\n> Note: This specification does not automatically assign a new interpretation to parameter names ending in an asterisk. As pointed out above, it's up to the specification for the non-extended parameter to \"opt in\" to the syntax defined here. That being said, some existing implementations are known to automatically switch to the use of this notation when a parameter name ends with an asterisk, thus using parameter names ending in an asterisk for something else is likely to cause interoperability problems.\n",
          "createdAt": "2016-11-17T09:45:31Z",
          "updatedAt": "2016-11-17T09:48:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Transitional Retrograde Internationalised Parameter Encoding?\n",
          "createdAt": "2016-11-18T00:33:28Z",
          "updatedAt": "2016-11-18T00:33:28Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Re OTOH -- you convinced me very effectively.\n",
          "createdAt": "2016-11-18T00:49:11Z",
          "updatedAt": "2016-11-18T00:49:11Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The examples of how to use this in header specifications needs to be deeper.\r\n\r\nThe whole of Section 4 is about that. What exactly are you missing?",
          "createdAt": "2017-01-07T15:52:56Z",
          "updatedAt": "2017-01-07T15:52:56Z"
        }
      ]
    },
    {
      "number": 268,
      "id": "MDU6SXNzdWUxOTAwMzk3MDA=",
      "title": "Enabling O(1) removal from digest",
      "url": "https://github.com/httpwg/http-extensions/issues/268",
      "state": "CLOSED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "Current spec is using Golomb-coded sets as the algorithm to create digests.\r\n\r\nWhile they show great space-efficiency, Golomb-coded sets do not enable O(1) removal from the digest, which means from a browser implementation perspective, the browser would have to calculate the hash for each host upon connection creation.\r\n\r\nThat poses a couple of issues from an implementation perspective:\r\n\r\n* Calculating the hash on each connection establishment may be expensive. That part seems inherent to the algorithm and not likely to be optimized away.\r\n* Calculating the hash requires per-host indexing. That part is just a limitation of many current cache implementations.\r\n\r\nA cache digest algorithm that enables O(1) removal (as well as addition) to the digest would enable us to move away from those limitations:\r\n\r\n* Browsers can calculate a per-host digest once, then keep updating it as resources are added to the cache as well as when resources are removed from the cache. No need for per-host indexing.\r\n  -  In order to do that, browsers would need to persist digests along with the cache\r\n* Upon connection establishment, the browser can just send the ready-made digest to the server. Win!\r\n\r\nDuring the HTTPWS, counting bloom filters were mentioned as an O(1) removal algorithm, but they are extremely inefficient when it comes to space. (~4 times bigger than bloom filters)\r\n\r\nTurns out, [Cuckoo filters](https://www.cs.cmu.edu/~binfan/papers/login_cuckoofilter.pdf) enable O(1) removal while being more space efficient than bloom filters. While they are slightly bigger than Golomb-coded sets based digests, the cheaper runtime costs can make up for that deficiency.\r\n\r\n/cc @kazuho @mnot @cbentzel @mcmanus\r\n\r\n\r\n",
      "createdAt": "2016-11-17T12:55:53Z",
      "updatedAt": "2017-08-14T08:32:43Z",
      "closedAt": "2017-07-28T01:42:04Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for opening the issue. I think we should adopt a method that can be implemented by web browsers easily, as long as the digest remains fairly compact. Regarding the size of the digest, I have no objection for choosing Cuckoo Filters.\n\nHowever, I am not sure if the proposed method would work as expected.\n\n> Browsers can calculate a per-host digest once, then keep updating it as resources are added to the cache as well as when resources are removed from the cache.\n\nThere are two digests (i.e. fresh and stale) for every host. You need to update the digests when the state of a cached response changes from fresh to stale, by evicting the corresponding entry from the fresh digest and inserting it into the stale digest.\n\nIs that possible?\n\nAlso, if it is possible to maintain a per-origin Cuckoo Filter that is kept in sync with the cached resources, I think it would also be possible to maintain a per-host list of cached URLs as well, which can be used to build the digest.\n\nAnyways, let me state that I'm very delighted to see people looking into how Cache Digests can be implemented within the web browser. I also hope that I'd be proved wrong, that it would be easier to implement Cache Digest in the browser than I had expected.\n\nPS. I was considering of polishing up my ServiceWorker implementation, but maybe I should spend my time looking into the browsers as well.\n",
          "createdAt": "2016-11-17T13:09:09Z",
          "updatedAt": "2016-11-17T13:26:32Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> There are two digests (i.e. fresh and stale) for every host. You need to update the digests when the state of a cached response changes from fresh to stale, by evicting the entry from the fresh digest and inserting it to the stale digest.\n\nHmm, that would indeed increase complexity as I believe the cache is not aware of resources going into the \"stale\" state unless they're queried. (@cbentzel & @mcmanus - please correct me if I'm wrong).\n\nIs there any reason we can't use a single digest with URL+ETag (so use the ETags also for fresh resources) to avoid that complexity? Are there any downsides to that?\n",
          "createdAt": "2016-11-17T13:28:54Z",
          "updatedAt": "2016-11-17T13:28:54Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Also, if it is possible to maintain a per-origin Cuckoo Filter that is kept in sync with the cached resources, I think it would also be possible to maintain a per-host list of cached URLs as well.\n\nThat is indeed possible, as I mentioned: \"Calculating the hash requires per-host indexing. That part is just a limitation of many current cache implementations\".\nThe problem with that is that creating a digest from that list of URLs would mean an O(N) operation.\n",
          "createdAt": "2016-11-17T13:32:46Z",
          "updatedAt": "2016-11-17T13:32:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@yoavweiss \n\n> Is there any reason we can't use a single digest with URL+ETag (so use the ETags also for fresh resources) to avoid that complexity? Are there any downsides to that?\n\nIt is true that you could use URL+ETag as a key of fresh digests (though server implementations might become slightly complicated).\n\nHowever, it is still desirable to be able to distinguish whether if a resource is freshly cached or stale-cached, since the server behavior needs to be different for the two. For freshly cached resources, there is no need to push anything. For stale-cached resources, the server needs to push 304.\n\nIf the client sends a single digest covering both freshly and stale-cached resources, then the server would need to either push nothing for both of them (which means that client would issue conditional requests for stale-cached responses that it need to use), or push 304 for both of them (which means that the server would send 304 for even the freshly cached resources).\n\nNote also that we haven't agreed on whether if sending a digest of stale responses is worth the extra bandwidth, or how we should push 304.\n\nLast time I looked into my Firefox's cache, the number of cached objects were as follows:\n\n| domain | total objects | fresh objects |\n| --- | --- | --- |\n| *.facebook.com | 2273 | 790 |\n| *.google.com | 1003 | 373 |\n\nAs you can see, fresh objects consists about 1/3 of the total objects cached for a domain. Sending a digest for all objects would roughly triple the size of the digest from when we just send the digest for freshly-cached objects.\n\nConsidering the fact that assets critical to the rendering path are more likely to be marked as fresh, it would make sense to just send the digest for freshly cached objects.\n",
          "createdAt": "2016-11-17T14:05:49Z",
          "updatedAt": "2016-11-17T14:28:59Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@yoavweiss \n\n> > Also, if it is possible to maintain a per-origin Cuckoo Filter that is kept in sync with the cached resources, I think it would also be possible to maintain a per-host list of cached URLs as well.\n> \n> That is indeed possible, as I mentioned: \"Calculating the hash requires per-host indexing. That part is just a limitation of many current cache implementations\".\n> The problem with that is that creating a digest from that list of URLs would mean an O(N) operation.\n\nI agree that it is O(N). However, for the browser use-case, we would not want to send a digest covering tens of thousands of responses (since it would not fit into a single TCP packet or two). And from the table in my comment above, it is likely that a digest would not be that big.\n\nSo I think N would not be very large that it would have impact on performance. Converting a pre-calculated SHA256 into a GCS entry is a lightweight operation: truncate, emit one or two '0's followed by '1' (corresponds to the quotient), and then the remainder bits.\n",
          "createdAt": "2016-11-17T14:13:02Z",
          "updatedAt": "2016-11-17T14:13:02Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@yoavweiss \nIn addition to my previous comments, I think you cannot _expand_ an existing Cuckoo Filter. \n\nIn other words, every time the number of resources that need to be tracked doubles (or halves), you would need to reconstruct a new Cuckoo Filter (of the adjusted size) by iterating through the cache entries. I do not think that is something you would like to do.\n",
          "createdAt": "2016-11-18T05:43:54Z",
          "updatedAt": "2016-11-18T05:43:54Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In addition to my previous comments, I think you cannot expand an existing Cuckoo Filter.\n> \n> In other words, every time the number of resources that need to be tracked doubles (or halves), you would need to reconstruct a new Cuckoo Filter (of the adjusted size) by iterating through the cache entries. I do not think that is something you would like to do.\n\nMy understanding from the Cuckoo filter and [Cuckoo hashing](http://www.it-c.dk/people/pagh/papers/cuckoo-jour.pdf) papers is that this expansion is taken into consideration in the amortized complexity analysis. Even if you look at the worst case, such expansion's cost is O(N), which is asymptotically similar to the cost GCS incur on every connection establishment.\n",
          "createdAt": "2016-11-18T15:59:07Z",
          "updatedAt": "2016-11-18T15:59:07Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@yoavweiss What I would like to discuss is not the amortized cost, but the time required to expand (or shrink) the digest.\n\nIn both Cuckoo hashing and Cuckoo filter, expansion or shrinking is done by rebuilding the hash table.\n\nWith Cuckoo Hashing, the cost of (re)building a hash table is O(N) (where N is the number of entries), since the entries within the hash table contains references to the objects being stored. During expansion, you iterate through the contained objects by dereferencing them to build a new hash table.\n\nHowever, in a Cuckoo Filter, there is no such reference. Therefore, to (re)build a Cuckoo Filter, you would need to use some pre-existing structure in the browser cache to iterate through the objects belonging to a specific origin. However, under premise that there is no per-origin index (note: we are considering the use of Cookie Filters since we do not want to introduce such index), we would need to iterate through the entire cache.\n\nCan we afford such an operation (e.g. iterating through the entire cache) running periodically?\n",
          "createdAt": "2016-11-19T08:40:10Z",
          "updatedAt": "2016-11-19T13:25:04Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> However, in a Cuckoo Filter, there is no such reference. Therefore, to (re)build a Cuckoo Filter, you would need to use some pre-existing structure in the browser cache to iterate through the objects belonging to a specific origin. However, under premise that there is no per-origin index (note: we are considering the use of Cookie Filters since we do not want to introduce such index), we would need to iterate through the entire cache.\n\nThat would indeed be a serious handicap to the Cuckoo filter approach.\nFortunately, browsers can extend the basic Cuckoo filter implementation to also store the full crypto hashes or other references to the stored objects on top of storing fingerprints.\n\nThis extra info won't be sent up as part of the Cuckoo filter, but can be used locally to extend it in O(N) complexity.\n\nSuch references to the actual stored objects can also allow periodic (potentially out-of-band) O(N) calculation to create a stale resources filter that would make it easier to push 304s.\n",
          "createdAt": "2016-11-20T08:05:27Z",
          "updatedAt": "2016-11-20T08:05:27Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Anyone willing to do a pull request for Cuckoo filters? The paper has better algorithm definitions, so we can avoid some of the details, but we still need to define a wire serialisation. \r\n\r\nMaybe use https://github.com/Leechael/python-cuckoo/blob/master/cuckoofilter/cuckoofilter.py#L143 as a starting point and figure out if we need to make changes / optimisations? That one appears to gzip pretty well, so there's likely space for improvement.",
          "createdAt": "2017-02-09T02:28:42Z",
          "updatedAt": "2017-02-09T02:28:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Prague; absent implementer activity and a concrete proposal, closing.",
          "createdAt": "2017-07-28T01:42:04Z",
          "updatedAt": "2017-07-28T01:42:04Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There's still implementer interest for this /cc @cbentzel @addyosmani",
          "createdAt": "2017-08-14T08:32:43Z",
          "updatedAt": "2017-08-14T08:32:43Z"
        }
      ]
    },
    {
      "number": 269,
      "id": "MDU6SXNzdWUxOTA2MDQxNzA=",
      "title": "mixed schemes",
      "url": "https://github.com/httpwg/http-extensions/issues/269",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "Can we coalesce http and https?  The implication from everything we've said is \"yes\", but Erik remains reluctant.",
      "createdAt": "2016-11-21T02:22:38Z",
      "updatedAt": "2016-12-22T03:36:09Z",
      "closedAt": "2016-12-22T03:36:09Z",
      "comments": []
    },
    {
      "number": 271,
      "id": "MDU6SXNzdWUxOTA2MDc1Njc=",
      "title": "5987bis writeup",
      "url": "https://github.com/httpwg/http-extensions/issues/271",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "5987bis"
      ],
      "body": "A few things I noticed / need to ask:\r\n\r\n* Is the Abstract still suitable? I note it doesn't mention 5987.\r\n\r\n* Is the intended status really Internet Standard? Given that 2026 requires \"a high degree of technical maturity and by a generally held belief that the specified protocol or service provides significant benefit to the Internet community\" and in light of the doubt around the use of this format, it seems like Proposed Standard might be more appropriate. Also, we'd need to document the implementations.\r\n\r\n* @reschke - If you have direct, personal knowledge of any IPR related to this document, has it already been disclosed?",
      "createdAt": "2016-11-21T03:00:00Z",
      "updatedAt": "2017-03-03T04:05:31Z",
      "closedAt": "2017-03-03T04:05:31Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- I think advice from the IESG varies about whether the abstract should include this. Maybe ask our AD before proceeding.\r\n\r\n- It is definitively mature, and we currently do not have an alternative. That said, where does the implementation documentation requirement come from? FWIW, there's Appendix B.\r\n\r\n- I'm not aware of any IPR related to my profiling of RFC 2231. ",
          "createdAt": "2016-11-21T06:54:37Z",
          "updatedAt": "2016-11-21T06:54:37Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After checking a few recent RFCs, I see that obsoletions are indeed usually mentioned in the abstract. Added that.",
          "createdAt": "2017-01-07T15:44:01Z",
          "updatedAt": "2017-01-07T15:44:01Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "based on https://lists.w3.org/Archives/Public/ietf-http-wg/2017JanMar/0025.html the consensus is to proceed with this on a proposed standard basis.",
          "createdAt": "2017-01-31T08:55:52Z",
          "updatedAt": "2017-01-31T08:55:52Z"
        }
      ]
    },
    {
      "number": 274,
      "id": "MDU6SXNzdWUxOTM5NzgxOTE=",
      "title": "Record size (rs) should be of ciphertext, not padded-plaintext",
      "url": "https://github.com/httpwg/http-extensions/issues/274",
      "state": "CLOSED",
      "author": "manger",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "encryption"
      ],
      "body": "It would be better to define the 'rs' (record size) parameter as the size of each ciphertext record (including the 16 byte tag for AEAD_AES_128_GCM).\r\n\r\nThat way a receiver can split the body into records without needing to add the algorithm-specific tag length. Then pass the bytes to a crypto library that does know details such as the tag length for a given alg.\r\n\r\nThis spec doesn't absolutely need alg agility as other algs would define their own content-encoding label. But it would be cleaner (& safer) if future algs could follow exactly the same pattern and same body format by simply defining a new content-encoding label. The format is very close, with the need to add 16 to 'rs' being the only wart.",
      "createdAt": "2016-12-07T07:37:43Z",
      "updatedAt": "2017-01-23T04:08:58Z",
      "closedAt": "2017-01-06T00:55:20Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I will define it this way.  Forgot to tag this correctly, so I missed it.",
          "createdAt": "2016-12-22T12:20:39Z",
          "updatedAt": "2016-12-22T12:20:39Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Addressed in latest version.",
          "createdAt": "2017-01-06T00:55:20Z",
          "updatedAt": "2017-01-06T00:55:20Z"
        },
        {
          "author": "manger",
          "authorAssociation": "NONE",
          "body": "Looks good. Couple of typos.\r\n* \"content of rs octets minus padding less padding (2-65537) and tag (16)\" -- drop \"minus padding\"\r\n* \"a record that contains contains only padding\" -- drop 1 \"contains\"",
          "createdAt": "2017-01-07T07:30:13Z",
          "updatedAt": "2017-01-07T07:30:13Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks.",
          "createdAt": "2017-01-09T00:31:36Z",
          "updatedAt": "2017-01-09T00:31:36Z"
        },
        {
          "author": "manger",
          "authorAssociation": "NONE",
          "body": "1 more typo:\r\n\r\n- \"cannot increase the record size beyond 65537 octets\" -- should be \"65553\" now that rs includes the tag",
          "createdAt": "2017-01-23T04:08:58Z",
          "updatedAt": "2017-01-23T04:08:58Z"
        }
      ]
    },
    {
      "number": 281,
      "id": "MDU6SXNzdWUxOTkwOTg5MTk=",
      "title": "Can dictionary keys repeat?",
      "url": "https://github.com/httpwg/http-extensions/issues/281",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "We need clear rules about whether this is OK\r\n\r\n```\r\nHeader: identifier;v=1;v=2\r\n```",
      "createdAt": "2017-01-06T00:56:22Z",
      "updatedAt": "2018-02-01T06:55:13Z",
      "closedAt": "2018-02-01T06:55:13Z",
      "comments": [
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have added the following text:\r\n\r\n```\r\nKey identifiers in dictionaries SHALL be unique, but semantically\r\noverlapping key identifiers for instance 'text/plain' and 'text/*'\r\nare ok.\r\n```\r\n",
          "createdAt": "2017-02-01T13:08:34Z",
          "updatedAt": "2017-02-01T13:08:34Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This invalidates the choice in QUIC, see https://quicwg.github.io/base-drafts/draft-ietf-quic-http.html#rfc.section.2.1",
          "createdAt": "2017-02-01T22:38:01Z",
          "updatedAt": "2017-02-01T22:38:01Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Either keys need to repeat, or there needs to be a list syntax as a value.  Either would satisfy the use case, but \"neither\" is a painful option.",
          "createdAt": "2017-03-31T14:43:19Z",
          "updatedAt": "2017-03-31T14:43:19Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As @jyasskin is encountering, there needs to be something better here.",
          "createdAt": "2017-12-06T18:15:36Z",
          "updatedAt": "2017-12-06T18:15:36Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Specifically, I believe this issue is a request to have some way to represent a dictionary member whose value is an ordered list? My use is in https://tools.ietf.org/id/draft-yasskin-http-origin-signed-responses-01.html#signature-header, where `certUrl` and `validityUrl` maybe should be lists of strings, and maybe the order should be significant to express a series of fallback URLs.\r\n\r\n[Quic](https://quicwg.github.io/base-drafts/draft-ietf-quic-http.html#alt-svc-version-hint) specifies its order to be significant.\r\n\r\nI do appreciate the default provided by \"SHALL be unique\" that dictionary members aren't lists unless we explicitly write that they are, since it helps my algorithms fail closed when someone sends an unexpected extra value.",
          "createdAt": "2017-12-06T19:12:32Z",
          "updatedAt": "2017-12-06T19:12:32Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "So, in the current iteration of structured headers, I think this question applies to both Dictionaries and Parameterised Labels.\r\n\r\nCurrently, Dictionaries forbid repeating members (\"If dictionary already contains this_key, raise an error.\"). Similar language is in the parsing algorithm for parameterised labels. \r\n\r\nIf that remains, it would be good to reinforce this in requirements (rather than just leaving it in the algorithms) for Dictionaries; Parameterised Labels already does that.\r\n\r\n**If** Alt-Svc were defined as a structured header, I think QUIC's use case could be shoe-horned in; e.g.,\r\n\r\n    Alt-Svc: hq=\":49288\";quic=\"1,51303334\"\r\n\r\nThat's not pretty, of course, but I question how common this particular scenario is (most headers that need to be ordered can just use a list).\r\n\r\nFor @jyasskin's use case, something similar can happen (whitespace is a natural choice for delimiting URLs); e.g.,\r\n\r\n    Signature: sig2;\r\n      sig=*MEQCIGjZRqTRf9iKNkGFyzRMTFgwf/BrY2ZNIP/dykhUV0aYAiBTXg+8wujoT4n/W+cNgb7pGqQvIUGYZ8u8HZJ5YH26Qg;\r\n      validityUrl=\"https://example.com/resource.validity https://fallback.example.net/foo\";\r\n      certUrl=\"https://example.com/certs https://and.another.example.org/bar\";\r\n      certSha256=*kQAA8u33cZRTy7RHMO4+dv57baZL48SYA2PqmYvPPbg;\r\n      date=1511301183; expires=1511905983\r\n\r\nIf we allowed multiple instances of Dictionary (and Parameterised Label) keys, I'm concerned that it would be significantly more difficult to map structured headers into common data structures, and therefore would increase the friction against the introduction of generic parsing and serialisation tools for them -- as well as complicate their use. Remembering that the goal for SH is **not** to be able to express every conceivable header, but to get the 80% of \"cream\", I think this is a good tradeoff.\r\n\r\n",
          "createdAt": "2018-01-30T00:33:13Z",
          "updatedAt": "2018-01-30T00:33:13Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can live with guidance to represent arrays by defining a custom parser that runs over strings.",
          "createdAt": "2018-01-30T00:40:55Z",
          "updatedAt": "2018-01-30T00:41:05Z"
        }
      ]
    },
    {
      "number": 282,
      "id": "MDU6SXNzdWUyMDExNjc1NjI=",
      "title": "Normalization for parameters",
      "url": "https://github.com/httpwg/http-extensions/issues/282",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Are the following header fields considered equal or equivalent or are they different?\r\n\r\n```\r\nHeader: value; p=pval\r\nHeader: value; p=\"pval\"\r\nHeader: value; p=\"Pval\"\r\nHeader: value; P=\"Pval\"\r\n```\r\n\r\nSome specializations of the header syntax permit both `quoted-string` and `token` for parameter values.  If the string value after removal of quotes is the same as the token, is it the same value?\r\n\r\nWhat about case folding for parameter names?  Do we do that?",
      "createdAt": "2017-01-17T03:27:57Z",
      "updatedAt": "2018-01-12T04:49:32Z",
      "closedAt": "2018-01-12T04:49:32Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "1) and 2) should be the same (token vs quoted string)\r\n\r\n3) is different\r\n\r\n4) might be the same as 3), there are at least some pre-existing header fields that treat parameter names case-insensitively.\r\n\r\n",
          "createdAt": "2017-01-17T07:15:48Z",
          "updatedAt": "2017-01-17T07:15:48Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That was my guess too, but the more pertinent question is: where is that written down?",
          "createdAt": "2017-01-17T20:39:41Z",
          "updatedAt": "2017-01-17T20:39:41Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We need to write it down. ",
          "createdAt": "2017-01-17T22:07:21Z",
          "updatedAt": "2017-01-17T22:07:21Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can see a point of automatically \"promoting\" an ascii-string to identifier if removing the quotes would make it one.\r\n\r\nFor the remaining questions I think the individual header definition should sort that out.",
          "createdAt": "2017-02-01T13:07:37Z",
          "updatedAt": "2017-02-01T13:07:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think this is OBE - @martinthomson can we close?",
          "createdAt": "2017-12-13T06:46:38Z",
          "updatedAt": "2017-12-13T06:46:38Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that the question remains relevant, but are you suggesting that I make it a 723x-bis question instead?",
          "createdAt": "2017-12-16T21:48:12Z",
          "updatedAt": "2017-12-16T21:48:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Well, if you want it to be addressed for `token` and `quoted-string` in `parameter`, it needs to be raised against httpter, yes. If you want it to be addressed within structured headers, I think it is OBE.",
          "createdAt": "2018-01-12T04:38:04Z",
          "updatedAt": "2018-01-12T04:38:04Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll reopen on bisbisbis then.",
          "createdAt": "2018-01-12T04:49:32Z",
          "updatedAt": "2018-01-12T04:49:32Z"
        }
      ]
    },
    {
      "number": 284,
      "id": "MDU6SXNzdWUyMDQyMjIyNTU=",
      "title": "Requiring Accept-CH",
      "url": "https://github.com/httpwg/http-extensions/issues/284",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "As discussed on list, a formal requirement to see `Accept-CH` before sending hints might be desirable, to reduce fingerprinting surface.",
      "createdAt": "2017-01-31T07:26:26Z",
      "updatedAt": "2017-02-27T05:48:57Z",
      "closedAt": "2017-02-27T05:48:57Z",
      "comments": [
        {
          "author": "npdoty",
          "authorAssociation": "NONE",
          "body": "To be clear this would both decrease fingerprinting surface (by not having clients send these hints when they're not needed -- a data minimization practice) *and* increase detectability of client fingerprinting (researchers can see that fingerprinting might be happening because of observable server behavior). I would support this requirement.",
          "createdAt": "2017-01-31T20:38:23Z",
          "updatedAt": "2017-01-31T20:38:23Z"
        },
        {
          "author": "michael-oneill",
          "authorAssociation": "NONE",
          "body": "There is still the possibility that an embedded third-party sends the Accept-CH and uses the hints for drive-by fingerprinting. IMO UAs should ignore Accept-CH from embedded third-party sub-resources unless DNT:0 .",
          "createdAt": "2017-02-01T01:01:51Z",
          "updatedAt": "2017-02-01T01:01:51Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please note that such a requirement will significantly reduce the capability of servers to adapt the main HTML document to viewport dimensions, network conditions, etc. So while I understand the need to reduce passive fingerprinting, I think the decision should be on a per-hint basis and based on the info that the hints actually expose.\r\n\r\nFor example, I'd argue in the case of viewport dimensions and screen density, that info is already exposed in the UA string (along with other, more specific data on the user's device and browser), and the hints only make it easier to adapt content without a device DB, while not necessarily increasing fingerprinting capabilities.\r\n\r\nAs for network conditions, while exposing them may add data to the fingerprinter's toolbox, they can vary wildly between sessions (and even during a session), so I'd argue they don't necessarily increase fingerprinting capabilities.",
          "createdAt": "2017-02-09T10:58:07Z",
          "updatedAt": "2017-02-09T10:58:07Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "CH is not just for browsers. There are other types of clients: native apps that talk to own backends, internal HTTP clients that talk to image servers, and so on. As such, I don't think we're in a position to make sweeping formal (MUST) requirements for how/when support for these hints should be advertised or when they can be sent. \r\n\r\nExisting section for Accept-CH starts with \"servers can advertise support\".. which, I think, is the right approach. The other relevant section is...\r\n\r\nhttps://tools.ietf.org/html/draft-ietf-httpbis-client-hints-03#section-2.1\r\n\r\n> 2.1.  Sending Client Hints\r\n> \r\n>   Clients control which Client Hint headers and their respective header\r\n>   fields are communicated, based on their default settings, user\r\n>   configuration and/or preferences.  The user can be given the choice\r\n>   to enable, disable, or override specific hints.\r\n>\r\n>   The client and server, or an intermediate proxy, can use an opt-in\r\n>   mechanism to negotiate which fields should be reported to allow for\r\n>   efficient content adaption.\r\n\r\nI believe the above already covers all the cases we brought up here and on the list?\r\n",
          "createdAt": "2017-02-11T09:46:59Z",
          "updatedAt": "2017-02-11T09:46:59Z"
        },
        {
          "author": "michael-oneill",
          "authorAssociation": "NONE",
          "body": "If hints are capable of uniquely identifying a user's device then the data communicated is personal data. If it concerns a European resident then before it is processed, meaning collected or used, the user must give their consent. This is a legal requirement in Europe, which will be strongly enforced after the GDPR and the new ePrivacy Regulation come into force next year.\r\nThis inevitably means that sending an Accept-CH requires opt-in consent. If the browser does not require it then all the sites (in Europe or elsewhere if directed at European residents) will have to.\r\n\r\n",
          "createdAt": "2017-02-11T11:37:14Z",
          "updatedAt": "2017-02-11T11:37:14Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That may be true for hints that are capable of uniquely identifying a user, but irrelevant for hints that are not. Therefore, we shouldn't impose a rule requiring an opt in for all hints.",
          "createdAt": "2017-02-11T12:43:41Z",
          "updatedAt": "2017-02-11T12:43:41Z"
        },
        {
          "author": "michael-oneill",
          "authorAssociation": "NONE",
          "body": "The more hints the more entropy. If an origin can place Accept-CH they can use that to single-out the user without their knowledge, unless opt-in is required. \r\nHow could entropy be reduced? Can it be quantified?",
          "createdAt": "2017-02-11T13:29:02Z",
          "updatedAt": "2017-02-11T13:29:02Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@michael-oneill I think we may be talking past each other here. Everything you describe is already possible within the provided text in the draft - e.g. if you're building a browser you can provide necessary opt-in's and all the rest; if you're building an app you can prompt the user to accept terms of service on install, and so on. How the various implementations chose to surface this is up to them; we're not in a position to enforce anything here.",
          "createdAt": "2017-02-11T15:20:06Z",
          "updatedAt": "2017-02-11T15:20:06Z"
        },
        {
          "author": "npdoty",
          "authorAssociation": "NONE",
          "body": "@igrigorik I recognize that Client Hints could be used by HTTP implementations that aren't a browser being used by a user. It seems like in most (or all?) of those suggested cases, a developer controls the server and the client and sending `Accept-CH` wouldn't be a challenge. (That said, it might be that this could be a SHOULD, or a requirement that explicitly describes the situations where it doesn't need to be followed.)\r\n\r\nWhile the current language provides flexibility to the client implementation, I think there are interoperability reasons to specify conditions that support user privacy here. Providing the expectation in the spec that the server receives Client Hints only if it has asked for them means that developers won't have to check UA implementations individually to try to figure out how to receive hints and UA implementers will have a common required condition which will benefit all users' privacy in providing for more detectability.",
          "createdAt": "2017-02-13T01:15:21Z",
          "updatedAt": "2017-02-13T01:15:21Z"
        },
        {
          "author": "npdoty",
          "authorAssociation": "NONE",
          "body": "@yoavweiss that User-Agent strings have, in some recent mobile implementations, increased their entropy and revealed more about the specific hardware isn't necessarily a good thing or something we should accept and duplicate in actual standards. The browser on the laptop I'm using right now doesn't reveal the specific model of MacBook that I'm using, or the size or density of its screen in the `User-Agent` or other HTTP headers. \r\n\r\nI agree that looking up info in device databases based on browser sniffing is not the ideal case; I don't think that means we should increase the presence of explicit device info in all HTTP requests. `Accept-CH` would be a data minimization method more similar to existing JavaScript implementations; sites that need the information can ask for it and ask for it in a way that's visible.",
          "createdAt": "2017-02-13T01:23:32Z",
          "updatedAt": "2017-02-13T01:23:32Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "PTAL https://github.com/httpwg/http-extensions/pull/305. ",
          "createdAt": "2017-02-24T17:38:18Z",
          "updatedAt": "2017-02-24T17:38:18Z"
        },
        {
          "author": "michael-oneill",
          "authorAssociation": "NONE",
          "body": "What is the purpose of sending Client Hints to embedded third-parties anyway? \r\nHow does the user know  a response to an embedded subresource contains Accept-CH? There should at least be a user agent setting so third-parties do not receive hints, preferably the default similar to the way third-party cookies are now blocked (somewhat) in Safari. A drive-by Accept-CH will be even more of a privacy risk especially if the user is never informed.",
          "createdAt": "2017-02-24T20:18:26Z",
          "updatedAt": "2017-02-24T20:18:26Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "It is common for sites to host resources on a CDN whose origin != document origin -- e.g. I host my images on a third-party image service and I want said CDN to optimize the resources based on advertised CH hints. Note that there is (already) nothing preventing the document from exporting the same data.. most commonly by appending it into the URL of the subresource.\r\n\r\nWhich is to say, and to reiterate once more, CH **does not** expose anything that was not previously available to the document via JavaScript and/or CSS.",
          "createdAt": "2017-02-25T00:21:35Z",
          "updatedAt": "2017-02-25T00:21:35Z"
        },
        {
          "author": "michael-oneill",
          "authorAssociation": "NONE",
          "body": "It exposes it to any resource immediately, without needing to return script in html which then has to return information in another request. It makes fingerprinting, already recognised as a privacy risk, much easier, and less detectable. \r\nUser agents should have default settings that block Client Hints. This could be qualified on a per origin basis by DNT or a new Permission that puts the user in control.",
          "createdAt": "2017-02-25T09:33:25Z",
          "updatedAt": "2017-02-25T09:33:25Z"
        },
        {
          "author": "michael-oneill",
          "authorAssociation": "NONE",
          "body": "or alternatively invent a mechanism for limiting the entropy",
          "createdAt": "2017-02-25T09:36:32Z",
          "updatedAt": "2017-02-25T09:36:32Z"
        },
        {
          "author": "inian",
          "authorAssociation": "CONTRIBUTOR",
          "body": "probably we can have an option for whitelisting / blacklisting the domains client hints should be sent to as a meta tag as well (CSP-style)",
          "createdAt": "2017-02-25T12:33:08Z",
          "updatedAt": "2017-02-25T12:33:08Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> User agents should have default settings that block Client Hints. This could be qualified on a per origin basis by DNT or a new Permission that puts the user in control.\r\n\r\nAs I said earlier\u2014see https://github.com/httpwg/http-extensions/issues/284#issuecomment-279151499 \u2014our guidance in the spec allows for this and we do recommend that they use Accept-CH as an opt-in. I'm not against DNT or additional permissions, but we're not in a position to make these policy decisions here; those decisions need to be made by the implementers. I don't think we're going to get much further in this discussion in this forum.",
          "createdAt": "2017-02-25T17:03:09Z",
          "updatedAt": "2017-02-25T17:03:25Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "And to be clear, this spec is for the protocol aspects of CH. We need to note the privacy and security considerations, but how it's actually used is application-specific, and the place that's being done for Web browsers is the Fetch spec. ",
          "createdAt": "2017-02-27T05:13:23Z",
          "updatedAt": "2017-02-27T05:13:23Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Resolved via https://github.com/httpwg/http-extensions/pull/305.",
          "createdAt": "2017-02-27T05:48:57Z",
          "updatedAt": "2017-02-27T05:48:57Z"
        }
      ]
    },
    {
      "number": 286,
      "id": "MDU6SXNzdWUyMDUwNTE4MzE=",
      "title": "Editorial suggestions",
      "url": "https://github.com/httpwg/http-extensions/issues/286",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "immutable"
      ],
      "body": "",
      "createdAt": "2017-02-03T01:53:21Z",
      "updatedAt": "2017-02-03T01:55:05Z",
      "closedAt": "2017-02-03T01:55:05Z",
      "comments": []
    },
    {
      "number": 288,
      "id": "MDU6SXNzdWUyMDUwNTQ4NDM=",
      "title": "The inverse of immutable",
      "url": "https://github.com/httpwg/http-extensions/issues/288",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "immutable"
      ],
      "body": "Chrome currently implements the semantics of `immutable` using a browser heuristic rather than an explicit signal from the server.\r\n\r\nif we define a complimentary CC extension with the inverse semantics of `immutable` -- i.e., roughly, \"always refresh this when the user hits reload\" -- it would allow Chrome to continue using a heuristic, but override it with an explicit signal from the server when the server cares about it.\r\n\r\nIf we do that, I think the CC extension name should be short (e.g., one or two characters).",
      "createdAt": "2017-02-03T02:17:10Z",
      "updatedAt": "2017-03-14T00:16:21Z",
      "closedAt": "2017-03-14T00:16:21Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can imagine such an extension, but its not this one and this one isn't incompatible with adding such a thing in a separate draft. immutable is based on running code and I'm not comfortable expanding that scope here.",
          "createdAt": "2017-03-13T16:16:45Z",
          "updatedAt": "2017-03-13T16:16:45Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Makes sense. If anyone needs this, we can revisit.",
          "createdAt": "2017-03-14T00:16:21Z",
          "updatedAt": "2017-03-14T00:16:21Z"
        }
      ]
    },
    {
      "number": 289,
      "id": "MDU6SXNzdWUyMDUwNTUyNzA=",
      "title": "immutable definition",
      "url": "https://github.com/httpwg/http-extensions/issues/289",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "immutable"
      ],
      "body": "The definition of `immutable`s semantics are a bit weird:\r\n\r\n> When present in an HTTP response, the `immutable` Cache-Control extension indicates that the origin server MUST NOT update the representation of that resource during the freshness lifetime of the response.\r\n\r\nI think it should be defined in terms of client operation, rather than server operation. E.g.,\r\n\r\n> When present in an HTTP response, the `immutable` Cache-Control extension indicates that clients SHOULD NOT issue a conditional request during the response's freshness lifetime (e.g., upon a \"reload\"), unless explicitly overridden by the user (e.g., a \"force reload\").\r\n",
      "createdAt": "2017-02-03T02:20:37Z",
      "updatedAt": "2017-03-13T16:29:46Z",
      "closedAt": "2017-03-13T16:29:46Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/httpwg/http-extensions/commit/dd7a9513d21b5e4c8a4571c909828bf002afaabe",
          "createdAt": "2017-03-13T16:29:46Z",
          "updatedAt": "2017-03-13T16:29:46Z"
        }
      ]
    },
    {
      "number": 290,
      "id": "MDU6SXNzdWUyMDUwNTU0NjU=",
      "title": "About Intermediaries",
      "url": "https://github.com/httpwg/http-extensions/issues/290",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [
        "mcmanus"
      ],
      "labels": [
        "editorial",
        "immutable"
      ],
      "body": "> An immutable response has the same semantic meaning for proxy clients as it does for User-Agent based clients and they therefore MAY also presume a conditional revalidation for a response marked immutable would return 304. A proxy client who uses immutable to anticipate a 304 response may choose whether to reply with a 304 or 200 to its requesting client.\r\n\r\nParse error :) What are you trying to do?",
      "createdAt": "2017-02-03T02:22:18Z",
      "updatedAt": "2017-03-13T16:29:02Z",
      "closedAt": "2017-03-13T16:29:02Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/httpwg/http-extensions/commit/fdc18b2ae5fee1e2a2540ca8d71ba0ed2553104b\r\n",
          "createdAt": "2017-03-13T16:29:02Z",
          "updatedAt": "2017-03-13T16:29:02Z"
        }
      ]
    },
    {
      "number": 291,
      "id": "MDU6SXNzdWUyMDUwNjExMzc=",
      "title": "Persistence",
      "url": "https://github.com/httpwg/http-extensions/issues/291",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "origin-frame"
      ],
      "body": "Dare we specify that clients MAY/SHOULD persist origin information for a given endpoint beyond the lifetime of the connection?",
      "createdAt": "2017-02-03T03:08:17Z",
      "updatedAt": "2017-04-19T01:33:30Z",
      "closedAt": "2017-04-19T01:33:30Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "origin set is defined per connection not (ironically) per origin.. so I'm not sure how this would work.",
          "createdAt": "2017-03-21T00:25:41Z",
          "updatedAt": "2017-03-21T00:25:41Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "2 loadbalanced hosts could have different sets of certs even if they answered to the same SNI on the same (public) IP..  I don't know how you could persist that.",
          "createdAt": "2017-03-21T00:28:35Z",
          "updatedAt": "2017-03-21T00:28:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yeah. I think there are a lot of ways we could mess up here. \r\n\r\nIf you think of the binding as between a set of origins and a connection, AIUI what's being posited here is that it might be interesting to re-attach that binding to a new connection.\r\n\r\nIt might be interesting if the server could associate a token with a particular set, and then have a dance where its use can be explicitly negotiated. Question is whether it's worth the effort (we've already tried to over-engineer this thing a few times).",
          "createdAt": "2017-03-21T00:33:39Z",
          "updatedAt": "2017-03-21T00:33:39Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed that persisting across connections seems like it may add too much risk and complexity and further additional interactions, especially if we include hosts not found through the DNS.  (And doesn't even make sense with some of the changes made to not always rely on DNS.)",
          "createdAt": "2017-03-31T14:37:45Z",
          "updatedAt": "2017-03-31T14:37:45Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Seems like there's no support for this ATM, closing. Comment if you disagree.",
          "createdAt": "2017-04-19T01:33:30Z",
          "updatedAt": "2017-04-19T01:33:30Z"
        }
      ]
    },
    {
      "number": 294,
      "id": "MDU6SXNzdWUyMDYzNTg4MDY=",
      "title": "Issues from old repo",
      "url": "https://github.com/httpwg/http-extensions/issues/294",
      "state": "CLOSED",
      "author": "estark37",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "estark37"
      ],
      "labels": [
        "expect-ct"
      ],
      "body": "I want to address these issues that were filed in the old repo https://github.com/bifurcation/expect-ct/:\r\n\r\n- [x] https://github.com/bifurcation/expect-ct/issues/18\r\n- [x] https://github.com/bifurcation/expect-ct/issues/16\r\n- [x] https://github.com/bifurcation/expect-ct/issues/7\r\n- [x] https://github.com/bifurcation/expect-ct/issues/6\r\n- [x] https://github.com/bifurcation/expect-ct/issues/4",
      "createdAt": "2017-02-08T23:31:57Z",
      "updatedAt": "2017-05-25T03:36:48Z",
      "closedAt": "2017-05-25T03:36:48Z",
      "comments": [
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oops, sorry, it looks like I wasn't supposed to close this on my own because of the design label, is that right @mnot?\r\n\r\nI think https://github.com/bifurcation/expect-ct/issues/18 was the only design issue on this list. I ended up only making fairly superficial changes, with my reasoning described in https://github.com/bifurcation/expect-ct/issues/18#issuecomment-303517543\r\n",
          "createdAt": "2017-05-23T20:21:14Z",
          "updatedAt": "2017-05-23T20:21:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "That's OK, we can reopen it if someone complains.",
          "createdAt": "2017-05-25T03:36:48Z",
          "updatedAt": "2017-05-25T03:36:48Z"
        }
      ]
    },
    {
      "number": 295,
      "id": "MDU6SXNzdWUyMDcxOTQxOTk=",
      "title": "clarify round-tripping of double quotes around cookie value",
      "url": "https://github.com/httpwg/http-extensions/issues/295",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "See discussion in <https://issues.apache.org/jira/browse/HTTPCLIENT-1006> -- I believe the spec needs to be clearer about this.",
      "createdAt": "2017-02-13T11:46:51Z",
      "updatedAt": "2017-08-07T13:09:18Z",
      "closedAt": "2017-08-07T13:08:54Z",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Adding a note in -02.",
          "createdAt": "2017-08-07T12:23:14Z",
          "updatedAt": "2017-08-07T12:23:14Z"
        }
      ]
    },
    {
      "number": 302,
      "id": "MDU6SXNzdWUyMDk2MTkyMTI=",
      "title": "Typo in SameSite cookie algorithm (?)",
      "url": "https://github.com/httpwg/http-extensions/issues/302",
      "state": "CLOSED",
      "author": "estark37",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "Step 5 of Section 2.1.1 of https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00#section-2.1.1 says `return \"top-site\"`, but \"top-site\" isn't defined anywhere. I think it's supposed to be the registerable domain of \"top-origin\"?\r\n\r\ncc @scotthelme",
      "createdAt": "2017-02-22T23:49:30Z",
      "updatedAt": "2017-08-07T13:09:18Z",
      "closedAt": "2017-08-07T13:08:54Z",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Thanks! Will be fixed in the -02 draft of RFC6265 I'm about to upload.",
          "createdAt": "2017-08-07T11:51:57Z",
          "updatedAt": "2017-08-07T11:51:57Z"
        }
      ]
    },
    {
      "number": 303,
      "id": "MDU6SXNzdWUyMTAwNTkxNjM=",
      "title": "div: removing all WSP characters?",
      "url": "https://github.com/httpwg/http-extensions/issues/303",
      "state": "CLOSED",
      "author": "waldbaerkoch",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "key"
      ],
      "body": "In the section about div:\r\n> 4. Remove all WSP characters from header_value.\r\n> 5. If header_value does not match the div ABNF rule, fail parameter processing ({{fail-param}}).\r\n\r\nSo a header value\r\n```\r\n23   45\r\n```\r\nwill become\r\n```\r\n2345\r\n```\r\nwhich matches `1*DIGIT`; everything is fine? Or is the intention to **trim** the header value?",
      "createdAt": "2017-02-24T14:17:14Z",
      "updatedAt": "2018-04-03T23:40:25Z",
      "closedAt": "2018-04-03T23:40:25Z",
      "comments": [
        {
          "author": "waldbaerkoch",
          "authorAssociation": "NONE",
          "body": "Same in the section about partition.",
          "createdAt": "2017-02-24T14:24:00Z",
          "updatedAt": "2017-02-24T14:24:00Z"
        }
      ]
    },
    {
      "number": 304,
      "id": "MDU6SXNzdWUyMTAwNjIzMzE=",
      "title": "partition: numbering issue",
      "url": "https://github.com/httpwg/http-extensions/issues/304",
      "state": "CLOSED",
      "author": "waldbaerkoch",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial",
        "key"
      ],
      "body": "> If header_value is less than segment_value when they are numerically compared, skip to step 7.\r\n\r\nThis should probably refer to step 8 (\"Return segment_id.\")\r\n\r\n\"For each segment_value in segment_list:\" should get the number 7 in the markdown file (6 is already 'Create a list segment_list by splitting parameter_value on \":\" characters.').",
      "createdAt": "2017-02-24T14:30:21Z",
      "updatedAt": "2018-04-03T23:40:25Z",
      "closedAt": "2018-04-03T23:40:25Z",
      "comments": []
    },
    {
      "number": 306,
      "id": "MDU6SXNzdWUyMTA0MDU0OTE=",
      "title": "Allow servers to specify max-age in the client hints header",
      "url": "https://github.com/httpwg/http-extensions/issues/306",
      "state": "CLOSED",
      "author": "tarunban",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "The [Accept-CH](http://httpwg.org/http-extensions/client-hints.html) header is currently included by origin servers in HTTP responses if they are interested in receiving client hints from the browser (e.g., DPR). The spec currently does not require browsers to persist the opt-in across browser restarts. This means that if the origins are interested in receiving hints on all requests, then they need to include the Accept-CH header on all responses. This has two disadvantages: (i) Browsers currently fail to include the hints on the first request after the browser restart; and, (ii) It may not be possible for the origin servers to include the Accept-CH header on all responses due to responses being served out of different endpoints (CDNs etc.).\r\n\r\nTo fix this: The Accept-CH header should also support a [max-age](http://wicg.github.io/reporting/#max-age-member) header value which indicates for how long should the browser remember this opt-in (including across browser restarts). A value of max-age set to 0 should cause the browser to stop sending client-hints to the origin. As an example,\r\n\r\n`Accept-CH: feature1, feature2, max-age=86400`\r\n\r\nwould imply that the browser should include hints `feature1` and `feature2` for next 86400 seconds for that origin.",
      "createdAt": "2017-02-27T07:17:05Z",
      "updatedAt": "2017-03-26T17:31:40Z",
      "closedAt": "2017-03-26T17:31:40Z",
      "comments": [
        {
          "author": "michael-oneill",
          "authorAssociation": "NONE",
          "body": "It crossed my mind also that the response determines a future request, so how long in the future?\r\n\r\nWhy not create a well-known named cookie, similar to the cookie prefix idea in RFC6265bis, then use that to convey Accept-CH. Then you get the potential fingerprinting showing up in the cook,ie store where the user (or privacy extensions) can see it. You also get the expiry functionality  for free. \r\n\r\nAnd the SameSite attribute to help with privacy.\r\n\r\n\r\n\r\n",
          "createdAt": "2017-02-27T17:25:49Z",
          "updatedAt": "2017-02-27T17:25:49Z"
        },
        {
          "author": "tarunban",
          "authorAssociation": "NONE",
          "body": "@michael-oneill I am not sure if cookies are the best place to store this information given that cookies are used by servers for state management, and this does not seem to fit that use case.",
          "createdAt": "2017-02-27T18:12:13Z",
          "updatedAt": "2017-02-27T18:12:13Z"
        },
        {
          "author": "michael-oneill",
          "authorAssociation": "NONE",
          "body": "Accept-CH makes the UA retain the state on what Client Hints are to be sent in future requests. The problem with Client Hints is that they can (will) be used to identify users by fingerprinting their UAs. \r\n\r\nUsers know to some extent that cookies are used to identify them, so why not hold this identifying styate their also.\r\n\r\nIt increases transparency,, enables user control and does not re-invent the wheel.\r\n\r\n",
          "createdAt": "2017-02-28T09:51:35Z",
          "updatedAt": "2017-02-28T09:51:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Making this a new directive in `Accept-CH` is a bit problematic, since that header field is defined as a list of header field names. It's technically possible, you just would get into situations where you have to switch your parser based upon the format of the directive, and reserve keywords that now can't be used as headers (and thus, have to register them as headers -- see `Connection`).\r\n\r\nYou *could* do it as a new header, though -- e.g.,\r\n\r\n`Accept-CH-Lifetime: 3600`\r\n\r\nor similar.\r\n\r\nThat has the additional benefit that it can be introduced later if there's need for it, and we decide not to do it now.\r\n\r\n@igrigorik, what do you think? Keeping in mind that we're doing this spec primarily to document what one (albeit big) implementation is doing, hence its Experimental status, is Chrome interested in implementing this? \r\n\r\nIf not, I'd suggest we close this issue; if it's interesting in the future, it's relatively easy to add that new header.\r\n\r\nAll of that said -- I *do* think there's a bit of an issue remaining with how the applicability of `Accept-CH` is scoped. I'll open a separate issue for that.",
          "createdAt": "2017-03-02T03:58:07Z",
          "updatedAt": "2017-03-02T03:58:07Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "My long-term hope is that this entire discussion is a no-op and origin policy will give us the right primitives (see https://github.com/WICG/origin-policy/issues/12) to solve this in a generic way for all opt-in behaviors. That said, there *is* interest in implementing this in Chrome\u2014 tarunban@ is driving that work\u2014and we need an alternative mechanism until OP is a thing.\r\n\r\nI agree with Mark that `Accept-CH-Lifetime` is better solution. The secondary benefit, as I see it, is that we can also no-op it later once Origin Policy becomes available. More details in https://github.com/httpwg/http-extensions/issues/307#issuecomment-284113236.\r\n\r\n",
          "createdAt": "2017-03-04T01:15:01Z",
          "updatedAt": "2017-03-04T01:15:01Z"
        },
        {
          "author": "filex",
          "authorAssociation": "NONE",
          "body": "Disclaimer: I'm new here, so please forgive possible naivety :)\r\n\r\nThinking about this issue and other kinds of scoping mechanisms (`max-age` directives in Cache Control, Cookies or HSTS, well-known Origin Policy files etc.), I was wondering whether we could try to attach directives to manage site properties (such as CH scope) in both time \"and space\" to the TLS scope.\r\n\r\nA TLS certificate is a necessary prerequisite for many HTTP/Web extensions. E.g. HSTS headers are ignored without a validated certificate. We could limit the possible lifespan of any time-bound directive to the remaining TTL of the certificate. Say my LE certificate expires in 30 days; the user  agent could store the CH settings for exactly this time span. Usually certificates are renewed before the expire. This should allow user agents to revalidate and reschedule the property expiry well before they expire. The same could apply to HSTS or other properties. A user agent may use this site/origin property until the certificate expires, and it must be revalidated at the next contact thereafter.\r\n\r\nThe spatial scope of the certificate is somewhat boring, because it usually covers a whole origin in sense of `/` on a certain domain name. However, wildcard certificates or ones with more than one common name could be used to tie together a bunch of hostnames. We could use that as an outer bound for origin properties.\r\n\r\nMore generally, could we transfer properties such as [Origin Policies](https://wicg.github.io/origin-policy/) or HSTS directives as part of the TLS handshake in an [ALPN](https://tools.ietf.org/html/rfc7301)-like fashion? This would enable the server to communicate transfer rules to the user agent before the first request on HTTP level is carried out.",
          "createdAt": "2017-03-06T13:31:21Z",
          "updatedAt": "2017-03-06T13:31:21Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@filex interesting idea, but I don't think we want to couple certificate lifetime to other settings.. there is no reason why cert lifetime is representative of the content lifetime transported over the TLS tunnel.",
          "createdAt": "2017-03-07T12:16:44Z",
          "updatedAt": "2017-03-07T12:16:44Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@filex, you will find that there is a great deal of reluctance to do that sort of thing.  If we were to start doing that, then we would create another reason to lengthen the validity period of certificates.  That's bad for security.\r\n\r\nIn other words, is an *advantage* to have a logical separation of details of the authentication mechanism from the management of state.",
          "createdAt": "2017-03-08T03:53:10Z",
          "updatedAt": "2017-03-08T03:53:10Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "First run at `Accept-CH-Lifetime`: https://github.com/httpwg/http-extensions/pull/313 - ptal.",
          "createdAt": "2017-03-17T22:28:39Z",
          "updatedAt": "2017-03-17T22:28:39Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Resolved via https://github.com/httpwg/http-extensions/pull/313.",
          "createdAt": "2017-03-26T17:31:40Z",
          "updatedAt": "2017-03-26T17:31:40Z"
        }
      ]
    },
    {
      "number": 307,
      "id": "MDU6SXNzdWUyMTEyODQyMzI=",
      "title": "Scoping of Accept-CH",
      "url": "https://github.com/httpwg/http-extensions/issues/307",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "The `Accept-CH` response header is defined as:\r\n\r\n> When a client receives Accept-CH, or if it is capable of processing the HTML response and finds an equivalent HTML meta element, it can treat it as a signal that the server is interested in receiving the Client-Hint header fields that match the advertised field-values; subsequent requests initiated to the same server and, optionally any subresource requests initiated as a result of processing the response from the server that includes the Accept-CH opt-in, can include the Client-Hint header fields that match the advertised field-values.\r\n>\r\n> For example, based on Accept-CH example above, a user agent could append DPR, Width, Viewport-Width, and Downlink header fields to all subresource requests initiated by the page constructed from the response. Alternatively, a client can treat advertised support as a persistent origin preference and append same header fields on all future requests initiated to and by the resources associated with that origin.\r\n\r\n\"All future requests\" is a long time indeed. While of course the client isn't going to literally do that (eventually it'll be garbage collected, or the user will reset state, or the machine will be recycled), from a server-side perspective, it'd be nice to have *some* level of control over how bloated your requests get.\r\n\r\nAdditionally, having `Accept-CH` possibly indicate that future references *to* **and** *from* this origin seems like a pretty broad brush to be painting with. While Chrome might make some reasonable decisions about tradeoffs here (and probably needs some wiggle room), if this ever does get implemented elsewhere, this broadness and freedom is a recipe for bad interop and worse server-side headaches.\r\n\r\nSo, can we nail this down at all? \r\n\r\nThe most conservative approach is:\r\n\r\n\"Send CH headers on subrequests generated by this content, please.\"\r\n\r\nHowever, the above also says \"subsequent requests initiated to the same server\" in the primary spot; the case above is relegated to \"optionally.\"\r\n\r\nPersonally, my preference would be to drop \"subsequent requests initiated to the same server and, optionally\" and the corresponding text in the example below it. The primary use case for CH as I understand it is serving appropriate subresources, NOT dynamically modifying HTML, so that should do the trick.\r\n\r\nAm I missing something, @igrigorik?\r\n\r\nRegardless of that, \"server\" is used very loosely above; I think you mean \"origin\", right? And \"can\" should probably be \"MAY\".\r\n\r\nCC @yoavweiss",
      "createdAt": "2017-03-02T04:09:39Z",
      "updatedAt": "2017-04-10T09:55:02Z",
      "closedAt": "2017-03-26T17:31:00Z",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> The primary use case for CH as I understand it is serving appropriate subresources, NOT dynamically modifying HTML, so that should do the trick.\r\n\r\nWith the benefit of few years of experience, absence of hints on the initial request has proven to be a major limitation that prevented wider adoption. In practice, many of the most critical decisions about page format are made when the HTML is generated -- e.g. whether you should serve \"light\" version of the page, picking resource density, ..., and feature-detecting support for CH to begin with. In short, we do need to allow hints on navigation responses.\r\n\r\n> \"Send CH headers on subrequests generated by this content, please.\"\r\n\r\nI think that's a reasonable definition for `Accept-CH`, iff we also combine it with `Accept-CH-Lifetime` proposed in https://github.com/httpwg/http-extensions/issues/306 to cover the case for initial navigation. Concretely, the proposal here would be: \r\n\r\n- Scope down `Accept-CH` to \"subsequent requests generated by this content\"\r\n- Define `Accept-CH-Lifetime` to allow opt-in to be remembered for specified period of time. \r\n  - When this is present, opt-in applies for all content that belongs to the origin.",
          "createdAt": "2017-03-04T01:13:29Z",
          "updatedAt": "2017-03-04T01:13:29Z"
        },
        {
          "author": "michael-oneill",
          "authorAssociation": "NONE",
          "body": "DNT has a mechanism for determining if the DNT:0 header sent to subresources, a JS API for specifying \"site-specific\" consent. This also can specify lifetime by having an \"expires\" or \"maxAge\" property in the parameter dictionary for the call.  \r\n\r\nThe TPWG has discussed using cookies as a more generic method, but the SOP gets in the way (you cannot limit the state to a top level context).\r\n\r\nThe Accept-CH header is similarly determining stateful site-specific behaviour for subresources, perhaps this points to a generalised solution? Especially as there are privacy/user control issues in common?\r\n\r\nI am thinking about a well-known cookie prefix (as proposed for RFC6265bis) that would cause the cookie to be sent to subresources in the cookie header, but only within the context of the parent that placed it. The existence of particular forms of this well-known cookie could then determine UA behaviour (such as sending Client Hints to subresources).\r\n\r\nImplementation would be simpler because the expiry procedures are already in place.\r\n\r\nA further advantage would then be that the state is automatically contained in the UAs cookie store, accessible to existing privacy oriented UA UIs and extensions, increasing transparency.\r\n\r\nFor example:\r\n\r\nSet-Cookie: __SRAccept-CH=DPR;expires=Sat, 05 Mar 2017 00:00:00 GMT",
          "createdAt": "2017-03-04T11:50:30Z",
          "updatedAt": "2017-03-04T11:50:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@igrigorik - Just thinking through doing this, a couple of questions --\r\n\r\nIt seems like there are a lot of potential dimensions that the server's preferences for sending CH could vary -- e.g., same-origin vs. third-party, navigation vs. subresource, etc. Are we offering the right capability (all requests from a given origin) here?\r\n\r\nWill having one `Accept-CH` policy for an entire origin work? What if different resources need different headers? How should clients behave when they get conflicting lists of headers and/or lifetimes for a given origin?\r\n\r\nUsing a cache to determine whether to sent hint headers means that the initial navigation request to a given origin won't have them, so any behaviour that depends on them will need a fallback. Is that just going to be \"serve the heavier page\", or something more complex?",
          "createdAt": "2017-03-06T05:40:33Z",
          "updatedAt": "2017-03-06T05:40:33Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> It seems like there are a lot of potential dimensions that the server's preferences for sending CH could vary -- e.g., same-origin vs. third-party, navigation vs. subresource, etc. Are we offering the right capability (all requests from a given origin) here?\r\n\r\nBased on the experience and feedback so far.. yes. It's the simplest strategy that covers all the use cases, and everything else just adds more configuration and implementation complexity.\r\n\r\n> Will having one Accept-CH policy for an entire origin work? What if different resources need different headers? How should clients behave when they get conflicting lists of headers and/or lifetimes for a given origin?\r\n\r\nLast registration wins, similar to HSTS.\r\n\r\n> Using a cache to determine whether to sent hint headers means that the initial navigation request to a given origin won't have them, so any behaviour that depends on them will need a fallback. Is that just going to be \"serve the heavier page\", or something more complex?\r\n\r\nThe former. Practically speaking, sites can't rely on CH hints being available from every browser in any case, so they need a fallback strategy regardless.\r\n",
          "createdAt": "2017-03-06T12:51:13Z",
          "updatedAt": "2017-03-06T12:51:13Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@mnot @mikewest would love to hear your thoughts on the cookie opt-in idea floated above.\r\n\r\n`Set-Cookie: __Secure-Accept-CH=DPR; Secure; Path=/images; Expires=<date>`\r\n\r\n- It does provides more flexibility than the origin wide opt-in -- e.g. customizable by path, etc.\r\n- It's visible to the user and subject to all other cookie policies and workflows.\r\n\r\nDo we have any other precedents that use cookies for feature opt-ins? Any gotchas with going down this path, spec/layering and implementation wise? It's also unclear to me whether we'd really need to invent new prefixes.. hoping the answer is \"no\". ",
          "createdAt": "2017-03-17T17:43:54Z",
          "updatedAt": "2017-03-17T17:43:54Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "From a practical perspective, this sounds expensive if we need to consult the cookie monster for every request. I suspect that we'd internally need to turn this into something like HSTS where we store the pins distinctly from cookies, at which point we lose much of the elegance of the proposal, I think.\r\n\r\nFrom a theoretical perspective, this is breaking new ground. We don't have any other special-purpose cookies that I know of. We'd need to reserve the name in some way (which is absolutely doable, if odd). Also, cookies have terrible scoping rules. The less eTLD+1 we have, the better, from my perspective.\r\n\r\nFrom a pinning perspective, spelling the pin as `Set-Cookie` vs `Set-CH-Disposition` or something is not terribly concerning. The server is expressing a preference, and we're caching it locally. The general idea of pinning that kind of preference seems fine to me. I'd prefer to see it done via origin policy, but I still haven't found anyone to implement that (nor have I addressed @mnot's feedback on the spec... :( ).",
          "createdAt": "2017-03-17T19:07:10Z",
          "updatedAt": "2017-03-17T19:07:10Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> From a practical perspective, this sounds expensive if we need to consult the cookie monster for every request. I suspect that we'd internally need to turn this into something like HSTS where we store the pins distinctly from cookies, at which point we lose much of the elegance of the proposal, I think.\r\n\r\nRight, you confirmed my main worry. Solving this problem via cookies is doable, but brings a lot of unrelated complexity that I'd much rather avoid. I'm inclined to keep things simple and...\r\n\r\n- Define a standalone `Accept-CH-Lifetime`, as proposed in https://github.com/httpwg/http-extensions/issues/306#issuecomment-283549512\r\n  - Give it origin-wide scope -- no subpaths, etc.\r\n  - Pin expires based on specified lifetime, or whenever cookies are cleared.\r\n- When we ship Origin Policy developers can just move the pin into their policy and everything will continue working as before.\r\n\r\nI'll take a run at a PR for the above.\r\n",
          "createdAt": "2017-03-17T21:21:55Z",
          "updatedAt": "2017-03-17T21:21:55Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "First run at `Accept-CH-Lifetime`: https://github.com/httpwg/http-extensions/pull/313 - ptal.",
          "createdAt": "2017-03-17T22:28:50Z",
          "updatedAt": "2017-03-17T22:28:50Z"
        },
        {
          "author": "michael-oneill",
          "authorAssociation": "NONE",
          "body": "Doesn't \"the cookie monster\" have to be consulted anyway for every request? If only to work out what to put in the Cookie header?\r\n\r\nMy idea was  mainly to give  users (and privacy protection extensions) the ability to detect the existence of the CH state by keeping it in the same place as cookies, where there already exist UIs etc. for seeing/dealing with them.\r\n\r\nIf a parallel system is implemented to manage CH state (with expiry etc.) then there would also be a need for similar UIs, API to support extensions etc. For cookies that already exists.\r\n\r\nIt is true the scoping rules are horrible, but they do not need to be used for these special prefixes. The \"secure\" attribute already restricts scoping for some cookies.\r\n\r\n\r\n\r\n",
          "createdAt": "2017-03-18T09:14:29Z",
          "updatedAt": "2017-03-18T09:14:29Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Doesn't \"the cookie monster\" have to be consulted anyway for every request? If only to work out what to put in the Cookie header?\r\n\r\nNot from inside the rendering engine, which is where CH headers are added.\r\n",
          "createdAt": "2017-04-10T09:55:02Z",
          "updatedAt": "2017-04-10T09:55:02Z"
        }
      ]
    },
    {
      "number": 308,
      "id": "MDU6SXNzdWUyMTEyODc1NjE=",
      "title": "CH editorial",
      "url": "https://github.com/httpwg/http-extensions/issues/308",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [
        "igrigorik"
      ],
      "labels": [
        "client-hints",
        "editorial"
      ],
      "body": "Taking a run through the spec before we sent it upstairs, a few suggestions --\r\n\r\n* In the abstract, `s/clients/user agents/g` (proxies aren't going to generate them, and shouldn't try)\r\n* Introduction - you might get complaints about the \"UA\" abbreviation; spell out as `User-Agent`?\r\n* Section 2 - \"Each one conveys a list of client preferences\" -- are they all list-based?\r\n* 2.2 - \"Servers respond with an optimized response based on one or more received hints from the client.\" -- awkward; suggest: \"When presented with a request that contains one or more client hint headers, servers can optimise the response based upon the information in them.\"\r\n* 2.2 - \"used hint\" --> \"hint used\"\r\n* 2.2 - \"emit\" --> \"generate\"  (has meaning in HTTP)\r\n* 2.2 \"confirm the property of the response, such that the client can adjust its processing\" --> \"convey related values to aid client processing\"\r\n* Sections 3-7: These feel like they should all be in their own subsection. Also, would you consider changing \"client hint\" in each title to \"header field\"? That will emphasise that they're just regular headers, not some new class of thing (I continue to be concerned that people think these are magical because they are called Client Hints).\r\n* Section 7: \"New token and extension token values can only be defined by revisions of this specification\" --> \"New token and extension token values can be defined by updates to this specification.\"  (IETF-specific wording)\r\n* Section 9: \"Client Hints defined in this specification do not expose new information about the user\u2019s environment beyond what is already available to, and can be communicated by, the application at runtime via JavaScript and CSS.\" --> \"The request header fields defined in this specification expose information that is already available to Web applications in the browser runtime itself (e.g., using JavaScript and CSS).\"\r\n* Section 9: \"However, implementors should consider the privacy implications of various methods to enable delivery of Client Hints - see \u201cSending Client Hints\u201d section.\" --> \"However, servers that gather this information through such mechanisms are typically observable (e.g., you can see that they're using JavaScript to gather it), whereas servers' use of the header fields introduced by this specification is not observable. Section 2.1 discusses potential mitigations.\" \r\n* Section 9: \"might reduce such fingerprinting risks\" --> \"can help mitigate the risk of such fingerprinting.\"\r\n* Section 9: \"The implementers can...\" --> \"Implementers ought to...\"\r\n* Section 9: \"...advertised: require...\" --> \"...advertised. For example, they could require...\"",
      "createdAt": "2017-03-02T04:37:29Z",
      "updatedAt": "2017-03-14T08:03:05Z",
      "closedAt": "2017-03-14T08:03:05Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "ping @igrigorik ",
          "createdAt": "2017-03-02T04:37:37Z",
          "updatedAt": "2017-03-02T04:37:37Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the thorough review Mark!\r\n\r\n> In the abstract, s/clients/user agents/g (proxies aren't going to generate them, and shouldn't try)\r\n\r\nI'm building an iOS/Android app and want to use CH.. \"user agent\" doesn't seem to fit? I'd prefer to keep it inclusive.\r\n\r\n> Introduction - you might get complaints about the \"UA\" abbreviation; spell out as User-Agent?\r\n\r\nWe do define it at the start: \"User-Agent (UA; Section 5.5.3 of {{RFC7231}})\"\r\n\r\n--\r\n\r\nOpened PR to address the rest: https://github.com/httpwg/http-extensions/pull/309",
          "createdAt": "2017-03-04T01:20:41Z",
          "updatedAt": "2017-03-04T01:20:41Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "\"client\" and \"user agent\" are defined terms in HTTP; client covers *anything* that sends a request, including proxies, whereas user agent is only the originator of requests -- regardless of whether it's a Web browser or app.\r\n\r\n(this is not the WHATWG :)\r\n\r\nI saw that you defined the abbreviation, but I suspect the RFC editor is going to change it; all other HTTP RFCs use the phrase \"user agent.\" Besides which, \"User-Agent\" is the name of the header field, further confusing things.",
          "createdAt": "2017-03-06T01:41:06Z",
          "updatedAt": "2017-03-06T01:41:06Z"
        }
      ]
    },
    {
      "number": 310,
      "id": "MDU6SXNzdWUyMTM1NDQ0NTE=",
      "title": "RFC 7515 (base64url) is only used in examples and can be moved to informative",
      "url": "https://github.com/httpwg/http-extensions/issues/310",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-03-11T17:40:37Z",
      "updatedAt": "2017-03-13T00:12:28Z",
      "closedAt": "2017-03-13T00:12:28Z",
      "comments": []
    },
    {
      "number": 312,
      "id": "MDU6SXNzdWUyMTQyMTE0ODY=",
      "title": "Expect-CT report-uri should be quoted",
      "url": "https://github.com/httpwg/http-extensions/issues/312",
      "state": "CLOSED",
      "author": "estark37",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "estark37"
      ],
      "labels": [
        "expect-ct"
      ],
      "body": "The report-uri syntax in Section 2.1.1 should quote the `absolute-URI`. This would most closely match HPKP, for which the report-uri syntax is not specified but all given examples are quoted. (https://tools.ietf.org/html/rfc7469#section-2.1.5)",
      "createdAt": "2017-03-14T21:25:44Z",
      "updatedAt": "2017-05-22T22:52:22Z",
      "closedAt": "2017-05-22T22:52:22Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually, it should be silent on this.\r\n\r\nAny parameter should take *either* token *or* quoted-string, without exception.\r\n\r\nIf the type of the parameter always requires to use quoted-string, that's fine and is something the sender needs to be aware of. That said, it should not be enforced in the grammar.",
          "createdAt": "2017-03-14T21:29:47Z",
          "updatedAt": "2017-03-14T21:29:47Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On second thought. I'm going to WontFix this. I don't think there's any reason that the report-uri has to be quoted, and since the syntax already differs somewhat from HPKP, I don't think we need to match the examples in the HPKP spec that closely.",
          "createdAt": "2017-05-22T22:52:22Z",
          "updatedAt": "2017-05-22T22:52:22Z"
        }
      ]
    },
    {
      "number": 314,
      "id": "MDU6SXNzdWUyMTU0NDE0NjQ=",
      "title": "origin frame race condition (not the obvious one)",
      "url": "https://github.com/httpwg/http-extensions/issues/314",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "origin-frame"
      ],
      "body": "7540 has coalescing rules that are overruled by Origin frames - we all know that can't take effect until the origin frame(s) have been received at the client - so that's the basic race condition that we're comfortable with.\r\n\r\nBut because the origin set is done one origin in one frame at a time, and there is no End-of-Set marker on it, the set can become initialized before it is complete upon receipt of the first frame. Initialization means any origin that will soon be in the set but has not yet been processed will not be coalesced onto this connection even if it meets the rules of 7540.. that's the state that is intended at the end of origin set processing, but this interim state seems counterproductive.\r\n\r\nThe easiest thing to do seems to be to create some kind of checkpoint flag that means 'generation done for now'.",
      "createdAt": "2017-03-20T14:40:43Z",
      "updatedAt": "2017-04-20T00:34:19Z",
      "closedAt": "2017-04-20T00:34:19Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It's not one-origin-per-frame; it can contain many.\r\n\r\nI think we've discussed this; both for Origin and Cache Digest. The problem is that if the COMPLETE (or whatever we call it) flag isn't set, how long does the client wait around for? We'd have to be very careful to make sure that the semantics are \"more ORIGIN frames immediately following\", rather than \"wait around, I might have some more for you in a bit.\"\r\n\r\nGiven that an ORIGIN frame can convey quite a few origins (unless you've restricted maximum frame size) is this enough of an issue to justify the mechanism?",
          "createdAt": "2017-03-20T22:47:56Z",
          "updatedAt": "2017-03-20T22:47:56Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm, without a COMPLETE signal, the client might not coalesce even if it could.  That's suboptimal but it resolves fairly quickly once ORIGIN arrives.  The client can interrupt an in-progress connection attempt and coalesce once it learns the new origin.\r\n\r\nAs @mnot observes, if you add a COMPLETE signal, the client can know that it might wait (by testing that the server is authenticated for the origin), but how long does it wait?  I think that I would rather just fall back to the non-coalescing mode and interrupt if the ORIGIN frame arrives in time.\r\n\r\nNote that in 1-RTT TLS 1.3 the server speaks first, so the race can be reduced somewhat.",
          "createdAt": "2017-03-20T23:52:30Z",
          "updatedAt": "2017-03-20T23:52:30Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "multiples definitely help - I forgot to acknowledge that. But the general case is N frames.\r\nI think this bothers me more than the base race condition of waiting for the ORIGIN frame to arrive, because it actually undoes 7540 quite accidentally.\r\n\r\nimagine wanting to coalesce a set and having it setup via the usual DNS rules.. you want to also advertise that same set via origin to get the privacy and no-lookup wins.. halfway through you lose any coalescing for part of the set :(\r\n\r\nnot sure what the big deal with waiting is. That's state you're going to have anyhow - you're just not committing it yet.",
          "createdAt": "2017-03-21T00:35:18Z",
          "updatedAt": "2017-03-21T00:35:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I can see that we introduced something new with the DNS rule change -- now there's a point in time where the client has to decide whether or not to resolve DNS for a given origin. ",
          "createdAt": "2017-03-21T00:53:55Z",
          "updatedAt": "2017-03-21T00:53:55Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "So it sounds like what you really want is a flag that triggers the omit-DNS behaviour?",
          "createdAt": "2017-04-19T01:38:03Z",
          "updatedAt": "2017-04-19T01:38:03Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "given a little time to let this issue breathe I think the right thing to do might be to just highlight the issue with a little text suggesting that frames should be atomic, which might lead folks to pack their frames rather than doing 1 per origin..",
          "createdAt": "2017-04-19T04:12:38Z",
          "updatedAt": "2017-04-19T04:12:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@mcmanus how's that?",
          "createdAt": "2017-04-19T06:20:36Z",
          "updatedAt": "2017-04-19T06:20:36Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "sure. thanks",
          "createdAt": "2017-04-19T18:31:50Z",
          "updatedAt": "2017-04-19T18:31:50Z"
        }
      ]
    },
    {
      "number": 315,
      "id": "MDU6SXNzdWUyMTU1ODk5NDk=",
      "title": "origin frames and 0-RTT",
      "url": "https://github.com/httpwg/http-extensions/issues/315",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "origin-frame"
      ],
      "body": "Do we want to allow clients to remember origin sets for when they resume?  Coalescing for 0-RTT could be a significant win.",
      "createdAt": "2017-03-20T23:53:16Z",
      "updatedAt": "2017-03-21T00:22:24Z",
      "closedAt": "2017-03-21T00:22:24Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Dup of #291.",
          "createdAt": "2017-03-21T00:22:24Z",
          "updatedAt": "2017-03-21T00:22:24Z"
        }
      ]
    },
    {
      "number": 316,
      "id": "MDU6SXNzdWUyMTg1MjAzOTI=",
      "title": "Expect-CT uses cookie syntax",
      "url": "https://github.com/httpwg/http-extensions/issues/316",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "expect-ct"
      ],
      "body": "Roy noted that the header syntax is copied from Cookies, which is an abomination.\r\n\r\nWe have the header-structure draft, which this could follow. Many of the other recent header fields that use comma-separated lists with semi-colon-separated parameter maps could serve as an example.",
      "createdAt": "2017-03-31T14:33:14Z",
      "updatedAt": "2017-03-31T14:58:44Z",
      "closedAt": "2017-03-31T14:43:02Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Does it? I don't think so:\r\n\r\n> Expect-CT-Directives = directive *( OWS \";\" OWS directive )\r\n> directive            = directive-name [ \"=\" directive-value ]\r\n> directive-name       = token\r\n> directive-value      = token / quoted-string",
          "createdAt": "2017-03-31T14:35:11Z",
          "updatedAt": "2017-03-31T14:35:11Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What is the definition for `Expect-CT` itself?  Because you are right, this looks fine.",
          "createdAt": "2017-03-31T14:36:35Z",
          "updatedAt": "2017-03-31T14:36:35Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems to be the ABNF for the field value (good), but the prose could be a bit more clear about that.",
          "createdAt": "2017-03-31T14:42:41Z",
          "updatedAt": "2017-03-31T14:42:41Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We can close this (invalid) and I will open a smaller issue about the definition of `Expect-CT` itself.  That can be just editorial.",
          "createdAt": "2017-03-31T14:43:02Z",
          "updatedAt": "2017-03-31T14:43:02Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "No, it is supposed to be a list.  It is defined as a semicolon-separated list.  That's the cookie syntax.\r\n\r\nIt should be\r\n\r\n```\r\n   Expect-CT       = #directive\r\n   directive       = directive-name [ \"=\" directive-value ]\r\n   directive-name  = token\r\n   directive-value = token / quoted-string\r\n```",
          "createdAt": "2017-03-31T14:52:31Z",
          "updatedAt": "2017-03-31T14:52:31Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": ":-) just because it doesn't use list syntax doesn't make it like cookies. For instance, that would make Content-Type \"cookie-like\" as well.\r\n\r\nThat said: yes, this might be a candidate for list syntax.",
          "createdAt": "2017-03-31T14:58:02Z",
          "updatedAt": "2017-03-31T14:58:02Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that the current text is incredibly opaque.  I think that #318 is OK to replace this.",
          "createdAt": "2017-03-31T14:58:44Z",
          "updatedAt": "2017-03-31T14:58:44Z"
        }
      ]
    },
    {
      "number": 317,
      "id": "MDU6SXNzdWUyMTg1MjE2MDk=",
      "title": "Request header for Expect-CT",
      "url": "https://github.com/httpwg/http-extensions/issues/317",
      "state": "CLOSED",
      "author": "siyengar",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "expect-ct"
      ],
      "body": "A request header for Expect-CT would allow servers to know how many clients actually support Expect-CT and might allow us to deprecate this header in the future. \r\n\r\nSpecifying that you MUST send Expect-CT response unless the header is sent might be nice as well.",
      "createdAt": "2017-03-31T14:37:17Z",
      "updatedAt": "2017-04-18T02:05:38Z",
      "closedAt": "2017-04-18T02:05:38Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "This would require including it in `Vary` on cacheable responses -- something that is going to reduce cache efficiency and also likely to cause operator error.\r\n\r\nIs the added complexity/risk worth it?",
          "createdAt": "2017-04-03T19:07:37Z",
          "updatedAt": "2017-04-03T19:07:37Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, I expect Expect-CT to be a somewhat niche feature, so we'd probably be adding wasted bytes to the vast majority of requests.",
          "createdAt": "2017-04-03T19:59:01Z",
          "updatedAt": "2017-04-03T19:59:01Z"
        },
        {
          "author": "siyengar",
          "authorAssociation": "NONE",
          "body": "i imagine HPACK would compress that out, and if it's needed only for a short period of time then when we don't need this header any more, we'd stop sending it from clients. Without this, is there a way we can deprecate this header from ever being sent by a server? User agent hints?\r\n\r\n@mnot do we really need to add it on Vary? Clients who get responses with this header and don't support Expect-CT will just ignore it.  Clients who get this but have not sent Expect-CT will ignore it. Clients who have deprecated Expect-CT will behave like clients who don't support Expect-CT.",
          "createdAt": "2017-04-05T23:15:27Z",
          "updatedAt": "2017-04-05T23:21:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "HPACK does not give infinite efficiency; we're already hearing about the dynamic table thrashing for some sites.\r\n\r\nIf you don't put it in Vary, then an intermediary cache will store the version without the `Expect-CT` hint and serve it to clients that could have used one.",
          "createdAt": "2017-04-07T04:56:58Z",
          "updatedAt": "2017-04-07T04:56:58Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@siyengar I think that servers could probably just look at User-Agents to determine when the header is no longer applicable for most of the clients contacting them. (I imagine they'll probably end up wanting to keep an eye on the CT policies for the UAs they care about anyway, because the server might not get any value out of Expect-CT even if the UA still supports it. For example, one could imagine a UA that fully requires CT for all certs, but still supports Expect-CT for reporting purposes, in which case a server that is not using reporting would want to not send Expect-CT even though the UA still advertises support for it.)",
          "createdAt": "2017-04-15T00:29:42Z",
          "updatedAt": "2017-04-15T00:29:42Z"
        },
        {
          "author": "siyengar",
          "authorAssociation": "NONE",
          "body": "@mnot @estark37 the same problem would occur if the server decides not to send Expect-CT based on UA. Either you send the header to everyone, or if you don't send it to everyone, you have to include a Vary: User-Agent instead of a Vary: Expect-CT. ",
          "createdAt": "2017-04-17T04:02:07Z",
          "updatedAt": "2017-04-17T04:02:07Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@siyengar I just meant that if a server knows (from looking at UA) that 99.9% of its clients are Browsers X, Y, and Z, then it can stop sending Expect-CT when Browsers X, Y, and Z no longer support Expect-CT.",
          "createdAt": "2017-04-17T04:21:50Z",
          "updatedAt": "2017-04-17T04:21:50Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@estark37 - in that case, it would need to include \"User-Agent\" in the \"Vary\" field value....",
          "createdAt": "2017-04-17T08:59:17Z",
          "updatedAt": "2017-04-17T08:59:17Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "as Emily says, this is a niche server feature. The global number of bytes\nspent advertising to sites unaware of CT is going to be way more than the\nnumber of bytes sent bearing the response header. It can be deprecated just\nas easily by watching market share counters as anything else. I would close\nthe issue wontfix personally.\n\nas a total aside - the hpack pressure is normally on the server table not\nthe client one, right?\n\nOn Mon, Apr 17, 2017 at 4:59 PM, Julian Reschke <notifications@github.com>\nwrote:\n\n> @estark37 <https://github.com/estark37> - in that case, it would need to\n> include \"User-Agent\" in the \"Vary\" field value....\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/httpwg/http-extensions/issues/317#issuecomment-294435651>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAP5sxJDxivobMDEHp4bulsjDszXx9Erks5rwynlgaJpZM4MvwJh>\n> .\n>\n",
          "createdAt": "2017-04-17T11:11:45Z",
          "updatedAt": "2017-04-17T11:11:45Z"
        },
        {
          "author": "siyengar",
          "authorAssociation": "NONE",
          "body": "@mcmanus that's fair. We can always set Vary: User-Agent if we want to set it for some UAs but not others. It's clunky, but doable.\r\n@estark37 I think I'm fine with this rationale and we can close this out.",
          "createdAt": "2017-04-18T01:38:08Z",
          "updatedAt": "2017-04-18T01:38:08Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Personally - I agree with @estark37 and @mcmanus. There's no need to advertise it in `Vary` if the server makes a decision about turning it on/off for **all** requests. That approach is more suitable to this situation IMO.\r\n\r\nWRT hpack pressure -- numbers are always interesting, of course, but I'm hearing a lot of people on both sides making proposals with the assumption that hpack will take care of their efficiency problems. That's true, but only to a certain point...\r\n\r\n",
          "createdAt": "2017-04-18T01:45:36Z",
          "updatedAt": "2017-04-18T01:45:36Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the input, everyone.",
          "createdAt": "2017-04-18T02:05:38Z",
          "updatedAt": "2017-04-18T02:05:38Z"
        }
      ]
    },
    {
      "number": 318,
      "id": "MDU6SXNzdWUyMTg1MjY0NDE=",
      "title": "Definition of Expect-CT is a little unclear",
      "url": "https://github.com/httpwg/http-extensions/issues/318",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "expect-ct"
      ],
      "body": "The convention for HTTP is to define header fields as follows:\r\n\r\n```\r\n<header-field-name> = #<header-field-name>-fields\r\n```\r\n\r\nWhich leads to me suggesting:\r\n\r\n```abnf\r\nExpect-CT = #Expect-CT-Directives\r\nExpect-CT-Directives = [ parameter *( OWS \";\" OWS parameter ) ]\r\n```\r\n\r\nNote that this doesn't follow the common structure, which uses:\r\n\r\n```abnf\r\ncommon-structure = 1* ( identifier dictionary )\r\n```\r\n\r\nIgnore the obvious errors in the common structure syntax, the intent is to have a list of identifiers followed by dictionaries.\r\n\r\nI've marked this as editorial, I think that the outcome will not affect the wire syntax at all.",
      "createdAt": "2017-03-31T14:53:48Z",
      "updatedAt": "2017-04-20T17:00:48Z",
      "closedAt": "2017-04-20T17:00:48Z",
      "comments": [
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "If it is supposed to be a list of directives (some of which may be name=value), then it should be\r\n```\r\n   Expect-CT       = #directive\r\n   directive       = directive-name [ \"=\" directive-value ]\r\n   directive-name  = token\r\n   directive-value = token / quoted-string\r\n```\r\nIf it is supposed to be a list of directives with optional name=value parameters to each directive, then\r\n```\r\n   Expect-CT       = #directive\r\n   directive       = directive-name *( OWS \";\" OWS parameter ) \r\n   directive-name  = token\r\n   parameter       = token / ( token \"=\" quoted-string )\r\n```\r\nI guess we could also use some examples in the specification.",
          "createdAt": "2017-03-31T15:07:35Z",
          "updatedAt": "2017-03-31T15:07:35Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson  what you suggested *does* change the wire syntax...\r\n",
          "createdAt": "2017-03-31T15:08:33Z",
          "updatedAt": "2017-03-31T15:08:33Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also disagree with the statement:\r\n\r\n> The convention for HTTP is to define header fields as follows:\r\n\r\nThat depends on the type of the field. It's definitively not true universally right now.",
          "createdAt": "2017-03-31T15:10:33Z",
          "updatedAt": "2017-03-31T15:10:40Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "BTW, that would be to match the standard HTTP/1.x syntax for most header fields. I don't think it is appropriate to use the experimental common structure, which is still just a proposal, unless folks want to make this header field a guinea pig.",
          "createdAt": "2017-03-31T15:10:37Z",
          "updatedAt": "2017-03-31T15:10:37Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://greenbytes.de/tech/webdav/rfc7838.html#rfc.section.3 might be a good template.",
          "createdAt": "2017-03-31T15:12:55Z",
          "updatedAt": "2017-03-31T15:12:55Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry for my delay here.\r\n\r\nIf I'm understanding correctly, then @royfielding's first suggestion is the intention: it's supposed to be a list of directives, some of which may be name=value:\r\n```\r\n   Expect-CT       = #directive\r\n   directive       = directive-name [ \"=\" directive-value ]\r\n   directive-name  = token\r\n   directive-value = token / quoted-string\r\n```\r\n\r\nHowever this changes the format from semicolon-separated directives (`Expect-CT: enforce; max-age=23`) to comma-separated (`Expect-CT: enforce, max-age=23`); is that correct?\r\n\r\nIf so, it's a little unfortunate that it'll differ from HPKP/HSTS syntax, which is semicolon-separated directives, but I suppose that's okay. @jcjones how do you feel about that from a Firefox implementation perspective?",
          "createdAt": "2017-04-14T18:55:32Z",
          "updatedAt": "2017-04-14T18:56:01Z"
        },
        {
          "author": "jcjones",
          "authorAssociation": "NONE",
          "body": "@estark37: Implementation-wise, it's not much work to accept a comma-delimited list instead of semicolons. However, since this is so similar to CSP/HPKP/HSTS, I'd _prefer_ it to have a similar structure of semicolon delineation, particularly since the reporting mechanism looks so much like CSP. It feels like it'd be weird to see the different delimiters side-by-side:\r\n\r\n```\r\n    add_header\t           Strict-Transport-Security \"max-age=31536000; includeSubDomains; preload\";\r\n    add_header             Content-Security-Policy \"default-src 'self'; script-src 'unsafe-eval' 'unsafe-inline' 'self' ... ; img-src data: 'self'; ... \";\r\n    add_header             Expect-CT \"enforce, max-age=1\";\r\n```",
          "createdAt": "2017-04-14T20:10:04Z",
          "updatedAt": "2017-04-14T20:10:04Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "Yes, comma-separated lists is the normal form in HTTP (inherited from the Internet message syntax of email and netnews) because it allows multiple header fields to be appended without changing the semantics of the field. In other words,\r\n```\r\nExpect-CT: enforce, max-age=23\r\n```\r\nis defined by HTTP to be equivalent to   \r\n```\r\nExpect-CT: enforce\r\nExpect-CT: max-age=23\r\n```\r\nwhich allows various implementation layers/filters to add to a message without rewriting the entire header block.\r\n\r\nIf the comma-separated list syntax is not used, then implementations are forbidden from sending the directives in more than one field and recipients must fail-with-error if more than one field is received.",
          "createdAt": "2017-04-16T19:22:55Z",
          "updatedAt": "2017-04-16T19:22:55Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "STS, like Cookie, is a bad example of a microsyntax that doesn't take advantage of the HTTP-native features.\r\n\r\nUsing the non-standard syntax can run afoul of some of the compression measures in HTTP/2.\r\n\r\nCSP is actually specifically defined as a single string, so the semi-colons are internal to the header field.  Note that CSP actively forbids multiple header field values (or makes them all apply equally, I can't remember).  In the ways that matter, CSP is actually perfectly compatible with Roy's suggestion.",
          "createdAt": "2017-04-18T07:39:28Z",
          "updatedAt": "2017-04-18T07:39:28Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Alright, like @jcjones I find it weird that the syntax will be different than HSTS/HPKP/CSP, but I suppose that's okay; Expect-CT will already differ in a couple other subtle ways so I think the syntax difference is not the end of the world.\r\n\r\n@martinthomson @royfielding @reschke could you please check if https://github.com/httpwg/http-extensions/pull/327 seems reasonable?",
          "createdAt": "2017-04-18T17:29:00Z",
          "updatedAt": "2017-04-18T17:29:00Z"
        }
      ]
    },
    {
      "number": 319,
      "id": "MDU6SXNzdWUyMTg1MzY4MDU=",
      "title": "EARLY-hints requirement on \"client MUST NOT process\" headers needs better wording",
      "url": "https://github.com/httpwg/http-extensions/issues/319",
      "state": "CLOSED",
      "author": "royfielding",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "early-hints",
        "editorial"
      ],
      "body": "Regarding \r\n```\r\n   A client MAY speculatively evaluate the headers included in the\r\n   informational response while waiting for the final response.  For\r\n   example, a client may recognize the link header of type preload and\r\n   start fetching the resource.  However, the evaluation MUST NOT affect\r\n   how the final response is processed; the client must behave as if it\r\n   had not seen the informational response.  A client MUST NOT process\r\n   the headers included in the response as if they belonged to the\r\n   informational response.\r\n```\r\nThe requirement in the last sentence needs to be re-worded, since `process` includes parsing and the client is clearly parsing those header fields and using them.",
      "createdAt": "2017-03-31T15:29:47Z",
      "updatedAt": "2017-05-18T01:19:39Z",
      "closedAt": "2017-05-18T01:19:39Z",
      "comments": [
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "I would rewrite the paragraph as\r\n```\r\n   A client MAY speculatively evaluate the header fields included in\r\n   the informational response while waiting for the final response.\r\n   For example, a client might recognize a link header field of type\r\n   preload and start fetching the indicated resource.  However, these\r\n   fields only provide hints to the client; they do not replace the header\r\n   fields on the final response. Aside from performance optimizations,\r\n   such evaluation of the 103 response's header fields MUST NOT\r\n   affect how the final response is processed. A client MUST NOT\r\n   interpret the 103 response header fields as if they applied to the\r\n   103 response itself (e.g., as metadata about the 103 response).\r\n```\r\n",
          "createdAt": "2017-03-31T15:47:57Z",
          "updatedAt": "2017-03-31T15:47:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Collision with my suggested edits; closing. Please ask to reopen if you still think there's a problem; we can address it in WGLC.",
          "createdAt": "2017-05-18T01:19:39Z",
          "updatedAt": "2017-05-18T01:19:39Z"
        }
      ]
    },
    {
      "number": 320,
      "id": "MDU6SXNzdWUyMTg1NDMxNjE=",
      "title": "client hints generally uses \"headers\" to refer to \"header fields\"",
      "url": "https://github.com/httpwg/http-extensions/issues/320",
      "state": "CLOSED",
      "author": "royfielding",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-hints",
        "editorial"
      ],
      "body": "The WG drafts that extend HTTP/1 should be consistent with the terminology of RFC7230 and RFC7231. That means `s/headers/header fields/g;`.",
      "createdAt": "2017-03-31T15:51:47Z",
      "updatedAt": "2017-05-03T02:26:54Z",
      "closedAt": "2017-05-03T02:26:54Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Seems to have been addressed.",
          "createdAt": "2017-05-03T02:26:54Z",
          "updatedAt": "2017-05-03T02:26:54Z"
        }
      ]
    },
    {
      "number": 321,
      "id": "MDU6SXNzdWUyMTg5MjAyODE=",
      "title": "Expect CT: Add an example",
      "url": "https://github.com/httpwg/http-extensions/issues/321",
      "state": "CLOSED",
      "author": "craigfrancis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "expect-ct"
      ],
      "body": "Would it be possible to include an example in the spec?\r\n\r\nSomething like...\r\n\r\n    Expect-CT: enforce; max-age=3600; report-uri=\"https://example.com/expect-ct-report\"\r\n\r\nAs I believe most developers like to work with examples, rather than just using the spec definition as found under the heading \"Response Header Field Syntax\".\r\n\r\n:-)",
      "createdAt": "2017-04-03T12:39:59Z",
      "updatedAt": "2017-04-20T17:00:42Z",
      "closedAt": "2017-04-20T17:00:42Z",
      "comments": []
    },
    {
      "number": 322,
      "id": "MDU6SXNzdWUyMTg5NTYwMzE=",
      "title": "Expect CT: includeSubDomains",
      "url": "https://github.com/httpwg/http-extensions/issues/322",
      "state": "CLOSED",
      "author": "craigfrancis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "expect-ct"
      ],
      "body": "Should the `Expect CT` header also have a `includeSubDomains` directive?\r\n\r\nIn the same way that [Strict-Transport-Security](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security) and [Public-Key-Pins](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Public-Key-Pins) has this feature.",
      "createdAt": "2017-04-03T14:42:22Z",
      "updatedAt": "2019-08-02T13:26:06Z",
      "closedAt": "2017-04-14T21:50:51Z",
      "comments": [
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've intentionally omitted `includeSubdomains` in Expect-CT. Though I acknowledge that it would be useful to site owners, I don't think we should add it because it considerably increases the size of the footgun, by offering the ability to require CT for subdomains that have never even demonstrated to the UA their CT compliance.\r\n\r\n(I also suspect that most site owners would primarily use it as a tool to learn about all their subdomains, which is a use that is somewhat orthogonal to Expect-CT's actual purpose.)",
          "createdAt": "2017-04-14T20:15:11Z",
          "updatedAt": "2017-04-14T20:15:11Z"
        },
        {
          "author": "craigfrancis",
          "authorAssociation": "NONE",
          "body": "That's a reasonable approach, if anyone else needs this they could re-open this issue.",
          "createdAt": "2017-04-14T21:50:51Z",
          "updatedAt": "2017-04-14T21:50:51Z"
        },
        {
          "author": "Avamander",
          "authorAssociation": "NONE",
          "body": "I'd honestly like to see this just to make it possible to holistically protect a domain, this would provide feature-parity with HSTS as well. Not to mention the possibility of making Expect-CT more preloadable than it is right now.",
          "createdAt": "2019-08-02T13:25:50Z",
          "updatedAt": "2019-08-02T13:26:06Z"
        }
      ]
    },
    {
      "number": 324,
      "id": "MDU6SXNzdWUyMjA4MTEzMTU=",
      "title": "frame type 0xb polluted by BLOCKED use 0xc for ORIGIN",
      "url": "https://github.com/httpwg/http-extensions/issues/324",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "origin-frame"
      ],
      "body": "pull #323 ",
      "createdAt": "2017-04-11T01:06:19Z",
      "updatedAt": "2017-04-19T01:34:14Z",
      "closedAt": "2017-04-19T01:34:14Z",
      "comments": []
    },
    {
      "number": 325,
      "id": "MDU6SXNzdWUyMjE0MjU4NTE=",
      "title": "Incomplete responses and immutable",
      "url": "https://github.com/httpwg/http-extensions/issues/325",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "immutable"
      ],
      "body": "Just wondering out loud -- should immutable have any consideration of whether the response is incomplete, or potentially incomplete (i.e., close-delimited, rather than byte-counted or chunked or h2)?\r\n\r\nOne of the reasons people hit 'reload' is when something on the page seems corrupted.\r\n\r\n@mcmanus any thoughts?",
      "createdAt": "2017-04-13T00:21:31Z",
      "updatedAt": "2017-05-03T01:55:07Z",
      "closedAt": "2017-05-03T01:55:07Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "so firefox calls this \"strongly vs weakly framed\".\r\n\r\nHitting reload, which normally does conditional revals, doesn't really help with weakly framed things because you just revalidate the etag or LM in the header.. and in the case of truncation (the common fail mode) the header is not what's wrong.\r\n\r\nso if you're weakly framed we don't do conditional revals at all - we just load unconditionally (the same as if you did a hard reload) because its not really trustworthy.\r\n\r\nnone of this is really an immutable specific issue though. immutable never bypasses 'hard reloads' and that's the only thing that's going to work here..",
          "createdAt": "2017-04-13T02:28:10Z",
          "updatedAt": "2017-04-13T02:28:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I was wondering if weakly framed content should be unconditionally be requested on a \"normal\" load, even despite the presence of immutable. \r\n\r\nSee also https://github.com/whatwg/fetch/issues/524",
          "createdAt": "2017-04-13T04:05:13Z",
          "updatedAt": "2017-04-13T04:05:13Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "you mean in normal reloads not normal loads, right? (the latter would just mean no-store I think.)\r\n\r\nand yes, that's what I believe we do.. and it isn't related to the presence of immutable. (Though I admit I think I put it in at the same time as working on immutable because these questions came up.)",
          "createdAt": "2017-04-13T11:58:18Z",
          "updatedAt": "2017-04-13T11:58:18Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "a large component of weakly framed responses are actually buggy responses that we tolerate due to server errors.. e.g. chunked without a 0 chunk or stuff that is short of its content-length",
          "createdAt": "2017-04-13T12:02:46Z",
          "updatedAt": "2017-04-13T12:02:46Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The current draft says:\r\n\r\n> Clients SHOULD NOT issue a conditional request during the response\u2019s freshness lifetime (e.g. upon a reload) unless explicitly overridden by the user (e.g. a force reload).\r\n\r\nWhat about amending it to:\r\n\r\n> Clients SHOULD NOT issue a conditional request during the response\u2019s freshness lifetime (e.g. upon a reload) unless explicitly overridden by the user (e.g. a force reload), or when the stored response is potentially corrupted (e.g., lacks strong framing).\r\n\r\n?",
          "createdAt": "2017-04-19T02:02:25Z",
          "updatedAt": "2017-04-19T02:02:42Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we ought to close this issue as not relevant in any special way to immutable.\r\n\r\nThe issue you are talking about is that conditional reloads do not work for fixing corrupted content because they re validate headers and not the corrupted content. The presence of immutable doesn't really matter to that equation - all it does is bypass a conditional request that wasn't working right anyhow because it is unaware the corruption is in the message body. You can insert this proposed rule to 'fix' that, but it doesn't fix all the resources without immutable that have the same problem for the same reason. The problem has nothing to do with immutable.\r\n\r\nI could support a rule for all resources that says clients SHOULD NOT issue a conditional revalidation when the stored response is potentially corrupted (i.e. they should do force reloads) - indeed that's firefox policy. but its not really immutable specific.",
          "createdAt": "2017-05-02T19:26:12Z",
          "updatedAt": "2017-05-02T19:26:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Fair enough. I'll raise an issue on the http11bis repo.",
          "createdAt": "2017-05-03T01:55:04Z",
          "updatedAt": "2017-05-03T01:55:04Z"
        }
      ]
    },
    {
      "number": 330,
      "id": "MDU6SXNzdWUyMjM1MDAzNjA=",
      "title": "Consulting the DNS on expanding ORIGIN set?",
      "url": "https://github.com/httpwg/http-extensions/issues/330",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "origin-frame"
      ],
      "body": "The current ORIGIN frame draft (as of the changes introduced from #212) now prohibits consulting DNS when establishing a connection's authority, as long as the TLS certificate is consulted:\r\n\r\n> Clients MUST NOT consult DNS to establish the connection's authority for new requests.  The TLS certificate MUST stil be used to do so, as described in [RFC7540] Section 9.1.1.\r\n\r\nAs @MikeBishop pointed out during discussion in Chicago, this is the first draft that explicitly removes DNS from the loop as a factor, rather than just delegating DNS.  I did not get the sense that strong consensus exists yet for removing DNS as a factor without an additional authenticator.\r\n\r\nParticular concerns (some of which are highlighted in the Security Considerations) include:\r\n\r\n* When a cert (or validation behavior) is compromised, currently active MitM or DNS poisoning is required to exploit.  This new behavior enables vulnerabilities here to be exploited by simply getting a client to follow a link to a malicious server that can expand the ORIGIN set to cover the origins it wants to hijack (and which are covered by the compromised cert or compromised validation behavior).\r\n* This has the change has potential to significantly change the operational behavior of clients.  Rather than clients always following DNS, clients may now aggregate origins onto a connection to a server that was never handed out in the DNS for that name.  This may have unintended consequences, such as allowing a non-production server sharing a cert with a production name to accidentally hijack production traffic; or otherwise giving a server operator with a cert covering a name the power to pull in client traffic for that name without this being explicitly configured through the DNS.\r\n\r\nThis change (to not follow the DNS) also becomes much more powerful (and more useful and more potentially perilous) when combined with any future pushed certificate functionality.  I'm not convinced that the having to follow the DNS name is \"onerous\" enough to justify the security impact.\r\n\r\nSome options appear to be:\r\n\r\n1) Remove this \"Clients MUST NOT consult DNS\" clause.  This doesn't prohibit the expansion of ORIGIN sets, but does mean that existing DNS service discovery and DNS following behavior must still be followed.  This change could be introduced in a subsequent draft that much more explicitly worked through the security considerations and mitigations.\r\n2) Leave the language as-is, possibly expand on security considerations, and do a more detailed security analysis (especially for how this might interact with future pushed server certs).\r\n3) Specify additional mitigations that should replace consulting DNS, such as a pushed DNSSEC record chain terminating in the server IP, signed Alt-Service records, or similar.  Most of these would require subsequent drafts to define in-detail, along with a corresponding security analysis.\r\n\r\n(Regardless, we may wish to clarify the subsequent bullet to make it clear that clients MAY consult the DNS to determine whether an existing connection can be reused or whether a new connection should be established.  While the existing \"MUST NOT consult DNS\" phrasing does not prohibit this, it is misleading on a first reading.)\r\n",
      "createdAt": "2017-04-21T21:21:11Z",
      "updatedAt": "2017-09-12T00:42:58Z",
      "closedAt": "2017-09-12T00:42:58Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Erik -\r\n\r\nI'm trying to understand your second concern WRT operational behavior of clients. The origins being added are explicitly nominated by the server; presence in the certificate is not enough to cause the connection to be used (indeed, that concern was a large part of the motivation of this draft).\r\n\r\nRegarding the first concern -- to me, the convincing argument was that the assurances added by using DNS are incredibly weak, to the point of being of no value, especially as more people use DNS services (Open DNS, Google Public DNS, etc.), and as networks mess with them (see <https://recdnsfp.github.io> for one example).\r\n\r\nIt might make sense to add more text to Security Considerations, e.g., encouraging (or requiring) use of a higher level of assurance (CT, pinning, etc.) as an effective second factor. Would that help?",
          "createdAt": "2017-04-26T05:28:07Z",
          "updatedAt": "2017-04-26T05:28:07Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm trying to understand your second concern WRT operational behavior of clients. The origins being added are explicitly nominated by the server; presence in the certificate is not enough to cause the connection to be used (indeed, that concern was a large part of the motivation of this draft).\r\n\r\nI believe that limiting origin-set and connection reuse was the original motivation for this draft, however, it seems that possible use cases changed a bit because of [draft-bishop-httpbis-http2-additional-certs](https://datatracker.ietf.org/doc/html/draft-bishop-httpbis-http2-additional-certs), which together with this draft, makes it possible to expand the origin-set and effectively hijack traffic for all domains that server has valid SSL certificates for.\r\n\r\nEven ignoring the compromised server scenario, there are at least a few operational issues with bypassing DNS:\r\n\r\n1. Many medium to large companies use multiple CDN providers and steer traffic using DNS. They use either custom GeoDNS solutions or services like [Cedexis](https://www.cedexis.com/solutions/multi-cdn/) to load balance traffic across multiple CDNs, or simply use one of the CDNs as the primary and rest as active backups. All those CDNs have valid SSL certificates, so neither CT nor certificate pinning would help.\r\nSimilarly, some websites migrate traffic to DDoS protection services only during attacks, but those services are configured and have valid SSL certificates at all times.\r\n**Basically, configured != active.**\r\n\r\n2. Servers with wildcard certificates can takeover all traffic for the domain, even if some subdomains would never be routed to a particular server. To give an extreme example, let's say that `www.bank.com`, `promotions.bank.com`, etc. are served by the CDN, but `secure.bank.com` is handled by the bank's own infrastructure. There is nothing stopping the CDN with valid certificate for `*.bank.com` from hijacking the traffic for `secure.bank.com`, and while certificate pinning would prevent traffic for `secure.bank.com` from reaching the CDN, it would effectively result in DoS and pretty bad end-user experience.\r\n\r\nOne solution that came up in discussions with @grittygrease and @enygren, was to include signed DNSSEC response in the `ORIGIN` frame, to prove that the traffic should be routed to this particular server. This obviously solves only part of the problem, since it doesn't mean that traffic from _this particular client_ would be routed to that server, but it's much better than servers going completely wild.",
          "createdAt": "2017-07-08T02:21:07Z",
          "updatedAt": "2017-07-08T02:21:07Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@PiotrSikora - thanks for the input.\r\n\r\nWRT global load balancing / CDN balancing -- one of the things that has been discussed is a bit to tell the client whether or not to check DNS; that would allow them to use this, I think.\r\n\r\nWRT wildcards -- ORIGIN doesn't currently support wildcarding.",
          "createdAt": "2017-07-09T05:41:50Z",
          "updatedAt": "2017-07-09T05:41:50Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Even without supporting wildcard ORIGINs, @PiotrSikora has a valid point that if a server has a wildcard cert it can pull in any hostnames that it wants to.\r\n\r\nTelling a client whether or not to check DNS certainly helps for some of these cases (ie, it helps avoid a few operational snafus) but doesn't help against malicious use-cases.\r\n\r\nMy inclination is still to pull this draft back to the original \"limiting origin set and connection reuse\" scenario but while leaving placeholders for a subsequent draft that would cover expanding the origin set (ie, with using additional-certs and whatever other mitigators are deemed appropriate).  Otherwise this draft changes the operational model of the web much more substantially than people may realize at first glance.  Any operational shift this significant likely wants to be a first-class discussion rather than being a side-effect of a draft that initially had a much more constrained scope.\r\n",
          "createdAt": "2017-07-10T21:58:04Z",
          "updatedAt": "2017-07-10T21:58:04Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "wrt \"check DNS\" flag - it's still the server (i.e. CDN) that's making this recommendation to the client, right? If so, then I don't think it fixes anything, since CDNs can omit this flag and prevent clients from consulting DNS, justifying this with \"we're improving the performance\" excuse.",
          "createdAt": "2017-07-10T22:31:37Z",
          "updatedAt": "2017-07-10T22:31:37Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let me try to summarize the concern in a different way: having a certificate for a name is not always sufficient basis for that server to be chosen and used.\r\n\r\nAll these cases reduce down to the same complaint: the client might be talking to an instance that has a certificate for N>1 names and the intent is that only a subset of those names is used.  This might be due to geographical distribution of nodes, contractual arrangements (the CDN is charging more than their competitor today, so they're on backup duty), or any other operational concern.\r\n\r\nThe problem with all of these is that there is no way to communicate this intent to the client that doesn't ultimately chain back to the certificate.  A certificate that the server instance has.  Relying on the DNS is a fig leaf.  As @PiotrSikora says, even DNSSEC fails because you can't be sure that this is the RRset that would be sent to *this* particular client.\r\n\r\nIt looks like what you are looking for is a better means of control over your server instances.  The reliance on DNS is a poor substitute for a genuine signal.\r\n\r\nCrazy suggestion, would a certificate extension that enabled this functionality make you happier?  As long as the CDN never received a certificate with the extension, it couldn't make these sorts of assertions.  I'm not saying that I think that's a good idea, but I want to explore the boundaries of your problem better.",
          "createdAt": "2017-07-11T00:11:32Z",
          "updatedAt": "2017-07-11T00:11:32Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson I originally wanted to dismiss this idea (since CDNs could mis-issue certs with the extension anyway, so it doesn't add 2nd factor). However, we chatted a bit about it with @grittygrease yesterday, and we came to conclusion that opt-in certificate extension, along with CT requirement (so that it would be obvious that CDN requested certificate with such extension, even when domain owner didn't opt-in for it) seems like an acceptable solution.",
          "createdAt": "2017-07-16T10:11:57Z",
          "updatedAt": "2017-07-16T10:11:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Please review proposed changes in latest commit.",
          "createdAt": "2017-07-31T04:05:23Z",
          "updatedAt": "2017-07-31T04:05:23Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see the associated suggestions in the Security Considerations, but I thought the discussion on the list led toward putting a \"MAY skip, but SHOULD use something else instead\"?  Even if the concrete suggestions of what the \"something else\" could be still live in Security Considerations....",
          "createdAt": "2017-07-31T23:32:27Z",
          "updatedAt": "2017-07-31T23:32:27Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I don't see how I can put \"SHOULD use something else\" in an RFC with a straight face. If someone can suggest appropriate wording here, I'd be ever so grateful. ",
          "createdAt": "2017-07-31T23:35:43Z",
          "updatedAt": "2017-07-31T23:35:43Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On the thread, \"Clients opting not to check DNS SHOULD employ some alternative means to increase confidence that the certificate is legitimate, such as Certificate Transparency or revocation checks\" got +1s from Ryan and @enygren.  Since you have a mention elsewhere, you could adapt that to \"such as those discussed in Section 4\" reasonably enough.",
          "createdAt": "2017-07-31T23:39:53Z",
          "updatedAt": "2017-07-31T23:39:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hmm. I suspect a requirement that's so vague won't get through IESG, but I guess we can try it.",
          "createdAt": "2017-07-31T23:52:32Z",
          "updatedAt": "2017-07-31T23:52:32Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "how about a non normative should.. that way you're describing the tradeoffs\nin a way that sheds some light on the situation (with examples) but not\ndoing a normative \"do something unspecific\"\n\n\nOn Mon, Jul 31, 2017 at 7:52 PM, Mark Nottingham <notifications@github.com>\nwrote:\n\n> Hmm. I suspect a requirement that's so vague won't get through IESG, but I\n> guess we can try it.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/httpwg/http-extensions/issues/330#issuecomment-319228529>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAP5syDDXgoZVomlOAAPMBOMGirt8jraks5sTmjBgaJpZM4NEzUM>\n> .\n>\n",
          "createdAt": "2017-08-01T14:18:53Z",
          "updatedAt": "2017-08-01T14:18:53Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seems ripe for an RFC6919 MAY WISH TO or SHOULD CONSIDER.",
          "createdAt": "2017-08-01T14:22:35Z",
          "updatedAt": "2017-08-01T14:22:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "/me is very tempted to get a 6919 ref in there",
          "createdAt": "2017-08-01T19:47:25Z",
          "updatedAt": "2017-08-01T19:47:25Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think we're almost there; see latest revision.",
          "createdAt": "2017-08-04T07:15:11Z",
          "updatedAt": "2017-08-04T07:15:11Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On the commits:\r\n\r\n- From discussions, I think the CT and OCSP responses should be an \"and\" not an \"or\".  They both address different threats and both are needed.  CT helps reduce some of the risks around mis-issuance while OCSP allows any mis-issuance to be addressed in a reasonable period of time.  \r\n\r\n- I think for \"Additionally, clients MAY avoid consulting DNS to establish the connection's authority for new requests.\" we may want append \"when employing adequate additional mitigations to security and operational risks.\"\r\n\r\nIs there a precedence or convention for having the \"adequate additional mitigations\" be defined in a future RFC?\r\n\r\nMy general concern continues to be that we're changing the security profile of a complex system in ways that crosses protocol layers.  Even if solving some of those problems requires a much more in-depth risk analysis, people looking to exploit these changes won't be constrained by a \"but that violates layering to specify more!\".\r\n\r\nNote that as discussed above, there is also a class of issues which might require a not-as-yet-defined certificate extension to make some of the people here fully comfortable.  (Which would possibly be in-addition to the OCSP and CT requirements.)\r\n",
          "createdAt": "2017-08-16T21:37:15Z",
          "updatedAt": "2017-08-16T21:37:15Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> From discussions, I think the CT and OCSP responses should be an \"and\" not an \"or\". They both address different threats and both are needed. CT helps reduce some of the risks around mis-issuance while OCSP allows any mis-issuance to be addressed in a reasonable period of time.\r\n\r\nMy sense of the discussion was that we flirted with \"and\" but settled on \"or\". Happy to be corrected there; @mcmanus?\r\n\r\n> I think for \"Additionally, clients MAY avoid consulting DNS to establish the connection's authority for new requests.\" we may want append \"when employing adequate additional mitigations to security and operational risks.\"\r\n\r\nSeems reasonable to me.\r\n\r\n> Is there a precedence or convention for having the \"adequate additional mitigations\" be defined in a future RFC?\r\n\r\nThat's possible, but as noted there's been a historical reluctance to define the exact requirements in RFCs. Remember that Web browsing is just one use of HTTP.\r\n",
          "createdAt": "2017-08-16T21:40:13Z",
          "updatedAt": "2017-08-16T21:40:13Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we also want to change the intro sentence for consistency:\r\n> This specification relaxes the requirement to check DNS when the ORIGIN frame is in use.\r\nto:\r\n> This specification relaxes the requirement to check DNS when the ORIGIN frame is in use in-combination with additional security mitigations.\r\n",
          "createdAt": "2017-08-16T21:40:18Z",
          "updatedAt": "2017-08-16T21:40:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The \"or\" seems appropriate here, given that these are examples only.  We might add new higher requirements for this over time.  For instance, we might require that these sites include Expect-Staple or Expect-CT policies (to match the checks for OCSP or CT), or we might devise new and better schemes for avoiding key theft and require those as well.  That certainly doesn't mean that \"and\" won't be the actual requirement.\r\n\r\nWe have to be careful not to overproscribe client policy here.  Browsers have a lot of resources to throw at these problems, but we could exclude other types of clients from these features by the sheer weight of the set of requirements that come with them.",
          "createdAt": "2017-08-17T01:23:03Z",
          "updatedAt": "2017-08-17T01:23:03Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the direction this is going is to say something along \"Examples of\nmechanisms that can give additional confidence in a certificate are [ct]\n[ocsp]\".. both \"or\" and \"and\" in the current text seem to convey more\npolicy than is meant.\n\nOn Wed, Aug 16, 2017 at 9:23 PM, Martin Thomson <notifications@github.com>\nwrote:\n\n> The \"or\" seems appropriate here, given that these are examples only. We\n> might add new higher requirements for this over time. For instance, we\n> might require that these sites include Expect-Staple or Expect-CT policies\n> (to match the checks for OCSP or CT), or we might devise new and better\n> schemes for avoiding key theft and require those as well. That certainly\n> doesn't mean that \"and\" won't be the actual requirement.\n>\n> We have to be careful not to overproscribe client policy here. Browsers\n> have a lot of resources to throw at these problems, but we could exclude\n> other types of clients from these features by the sheer weight of the set\n> of requirements that come with them.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/httpwg/http-extensions/issues/330#issuecomment-322942923>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAP5s4nA8QgvkAKYllvpWoRRR5QXdM0dks5sY5X3gaJpZM4NEzUM>\n> .\n>\n",
          "createdAt": "2017-08-18T17:47:10Z",
          "updatedAt": "2017-08-18T17:47:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@mcmanus seems reasonable. There will need to be an \"and\" in there because english, but it'll be clear it's not requiring the set (because examples).",
          "createdAt": "2017-08-18T17:52:32Z",
          "updatedAt": "2017-08-18T17:52:32Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good, thanks!\r\n\r\nOne missing thing is that there is no way to limit the Origin Set (which was the original motivation behind this draft) without allowing clients to bypass DNS, leading to the aforementioned operational issues with DNS-based load balancing. This could be easily solved with 1-bit flag, but it's such an edge case, that I'm not sure if it's worth accommodating.",
          "createdAt": "2017-08-26T02:18:46Z",
          "updatedAt": "2017-08-26T02:18:46Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I remember some conversations about that (although I don't *think* it was in a WG session); the conclusion was that it probably wasn't worth the trouble. The biggest use case is sending the empty origin frame (i.e., limiting to SNI), which means that the DNS bypass is a no-op.",
          "createdAt": "2017-08-31T04:47:28Z",
          "updatedAt": "2017-08-31T04:47:28Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing, as we *seem* to have consensus. AIUI we're going to WGLC soon, so please say otherwise if you don't agree.",
          "createdAt": "2017-09-12T00:42:58Z",
          "updatedAt": "2017-09-12T00:42:58Z"
        }
      ]
    },
    {
      "number": 331,
      "id": "MDU6SXNzdWUyMjM1MDQ3MjA=",
      "title": "Origin set definition (and port interaction with Alt-Svc)",
      "url": "https://github.com/httpwg/http-extensions/issues/331",
      "state": "CLOSED",
      "author": "enygren",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "origin-frame"
      ],
      "body": "Some potential (editorial?) issues with the Origin Set definition (Section 2.3):\r\n\r\n* For Host we may wish to use a better term than \"the value sent in Server Name Indication\".  In particular, this could cause problems in the future for any SNI-masking work.  This also has potentially weird interactions with DANE as it specifies that the SNI should be the terminal CNAME or SRV record target.\r\n\r\n* For Port, there is a weird interaction with Alt-Svc.  In particular, the server's port may be different than the port of Origin.  For example, an Alt-Svc for https://www.example.com to alt.example.com:8443 still has the origin of https://www.example.com:443 but given the current wording would have the incorrect initial origins set of https://www.example.com:8443\r\n\r\nWould it be better to have the implicit initial Origin Set from a client's perspective (when an ORIGIN frame is first received) be \"the origin (as per [RFC6454]) that resulted in the successful establishment of the connection\" ?   \r\n\r\nThis is ambiguous from the servers' perspective but perhaps much cleaner and simpler from the client's perspective.\r\n\r\nAnother ambiguity: if a 421 is received for the last origin in the Origin Set, does it become empty or return to uninitialized?  (Should we clarify the former, and that clients may wish to soon close out the connection if no new origin additions are received soon?)\r\n",
      "createdAt": "2017-04-21T21:42:32Z",
      "updatedAt": "2017-07-31T06:43:45Z",
      "closedAt": "2017-07-31T06:43:45Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thinking about Host more, leaving it as the SNI value may make the most sense, especially as some load balancers may be using the SNI to route to the proper backend server or connection handling context.  (Although this is still \"the origin (as per [RFC6454]) that resulted in the successful establishment of the connection\".)\r\n\r\nThis is also an area where #214 could still use some clarifications.  For example, take the case of:\r\n\r\n* origin1 returns \"Alt-Svc: h2=origin2:443\"\r\n* origin1 and origin2 are both covered by the cert at the IP address of origin2\r\n* The server at origin2 receives a connection with SNI=origin1 so the default Origin Set would be \"origin1\"\r\n* If a client intended to coalesce requests directly to origin2 onto the connection with SNI=origin1, these (origin2) would not be covered by the default Origin Set.\r\n\r\nIt's not clear that the text from #214 is enough to clarify this case.\r\n\r\nThat also still leaves the Port issue as a little odd with the Alt-Svc interactions in the current text.",
          "createdAt": "2017-04-22T13:42:34Z",
          "updatedAt": "2017-04-22T13:42:34Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'm starting to think it might be best to have the initial origin set be empty, so that all origins added need to be explicit; making the first member \"what I think you think it is\" is needlessly ambiguous.\r\n\r\nThe only downside AFAICT is that the common use case \"limit it just to the initial origin\" now can't be served by sending an empty set; it needs to be explicitly sent.\r\n\r\n@mcmanus thoughts?",
          "createdAt": "2017-04-26T04:21:22Z",
          "updatedAt": "2017-04-26T04:21:22Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Sat, Apr 22, 2017 at 9:42 AM, Erik Nygren <notifications@github.com>\nwrote:\n\n> This is also an area where #214\n> <https://github.com/httpwg/http-extensions/issues/214> could still use\n> some clarifications. For example, take the case of:\n>\n>    - origin1 returns \"Alt-Svc: h2=origin2:443\"\n>    - origin1 and origin2 are both covered by the cert at the IP address\n>    of origin2\n>    - The server at origin2 receives a connection with SNI=origin1 so the\n>    default Origin Set would be \"origin1\"\n>    - If a client intended to coalesce requests directly to origin2 onto\n>    the connection with SNI=origin1, these (origin2) would not be covered by\n>    the default Origin Set.\n>\n>\nThis is not confusing to me at all, other than for clarity I would not use\nthe word \"origin2\" in the Alt-Svc response. Alt-Svc never advertises\norigins, just routes (i.e. hostnames) to the transaction's existing origin.\nThe fact that this hostname might be some other origin's default route is\nnot relevant (but it is distracting and confusing!)\n\nSo I would rephrase the example equivalently as\n\n1] origin1 returns \"Alt-Svc: h2=somehost2:443\"\n2]origin1 and origin2 are both covered by the cert at the IP address of\nsomehost\n3]somehost receives a connection with SNI=origin1 so the default origin set\nwould be origin1\n4] If a client intended to coalesce for origin2 onto the connection with\nsni=origin1 from step 3 then these origin2 requests would not be covered by\nthe default origin set.\n\nThat all seems fine and logical to me with the current text. I'm not seeing\nthe problem. (perhaps the problem is with port? Which is harder.)\n",
          "createdAt": "2017-04-26T13:00:16Z",
          "updatedAt": "2017-04-26T13:00:16Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Wed, Apr 26, 2017 at 12:21 AM, Mark Nottingham <notifications@github.com>\nwrote:\n\n> The only downside AFAICT is that the common use case \"limit it just to the\n> initial origin\" now can't be served by sending an empty set; it needs to be\n> explicitly sent.\n\n\nThat is definitely a serious downside - we know from the way servers rolled\nout h2 that this kind of TLS/HTTP separation of concerns actually makes it\nhard on some of them to know what SNI even was, so they may not be able to\nissue that \"limit it to SNI\" very well if they need to enumerate SNI\nexplicitly.\n\nBut I think the much bigger downside is that you would now have a\npsuedo-security property that says a connection can't be used for its\ndefault purpose beyond coalescing - and now ORIGIN is having a much bigger\nimpact than just coalescing rules which I think is its appropriate scope. I\nknow in my codebase that would be a significant problem - the coalescing\nrules are all centralized but not all dispatch is about coalescing.\n\nImagine a case where you're connected to the default host for the origin\nand receive an empty ORIGIN frame (and we change the rule to be default is\nthe null set). There is nothing you can do but 1] wait, 2] callback and\nrace against the ORIGIN Frame, or 3] pretend you didn't read it. All of\nthose are bad. I think if you handshake for SNI you need to accept requests\nfor it and its outside the scope of coalescing to change that.\n",
          "createdAt": "2017-04-26T13:12:08Z",
          "updatedAt": "2017-04-26T13:12:08Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@enygren any further thoughts? \r\n\r\nI see what you're saying about future SNI masking potentially being an issue; not so sure about DANE, since it's effectively dead in the water. Still, it'd be nice not to have a layer violation here. How about something like \r\n\r\n> the hostname that the connection was established for, converted to lower case; typically the value sent in Server Name Indication ([RFC6066] Section 3)\r\n\r\nWRT the port, I don't see a problem; alt-svc does **not** change the origin port.",
          "createdAt": "2017-05-01T00:53:00Z",
          "updatedAt": "2017-05-01T00:53:00Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "This seems to have turned editorial (as Erik originally suggested). \r\n\r\nErik, if you can make specific proposals on what needs to be changed, that would be helpful.",
          "createdAt": "2017-05-11T05:15:55Z",
          "updatedAt": "2017-05-11T05:15:55Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Take a look at #348 for my take on this.",
          "createdAt": "2017-05-23T05:01:09Z",
          "updatedAt": "2017-05-23T05:01:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "That worked out well - thx mt.",
          "createdAt": "2017-07-31T06:43:45Z",
          "updatedAt": "2017-07-31T06:43:45Z"
        }
      ]
    },
    {
      "number": 333,
      "id": "MDU6SXNzdWUyMjQ0Njg2ODI=",
      "title": "internal section references should be dynamic",
      "url": "https://github.com/httpwg/http-extensions/issues/333",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "Right now they use hardwired section numbers (likely from RFC6265); this is going to fail when numbers change.",
      "createdAt": "2017-04-26T13:29:59Z",
      "updatedAt": "2017-05-17T06:51:53Z",
      "closedAt": "2017-05-17T06:51:53Z",
      "comments": []
    },
    {
      "number": 339,
      "id": "MDU6SXNzdWUyMjQ3OTg0MDY=",
      "title": "Potential security issues with ORIGIN frame",
      "url": "https://github.com/httpwg/http-extensions/issues/339",
      "state": "CLOSED",
      "author": "wolfbeast",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial",
        "origin-frame"
      ],
      "body": "When investigating http extensions, I came across the `ORIGIN` frame draft here.\r\n\r\nAlthough I think the goals set out for it are good, there are some inherent issues with adding this extension:\r\n- Service exposure on servers: the `ORIGIN` frame will potentially expose previously unknown services on the same host (e.g. administration interfaces on different ports) that should not be advertised.\r\n- Shared-host exposure: the frame will (by design) expose other domains/hosts served by the same server. For shared hosts, this can cause severe privacy issues by exposing which other domains/hosts are served by the same server.\r\n- Origin IP exposure: unless explicitly filtered out, any reverse-proxied connection can expose the origin server's IP to a connecting client, due to the previous point's type of exposure. \r\ne.g. `example.com` is proxied, `example2.com` is not proxied. Connecting to `example.com` connects to the proxy, exposes `example2.com` also being hosted in the `ORIGIN` frame. Looking up `example2.com` in DNS then exposes the origin IP of `example.com`.",
      "createdAt": "2017-04-27T14:17:01Z",
      "updatedAt": "2017-06-20T00:05:17Z",
      "closedAt": "2017-06-20T00:05:17Z",
      "comments": [
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since the ORIGIN frame can only be used for hosts covered by the TLS certificate, how does this make 1 and 3 worse?  All of these can already be seen in the certificate (at least until certificate pushing is defined).  For the second point, that may be worth calling out in Security Considerations that giving ORIGINs for specific names which are covered by a broader wildcard certificate may expose information about the server to the client (albeit intentionally on the server's behalf).",
          "createdAt": "2017-04-28T01:27:39Z",
          "updatedAt": "2017-04-28T01:27:39Z"
        },
        {
          "author": "wolfbeast",
          "authorAssociation": "NONE",
          "body": "The first is an issue because it exposes port numbers. Stuff you can otherwise only garner from port scanning (which any IDS will easily catch and halt)\r\nThe other points are worse because it provides direct confirmation that the hosts covered are _actively_ running on the same machine. That is crucial information and lead to discovery of information a server operator may not want exposed. Certificates often cover more hosts than are running on servers, but the origin frame will actually confirm which hosts are running on which servers; and as said, can indirectly lead to origin IP discovery (making the server more effectively targetable for DoS attacks, bypassing a CDN, for example)",
          "createdAt": "2017-04-28T02:03:25Z",
          "updatedAt": "2017-04-28T02:03:25Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't get this.  Why would a server advertise something that it doesn't want to advertise?  This is entirely voluntary for servers.",
          "createdAt": "2017-04-28T02:08:09Z",
          "updatedAt": "2017-04-28T02:08:09Z"
        },
        {
          "author": "wolfbeast",
          "authorAssociation": "NONE",
          "body": "Let me ask you this then: does it offer granular control over exactly which hosts are being advertised in this frame on a multi-homed server with a broadly-covering certificate?",
          "createdAt": "2017-04-28T02:12:21Z",
          "updatedAt": "2017-04-28T02:12:21Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "yes - the point of the origin extension is fine grained control of which\norigins you wish to advertise on a per connection basis.\n\nOn Thu, Apr 27, 2017 at 10:12 PM, Moonchild <notifications@github.com>\nwrote:\n\n> Let me ask you this then: does it offer granular control over exactly\n> which hosts are being advertised in this frame on a multi-homed server with\n> a broadly-covering certificate?\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/httpwg/http-extensions/issues/339#issuecomment-297888573>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAP5s3EU3TOta5aYk4v_ERU20t-0t_wcks5r0UsFgaJpZM4NKR4m>\n> .\n>\n",
          "createdAt": "2017-04-28T02:19:19Z",
          "updatedAt": "2017-04-28T02:19:19Z"
        },
        {
          "author": "wolfbeast",
          "authorAssociation": "NONE",
          "body": "Well, considering the following in the document:\r\n\r\n> senders are encouraged to include as many origins as practical within a single ORIGIN frame\r\n\r\nOne would assume that server implementations would use a default set of all active hosts served by the server that are part of the TLS certificate. So as it stands, this fine-grained control will likely not be security-aware unless a server implementation does not make this assumption and requires administrators to specifically indicate which hosts to advertise. The document focuses mainly on client implementations and should be extended to address these concerns for the server side.\r\n\r\nDon't get me wrong, there's nothing _inherently_ wrong with the spec, but as the issue title said, there are certainly _potential_ security issues with this extension, depending on how it is implemented and to what level configuration is possible. That should be given some more attention.",
          "createdAt": "2017-04-28T13:09:44Z",
          "updatedAt": "2017-04-28T13:09:44Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Fri, Apr 28, 2017 at 9:09 AM, Moonchild <notifications@github.com> wrote:\n\n> senders are encouraged to include as many origins as practical within a\n> single ORIGIN frame\n\n\n\nah - that language can be tweaked. It is meant to say \"dear servers: you\nare encouraged to use as few frames as possible to send your origin set\"\n(as opposed to one origin per frame).\n\nit isn't meant to influence which origins you decide to advertise.\n\noverall though I think you're right that its worth a sentence in the\nsecurity considerations to just say pay attention to what you advertise.\n",
          "createdAt": "2017-04-28T13:28:13Z",
          "updatedAt": "2017-04-28T13:28:13Z"
        }
      ]
    },
    {
      "number": 342,
      "id": "MDU6SXNzdWUyMjkyMjQwNDI=",
      "title": "Viewport Height",
      "url": "https://github.com/httpwg/http-extensions/issues/342",
      "state": "CLOSED",
      "author": "JamiesonRoberts",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "With the slow but continual adoption of CSS grid's and allowing of 2 dimensional layouts, as well as the push to eliminate render blocking CSS for initial views, it would be incredibly useful to be able to capture both the width and height of the requesting viewport to handle server side inclusion of the specific styles needed for the initial view. This allows developers to not have to tightly align their markup creation with the style creation and maintain the separation of concerns.",
      "createdAt": "2017-05-17T02:56:58Z",
      "updatedAt": "2017-12-13T01:32:30Z",
      "closedAt": "2017-12-13T01:32:30Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It's probably best to bring this up the mailing list.",
          "createdAt": "2017-12-13T01:32:30Z",
          "updatedAt": "2017-12-13T01:32:30Z"
        }
      ]
    },
    {
      "number": 343,
      "id": "MDU6SXNzdWUyMjkyNTM5MDM=",
      "title": "text about why RFC 3490 is cited is missing",
      "url": "https://github.com/httpwg/http-extensions/issues/343",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "See the annotation in https://greenbytes.de/tech/webdav/rfc6265.html#RFC3490 ",
      "createdAt": "2017-05-17T06:52:52Z",
      "updatedAt": "2017-08-07T11:49:35Z",
      "closedAt": "2017-08-07T11:49:35Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Opened https://github.com/cabo/kramdown-rfc2629/issues/42",
          "createdAt": "2017-05-17T07:54:13Z",
          "updatedAt": "2017-05-17T07:54:13Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Will be addressed in the -02 I'll be uploading shortly, thanks to your patch in https://github.com/httpwg/http-extensions/commit/d5f7cb8c000f7a5c6d3545827883efe1a90eac99.",
          "createdAt": "2017-08-07T11:49:33Z",
          "updatedAt": "2017-08-07T11:49:33Z"
        }
      ]
    },
    {
      "number": 349,
      "id": "MDU6SXNzdWUyMzA1ODg0ODk=",
      "title": "ORIGIN and server authority",
      "url": "https://github.com/httpwg/http-extensions/issues/349",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "origin-frame"
      ],
      "body": "I'm reading the bit that touches on [server authority](http://httpwg.org/http-extensions/origin-frame.html#authority) and it's kinda vague on what the server is authoritative for.\r\n\r\nI see two alternatives: \r\n\r\n1. ORIGIN is an explicit disavowal of authority for any name for which the server would otherwise be authoritative for.\r\n2. ORIGIN doesn't say anything about authority, but instead relies on the definitions in RFC 7230 and 7540.  What it does say is that requests made to (or pushed for) origins that aren't in the Origin Set are somehow invalid.\r\n\r\nI think that the text leans toward option 1, but it could be the latter.",
      "createdAt": "2017-05-23T05:06:25Z",
      "updatedAt": "2017-07-31T04:33:21Z",
      "closedAt": "2017-07-31T04:33:21Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I don't want to get into a situation where a connection's authority changes based upon the ability of the client to understand an optional-to-implement frame; that's why the draft is written how it is (i.e., not directly affecting authority).\r\n\r\nSo, your #2 is closer to the mark. If the client understands and implements ORIGIN, a new set of requirements are applied to it, ones that take certain origins out of consideration for actual use (not authority) for a given connection.\r\n\r\nYes, this could be clarified. It also makes me think we might not want to have ORIGIN apply to server push.",
          "createdAt": "2017-05-23T06:20:06Z",
          "updatedAt": "2017-05-23T06:20:06Z"
        }
      ]
    },
    {
      "number": 350,
      "id": "MDU6SXNzdWUyMzA1ODg2ODk=",
      "title": "Julian's feedback",
      "url": "https://github.com/httpwg/http-extensions/issues/350",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [
        "mcmanus"
      ],
      "labels": [
        "editorial",
        "immutable"
      ],
      "body": "> 2.1.  About Intermediaries\r\n>\r\n>  An immutable response has the same semantic meaning when received by\r\n>  proxy clients as it does when received by User-Agent based clients.\r\n>  Therefore proxies SHOULD skip conditionally revalidating fresh\r\n>  responses containing the immutable extension unless there is a signal\r\n>  from the client that a validation is necessary (e.g. a no-cache\r\n>  Cache-Control request directive).\r\n\r\nMaybe point to Section 5.2.1.4 of RFC 7234 here...\r\n\r\n>  A proxy that uses immutable to bypass a conditional revalidation may\r\n>  choose whether to reply with a 304 or 200 to its requesting client\r\n>  based on the request headers the proxy received.\r\n\r\ns/may/MAY/ or s/may/can/\r\n\r\n> 2.2.  Example\r\n>\r\n>  Cache-Control: max-age=31536000, immutable\r\n\r\nMaybe add a full example, including a request/response pair for the case when \"immutable\" is not present?\r\n\r\n> 4.  IANA Considerations\r\n>\r\n>  [RFC7234] sections 7.1 and 7.1.2 require registration of the\r\n\r\ns/[RFC7234] sections 7.1 and 7.1.2/Section 7.1 of .../",
      "createdAt": "2017-05-23T05:08:07Z",
      "updatedAt": "2017-07-03T19:20:56Z",
      "closedAt": "2017-07-03T19:20:56Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Maybe add a full example, including a request/response pair for the case when \"immutable\" is not present?\r\n\r\nI actually toyed with this originally and decided the current arrangement was better. Drawing the absence of a request (or the case when nothing is different from the 723x state) didn't really clarify the normative text. It turned out better to just focus on the syntax of immutable in a response imo.",
          "createdAt": "2017-07-03T19:08:08Z",
          "updatedAt": "2017-07-03T19:08:08Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "remainder addressed in -03. thanks",
          "createdAt": "2017-07-03T19:20:56Z",
          "updatedAt": "2017-07-03T19:20:56Z"
        }
      ]
    },
    {
      "number": 351,
      "id": "MDU6SXNzdWUyMzA1ODkyNzM=",
      "title": "Immutable references",
      "url": "https://github.com/httpwg/http-extensions/issues/351",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [
        "mcmanus"
      ],
      "labels": [
        "editorial",
        "immutable"
      ],
      "body": "* [ ] Immutable doesn't contain the RFC2119 boilerplate, even though it uses the language. \r\n* [ ] It also has a dangling reference to RFC7231.",
      "createdAt": "2017-05-23T05:13:52Z",
      "updatedAt": "2017-07-03T19:21:11Z",
      "closedAt": "2017-07-03T19:21:11Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "addressed in -03. thanks",
          "createdAt": "2017-07-03T19:21:11Z",
          "updatedAt": "2017-07-03T19:21:11Z"
        }
      ]
    },
    {
      "number": 355,
      "id": "MDU6SXNzdWUyMzIxNTc5NTY=",
      "title": "ORIGIN and Server Push",
      "url": "https://github.com/httpwg/http-extensions/issues/355",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "origin-frame"
      ],
      "body": "#349 made me realise that, from the server's perspective, they don't have hard information about whether the client supports ORIGIN at the time they send the ORIGIN frame. \r\n\r\nWhile they might gather this based upon the requests that the client subsequently sends, this isn't information you'd want to rely upon.\r\n\r\nThis is especially relevant to Server Push. Right now, ORIGIN is defined to affect what the client is able to push, but (as above), the server doesn't have a firm idea about the origins that are actually valid to use on the connection at any given time. \r\n\r\nA number of potential solutions:\r\n\r\n1. The server just speculatively pushes and figures it out based upon the responses (i.e. no change)\r\n2. We create an explicit signal from the client to the server (e.g., \"I will process ORIGIN\", probably a SETTING, or \"I have processed ORIGIN\", probably a frame)\r\n3. ORIGIN doesn't constrain Server Push\r\n\r\nNote that 1 is not optimal (wasted bytes), and 3 might collide badly with future uses of ORIGIN.",
      "createdAt": "2017-05-30T06:52:04Z",
      "updatedAt": "2017-07-31T04:07:34Z",
      "closedAt": "2017-07-31T04:07:34Z",
      "comments": [
        {
          "author": "icing",
          "authorAssociation": "NONE",
          "body": "_what the_ server _is able to push_, you mean?\r\n\r\nHmm, I would expect a server that sends out ORIGIN to have a positive idea what it is willing to serve on the connection. If it has no clear idea, it should probably refrain from ORIGIN?\r\n\r\nIf I understood correctly, the question boils down to: \"Can the server, having send out ORIGIN, still PUSH resources from domains that are not in ORIGIN?\"\r\n\r\nAnd my answer would be no. I would like to use ORIGIN to hint to the client that on any other domain, it can expect a 421 as answer. The reason for that lies in separate TLS options for hosts that share a certificate. If those differ, the server should not server _or push_ resources from the other domain. It could require a client cert, or only stronger ciphers.\r\n",
          "createdAt": "2017-05-30T07:27:05Z",
          "updatedAt": "2017-05-30T07:27:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@icing - the server doesn't know whether the client implements ORIGIN. It may have different PUSH strategies based upon ORIGIN support.",
          "createdAt": "2017-05-30T07:41:37Z",
          "updatedAt": "2017-05-30T07:41:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "(It may be a corner case now, but if we open up the origin set a la CERTIFICATE, we'll hit this. That might be an argument for approach 1 - i.e., \"we'll deal with it then.\").",
          "createdAt": "2017-05-30T07:43:25Z",
          "updatedAt": "2017-05-30T07:43:25Z"
        },
        {
          "author": "icing",
          "authorAssociation": "NONE",
          "body": "It could, yes. But is that sane? Can ORIGIN require that the server answers requests outside of those domain the same way, no matter if the client understands it or not?",
          "createdAt": "2017-05-30T07:43:44Z",
          "updatedAt": "2017-05-30T07:43:44Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "even in the absence of ORIGIN, the server does not know the client's effective origin set unless it is completely ignoring 7540 coalescing.. as mike bishop says we don't standardize pki decisions. istm its just a particular instance of a general push problem.",
          "createdAt": "2017-05-31T00:38:02Z",
          "updatedAt": "2017-05-31T00:38:02Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot \r\n> (It may be a corner case now, but if we open up the origin set a la CERTIFICATE, we'll hit this. That might be an argument for approach 1 - i.e., \"we'll deal with it then.\").\r\n\r\nMy +1 goes to this.\r\n\r\nWhen servers start sending secondary certificates to expand the authority (than that allowed by the names stored in the certificate sent during the TLS handshake), we would inevitably requiring the client to send a signal indicating if it accepted the certificate, which can be used as a signal.\r\n\r\nUntil then, I think that there is no need for an indication.\r\n\r\nIn fact, I think that it might be a good idea to clarify that the ORIGIN frame only changes what a _client_ is expected to request, and that it does not change what a server is allowed to push.",
          "createdAt": "2017-05-31T02:06:32Z",
          "updatedAt": "2017-05-31T02:06:32Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "in the end, there are always going to be two different evaluations of the can-i-push rule and its going to be done on a per origin basis - once on the server and once on the client. This is just a generalization of the existing situation (and yet another example of the complexity of push). That's true of 7540 coalescing (e.g. client has a key pin rule that prohibits the coalescing the server doesn't know about), origin, and certificate.\r\n\r\nI really think the RST_STREAM mechanism is sufficient - perhaps with a new error code made available for it.\r\n\r\nThis is an argument for 1.",
          "createdAt": "2017-05-31T12:40:03Z",
          "updatedAt": "2017-05-31T12:40:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Sounds like there's agreement on #1; closing with no action.",
          "createdAt": "2017-07-31T04:07:34Z",
          "updatedAt": "2017-07-31T04:07:34Z"
        }
      ]
    },
    {
      "number": 356,
      "id": "MDU6SXNzdWUyMzIzMjc4Njg=",
      "title": "Form-encode Expect-CT report bodies?",
      "url": "https://github.com/httpwg/http-extensions/issues/356",
      "state": "CLOSED",
      "author": "estark37",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "expect-ct"
      ],
      "body": "Background for this issue is in https://github.com/bifurcation/expect-ct/issues/18, where it is argued that Expect-CT reports should have a special Content-Type, like Content Security Policy reports, but it is also argued that they should be sent with CORS preflights when Expect-CT is implemented by a web browser, since they are not a whitelisted safe request.\r\n\r\nUnfortunately, implementing preflights for Expect-CT reports probably can't be done in Chrome in any reasonable amount of time, and would probably be difficult for other implementors as well. Expect-CT is checked at connection setup time, completely divorced from any context from which we can construct an `Origin` header.\r\n\r\nTherefore I think we need to resort to using `application/x-www-form-urlencoded` for reports, if we want Expect-CT to be reasonably implementable in a web browser without violating the SOP.\r\n\r\n@scotthelme @mikewest @eranmes",
      "createdAt": "2017-05-30T17:38:57Z",
      "updatedAt": "2018-05-19T15:59:52Z",
      "closedAt": "2018-05-19T15:59:52Z",
      "comments": [
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@sleevi do you think this is the right way forward given the time pressures on Expect-CT?",
          "createdAt": "2017-05-30T17:46:38Z",
          "updatedAt": "2017-05-30T17:46:38Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@estark37 It's above my paygrade. I'm not sure these requests should abide by CORS, especially if we think of \"Expect-CT\" as part of an input to the PKI validation blackbox, but if it helps adoption, then such is the life of standards and compromises.",
          "createdAt": "2017-05-30T18:12:03Z",
          "updatedAt": "2017-05-30T18:12:03Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Use an HTTP method other than POST?",
          "createdAt": "2017-06-06T16:58:34Z",
          "updatedAt": "2017-06-06T16:58:34Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke that doesn't resolve the issue; preflight requests are required as long as there is a non-whitelisted `Content-Type` header of application/json.",
          "createdAt": "2017-06-06T17:42:41Z",
          "updatedAt": "2017-06-06T17:42:41Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That would be a bug in CORS. No preflight is needed if the HTTP method by definition can not ve generated by an HTML form.",
          "createdAt": "2017-06-06T17:50:54Z",
          "updatedAt": "2017-06-06T17:50:54Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's not a bug in CORS, it's exactly the point of CORS -- to prevent requests that cannot be generated by legacy web content (for example, via an `img` tag or an HTML form submission) unless the server opts in.",
          "createdAt": "2017-06-06T18:10:51Z",
          "updatedAt": "2017-06-06T18:10:51Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes.\r\n\r\nBut form content and links can only generate GET, HEAD and POST requests.\r\n\r\nI was suggesting to use a different method than these.",
          "createdAt": "2017-06-06T18:15:35Z",
          "updatedAt": "2017-06-06T18:15:35Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "But CORS also disallows non-GET/HEAD/POST methods without a preflight, and that's not a bug; it's because servers might rely on web content not being able to generate those methods and would be vulnerable if web content could send such requests.",
          "createdAt": "2017-06-06T18:27:14Z",
          "updatedAt": "2017-06-06T18:27:14Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, indeed. I was temporarily confused.",
          "createdAt": "2017-06-06T18:30:49Z",
          "updatedAt": "2017-06-06T18:30:49Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After further discussion on the list (https://lists.w3.org/Archives/Public/ietf-http-wg//2017AprJun/0168.html), I suppose we should leave things as they are: leave it up to the UA to decide if and how to send preflights, with the report-collection server advised to expect preflights from some clients (\"The UA MAY perform other operations as part of sending the HTTP POST request, for example sending a CORS preflight as part of [FETCH]\").\r\n\r\nWhile it isn't feasible to implement true preflights in a network stack like Chrome's, we could feasibly implement null-origin preflights for Expect-CT reports.",
          "createdAt": "2017-06-19T23:44:51Z",
          "updatedAt": "2017-06-19T23:44:51Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Moving discussion over to Fetch (https://github.com/whatwg/fetch/issues/567), will circle back here if it turns out there's something we should do in Expect-CT specifically. cc @martinthomson ",
          "createdAt": "2017-07-19T12:52:56Z",
          "updatedAt": "2017-07-19T12:52:56Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@estark37, I don't want to create a false impression that there is no issue remaining.  Is your intent to track the issue we discussed in some other way?\r\n\r\nAs we discussed, I think that the requesting origin for the request is the origin of the response that contained the Expect-CT header field.",
          "createdAt": "2017-07-19T14:02:18Z",
          "updatedAt": "2017-07-19T14:02:18Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson I thought your suggestion was to discuss with Fetch how to handle these requests?\r\n\r\nI'm fine with using the Expect-CT origin as the Origin for the preflight, but I'm still not sure that the Expect-CT spec is the right place to say that, as it doesn't make sense for non-browser clients. (I think it belongs better in Fetch.)",
          "createdAt": "2017-07-19T14:18:52Z",
          "updatedAt": "2017-07-19T14:18:52Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, that sounds good.  My suggestion is to keep this open until we have greater clarity about how this is captured, even if that means closing this with no action because Fetch is covering it.",
          "createdAt": "2017-07-19T14:32:32Z",
          "updatedAt": "2017-07-19T14:32:32Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is covered as an exception in Fetch now: https://fetch.spec.whatwg.org/#cors-protocol-exceptions",
          "createdAt": "2018-05-19T15:59:52Z",
          "updatedAt": "2018-05-19T15:59:52Z"
        }
      ]
    },
    {
      "number": 358,
      "id": "MDU6SXNzdWUyMzcwNDgzNzQ=",
      "title": "Allow both v1 and v2 SCTs to be included in Expect-CT reports",
      "url": "https://github.com/httpwg/http-extensions/issues/358",
      "state": "CLOSED",
      "author": "estark37",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "estark37"
      ],
      "labels": [
        "expect-ct"
      ],
      "body": "To support both 6962 and 6962-bis clients, we should allow Expect-CT reports to contain both v1 and v2 SCTs. One way to do that is include SCTs as a JSON object:\r\n```\r\nversion: 1 / 2,\r\nserialized_sct: <base64-encoded serialized SignedCertificateTimestamp from 6962> / <base64-encoded serialized TransItem struct from 6962-bis>\r\n```",
      "createdAt": "2017-06-19T23:06:35Z",
      "updatedAt": "2018-05-19T16:00:31Z",
      "closedAt": "2018-05-19T16:00:31Z",
      "comments": []
    },
    {
      "number": 359,
      "id": "MDU6SXNzdWUyMzcwNTg0NzA=",
      "title": "Julian's CH feedback",
      "url": "https://github.com/httpwg/http-extensions/issues/359",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [
        "igrigorik"
      ],
      "labels": [
        "client-hints",
        "editorial"
      ],
      "body": "http://www.w3.org/mid/624e3e87-43bc-0dc2-d38c-2d69cbb9e93b@gmx.de\r\n\r\nMost of this is editorial, so you can dispose of it as you see fit (although some of it is likely to come back up in IETF LC if not addressed. The exceptions are **bold**; I think we need to give some sort of response to those.\r\n\r\n* [x] Througout: avoid lowercase BCP14 keywords (may->can, should->ought to, ...), or actually invoke the new boilerplate defined in draft-leiba-rfc2119-update.\r\n* [x] s/headers/header fields/\r\n* [x] **It's not optimal to mention a draft that for now is work in progress so close to a \"MUST\", even with \"optionally\" sprinkled in. My recommendation continues to move all material that refers to the Key header field to an appendix.**\r\n* [x] s/defines/defines the/\r\n* [x] We should define \"origin\" somewhere (and also explain \"subresource\").\r\n* [x] Througout: uppercase \"header field\" in section titles.\r\n* [x] Isn't that evident because sending the hints is purely OPTIONAL anyway?\r\n* [x] **Why aren't we using HTTP list syntax here? Also, what does it mean when the field appears more than once?**\r\n* [x] I would rename this to \"CSSVAL\" (or something like that) for readability.\r\n* [x] I would rename this to \"HTML5\" (or something like that) for readability. \r\n* [x] I would rename this to \"KEY\" (or something like that) for readability. \r\n* [x] Finally: no Acknowledgements?",
      "createdAt": "2017-06-20T00:16:57Z",
      "updatedAt": "2017-07-21T15:05:20Z",
      "closedAt": "2017-07-21T15:05:20Z",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> I would rename this to \"CSSVAL\" (or something like that) for readability.\r\n>  I would rename this to \"HTML5\" (or something like that) for readability.\r\n>  I would rename this to \"KEY\" (or something like that) for readability.\r\n\r\nI'm inclined to keep them as is. The CSS spec is CSS2, not CSS values specific, and other names are auto generated -- don't think it's worth overwriting.\r\n\r\n>> If the desired resource width is not known at the time of the request\r\n>> or the resource does not have a display width, the Width header field\r\n>> can be omitted. ...\r\n>\r\n> Isn't that evident because sending the hints is purely OPTIONAL anyway?\r\n\r\nYes, you could make that case, but it's there to highlight a non-obvious implementation edge case that most will not consider until much later in implementation.. I think it's worth keeping as is.\r\n\r\n>> Save-Data = sd-token *( OWS \";\" OWS [sd-token] )\r\n>>      sd-token = token\r\n>\r\n> Why aren't we using HTTP list syntax here? Also, what does it mean when \r\n> the field appears more than once?\r\n\r\nThis is a repeat of discussion in https://lists.w3.org/Archives/Public/ietf-http-wg/2016OctDec/0688.html + https://lists.w3.org/Archives/Public/ietf-http-wg/2016OctDec/0678.html. I've added a callout for repeat fields.\r\n\r\n---\r\n\r\nOpened https://github.com/httpwg/http-extensions/pull/361. I believe it should address all of the above -- ptal.",
          "createdAt": "2017-06-26T20:57:55Z",
          "updatedAt": "2017-06-26T20:57:55Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm inclined to keep them as is. The CSS spec is CSS2, not CSS values specific, and other names are auto generated -- don't think it's worth overwriting.\r\n\r\nI think it's worthwhile to override names when those are clearly ugly because they're auto-generated (for instance, because they include a date that the reader will not care about at all). Also, FWIW, the reference is for  W3C.CR-css-values-3-20160929 which is *not* the generic CSS spec, right)? Will provide a PR.\r\n",
          "createdAt": "2017-07-16T15:16:09Z",
          "updatedAt": "2017-07-16T16:13:37Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Resolved via https://github.com/httpwg/http-extensions/pull/361.",
          "createdAt": "2017-07-21T15:05:20Z",
          "updatedAt": "2017-07-21T15:05:20Z"
        }
      ]
    },
    {
      "number": 360,
      "id": "MDU6SXNzdWUyMzcwNTg2NzA=",
      "title": "Header relationships, cardinality",
      "url": "https://github.com/httpwg/http-extensions/issues/360",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [
        "igrigorik"
      ],
      "labels": [
        "client-hints"
      ],
      "body": "From thread at <http://www.w3.org/mid/20170419164106.EFBCF24249@welho-filter4.welho.com>:\r\n\r\n> Is it assumed that \"Accept-CH\" is given in http-equiv attribute, but \"Accept-CH-Lifetime\" on http response ?\r\n\r\nYes. \r\n\r\n> Or is that needed so that \"Accept-CH\" can be given on several times?\r\n\r\nNo, that's implicit in its definition as a comma separated list of values. Correct me if I'm wrong, but my understanding is that default semantics allow multiple headers with same field-name, as long as the field-value is defined as a comma separated list.. Meaning, there can be multiple Accept-CH header fields and they can be combined into a single list.\r\n \r\n> What happens if there is several \"Accept-CH-Lifetime\" on response?\r\n\r\nFor Accept-CH-Lifetime, I guess we just need to specify which one wins, correct? Any defaults I can point to or reuse? Last one wins?\r\n",
      "createdAt": "2017-06-20T00:18:33Z",
      "updatedAt": "2017-07-21T15:05:29Z",
      "closedAt": "2017-07-21T15:05:29Z",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "I believe https://github.com/httpwg/http-extensions/pull/361 should address this, ptal.",
          "createdAt": "2017-06-26T21:02:20Z",
          "updatedAt": "2017-06-26T21:02:20Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Resolved via https://github.com/httpwg/http-extensions/pull/361.",
          "createdAt": "2017-07-21T15:05:29Z",
          "updatedAt": "2017-07-21T15:05:29Z"
        }
      ]
    },
    {
      "number": 364,
      "id": "MDU6SXNzdWUyMzk0NzQxMjE=",
      "title": "Geolocation Header",
      "url": "https://github.com/httpwg/http-extensions/issues/364",
      "state": "CLOSED",
      "author": "luisbargu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello,\r\n\r\nMy name is Luis. I'd like to discuss with you a proposal to solve the following use case:\r\n\r\nCurrently, the only mechanism to share your location with a website is through the JS Geolocation API. This has some limitations: First, in order to have the server know the client\u2019s location there are two full roundtrips required (one roundtrip to load the page with Javascript code, and a second roundtrip to actually send the location to the server and get back a location-aware response). While not as significant as the first limitation, the second limitation is that the client must execute Javascript in order to acquire location.\r\n\r\nFor example, for services like Search, it means that the very first response from a server will contain non-localized results, and a second roundtrip would be required to refresh those results (assuming Geolocation permission is already granted for the origin).\r\n\r\nThere's many ways to solve this problem through headers, so no JS would be required and clients could proactively include geolocation data in the very first request (after the server asked for it in previous sessions, and permissions are granted).\r\n\r\n[Here you can find a document detailing the problem and a possible proposal](https://docs.google.com/document/d/1zL4qyOpp6W36H4_eMpmth3Yj_ZTMZ3wCupc01q5qatA/edit)\r\n\r\nAfter discussing with @igrigorik he suggested that Client Hints might be a potential way to implement this too, which makes perfect sense. However, some features in the original proposal would not be possible with current CH draft (parameters for CH-Accept or path restrictions for when the data should be included).\r\n\r\nIt would be great to get your opinion on this and whether this is something that might be interesting for people in this working group.\r\n\r\nThanks!\r\nLuis.",
      "createdAt": "2017-06-29T13:13:08Z",
      "updatedAt": "2017-07-21T14:54:07Z",
      "closedAt": "2017-06-30T02:07:25Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hi Luis,\r\n\r\nWelcome. The best way to make a proposal for new work to the WG is to send e-mail; we generally use this repo to talk about things we've already decided to do.\r\n\r\nClient Hints is already very advanced in the process, so we're not likely to add it to that spec. However, it doesn't have to be in that document to be considered a \"client hint\" (which is really just a use of content negotiation). \r\n\r\nI'd encourage you to bring this up on the WG mailing list:\r\n  https://lists.w3.org/Archives/Public/ietf-http-wg/\r\n(you can just paste the text above into an e-mail)\r\n\r\nBe aware that, because it's Geolocation, there's going to be extra scrutiny from a privacy/security perspective. Also, one of the primary things we look at when deciding to adopt something is whether it's likely to get implemented. \r\n\r\nCheers,\r\n",
          "createdAt": "2017-06-30T02:07:25Z",
          "updatedAt": "2017-06-30T02:07:25Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@mnot I suggested to @luisbargu that we should start a thread here first to hash out a few high-level questions about the existing proposal and possible CH integration, before we take it to the wider list. I'll re-open this, but if you feel that this belongs on the list, we can take it there.\r\n\r\n---\r\n\r\nFirst off, I think CH is a great conceptual fit to what @luisbargu is proposing, and I'd _really_ love to see us reusing established CH mechanism to ease implementation, both on the UA/client side and for developers \u2014 this makes everyone's life easier. I'll leave the \"what\" discussion, like granularity and type of data delivered via this hint, for a separate discussion, and focus on the how here...\r\n\r\n>Header sent from the server to the user agent when a host is compatible with the Geolocation\r\n> Header and is requesting geolocation to be attached in subsequent requests.\r\n>\r\n>>Geolocation-Request: Path=\"/localService\"; Type=IfAlreadyGranted; Expires=Thu, 18 Dec 2017 12:00:00 UTC\r\n\r\nThe CH mechanism for the above is:\r\n\r\n> Accept-CH: Geolocation\r\n> Accept-CH-Lifetime: 86400 (seconds)\r\n\r\nThere are two bits missing: Path and Type. \r\n\r\n### Path\r\nThis is something we considered for CH in the past \u2014 \"I want to scope my hints to a subpath\" \u2014 but punted on due to limited (or so we deemed at the time, at least) utility vs implementation complexity tradeoff (equivalent to cookie paths, which is a burden we didn't want to take on). In the last few years of CH experiments, I've not heard any complaints or requests for this. I think that was the right call, and I'd suggest we stick with it.\r\n\r\n### Type\r\nfwiw, I'd like to make an argument that we should omit this. The idea here is to enable sites to trigger a permission prompt via a header, which seems convenient on the surface, but experience shows that this is a bad UX pattern: you [should be using JS API to trigger permission prompt after explaining the intent](https://docs.google.com/document/d/1WNPIS_2F0eyDm5SS2E6LZ_75tk6XtBSnR1xNjWJ_DPE/edit) and motivation. The incremental value we're adding with the header trigger is low, and seems more like a footgun. \r\n\r\nIf you buy both of the above, then CH has all the necessary building blocks to enable Geolocation. \r\n\r\n---\r\n\r\n@luisbargu WDYT? How critical, or not, are Path and Type for the use case you had in mind?\r\n\r\n@yoavweiss curious to hear your thoughts on the above, and Geolocation use case for CDNs.\r\n\r\n@mnot tactical question: what's the right process for followup RFC's to \"register\" hints to be compatible with Accept-CH? Do we need any extra steps in CH for a registry, or some extension hooks?",
          "createdAt": "2017-07-02T22:41:52Z",
          "updatedAt": "2017-07-02T22:41:52Z"
        },
        {
          "author": "luisbargu",
          "authorAssociation": "NONE",
          "body": "I still feel path can be useful, mainly to not \"over-send\" data that in this case might be sensitive from a privacy point of view. But I also understand the complexity tradeoffs, and Path is not core to this proposal. So if you went through this for CH and considered path was not worth, it probably applies well to this case.\r\n\r\nRegarding Type to trigger prompts... Right, it's doable through JS but was nice to offer a purely http based solution. Also understand the tradeoff in this case for value vs complexity, and agree it's also not core to the geolocation header.\r\n\r\nSo on my side, if others think CH is the right approach for this, then for consistency and simplicity I'd be happy to follow that path and start a draft, on top of CH. Happy to hear other opinions :)",
          "createdAt": "2017-07-04T19:32:25Z",
          "updatedAt": "2017-07-04T19:32:25Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One major difference between this and the other CH headers is that this header should only be sent to the first party (or only to hosts which have permission to view geolocation data, so to third parties that got such permissions before).\r\nThe use case of using geo info for content adaptation at the edge or origin seems an interesting one.",
          "createdAt": "2017-07-13T15:00:21Z",
          "updatedAt": "2017-07-13T15:00:21Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> One major difference between this and the other CH headers is that this header should only be sent to the first party (or only to hosts which have permission to view geolocation data, so to third parties that got such permissions before).\r\n\r\nSee https://github.com/httpwg/http-extensions/issues/372 for discussions related to that. I think this example is highlighting the need for origin-scoped hints, which I think we can do with ACH.\r\n\r\n> So on my side, if others think CH is the right approach for this, then for consistency and simplicity I'd be happy to follow that path and start a draft, on top of CH. Happy to hear other opinions :)\r\n\r\nI think CH is the right fit. For a hot-off-the-press example, take a look at the [Device Memory i2s on blink-dev](https://groups.google.com/a/chromium.org/forum/#!msg/blink-dev/8qlTjzRY9Mc/BYCuqWJXBwAJ).. Assuming we can drop the prompt trigger and path requirements, you can just follow that template.\r\n\r\n",
          "createdAt": "2017-07-21T14:54:07Z",
          "updatedAt": "2017-07-21T14:54:07Z"
        }
      ]
    },
    {
      "number": 365,
      "id": "MDU6SXNzdWUyNDA4MDE2MDM=",
      "title": "No multiple headers with the same name",
      "url": "https://github.com/httpwg/http-extensions/issues/365",
      "state": "CLOSED",
      "author": "vasilakisfil",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "early-hints"
      ],
      "body": "I just noticed that you have 2 `Link` headers in the same response. According to 7230:\r\n\r\n>  A sender MUST NOT generate multiple header fields with the same field\r\n>   name in a message unless either the entire field value for that\r\n>  header field is defined as a comma-separated list [i.e., #(values)]\r\n>   or the header field is a well-known exception (as noted below).",
      "createdAt": "2017-07-05T23:14:14Z",
      "updatedAt": "2017-07-05T23:18:53Z",
      "closedAt": "2017-07-05T23:16:48Z",
      "comments": [
        {
          "author": "vasilakisfil",
          "authorAssociation": "NONE",
          "body": "This is for Early Hints draft, not sure how I can put labels.",
          "createdAt": "2017-07-05T23:14:56Z",
          "updatedAt": "2017-07-05T23:14:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes, but `Link` is defined by RFC5988 as:\r\n\r\n```\r\n  Link           = \"Link\" \":\" #link-value\r\n```\r\n\r\ni.e., it uses the comma-separated list syntax.",
          "createdAt": "2017-07-05T23:16:45Z",
          "updatedAt": "2017-07-05T23:16:45Z"
        },
        {
          "author": "vasilakisfil",
          "authorAssociation": "NONE",
          "body": "right.",
          "createdAt": "2017-07-05T23:18:53Z",
          "updatedAt": "2017-07-05T23:18:53Z"
        }
      ]
    },
    {
      "number": 368,
      "id": "MDU6SXNzdWUyNDM2OTg2MTM=",
      "title": "Repetition of Fields",
      "url": "https://github.com/httpwg/http-extensions/issues/368",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "origin-frame"
      ],
      "body": "From Lucas:\r\n\r\nI naively assumed the ORIGIN frame was very similar to the ALTSVC frame, I missed out on the repetition element. I think it would help to improve upon diagram in section 2.1, first coin a term for the Origin-Len:ASCII-Origin pair (it is loosely referred to as set, which is easily confused with Origin Set), for this email I\u2019ll use the term Origin-Entry. Section 2.1 would be changed to contain two clearly labelled diagrams: one shall show the fields comprising an Origin-Entry, the other shall show the ORIGIN frame payload as an OPTIONAL sequence of Origin-Entries, with cardinality of 0-*. 0 indicates an empty ORIGIN frame, which is implied by the text in Appendix B - \u201cinform the client that the connection is only to be used for the SNI-based origin, by sending an empty ORIGIN frame.\u201d.",
      "createdAt": "2017-07-18T12:27:27Z",
      "updatedAt": "2017-07-31T04:10:57Z",
      "closedAt": "2017-07-31T04:10:57Z",
      "comments": []
    },
    {
      "number": 369,
      "id": "MDU6SXNzdWUyNDM2OTg4MjM=",
      "title": "Expectations of Origin Set Size",
      "url": "https://github.com/httpwg/http-extensions/issues/369",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "origin-frame"
      ],
      "body": "From Lucas:\r\n\r\nIf my interpretation of the specification is correct, the Origin Set is currently unbounded. While the size of an individual H2 frame is bounded and negotiated, the Origin set can seemingly be added to ad nauseam. Even in the default size case, for a short ASCII-Origin such as http://dk, if might be possible to create an Origin set with ~1500 entries. I like the fact that ORIGIN frame extension doesn\u2019t need any negotiation, so perhaps some guidance for client-side implementations would help e.g. be aware of the Origin Set size and be prepared to close the connection if you\u2019re getting unhappy.",
      "createdAt": "2017-07-18T12:28:20Z",
      "updatedAt": "2017-07-31T04:36:03Z",
      "closedAt": "2017-07-31T04:36:03Z",
      "comments": []
    },
    {
      "number": 370,
      "id": "MDU6SXNzdWUyNDM2OTg5NTY=",
      "title": "Non-normative processing algorithm",
      "url": "https://github.com/httpwg/http-extensions/issues/370",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "origin-frame"
      ],
      "body": "From Lucas:\r\n\r\nIs this reflective of current ORIGIN frame fields? The terminology seems slightly askew as each Origin is comprised of two fields and I\u2019m wondering if it got outdated. Using the term Origin-Entry could help here.",
      "createdAt": "2017-07-18T12:28:52Z",
      "updatedAt": "2017-07-31T04:13:17Z",
      "closedAt": "2017-07-31T04:13:17Z",
      "comments": []
    },
    {
      "number": 371,
      "id": "MDU6SXNzdWUyNDM4Mjc1ODI=",
      "title": "multiple 103s are cumulating or overwriting headers?",
      "url": "https://github.com/httpwg/http-extensions/issues/371",
      "state": "CLOSED",
      "author": "ddragana",
      "authorAssociation": "NONE",
      "assignees": [
        "kazuho"
      ],
      "labels": [
        "early-hints",
        "editorial"
      ],
      "body": "In section 2.  \"103 Early Hints\" the last paragraph describes that 103 can be send multiple time. The given example reads as if a server may correct its previous 103 that is made from a cached resource. So the following 103 are correcting the older ones, they are only adding headers to the previous ones or are they replacing them completely? Maybe sentence clarifying this would be good.",
      "createdAt": "2017-07-18T19:36:39Z",
      "updatedAt": "2017-08-11T04:00:33Z",
      "closedAt": "2017-08-11T04:00:33Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is an interesting question. I think that we should agree on what the expected behavior is before discussing how (or if) we should update the text.\r\n\r\nRegarding the question, I think that we should consider two (or more) Early Hints responses as expectations from different sources, rather than considering the following one to update the earlier ones. \r\n\r\nThe reason I think so is because nonexistence of a header field in the 103 response does not imply that the header field will not exist in the final response, since we are not required to include in 103 response all the headers that are expected to be included in the final response.\r\n\r\nSo consider the following example: a caching intermediary might generate an Early Hints response from a stale-cached response. That Early Hints response could contain a header field that will never be included within an Early Hints response sent from the origin. In such case, considering both of the Early Hints responses as genuine makes the most sense.\r\n\r\n",
          "createdAt": "2017-08-04T05:00:48Z",
          "updatedAt": "2017-08-04T05:00:48Z"
        }
      ]
    },
    {
      "number": 372,
      "id": "MDU6SXNzdWUyNDQwODcxNDY=",
      "title": "Accept-CH-Lifetime privacy concerns",
      "url": "https://github.com/httpwg/http-extensions/issues/372",
      "state": "CLOSED",
      "author": "arturjanc",
      "authorAssociation": "NONE",
      "assignees": [
        "igrigorik"
      ],
      "labels": [
        "client-hints"
      ],
      "body": "Based on https://groups.google.com/a/chromium.org/forum/#!msg/blink-dev/QHI3sio6--Q/v_zWX1O6AAAJ I have a couple of questions about the impact of `Accept-CH-Lifetime` as currently defined in https://tools.ietf.org/html/draft-ietf-httpbis-client-hints-04#section-2.2.2\r\n\r\nThe main risk, touched upon in the [Security Considerations](https://tools.ietf.org/html/draft-ietf-httpbis-client-hints-04#section-5) section, is the fact that providers of cross-origin subresources (e.g. images) loaded from pages with `Accept-CH` headers will start receiving fingerprinting-prone information about the configuration of a connecting client. Note that it will expose more information than what was available to these parties in the past because subresources such as images cannot use client-side logic to access information sent in Client Hints. A related issue is that based on the sets of headers sent in such subresource requests, the subresource owner might be able to identify the referring site even if it sets a Referrer Policy to prevent disclosing its URL or origin. For example, requests from a large site which sets `Referrer-Policy: no-referrer; Accept-CH: DPR` will be distinguishable from requests from sites with `Accept-CH: DPR, Viewport-Width` and from those without client hints. Depending on the chosen set of hints this can in practice uniquely identify the origin visited by the user.\r\n\r\nThe introduction of `Accept-CH-Lifetime` will extend this problem to all resources on a given origin -- if one page sets the header, then subresource requests from all pages in that origin will start carrying hint information. This can be undesirable for the user because it can disclose information about the visited origin and broadcasts fingerprintable information to all parties from which the given origin loads subresources.\r\n\r\nIt seems like this should be mitigated, possibly by one of the following:\r\n- (Preferably) Not broadcasting client hints on cross-origin subresource loads.\r\n- Obeying Referrer Policy and omitting hints if the referring page attempts to restrict data which is sent in the `Referer` header. Similarly, hints should probably also be stripped on HTTPS -> HTTP transitions.",
      "createdAt": "2017-07-19T15:46:03Z",
      "updatedAt": "2019-06-05T20:20:29Z",
      "closedAt": "2018-01-25T07:49:38Z",
      "comments": [
        {
          "author": "tarunban",
          "authorAssociation": "NONE",
          "body": "> The introduction of Accept-CH-Lifetime will extend this problem to all resources on a given origin -- if one page sets the header, then subresource requests from all pages in that origin will start carrying hint information. \r\n\r\nIIUC, this is not correct. If the origin includes `Accept-CH-Lifetime` header, then the user agent is expected to send the client hints for requests to only that origin.\r\n\r\n> Similarly, hints should probably also be stripped on HTTPS -> HTTP transitions.\r\n\r\nThe Chromium implementation (currently underway) processes `Accept-CH-Lifetime` header from only HTTPS origins. So, the client hints sent because the user agent received `Accept-CH-Lifetime` in the past would be sent to only HTTPS origins. Quoting the spec:\r\n\r\n> Implementers ought to provide mechanisms and policies to control how\r\n   and when such hints are advertised. \r\n\r\ncc'ing @igrigorik to comment on if any spec changes are needed here to make this more explicit.",
          "createdAt": "2017-07-19T16:02:56Z",
          "updatedAt": "2017-07-19T16:02:56Z"
        },
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "> If the origin includes Accept-CH-Lifetime header, then the user agent is expected to send the client hints for requests to only that origin.\r\n\r\nHmm, I'm getting a different impression from the text in the [spec](https://tools.ietf.org/html/draft-ietf-httpbis-client-hints-04#section-2.2.2): \r\n\r\n> if a request is initiated to the same origin before the preference is stale (e.g. as a result of a navigation to the origin, or fetching a subresource from the origin) the client could append the requested header fields (DPR and Viewport-Width in this example) to the request **and any subresource requests initiated as a result of processing a response from same origin**.\r\n\r\nIf hints are supposed to be sent only on same-origin subresource requests it would address my main concern. In general, it would be great if the current _non-lifetime_ Accept-CH behavior was also limited to same-origin subresources -- I don't think requiring developers who want to use client hints to also leak this information to owners of third-party subresources loaded on their pages is particularly great.\r\n\r\n> The Chromium implementation (currently underway) processes Accept-CH-Lifetime header from only HTTPS origins.\r\n\r\nWhat about HTTPS pages which have HTTP subresources? The behavior I currently see for Accept-CH is that the HTTP subresource requests have client hints (but no Referer); I believe you're saying this behavior would change with Accept-CH-Lifetime? If so, this sounds good, though see above re: the broader concern about non-same-origin subresources.",
          "createdAt": "2017-07-19T20:07:35Z",
          "updatedAt": "2017-07-19T20:07:35Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@arturjanc thanks for the great feedback. Let me try to unpack...\r\n\r\nPrior to introduction of `Accept-CH-Lifetime` (ACL) \u2014 which is very recent \u2014 there was no mechanism in place for an origin to persist a preference for hints across independent requests. As a result, navigation requests did not get any hints and only subrequests of the \"opted-in document\" were eligible. The extra complication here is that the initial set of core use cases (image optimization) frequently relies on use of CDN's and third-party services+origins, which means that prior to ACL there was no way for those origins to enable CH hints, since page origin != resource origin. As a result, the decision was to extend Accept-CH opt-in to all resources fetched by the page.\r\n\r\nNow that we have ACL, it may be possible to revisit this setup. In particular, if we scope ACL to per-origin, then both the page origin and resource origin can advertise support separately and these preferences will be persisted across requests. In fact, I suspect that this is what will happen anyway, because for cases like image serving CDNs will advertise support for hints on their own origins, such that any site relying on their service can benefit by default.\r\n\r\n@yoavweiss wdyt?\r\n\r\n---\r\n\r\n> What about HTTPS pages which have HTTP subresources? The behavior I currently see for Accept-CH is that the HTTP subresource requests have client hints (but no Referer);\r\n> ...\r\n> Obeying Referrer Policy and omitting hints if the referring page attempts to restrict data which is sent in the Referer header. Similarly, hints should probably also be stripped on HTTPS -> HTTP transitions.\r\n\r\nI think this would naturally fall out of the origin-scoped model? As in, if opt-in is scoped to HTTPS then we wouldn't send hints to HTTP, unless the HTTP origin also explicitly opted-in. \r\n\r\nRe, Referer:  \"I have third party resources on my site, which may have hints enabled, and I want to strip those alongside referrers\", is that the use case? If so, that seems legitimate, but using Referer does feel a little action-at-a-distance to me. As in, I wouldn't expect Referrer to control hints? That said, I don't have a better suggestion either. @mikewest wdyt?\r\n\r\n> A related issue is that based on the sets of headers sent in such subresource requests, the subresource owner might be able to identify the referring site even if it sets a Referrer Policy to prevent disclosing its URL or origin. For example, requests from a large site which sets Referrer-Policy: no-referrer; Accept-CH: DPR will be distinguishable from requests from sites with Accept-CH: DPR, Viewport-Width and from those without client hints. Depending on the chosen set of hints this can in practice uniquely identify the origin visited by the user.\r\n\r\nGood points, we should flag this in the privacy & security section.\r\n",
          "createdAt": "2017-07-20T03:29:41Z",
          "updatedAt": "2017-07-20T03:29:41Z"
        },
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "> Now that we have ACL, it may be possible to revisit this setup. In particular, if we scope ACL to per-origin, then both the page origin and resource origin can advertise support separately and these preferences will be persisted across requests.\r\n\r\nThis seems like a better model than the status quo because it limits the sending of hints to origins which opt into receiving them. However, it still has the issue of revealing new information to providers of third-party subresources which they can't obtain now. This seems fine to do with opt-in from the first party (which can already get the Viewport-Width, etc via client-side scripts and then provide it to the CDN in the URL), but seems less great if the CDN can decide to always get hints in all requests, because of the passive fingerprinting potential.\r\n\r\nWhat do you think of double-keying the hints on both the first- and third-party? That is, if you set `Accept-CH(-Lifetime)`:\r\n- Requests for same-origin subresources will carry client hints (up until the max-age if you specify the lifetime).\r\n- Requests for non-same-origin subresources will not carry client hints if the other origin doesn't set `Accept-CH-Lifetime`.\r\n- If you load third-party resources from an origin which sets `Accept-CH-Lifetime`, requests from your origin to the third party will carry client hints.\r\n- Requests from other origins (which don't set `Accept-CH`) to the third party will not carry hints.\r\n\r\nI realize this reduces the \"on by default\" benefit you mentioned, but it seems like a relatively simple opt-in for the first party (which is already a necessary condition in `Accept-CH`) and it mitigates the risk of enabling passive tracking of users based on client hints, which I assume will evolve to expose more interesting data. As you mentioned above, this would also make the Referrer discussion moot (and I agree that controlling client hints via Referrer Policy seems awkward).",
          "createdAt": "2017-07-20T10:47:04Z",
          "updatedAt": "2017-07-20T10:47:04Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Would double-keying have material effect on this though? Yes, implementing it this way reduces passive fingerprinting, but only for the very first visit. Nothing prevents every 3P origin from advertising a blanket opt-in policy (in fact, I expect that's exactly how image CDN's will implement it), which will result in same exposure for any repeat visit. Also, as a side effect, double-keying would expose first vs repeat visit bit?\r\n\r\nI'm not ruling it out, but it's not clear to me that it would be a big win in this context?",
          "createdAt": "2017-07-21T15:12:15Z",
          "updatedAt": "2017-07-21T15:12:15Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@arturjanc started a branch @ https://github.com/httpwg/http-extensions/pull/373 - ptal.",
          "createdAt": "2017-07-21T16:31:08Z",
          "updatedAt": "2017-07-21T16:31:08Z"
        },
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "Re: double-keying, the point is that if you're visiting a first party _without_ Accept-CH then the browser wouldn't send client hints to a CDN even if it sets ACL. Essentially, if you have a first party which wants to use client hints they can opt into them and then their non-same-origin subresources can gets hints if their providers also set ACL (which is fine because the first party could manually pass the hints in the URLs anyway). This prevents CDNs and other origins from which subresources are loaded from getting hints during the user's visit to non-cooperating sites, but should still offer the benefits you're looking for in cases where both parties opt in.\r\n\r\nI commented on https://github.com/httpwg/http-extensions/pull/373 -- it looks good to me in general, modulo the broader double-keying issue (which I believe is important).",
          "createdAt": "2017-07-22T15:19:16Z",
          "updatedAt": "2017-07-22T15:19:16Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Artur: makes sense, thanks. \r\n\r\n@yoavweiss @tarunban curious to hear your thoughts on double-keying. Any implementation gotchas here that we should think through?",
          "createdAt": "2017-07-22T15:33:31Z",
          "updatedAt": "2017-07-22T15:33:31Z"
        },
        {
          "author": "tarunban",
          "authorAssociation": "NONE",
          "body": "No implementation gotchas wrt double-keying.",
          "createdAt": "2017-07-24T16:00:55Z",
          "updatedAt": "2017-07-24T16:00:55Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Apologies for the late reply (was exploring the Canadian wilderness...)\r\n\r\nI don't see a particular problem with double keying but I also don't to see the privacy advantages of it. As @igrigorik said earlier, all third parties will add an automatic ACHL and will get the hints as soon as the main document opts-in, meaning the situation will not be different from today.\r\n\r\nI think the concerns that @arturjanc raises are real and ACHL will expose new information regarding origins that are not capable of running scripts in the context of the page, new info regarding viewport, DPR and network conditions that they don't currently have. \r\n\r\nMaybe we need `Accept-CH-Lifetime` to be able to define a list of hosts that will get subresource hints? I vaguely remember us discussing a proposal in that spirit in the past, but failing to find references to such a discussion.",
          "createdAt": "2017-08-10T14:07:42Z",
          "updatedAt": "2017-08-10T14:07:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "*not chair hat*\r\n\r\nCould we please stop calling this use case \"CDN\"? Most CDNs take all traffic for an origin, not just images, etc. (that's very 1999). It's true that some sites direct images.* to a CDN (for example), but that's not great practice.\r\n\r\nWe should really be talking about this as 3rd party content -- e.g., widgets and ads. Given the history there, it's entirely reasonable to be concerned about increasing fingerprinting exposure.\r\n\r\nRequiring the origin to opt-in to any 3rd party CHs is an improvement, but not a huge one; it'll just give an incentive to 3rd parties to instruct the origin to set whatever policy we require.\r\n\r\nI think that at a minimum, we should warn (Security Considerations) specifically about the new vector for 3rd party content fingerprinting here, and allow implementations to decide whether they send it to 3rd parties (at all, or when they're in private browsing mode, or...).\r\n\r\nI'd like to also see at least consideration of making this 1st party only. Given that the use case for CH is mostly to allow intermediaries to do content optimisation -- and remembering that origins already have other techniques available to them -- I'm wondering if allowing third party origins to do intermediary-imposed optimisations is worth the potential privacy tradeoff here. After all, widgets and ads are usually served by `script` tags, so there's an opportunity for script running and URL rewriting by them before the requests are made. ",
          "createdAt": "2017-08-14T21:08:16Z",
          "updatedAt": "2017-08-14T21:08:16Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Could we please stop calling this use case \"CDN\"? Most CDNs take all traffic for an origin, not just images, etc. (that's very 1999). It's true that some sites direct images.* to a CDN (for example), but that's not great practice.\r\n\r\nWhile we can argue that in an H2 world this is not the best practice, having a separate domain for images is not uncommon. e.g. looking at https://www.nytimes.com/ its images are served from https://static01.nyt.com. All served from the same CDN (and covered by a single cert AFAICT), but still considered a third party from a SOP perspective. It's also not uncommon to have separate certs to such \"static domains\" as an infosec requirement.\r\n\r\nSo I don't think we can consider sending CH to third parties as something that will only benefit 3rd party content.\r\n\r\n\r\n\r\n\r\n> Requiring the origin to opt-in to any 3rd party CHs is an improvement, but not a huge one; it'll just give an incentive to 3rd parties to instruct the origin to set whatever policy we require.\r\n\r\nThey can similarly add requirements for the origin to include their JS that will beacon up that data to them. There's very little we can do about that other than trust the first party's judgement (and make them aware of what they're enabling).\r\n\r\n\r\n\r\n> I'd like to also see at least consideration of making this 1st party only.\r\n\r\nThat would exclude many legitimate use cases, as discussed above.\r\n\r\n\r\n\r\n> After all, widgets and ads are usually served by script tags, so there's an opportunity for script running and URL rewriting by them before the requests are made.\r\n\r\nIf they run a script in the context of the main page, they can easily exfiltrate that data, which is available through JS APIs.",
          "createdAt": "2017-08-17T14:24:14Z",
          "updatedAt": "2017-08-17T14:24:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hey Yoav. Absolutely, but the Web security model doesn't have any concept of CDN; images.* is a third-party host as far as same-origin is concerned.",
          "createdAt": "2017-08-17T18:25:12Z",
          "updatedAt": "2017-08-17T18:25:12Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Absolutely, but the Web security model doesn't have any concept of CDN; images.* is a third-party host as far as same-origin is concerned.\r\n\r\nIndeed. All I'm saying is that exposing CH to such \"first party owned third parties\" is a legitimate and very common use-case. I'd prefer we find ways to address that use-case (with appropriate means to maintain user-privacy), rather than block it. ",
          "createdAt": "2017-08-18T08:14:27Z",
          "updatedAt": "2017-08-18T08:18:28Z"
        },
        {
          "author": "michael-oneill",
          "authorAssociation": "NONE",
          "body": "I agree. If subresources can use CH then it is bound to be misused. The trend is to further restrict access to third-party cookies e.g. Safari\u2019s ITB, so there will be more incentive to find other ways to track. CH headers allow that to be done much more efficiently as there is no need for an extra roundtrip.",
          "createdAt": "2017-08-22T11:56:26Z",
          "updatedAt": "2017-08-30T19:20:10Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Thanks everyone for the feedback. \r\n\r\nNomenclature discussions on \"CDN\" vs.  \"widget\" vs \"3P\" aside, I agree with Yoav that subresource optimization is a _critical_ use case for CH and not something we can omit. It may be the case that some particular hints make sense to be scoped to first-party only, but that's a discussion we should have in the context of individual hints; as a general mechanism, CH must support delivery of hints to all origins, possibly with knobs for 1P origin to control which 3P origins are allowed to receive hints. \r\n\r\n**Current proposal for `Accept-CH-Lifetime` is to allow hint preferences to be registered by any origin.** The limitation, as pointed out in discussion above, is that it doesn't provide any distinction between 1P or 3P opt-in. To that end, we discussed a few options:\r\n\r\n1. We can add double-keying to scope 3P registrations to within 1P origin \u2014 i.e. 3P registration on foo.com does not propagate to same 3P origin on bar.com.\r\n1. We can further restrict 3P ability to register for hints by requiring that 1P opts in for receiving CH hints \u2014 i.e. what @arturjanc proposed above.\r\n\r\nFWIW, I think (1) is the right behavior, from a user perspective. However, what it doesn't address is the 1P -> 3P delegation case where 1P origin may want to control if (and which) 3P is allowed to request CH. @arturjanc's proposal (b) is an attempt at this, but a fairly blunt one: 3P is allowed to receive hints if 1P opt's in, but this is a blanket policy for all 3P origins and it similarly doesn't provide any fine grained control for which hints are allowed to be requested. If we all agree that the \"1P -> 3P hint delegation\" use case is an important one, I think we need to explore mechanisms beyond (b). \r\n\r\nTo that end, squinting at this space, I see close parallels to Feature Policy: we have features (hints) that we want to selectively enable/disable, and we may want to scope them to a list of origins \u2014 e.g. enable them for \"self\" / 1P only, selectively enable them for some set of origins, or disable them outright. And so, here's my crazy proposal of the day: \r\n\r\n1. ACL registrations should be double keyed -- see (1).\r\n1. Control over which hints are enabled, plus delegation, should (?) be addressed via Feature Policy. \r\n\r\n```\r\nFeature-Policy: {\r\n   \"ch-dpr\": [\"self\"],  // DPR hint is 1P only\r\n   \"ch-ex1\": [\"self\", \"foo.com\", \"bar.com\"],  // ex1 hint is 1P + select 3P\r\n   \"ch-ex2\": [] // ex2 hint is disabled for everyone\r\n} \r\n```\r\n\r\nThe other benefit here is that this opens a well-defined way to think about a \"default FP policy\" for each hint. For example, some hints may be restricted by the UA to be 1P only, other may be on-by-default for everyone (e.g. save-data), and others may be off by default.\r\n\r\nWDYT? Crazy talk? :)\r\n\r\n/cc @clelland @rbyers",
          "createdAt": "2017-08-30T20:26:50Z",
          "updatedAt": "2017-08-30T20:26:50Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's not the craziest thing I've read today :)\r\n\r\nIt's a bit mind-stretching to think of these as features, but it definitely is a kind of power or trust that is being delegated to other origins by the embedding page, so it's not *too far* from the goals of feature policy.\r\n\r\nOne question I would bring up would be regarding the inheritance of ACL in deeply-nested frame trees -- Feature Policy's model is that once disabled in an frame, a feature can never be reenabled by any subcontent; I wouldn't want to break that invariant without a real compelling case.\r\n\r\nWith the FP model, if `a.com` embeds `b.com`, and does not grant it the ability to receive hints, then it is not possible for `b.com` to embed a fourth-party, `c.com`, and have hints sent to *that* domain instead. That sounds like desirable behavior to me, but I don't think it's been brought up on this thread yet.",
          "createdAt": "2017-08-30T21:45:23Z",
          "updatedAt": "2017-08-30T21:45:23Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "I think FP's current inheritance behavior makes perfect sense in this context as well. If I disable use of a particular hint on my site, I expect this policy to propagate to all nested frames.",
          "createdAt": "2017-08-30T21:51:37Z",
          "updatedAt": "2017-08-30T21:51:37Z"
        },
        {
          "author": "tarunban",
          "authorAssociation": "NONE",
          "body": "> If we all agree that the \"1P -> 3P hint delegation\" use case is an important one\r\n\r\nNaive question: IIUC, any information that can be obtained by an origin via client hints can also be obtained by that origin using a combination of Javascript and cookies. Is it currently possible for 1P origins to control Javascript/cookies behavior of 3P origins?",
          "createdAt": "2017-08-30T22:52:39Z",
          "updatedAt": "2017-08-30T22:52:39Z"
        },
        {
          "author": "tarunban",
          "authorAssociation": "NONE",
          "body": "At a high level, I am not sure why the client hints permission for foo.com is not the same as (permission for foo.com to run Javascript AND permission for foo.com to store cookies)?",
          "createdAt": "2017-08-30T23:12:07Z",
          "updatedAt": "2017-08-30T23:12:07Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@tarunban the key difference here is passive content (e.g. images, audio, video, etc): today such resources/origins cannot obtain data that we expose with CH, unless there is active content executing in top level page and scheduling their fetches. I think it's reasonable for origins to have control over whether such passive content providers should be able to request data exposed by CH.",
          "createdAt": "2017-08-30T23:19:55Z",
          "updatedAt": "2017-08-30T23:19:55Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Really interesting, Ilya. It *is* a big change :)\r\n\r\nOn the face of it, it seems workable. Feature Policy doesn't have a concept similar to `Accept-CH-Lifetime`; would that move into FP, or remain CH-specific?\r\n\r\nI'm not crazy about the verbosity of `Feature-Policy`, nor the (relative) complexity. Also a bit concerned about making such a prominent part of CH an external dependency -- especially since FP is effectively browser-specific, whereas I suspect at least some people want CH to be applicable to other HTTP clients.\r\n\r\nStill digesting...",
          "createdAt": "2017-08-31T04:20:12Z",
          "updatedAt": "2017-08-31T04:20:12Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interesting indeed!\r\nA couple of thoughts:\r\n* FP's inheritance model makes some sense, but *is* more restrictive than info that iframes currently have (as iframes are *not* passive content). Would've been great if we could limit exposure of privacy sensitive info to 3rd party passive content while enabling it for active content (by allowing new contexts to override). One use case I can think of is an ad iframe that wants to do the right thing in terms of DPR/viewport based image compression will now require all embedding sites to opt-in, which most won't.\r\n* This will obsolete `Accept-CH` entirely, correct?",
          "createdAt": "2017-08-31T07:33:56Z",
          "updatedAt": "2017-08-31T07:34:41Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not essential to the proposal's semantics, but seems like FP is [moving away](https://groups.google.com/a/chromium.org/d/msg/blink-dev/uKO1CwiY3ts/2pSbOUb3CQAJ) from JSON towards a CSP-like structure.",
          "createdAt": "2017-09-01T09:27:31Z",
          "updatedAt": "2017-09-01T09:27:31Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interesting. I'm pretty sure that the newly proposed syntax has several flaws.  See my comment over there.",
          "createdAt": "2017-09-01T10:17:05Z",
          "updatedAt": "2017-09-01T10:17:18Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke Could you add a link to your comments? I'm failing to find them...",
          "createdAt": "2017-09-04T08:38:16Z",
          "updatedAt": "2017-09-04T08:38:16Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/WICG/feature-policy/issues/78#issuecomment-326544934",
          "createdAt": "2017-09-04T08:46:38Z",
          "updatedAt": "2017-09-04T08:46:38Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@mnot @yoav I'm _not_ suggesting we rebase the entire opt-in mechanism against FP \u2014\u00a0it's also not sufficient on its own because, as you pointed out, it's missing ACHL semantics amongst other things. Rather, I'm suggesting that we should separate these concerns: \r\n\r\n- Accept-CH + Accept-CH-Lifetime define a mechanism for origins to advertise their hint and hint lifetime preferences for subsequent visits; these two primitives are used to negotiate what hints will be made available to the origin.\r\n- With above in place, delegation is \u2014 I claim \u2014 a separate and complex enough problem that deserves its own treatment. As it happens, that's what FP is solving, and we should leverage that. \r\n  - We _can_ still make a default double-keyed recommendation for 3P opt-in.\r\n  - We _can_ define default hint policies in terms of FP primitives.\r\n\r\nYes, we are coupling two mechanisms here, but delegation is not an easy problem and I'd much rather we reuse mechanisms than try to blaze yet another trail here. Also, it's true that FP is designed with browser in mind, but there is no reason why it can't or shouldn't work with other types of clients.",
          "createdAt": "2017-10-06T17:36:47Z",
          "updatedAt": "2017-10-06T17:36:47Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Updated https://github.com/httpwg/http-extensions/pull/373 with outstanding feedback \u2014 ptal. \r\n\r\nAs a quick recap, with #373 we have:\r\n - Accept-CH and Accept-CH-Lifetime are the mechanisms to advertise support and lifetime prefs.\r\n  - Both are scoped to secure transports.\r\n  - Preference is bound to the origin / double-keyed.\r\n\r\nCurrent update does _not_ address delegation. As proposed above, I'm suggesting we solve that part of the problem via Feature Policy. If that sounds reasonable, I can add some language in #373 to outline how/where this should be defined.\r\n\r\nWDYT?",
          "createdAt": "2017-10-06T18:56:40Z",
          "updatedAt": "2017-10-06T18:56:40Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@arturjanc @mnot @yoavweiss friendly bump.. :bowtie: ",
          "createdAt": "2017-10-13T21:30:54Z",
          "updatedAt": "2017-10-13T21:30:54Z"
        },
        {
          "author": "tarunban",
          "authorAssociation": "NONE",
          "body": "Is this fixed?",
          "createdAt": "2017-10-25T16:32:11Z",
          "updatedAt": "2017-10-25T16:32:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think it'd be good to see #373 in situ; from what I see in the patch, I think it's strictly better. No guarantees that there aren't other issues, or that this isn't completely covered, but personally I think it's better.",
          "createdAt": "2017-10-26T00:25:38Z",
          "updatedAt": "2017-10-26T00:25:38Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "I've landed #373. As a tl;dr on substantive changes: \r\n- Accept-{CH,CH-Lifetime} opt-in is scoped to secure transports\r\n- Opt-in preference is bound to opt-in origin\r\n\r\nIn effect, this update makes Client Hints HTTPS-only and opt-in preference is double keyed against opt-in origin. We've also updated [security considerations section](http://httpwg.org/http-extensions/client-hints.html#security-considerations) to reflect these updates.\r\n\r\n---\r\n\r\nThe one remaining thread raised in this issue is around \"hint delegation\": if origin A is loading a subresource from origin B, can A control if B is allowed to opt-in to receive hints? As it stands today, the answer is \"yes\", and CH does not define a mechanism to control this.\r\n\r\nI do think this is a valid use case, but I don't think we should be solving it within CH directly. Rather, we should be reusing client specific infrastructure to address this.. e.g. in a context of a browser that's [Feature Policy](https://wicg.github.io/feature-policy/), which provides a mechanism to selective enable/disable features and defines relevant delegation mechanisms \u2014 e.g. policy based, frame-level control, cascading logic, etc.\r\n\r\nSo, my proposal here is:\r\n - @arturjanc I believe we addressed your original concerns via #373. \r\n    - We can resolve this thread\r\n    - Publish new 05 draft with updates in #373\r\n - Pursue delegation discussions in context of Feature Policy.\r\n\r\n@arturjanc @mnot does that sound reasonable?",
          "createdAt": "2017-10-27T19:21:34Z",
          "updatedAt": "2017-10-27T19:21:34Z"
        },
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "Thanks, Ilya! I re-read the spec with your changes and I also think it's a significant improvement, particularly when it comes to binding subresource hints to the opt-in origin, hindering cross-origin linking between 1p sites which don't use `Accept-CH`.\r\n\r\nMy main outstanding worry is indeed the \"hint delegation\" issue you mentioned above: specifically, the fact that opting an origin into receiving hints still results in sending hints on subresources by default if the 3p also opts in, potentially giving it information about the referring page that it wouldn't currently receive. Similarly, such 3p origins hosting subresources used by an `Accept-CH`-enabled origin would start getting hints which disclose a few bits of information about the user and could be used for opportunistic linking across 1p visits to different `Accept-CH`-enabled origins.\r\n\r\nI like the idea of using Feature Policy to control this, but it's doubtful that developers would understand the privacy benefit of restricting subresource hints via FP, which means they wouldn't take action to prevent them from being sent. What do you think about flipping this around and only sending hints on 3p subresource requests if the origin is explicitly whitelisted via Feature Policy? This would be a direct signal from the developer that they want to trust the third-party, and might be more in line with the interests of both the first-party and the user.",
          "createdAt": "2017-11-27T16:52:30Z",
          "updatedAt": "2017-11-27T16:52:30Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> What do you think about flipping this around and only sending hints on 3p subresource requests if the origin is explicitly whitelisted via Feature Policy? This would be a direct signal from the developer that they want to trust the third-party, and might be more in line with the interests of both the first-party and the user.\r\n\r\nI'd be supportive of restricting third party access by default and providing a Feature Policy explicit opt-in to specific third-party domains that the origin trusts. \r\n",
          "createdAt": "2017-11-27T17:07:19Z",
          "updatedAt": "2017-11-27T17:07:19Z"
        },
        {
          "author": "tarunban",
          "authorAssociation": "NONE",
          "body": "How important it is to expose client hints to third party domains? It seems that even now (without Accept-CH header) first party can provide client hints to the third party domains as URL parameters. In that case, I wonder if it is worth the effort to tie Accept-CH for third-party with Feature Policy, or we should just: (i) Restrict Accept-CH to only first part domains; and, (ii) Let first party use URL parameters to pass on the client hints to third parties.\r\n\r\nThe goal of Accept-CH was to provide client hints to the first parties in the very first HTTP request itself. Restricting third party access by default does not affect that goal, so I am in support of it.",
          "createdAt": "2017-12-07T20:24:03Z",
          "updatedAt": "2017-12-07T20:24:03Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> How important it is to expose client hints to third party domains? It seems that even now (without Accept-CH header) first party can provide client hints to the third party domains as URL parameters. In that case, I wonder if it is worth the effort to tie Accept-CH for third-party with Feature Policy, or we should just: (i) Restrict Accept-CH to only first part domains; and, (ii) Let first party use URL parameters to pass on the client hints to third parties.\r\n\r\nThat's precisely the problem we're trying to solve, you shouldn't have to jump through these hoops as it doesn't play well with caching, and doesn't work for dynamic preferences (e.g. save-data, memory, etc) where the URLs would have to be dynamically generated for each request and enumerate all the hints. This _is_ what some sites already do today, but it's gnarly and complicated solution that doesn't play well with edge delivery / hinders automation of this space.\r\n\r\n> My main outstanding worry is indeed the \"hint delegation\" issue you mentioned above: specifically, the fact that opting an origin into receiving hints still results in sending hints on subresources by default if the 3p also opts in, potentially giving it information about the referring page that it wouldn't currently receive. Similarly, such 3p origins hosting subresources used by an Accept-CH-enabled origin would start getting hints which disclose a few bits of information about the user and could be used for opportunistic linking across 1p visits to different Accept-CH-enabled origins.\r\n\r\nCan you elaborate on a particular use case or example that you're worried about here? I hear your concern, but I'm not convinced that the real risk is any more significant than what is already exposed by most sites to 3P's through active content (or CSS even). \r\n\r\n> What do you think about flipping this around and only sending hints on 3p subresource requests if the origin is explicitly whitelisted via Feature Policy? \r\n\r\nOn a tactical (spec language) level, FP is a UA-specific concept and I don't think we can couple it here with CH; FP does not apply to non-UA clients. On the other hand, a UA may choose to define a \"default off\" FP policy for CH for 3P origins and that's totally fine: that's an implementation decision of the UA, and different UAs may even chose different policies for different hints, instead of applying a blanket policy for all CH hints - e.g. Chrome communicates Save-Data hint to all origins today if data saver feature is enabled.\r\n\r\nAs such, I think we can add some language in CH to explain and allow for above implementation options, but I don't think we can dictate a default FP policy in this spec. \r\n\r\nSpec language bits aside, and with respect to UA implementation: I think we should have a more detailed conversation, on a hint-by-hint basis, to determine default on/off policies, and I'd suggest that we move that discussion to FP forum. \r\n\r\nDoes that sound reasonable to you guys?",
          "createdAt": "2017-12-08T19:33:49Z",
          "updatedAt": "2017-12-08T19:33:49Z"
        },
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "> Can you elaborate on a particular use case or example that you're worried about here? I hear your concern, but I'm not convinced that the real risk is any more significant than what is already exposed by most sites to 3P's through active content (or CSS even).\r\n\r\nI'd set aside the case of fully active content and focus on 3p resources that do not allow the hosting party to get information that would be exposed in hints (i.e. loading content such as images, fonts, audio/video, or even JS/CSS pinned to a specific version via Subresource Integrity). If a website loads such resources -- which is very common -- and it enables hints, *and* the 3p separately also enables hints, it has two consequences:\r\n\r\n- The user will start sending hint information to the third party, which may allow the 3p to correlate requests from that user across different 1p sites which use hints, even if third-party cookies are disabled. The hints will also be sent automatically, rather than require active probing, which will result in potentially fingerprintable information being sent out to third parties which either couldn't obtain it, or which likely wouldn't resort to actively detecting it and sending it out.\r\n- The user will start sending hint information which might tell the 3p which website/page the user is on, even if the website uses Referrer Policy to remove the Referer header (e.g. in the case where the 3p knows their resource is being loaded by 10 other sites, and only 1 of them enables the set of hints they see in the request).\r\n\r\nThis behavior is arguably worse privacy-wise than the status quo for users of sites which enable hints. I like being able to control 3p hints via FP, but developers won't understand why they might want to do it (partly because the third-parties they load data from might not enable hints until later, so the developer would not see them in 3p requests while testing on their sites).\r\n\r\nFWIW I do think this is strictly better than the original proposal, so \"3p hints should be off by default unless enabled by Feature Policy\" is not a hill I'd want to die on. Solving this with safe defaults at the FP level sounds okay; I'm a little wary about relying on a completely independent mechanism to enforce good privacy properties of client hints, but it's probably workable -- we'd just need to have the FP-focused discussion about this.",
          "createdAt": "2017-12-11T17:53:28Z",
          "updatedAt": "2017-12-11T17:53:28Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@arturjanc thanks, I think we're converging on a good solution here.\r\n\r\na) Opened a feature request against FP: https://github.com/WICG/feature-policy/issues/129\r\nb) Assuming we all agree on the above, I'd propose the following update in CH...\r\n\r\n```diff\r\ndiff --git a/draft-ietf-httpbis-client-hints.md b/draft-ietf-httpbis-client-hints.md\r\nindex 91ebc81..4455ff0 100644\r\n--- a/draft-ietf-httpbis-client-hints.md\r\n+++ b/draft-ietf-httpbis-client-hints.md\r\n@@ -100,7 +100,7 @@ A Client Hint request header field is a HTTP header field that is used by HTTP c\r\n\r\n ## Sending Client Hints\r\n\r\n-Clients control which Client Hints are sent in requests, based on their default settings, user configuration and/or preferences. The client and server can use an opt-in mechanism outlined below to negotiate which fields should be sent to allow for efficient content adaption.\r\n+Clients control which Client Hints are sent in requests, based on their default settings, user configuration, and server preferences. The client and server can use an opt-in mechanism outlined below to negotiate which fields should be sent to allow for efficient content adaption, and optinally use additional mechanisms to negotiate delegation policies that control access of third parties to same fields.\r\n\r\n Implementers should be aware of the passive fingerprinting and network information disclosure implications when implementing support for Client Hints, and follow the considerations outlined in \"Security Considerations\" section of this document.\r\n\r\n@@ -263,6 +263,7 @@ Transmitted Client Hints header fields SHOULD NOT provide new information that i\r\n\r\n Implementers ought to consider both user and server controlled mechanisms and policies to control which Client Hints header fields are advertised:\r\n\r\n+  - Implementers SHOULD restrict delivery of some or all Client Hints header fields to the opt-in origin only, unless the opt-in origin has explicitly delegated permission to another origin to request Client Hints header fields.\r\n   - Implementers MAY provide user choice mechanisms so that users may balance privacy concerns with bandwidth limitations. However, implementers should also be aware that explaining the privacy implications of passive fingerprinting or network information disclosure to users may be challenging.\r\n   - Implementations specific to certain use cases or threat models MAY avoid transmitting some or all of Client Hints header fields. For example, avoid transmission of header fields that can carry higher risks of linkability.\r\n```\r\n\r\nTo recap, this would leave us with:\r\n- CH is HTTPS only\r\n- Delivery of hints is bound to origin and requires explicit origin opt-in (https://github.com/httpwg/http-extensions/commit/d85cc9d8e49cff59cf97e30fe140d3155618c6c7)\r\n- FP controls 3P delegation for UAs, with custom default policies for each hint:\r\n  - By default most hints are scoped with FP policy of `self`, which means that 1P has to explicitly allow 3P's to request access to the hint. \r\n  - One exception today is Save-Data, which we believe (and as currently implemented in Chrome) should have a default FP policy of `*`.\r\n\r\nDoes that land us in a good place to resolve this thread? :-)",
          "createdAt": "2018-01-19T17:43:42Z",
          "updatedAt": "2018-01-19T17:44:12Z"
        },
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "Looks good to me -- thanks for all the work on this, Ilya!",
          "createdAt": "2018-01-22T12:47:02Z",
          "updatedAt": "2018-01-22T12:47:02Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM2! :)",
          "createdAt": "2018-01-22T19:42:22Z",
          "updatedAt": "2018-01-22T19:42:22Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Excellent, looks like we've landed in a good place! I've updated the CH spec and resolving this issue. Let's continue the FP discussion in WICG/feature-policy#129. \r\n\r\nThanks all for your patience and help here!",
          "createdAt": "2018-01-25T07:49:38Z",
          "updatedAt": "2018-01-25T07:49:38Z"
        },
        {
          "author": "npdoty",
          "authorAssociation": "NONE",
          "body": "I'm confused by this text, given my understanding of the resolution of this issue:\r\n>    Implementers SHOULD restrict delivery of some or all Client Hints\r\n      header fields to the opt-in origin only, unless the opt-in origin\r\n      has explicitly delegated permission to another origin to request\r\n      Client Hints header fields.\r\n\r\nWhy SHOULD and not MUST? Why the qualification of \"some or all\"? If explicit delegation of permission is required (through feature policy or some other means), shouldn't we just say so? Also, would it help to cite Feature Policy explicitly?",
          "createdAt": "2018-03-20T16:52:07Z",
          "updatedAt": "2018-03-20T16:52:07Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "I don't think we can or should assume that the only \"client\" for CH is a browser. I may be building a (native) app that's not subject to this and hence SHOULD. Does that sound reasonable?",
          "createdAt": "2018-03-27T00:52:31Z",
          "updatedAt": "2018-03-27T00:52:31Z"
        },
        {
          "author": "npdoty",
          "authorAssociation": "NONE",
          "body": "I'm not sure I understand. In your non-browser app example, will the opt-in origin not delegate permission to another origin but the app will choose to send Client Hints to that other origin anyway? Is there a reason that behavior needs to be considered conformant? Or just that delegated permission will be communicated in a different way than Feature Policy for non-browser clients?\r\n\r\nRe-reading this thread, it seems like maybe \"some or all\" is here because `Save-Data` is considered a special case where first-party opt-in won't be required. That seems like something that could be explicitly stated, rather than needing to dig through issue threads to discover.",
          "createdAt": "2018-04-04T20:47:17Z",
          "updatedAt": "2018-04-04T20:47:17Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> I'm not sure I understand. In your non-browser app example, will the opt-in origin not delegate permission to another origin but the app will choose to send Client Hints to that other origin anyway? Is there a reason that behavior needs to be considered conformant? Or just that delegated permission will be communicated in a different way than Feature Policy for non-browser clients?\r\n\r\nThe latter. Let's say I'm building a native game app, with assets living on one or multiple CDNs which I know and trust upfront. I may encode my \"delegation decision\" directly into my code (by appending appropriate CH hints on outbound requests) that's responsible for initiating the fetches; all of this work lives outside of a webview/browser. Which is to say, CH is not browser specific and we should allow for non-FP delegation mechanisms. ",
          "createdAt": "2018-04-10T16:20:52Z",
          "updatedAt": "2018-04-10T16:21:01Z"
        },
        {
          "author": "npdoty",
          "authorAssociation": "NONE",
          "body": "Gotcha. So it sounds like there is agreement that non-browser clients should restrict delivery unless there is explicitly delegated permission, and just that in the non-Web case that permission might be delegated through means other than Feature Policy, e.g. internal policy implemented through server/client code.\r\n\r\nCan we remove \"some or all\" or explicitly note the hints that aren't restricted to particular origins? Do we want this to be SHOULD even if it applies to all kinds of servers/clients?",
          "createdAt": "2018-04-11T20:37:24Z",
          "updatedAt": "2018-04-11T20:37:24Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> Can we remove \"some or all\" or explicitly note the hints that aren't restricted to particular origins? \r\n\r\nAs outlined in https://github.com/WICG/feature-policy/issues/129, in some cases the default \"delegation policy\" can be \"*\" \u2014 i.e. deliver to all. Concrete example today is Save-Data, where Chrome decided to deliver this hint on all requests when Data Saver feature is enabled. As such, I think we need to keep the \"some or all\".\r\n\r\n> Do we want this to be SHOULD even if it applies to all kinds of servers/clients?\r\n\r\n\"MUST ... some or all\" doesn't seem right? In fact, I'm wondering if I ought to convert all the capital terms in that sections to non-normative.",
          "createdAt": "2018-04-11T21:53:19Z",
          "updatedAt": "2018-04-11T21:53:19Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Generally, 2119 requirements in Security Considerations are a bit weird / frowned upon. Requirements are to improve interop; general advice to specifications and implementations aren't what they're for. \r\n\r\nAlso, the W3C TAG has expressed some sadness about these requirements. So personally I think that turning this text into prose is appropriate, FWIW.",
          "createdAt": "2018-04-11T23:13:33Z",
          "updatedAt": "2018-04-11T23:13:33Z"
        },
        {
          "author": "npdoty",
          "authorAssociation": "NONE",
          "body": "Can the TAG have written comments somewhere so we can understand that better?\r\n\r\nI agree that 2119 language is intended for interop. Sometimes knowing which things require permission and which don't is both a security consideration and important for interoperability of implementations.",
          "createdAt": "2018-04-12T00:20:23Z",
          "updatedAt": "2018-04-12T00:20:23Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "TAG discussion is here: https://github.com/w3ctag/design-reviews/issues/206",
          "createdAt": "2018-04-12T00:23:16Z",
          "updatedAt": "2018-04-12T00:23:16Z"
        },
        {
          "author": "thiemonagel",
          "authorAssociation": "NONE",
          "body": "Now that Save-Data has been dropped from the spec, would it make sense to revisit the \"some or all\" language?",
          "createdAt": "2018-09-28T13:32:34Z",
          "updatedAt": "2018-09-28T13:32:34Z"
        },
        {
          "author": "thiemonagel",
          "authorAssociation": "NONE",
          "body": "> CH is HTTPS only\r\n\r\nThe way I read the spec, secure transport is only required for CH opt-in, but CH could be delegated to non-secure origins via Feature Policy. Do you agree with that reading of the spec? Is it intentional to allow CH for (some) non-secure connections? -- That would provide passive network attackers with additional information to track users which I don't think is good.",
          "createdAt": "2018-09-28T15:17:26Z",
          "updatedAt": "2018-09-28T15:17:26Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@thiemonagel Save-Data is alive and well, we just moved its definition to [NetInfo API](https://wicg.github.io/netinfo/#save-data-request-header-field). \r\n\r\nRe, opt-in: you cannot opt-in an non-secure origin. The opt-in only extends to the origin for which it was advertised, and CH is now scoped to only support opt-in on secure origins.",
          "createdAt": "2018-09-28T15:48:18Z",
          "updatedAt": "2018-09-28T15:48:18Z"
        },
        {
          "author": "thiemonagel",
          "authorAssociation": "NONE",
          "body": "> Save-Data is alive and well, we just moved its definition to NetInfo API.\r\n\r\nThanks! Where can the complete list of client hints be found? Would it make sense to insert a reference?\r\n\r\n> The opt-in only extends to the origin for which it was advertised, and CH is now scoped to only support opt-in on secure origins.\r\n\r\nThanks! I missed that for 3rd parties both delegation and opt-in are required. (Would it make sense to spell out explicitly that secure transport is a prerequisite, e.g. in 2.1. or in 5.?)",
          "createdAt": "2018-09-28T16:18:35Z",
          "updatedAt": "2018-09-28T16:18:35Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> Where can the complete list of client hints be found?\r\n\r\n@dret assuming upstream specs provide the IANA registrations with a CH note, is there a page where we could see all the CH hints in one place? \r\n\r\n@thiemonagel in the meantime, at least for Chrome: https://client-hints-demo.appspot.com/\r\n\r\n> Would it make sense to spell out explicitly that secure transport is a prerequisite, e.g. in 2.1. or in 5.?\r\n\r\nWe already do in:\r\n- https://httpwg.org/http-extensions/client-hints.html#rfc.section.2.2.1\r\n- https://httpwg.org/http-extensions/client-hints.html#rfc.section.2.2.2\r\n\r\n\r\n\r\n",
          "createdAt": "2018-09-29T21:17:04Z",
          "updatedAt": "2018-09-29T21:17:04Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we should make that explicit in https://github.com/whatwg/fetch/pull/773, and update the processing so that hints are not added on non-secure connections, regardless of the opt-in mechanism.\r\n\r\n",
          "createdAt": "2018-09-30T19:26:18Z",
          "updatedAt": "2018-09-30T19:26:18Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @dret <https://github.com/dret> assuming upstream specs provide the IANA \n> registrations with a CH note, is there a page where we could see all the \n> CH hints in one place?\n\nyes, but only if the spec creates a registry of the hints and \nrequires/recommends hints to be registered.\n\ni may understand the spec wrong, but currently there is no clear \ndefinition of which header fields can be used in Accept-CH, right? if \nthat's true, then almost be definition *all* registered header fields \ncan be CH hints, right?\n\nfor this to be different, a registry might be the way to go.\n",
          "createdAt": "2018-09-30T19:47:36Z",
          "updatedAt": "2018-09-30T19:47:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I don't understand the value a registry would provide here.\r\n\r\nThe primary reason for registries -- avoiding collisions -- is already served by the HTTP header registry. \r\n\r\nIs there any technical use case for being able to recognise that a particular header is a client hint without actually implementing it?",
          "createdAt": "2018-10-01T06:46:45Z",
          "updatedAt": "2018-10-01T06:46:45Z"
        },
        {
          "author": "dret",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Oct 1, 2018, at 08:46, Mark Nottingham <notifications@github.com> wrote:\n> I don't understand the value a registry would provide here.\n> \nthe question was how to have a place where to look up possible client hints. a registry would be one way of achieving that, right?\n> Is there any technical use case for being able to recognise that a particular header is a client hint without actually implementing it?\n> \n\nthat i don't know. i just wanted to point out one possibility how to provide a list of possible client hints.",
          "createdAt": "2018-10-01T08:34:25Z",
          "updatedAt": "2018-10-01T08:34:25Z"
        },
        {
          "author": "thiemonagel",
          "authorAssociation": "NONE",
          "body": "Say I'm a web developer and I'd like to know which values I can set for Accept-CH. Shouldn't the spec answer that question, if only by referring to some other doc?",
          "createdAt": "2018-10-01T14:15:40Z",
          "updatedAt": "2018-10-01T14:15:40Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Client Hints is a framework describing a pattern of use for other headers. It's not developer documentation, as such; I think we'd expect that need to be filled elsewhere (e.g., books, blog entries, etc.).",
          "createdAt": "2018-10-08T05:15:45Z",
          "updatedAt": "2018-10-08T05:15:45Z"
        }
      ]
    },
    {
      "number": 374,
      "id": "MDU6SXNzdWUyNDY1ODcyNTE=",
      "title": "Early Hints and Caching Intermediaries",
      "url": "https://github.com/httpwg/http-extensions/issues/374",
      "state": "CLOSED",
      "author": "filex",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The proposal for the _103 Early Hints_ response contains a few examples referencing (probably caching) intermediaries. For example, to trigger a h2 server-push when an origin sends a 103 carrying `Link` headers. However, there is no explicit definition on what a cache or proxy server may or may not do with 103 responses.\r\n\r\nBy definition, the informational response cannot have any own meta data:\r\n\r\n_\"A client MUST NOT interpret the 103 (Early Hints) response header fields as if they applied to the informational response itself\"._\r\n\r\nObviously, 103 is not among the status codes cacheable by default defined in [RFC7231 6.1](https://tools.ietf.org/html/rfc7231#section-6.1). Furthermore the response cannot contain an entity body and it must be considered an intermediate response as the final response is still to come. I assume all that forbids storing the 103 in a cache.\r\n\r\nConsidering the objective to speed up Web site delivery, I would like to discuss the idea of adding a mechanism that would allow an intermediary cache to store data from the 103 response.\r\n\r\nIn a CDN-like setup an edge-server first receives an HTTP request and forwards it to the origin. Let's say the final answer took a long time, was private and could not be stored in the cache. However, a 103 intermediate response was received in the mean time and forwarded to the client. For subsequent requests to the same URL (according to the cache key calculation\u2026) the edge cache could send the _cached_ 103 downstream to the client while the original request is sent upstream to the origin _at the same time_. I think this could be a very effective way to use waiting time.\r\n\r\nA similar situation was proposed at the end of section 2, where an _\"intermediary generates a 103 (Early Hints) response based on the header fields of a stale-cached\u00a0response\"_. However, this can only apply to cacheable content. But HTML documents are most often private.\r\n\r\nTo avoid \"guessing\" in intermediaries, we could define a special Cache Control header field accompanying the 103 status, such as `Early-Hint-Control`. An origin could then define a 103 to be cacheable in a proxy server or cache. For subsequent requests the stored 103 could be sent downstream regardless of whether the final response is public or private.\r\n\r\nThe header field could follow the `Cache-Control` semantics. The `public` and `max-age=N` directives seem appropriate. A proxy server would have to store the Early Hint information apart from regular responses (e.g. 200) to not confuse it with a final response. When the field `Early-Hint-Control: public` is not present, the 103 response should not be stored.",
      "createdAt": "2017-07-30T14:30:20Z",
      "updatedAt": "2017-08-01T00:58:36Z",
      "closedAt": "2017-07-31T12:56:05Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The early hints document has completed both WG and IETF last call so it should not be re-opened for new features.\r\n\r\nIt sounds like you're suggesting new work - and httpbis is open to taking on new work. You should suggest that, even better with a draft, on the mailing list.\r\n\r\nThanks.\r\n",
          "createdAt": "2017-07-31T12:56:05Z",
          "updatedAt": "2017-07-31T12:56:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Also, this is a general problem with the HTTP caching model, not specific to 103. See:\r\nhttpwg/http11bis#29",
          "createdAt": "2017-08-01T00:58:35Z",
          "updatedAt": "2017-08-01T00:58:35Z"
        }
      ]
    },
    {
      "number": 382,
      "id": "MDU6SXNzdWUyNTAwMjY5NTQ=",
      "title": "wglc cache digest editorial feedback reschke",
      "url": "https://github.com/httpwg/http-extensions/issues/382",
      "state": "OPEN",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "cache-digest",
        "editorial"
      ],
      "body": "https://lists.w3.org/Archives/Public/ietf-http-wg/2017JulSep/0263.html\r\n\r\nSome editorial feedback:\r\n\r\n1) ABNF list rule reference has wrong section \r\n(https://github.com/httpwg/http-extensions/pull/376)\r\n\r\n2) Throughout s/header/header field/\r\n\r\n3) \r\n<https://www.greenbytes.de/tech/webdav/draft-ietf-httpbis-cache-digest-02.html#rfc.section.5.p.4>:\r\n\r\n\"TODO: discuss how effective the suggested mitigations actually would be.\"\r\n\r\n4) Please avoid lowercase BCP 14 keywords such as \"may\", or invoke \r\n<https://tools.ietf.org/html/rfc8174>\r\n\r\nBest regards, Julian",
      "createdAt": "2017-08-14T13:13:43Z",
      "updatedAt": "2019-07-10T08:00:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Left to do:\r\n\r\n1. Throughout s/header/header field/\r\n2. https://www.greenbytes.de/tech/webdav/draft-ietf-httpbis-cache-digest-02.html#rfc.section.5.p.4: \"TODO: discuss how effective the suggested mitigations actually would be.\"\r\n3. Please avoid lowercase BCP 14 keywords such as \"may\", or invoke https://tools.ietf.org/html/rfc8174\r\n",
          "createdAt": "2019-07-10T07:59:41Z",
          "updatedAt": "2019-07-10T08:00:24Z"
        }
      ]
    },
    {
      "number": 383,
      "id": "MDU6SXNzdWUyNTAyNDAxNDI=",
      "title": "HTML references",
      "url": "https://github.com/httpwg/http-extensions/issues/383",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "expect-ct"
      ],
      "body": "The spec currently references both HTML-the-living-spec (with potentially incorrect author information), and HTML 4.01. Only the latter is actually used.",
      "createdAt": "2017-08-15T07:25:00Z",
      "updatedAt": "2018-05-21T06:05:39Z",
      "closedAt": "2018-05-19T16:18:54Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It's not that cut-and-dried. ",
          "createdAt": "2017-08-15T23:19:30Z",
          "updatedAt": "2017-08-15T23:19:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Emily - there are a few things going on here:\r\n\r\n1. If you want to keep the WHATWG HTML reference, you need to actually use it.\r\n2. The WHATWG has moved away from listing document authors, so you'll need to reflect that.\r\n3. How to reference HTML is a thorny issue. I personally think the right thing to do is reference both the WHATWG and W3C specifications; YMMV. \r\n4. Referencing \"living documents\" may cause some issues/discussion in IETF evaluation. However, we're going to need to figure out how to do that, as we're starting to have more dependencies on WHATWG documents, so don't take that as discouragement from referencing them.",
          "createdAt": "2018-05-07T23:09:27Z",
          "updatedAt": "2018-05-07T23:09:27Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, I don't think this is going to work, because references appear in a \"MUST NOT\" statement, but are listed as informative. ",
          "createdAt": "2018-05-21T06:05:39Z",
          "updatedAt": "2018-05-21T06:05:39Z"
        }
      ]
    },
    {
      "number": 386,
      "id": "MDU6SXNzdWUyNTMxNDAwODQ=",
      "title": "AUTH48 changes for rfc5987bis",
      "url": "https://github.com/httpwg/http-extensions/issues/386",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "reschke"
      ],
      "labels": [
        "5987bis",
        "editorial"
      ],
      "body": "",
      "createdAt": "2017-08-27T04:17:59Z",
      "updatedAt": "2017-09-15T06:34:48Z",
      "closedAt": "2017-09-15T06:34:48Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(closed as the document has already been removed from git)",
          "createdAt": "2017-08-27T05:30:48Z",
          "updatedAt": "2017-08-27T05:30:48Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/httpwg/http-extensions/commit/c86fae8ef053e57e90f3e70107ea003abbc45824",
          "createdAt": "2017-09-01T08:14:29Z",
          "updatedAt": "2017-09-01T08:14:29Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/httpwg/http-extensions/commit/5fdb37e44485d812ac4bcf997057afd811a7c90a",
          "createdAt": "2017-09-01T08:14:59Z",
          "updatedAt": "2017-09-01T08:14:59Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Published as RFC 8187.",
          "createdAt": "2017-09-15T06:34:48Z",
          "updatedAt": "2017-09-15T06:34:48Z"
        }
      ]
    },
    {
      "number": 388,
      "id": "MDU6SXNzdWUyNTQzOTM2OTk=",
      "title": "How does the CSP syntax fit into the header structure?",
      "url": "https://github.com/httpwg/http-extensions/issues/388",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-01?#appendix-A surveys the 723* RFCs but not, for example, https://www.w3.org/TR/CSP2/#content-security-policy-header-field. You probably should include that example of structured data in your analysis.\r\n\r\nhttps://github.com/WICG/feature-policy/issues/78 proposes to extend the CSP format into a new non-CSP header. Should they be considering draft-ietf-httpbis-header-structure?",
      "createdAt": "2017-08-31T16:26:06Z",
      "updatedAt": "2017-12-13T01:33:00Z",
      "closedAt": "2017-12-13T01:33:00Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Overcome by events.",
          "createdAt": "2017-12-13T01:33:00Z",
          "updatedAt": "2017-12-13T01:33:00Z"
        }
      ]
    },
    {
      "number": 389,
      "id": "MDU6SXNzdWUyNTQ2OTQwNTE=",
      "title": "SameSite Cookie Attribute - Is attribute-value required?",
      "url": "https://github.com/httpwg/http-extensions/issues/389",
      "state": "CLOSED",
      "author": "ericlaw1979",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "https://bugs.chromium.org/p/chromium/issues/detail?id=635882\r\n\r\nSection 3.1 of the spec states that \"SameSite\" alone (without an attribute value) is a valid token: https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00#section-3.1\r\n\r\nSection 4.1 https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00#section-4.1 states \r\n\r\n   1.  If \"cookie-av\"'s \"attribute-value\" is not a case-insensitive\r\n       match for \"Strict\" or \"Lax\", ignore the \"cookie-av\".",
      "createdAt": "2017-09-01T16:40:44Z",
      "updatedAt": "2018-04-11T06:43:21Z",
      "closedAt": "2018-04-11T06:43:21Z",
      "comments": [
        {
          "author": "ericlaw1979",
          "authorAssociation": "NONE",
          "body": "Ah.  https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00 draft is outdated vs. https://github.com/httpwg/http-extensions/edit/master/draft-ietf-httpbis-cookie-same-site.md. The latter no longer allows a bare \"SameSite\" token, and it calls for the cookie to be dropped in the event that the samesite-value isn't either \"strict\" or \"lax\".\r\n\r\nHowever, I think this text isn't quite right:\r\n\r\n  If `cookie-av`'s `attribute-value` is not a case-insensitive match for\r\n    \"Strict\" or \"Lax\", ignore the `cookie-av`.\r\n\r\nThe `cookie-av` in this case is 'SameSite=whatever' and we want to ignore the whole cookie, not just the invalid attribute?",
          "createdAt": "2017-09-07T17:16:36Z",
          "updatedAt": "2017-09-07T17:16:36Z"
        },
        {
          "author": "fmarier",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#574 is my proposal to fix this.\r\n\r\nWe ran into this issue in the Firefox implementation: https://bugzilla.mozilla.org/show_bug.cgi?id=1430803",
          "createdAt": "2018-04-09T19:06:07Z",
          "updatedAt": "2018-04-09T19:06:07Z"
        }
      ]
    },
    {
      "number": 391,
      "id": "MDU6SXNzdWUyNTU0NzUzMDk=",
      "title": "Early data that arrives after the handshake completes",
      "url": "https://github.com/httpwg/http-extensions/issues/391",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "The conclusion in the draft is that early data is relatively \"safe\" (for some definition of the term, see the draft for details) if the handshake is complete. Early data in a transport that provides ordered delivery will always arrive before the handshake completes. But this is not the case in QUIC, or anything like DTLS. We should offer some advice for these situations.\r\n\r\nFrom martinthomson/http-replay#43",
      "createdAt": "2017-09-06T04:14:04Z",
      "updatedAt": "2017-09-28T22:40:37Z",
      "closedAt": "2017-09-28T22:40:37Z",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "But can this *really* happen ? I mean, my understanding is that the handshake happens in response to a Hello message which also conveys early data. Can we have early data outside of a hello message, or may we receive a handshake response before a hello message ?",
          "createdAt": "2017-09-20T19:40:38Z",
          "updatedAt": "2017-09-20T19:40:38Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With reordering of packets in QUIC, you can get a packet that was sent before the handshake completes after the handshake completes.  The order of sending might be \"ClientHello, 0-RTT1, 0-RTT2, Client Finished\", but the server can get \"ClientHello, 0-RTT2, Client Finished, 0-RTT1\".  Early data is sent in separate packets (this is a hard rule right now, but we might change the format so that the packets can be sent together in future).\r\n\r\nThis is unlike TCP fast open where you only get to send the \"early data\" in the SYN segment.  You can send an awful lot of early data if you want.",
          "createdAt": "2017-09-25T06:46:55Z",
          "updatedAt": "2017-09-25T06:46:55Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "OK thanks for the explanation. I tend to think that such behaviours are\nout of the *current* scope of the draft but will fall into it as QUIC\nprogresses. Maybe all of this can be summarized (for now) as \"In case a\nTLS implementation supports receiving early data after the handshake\ncompletes, such early data has to be silently discarded\". That covers\nthis case for QUIC and any possible TLS implementation specificity or\neven bug.\n",
          "createdAt": "2017-09-26T03:28:43Z",
          "updatedAt": "2017-09-26T03:28:43Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that we might add \"... discarded unless the data can be unambiguously identified as being early data\" or something like that.  After all, it's not replayed data if the handshake completes, so I don't want to prohibit its use.  The main problem is that it's hard to properly identify and handle.\r\n\r\nFWIW, we debated this for our DTLS 1.3 implementation and chose to discard. That is the easiest answer.",
          "createdAt": "2017-09-26T06:18:54Z",
          "updatedAt": "2017-09-26T06:18:54Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "I'd still be tempted to simply discard for now, just to avoid the problems\nof confusing the client with an out-of-order handshake that may make it\nthink the \"late\" early data were lost while in the end they are considered.\nI'd rather avoid a client sending a request again as regular data and seeing\nthe server concatenate it with the late arrived early data for example. I\nreally think it's something we can improve later as the out-of-order use\ncases become more obvious. It would also offer us a safety belt allowing\nmore fancy stuff in QUIC, otherwise we could end up saying \"nah don't do\nthis or that, it could cause trouble with early data\". The rule might then\nbe relaxed. It will not affect TCP-based implementations anyway.\n",
          "createdAt": "2017-09-26T06:29:36Z",
          "updatedAt": "2017-09-26T06:29:36Z"
        }
      ]
    },
    {
      "number": 392,
      "id": "MDU6SXNzdWUyNTU0NzU0NTA=",
      "title": "Pick a status code",
      "url": "https://github.com/httpwg/http-extensions/issues/392",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "Can we just have 425 now that it's official-ish?\r\n\r\nFrom martinthomson/http-replay#37",
      "createdAt": "2017-09-06T04:15:14Z",
      "updatedAt": "2017-09-06T04:28:05Z",
      "closedAt": "2017-09-06T04:28:05Z",
      "comments": []
    },
    {
      "number": 394,
      "id": "MDU6SXNzdWUyNTU3Nzg1NzM=",
      "title": "table of contents is \"#rfc..toc\"",
      "url": "https://github.com/httpwg/http-extensions/issues/394",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mnot"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Note the two periods in the identifier.  It's screwing up the styling.  @reschke, this appears to be a product of your XSLT.  Can you see if this is a problem specific to this repo, or a more general one?",
      "createdAt": "2017-09-07T00:17:38Z",
      "updatedAt": "2017-09-11T00:37:45Z",
      "closedAt": "2017-09-07T12:41:26Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually caused by @mnot 's bootstrap modifications out of sync with the base XSLT.",
          "createdAt": "2017-09-07T05:50:57Z",
          "updatedAt": "2017-09-07T05:50:57Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ahh, we can assign this to @mnot then.",
          "createdAt": "2017-09-07T12:39:32Z",
          "updatedAt": "2017-09-07T12:39:32Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We could, but I already fixed the issue in https://github.com/httpwg/http-extensions/commit/e93b105d34f5a8418edcfe32193508e21ef7d83b",
          "createdAt": "2017-09-07T12:41:26Z",
          "updatedAt": "2017-09-07T12:41:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks! PR for upstream?",
          "createdAt": "2017-09-11T00:37:45Z",
          "updatedAt": "2017-09-11T00:37:45Z"
        }
      ]
    },
    {
      "number": 401,
      "id": "MDU6SXNzdWUyNTkyNzgxMjY=",
      "title": "Post-review notes, typos, editorial stuff only",
      "url": "https://github.com/httpwg/http-extensions/issues/401",
      "state": "CLOSED",
      "author": "wtarreau",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "This is what I found during a quiet throrough review : \r\n\r\n- paragraph 4: s/The client the retries the request/The client then retries the request  (s/the/then)\r\n\r\nWell, nothing else, the doc looks very exhaustive on all possible situations, all the interrogations that stemmed in my mind during the reading were answered a few lines later.\r\n",
      "createdAt": "2017-09-20T19:38:41Z",
      "updatedAt": "2017-09-27T22:10:32Z",
      "closedAt": "2017-09-27T22:10:18Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Glad to hear it Willy :)",
          "createdAt": "2017-09-27T22:10:32Z",
          "updatedAt": "2017-09-27T22:10:32Z"
        }
      ]
    },
    {
      "number": 410,
      "id": "MDU6SXNzdWUyNjE4MjEwNjY=",
      "title": "Avoid sending the digest when not used",
      "url": "https://github.com/httpwg/http-extensions/issues/410",
      "state": "OPEN",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "While discussing this, I heard raised concerns that:\r\n* Adding cache digest support as currently specced may result in sending the digest even in cases where it is not used. Since initially this is likely to be most cases, shipping support is likely to result in performance regressions.\r\n* OTOH, a digest negotiation mechanism is likely to result in an RTT worth of delay before the digest reaches the server.\r\n\r\nA mechanism to solve this may look something like:\r\n* Client SETTING parameter that tells the server \"I'm going to send a cache digest, wait for it\". If this setting is not present, the server should not wait for a digest before pushing.\r\n* Server SETTING parameter that tells the client \"I really like to get a cache digest next time around\"\r\n* Client implementations SHOULD/MUST maintain server preference for future sessions, and MAY not send a cache digest if a past session with that server did not include a \"I want a digest\" SETTING parameter.\r\n* On the very first connection to a server, the client's cache is empty, so not sending the digest in that case has no penalty.\r\n",
      "createdAt": "2017-09-30T05:57:57Z",
      "updatedAt": "2018-10-29T03:35:28Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Is it really a perf regression if the first RT is otherwise idle?",
          "createdAt": "2017-10-01T14:34:29Z",
          "updatedAt": "2017-10-01T14:34:29Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since a typical website connects to multiple hosts, and connections established to fetch subresources often contend on bandwidth with other subresource fetches, sending digests for nothing could result in uplink bandwidth contention, and could delay subresource requests from going up.",
          "createdAt": "2017-10-05T04:51:30Z",
          "updatedAt": "2017-10-05T04:51:30Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Related to the question of when to send the digest, there's also the question of which digests to send when a connection could be authoritative for many hostnames.  A certificate with multiple SANs, or worse yet, a wildcard subdomain?  A client likely won't want to send the digest for all origins if the set is large, but sending it just for the first origin isn't likely to be sufficient assuming that the page has resources on subdomains / related domains.",
          "createdAt": "2018-01-04T22:56:53Z",
          "updatedAt": "2018-01-04T22:56:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@MikeBishop the frame already has a slot for origin, so I think the approach would be to send separate digests for those origins you're interested in sending them for. If you find text that contradicts that (or if it isn't clear enough), or want to advocate another approach, open a separate issue?",
          "createdAt": "2018-02-01T07:39:12Z",
          "updatedAt": "2018-02-01T07:39:12Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, but it's not the mechanics of how to send digests for multiple domains that I'm questioning.  It's determining *which* domains to send.  I see the thrust of this issue as being that the spec currently provides mechanics, but a lack of guidance to clients on how to use it.\r\n\r\nThe domains are likely coalesced because there are subresources that span them.  So while the client might know it wants to make a request of www.example.com, the server knows it wants to push resources for img.example.com and dynamic.example.com as well, and needs to see those digests.\r\n\r\nFor HTTP/QUIC and variable-length settings, I would say the server sends a setting that's the list of domains it would like to see the digests for.  That's less feasible in HTTP/2's 32 bits.  (You could overload ORIGIN, but assuming that the desired set is less than all the origins the server supports....)",
          "createdAt": "2018-02-01T17:58:46Z",
          "updatedAt": "2018-02-01T17:58:46Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Or an extension flag on ORIGIN that indicates what origins the server wants CACHE_DIGEST for. Although arguably, simply getting an ORIGIN covering a given origin indicates interest in CD for it. If a server adds an origin to a connection, that's a pretty strong signal it expects to have requests for it.",
          "createdAt": "2018-02-02T03:49:56Z",
          "updatedAt": "2018-02-02T03:49:56Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that the draft already defines a way for a server to notify the client if it wants to see a digest (see [ACCEPT_CACHE_DIGEST parameter](http://httpwg.org/http-extensions/draft-ietf-httpbis-cache-digest.html#the-acceptcachedigest-settings-parameter)). However, the information is currently tied to the connection instead of the origin.\r\n\r\nThat said, one way of addressing the issue would be to add a way to define per-origin settings to the ORIGIN frame. Considering the fact that the use of the SETTINGS parameters is the suggested way for negotiating features, it would be natural to provide the opportunity to use them at a per-origin basis.",
          "createdAt": "2018-02-02T05:38:02Z",
          "updatedAt": "2018-02-02T05:38:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "A client->server \"I'm going to send a CD, you might not want to push until you see it\" setting sounds reasonable to me. I would imagine that clients that support CD will always send it; servers that think they know better can ignore it, of course.\r\n\r\nACCEPT_CACHE_DIGEST seems like it's optimised for the case that the browser doesn't want to send CD until it knows the server wants it, and it's OK if it doesn't show up in the first RT or two of the connection -- i.e., the client sends it sometime after the first request, and everyone is willing to wear a bit of inefficiency in the first few pushes, because we assume that there will be further interactions on the connection that can benefit from CD.\r\n\r\nI think I agree that doesn't work so well for 3rd party content. \r\n\r\nHowever, making settings persistent beyond  the scope of a connection is something we've shied away from in the past; it's effectively defining a new kind of cache. Also, from a developer experience perspective, emitting new SETTINGS is not easy from some servers (never mind load balancers, CDNs, etc).\r\n\r\nIf @mikewest's [Origin Policy](https://wicg.github.io/origin-policy/) had any life in it, that might be appropriate here. Alternatively, we could define a well-known resource for this sort of origin-wide HTTP configuration along the lines of [Site-Wide HTTP Headers](https://mnot.github.io/I-D/site-wide-headers/). \r\n\r\nThat would make the interaction something like:\r\n\r\n~~~\r\nc                                    s\r\n|   SETTING WAIT_FOR_MY_DIGEST       |\r\n|   SETTING I_WANT_HTTPSTUFF         |\r\n|         GET /whatever              |\r\n| +--------------------------------> |\r\n|                                    |\r\n|    PUSH /.well-known/httpstuff     |\r\n| <--------------------------------+ |\r\n|                                    |\r\n|        200 OK /whatever            |\r\n| <--------------------------------+ |\r\n|                                    |\r\n|        CACHE_DIGEST                |\r\n| +--------------------------------> |\r\n|                                    |\r\n|    PUSH some other stuff           |\r\n| <--------------------------------+ |\r\n|                                    |\r\n|                                    |\r\n\r\n\r\n\r\n\r\n~~~\r\n\r\nWDYT? Of course, we could also define a response header to do this, or a couple of other things.",
          "createdAt": "2018-02-12T00:46:54Z",
          "updatedAt": "2018-02-12T00:48:01Z"
        }
      ]
    },
    {
      "number": 412,
      "id": "MDU6SXNzdWUyNjc4OTUxMDc=",
      "title": "Single / Multiple headers?",
      "url": "https://github.com/httpwg/http-extensions/issues/412",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Should we allow splitting common structure data over multiple headers ?\r\n\r\nPro:\r\n\r\nAvoids size restrictions, easier on-the-fly editing\r\n\r\nContra:\r\n\r\nCannot act on any such header until all headers have been received.\r\n\r\nWe must define where headers can be split (between identifier and dictionary ?, in the middle of\r\ndictionaries ?)\r\n\r\nMost on-the-fly editing is hackish at best.\r\n\r\n_from the draft_",
      "createdAt": "2017-10-24T04:39:59Z",
      "updatedAt": "2018-01-30T00:38:53Z",
      "closedAt": "2018-01-30T00:38:53Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OBE; new draft allows them.",
          "createdAt": "2018-01-30T00:38:53Z",
          "updatedAt": "2018-01-30T00:38:53Z"
        }
      ]
    },
    {
      "number": 415,
      "id": "MDU6SXNzdWUyNzI4OTg0NjQ=",
      "title": "ABNF reference",
      "url": "https://github.com/httpwg/http-extensions/issues/415",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "rand-access-live"
      ],
      "body": "1) It should be RFC 5234, not RFC 4234\r\n2) If it's there, it should actually be mentioned somewhere in the spec.",
      "createdAt": "2017-11-10T11:10:57Z",
      "updatedAt": "2017-11-25T04:32:04Z",
      "closedAt": "2017-11-25T04:32:04Z",
      "comments": []
    },
    {
      "number": 416,
      "id": "MDU6SXNzdWUyNzMyNDIxOTI=",
      "title": "Expect-CT should be extended with concept of test reports",
      "url": "https://github.com/httpwg/http-extensions/issues/416",
      "state": "CLOSED",
      "author": "ivanr",
      "authorAssociation": "NONE",
      "assignees": [
        "estark37"
      ],
      "labels": [
        "expect-ct"
      ],
      "body": "Here's my use case: I am developing a testing tool (Hardenize), which analyses web site configuration and tries to determine if everything is in order. If I see Expect-CT on a site I need to know if the configured reporting endpoint is operational. It's all to easy for a reporting endpoint to break for whatever reason and without anyone noticing. I think this will be especially problematic for Expect-CT, which I would expect to be a \"quiet\" header.\r\n\r\nTo that end, I'd like to submit a test report and examine the response. For this to work properly, we need 1) an ability to indicate that a report is being submitted for testing purposes only and 2) for the server to be able to signal if the report is being accepted. With 1, the server can process the test response as it would a real one, but MAY delete it afterwards. With 2, the testing tool can determine if the endpoint is working correctly.\r\n\r\nFor #2, the RFC could be extended with section 3.3 Receiving a violation report, which could say that servers should respond with 200 if they are happy and able to receive a report for the indicated hostname, 4xx if there's something's wrong with the report (e.g., the indicated hostname is not known to the server), and 5xx if there is some other problem.",
      "createdAt": "2017-11-12T16:13:45Z",
      "updatedAt": "2018-02-26T21:24:31Z",
      "closedAt": "2018-02-26T21:24:31Z",
      "comments": []
    },
    {
      "number": 417,
      "id": "MDU6SXNzdWUyNzMyNDI2ODc=",
      "title": "Expect-CT reports should indicate failure mode (report only or enforcing)",
      "url": "https://github.com/httpwg/http-extensions/issues/417",
      "state": "CLOSED",
      "author": "ivanr",
      "authorAssociation": "NONE",
      "assignees": [
        "estark37"
      ],
      "labels": [
        "expect-ct"
      ],
      "body": "From an operational perspective, site operators need to be able to distinguish if Expect-CT failure  caused access to the site to be denied. In any organisation of non-trivial size it's likely that there will be a mixture of sites with report-only and enforcing policies. Thus, not all reports are equal. A failure of enforcing Expect-CT needs to be treated with urgency and perhaps an immediate action. Failures of report-only policies are not urgent and can be reviewed from time to time during normal working hours.",
      "createdAt": "2017-11-12T16:20:01Z",
      "updatedAt": "2018-02-26T21:16:01Z",
      "closedAt": "2018-02-26T21:16:01Z",
      "comments": []
    },
    {
      "number": 420,
      "id": "MDU6SXNzdWUyNzQ5MjUxNzM=",
      "title": "Support includeSubdomains in Expect-CT",
      "url": "https://github.com/httpwg/http-extensions/issues/420",
      "state": "CLOSED",
      "author": "devd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "expect-ct"
      ],
      "body": "It would provide immense security value and ease of deployment.\r\n\r\nCookies are sent across all sub domains; so if example.com has auth cookies, a malicious actor can compromise a CA and create a \"$random.example.com\" cert and serve it to get a user's cookies. Since example.com never knew about nor had ever served $random.example.com, the UA won't enforce CT requirement on this domain. This would mean a cert that's not on a CT log would work fine to get the user's cookies.\r\n",
      "createdAt": "2017-11-17T16:41:36Z",
      "updatedAt": "2018-05-19T15:58:16Z",
      "closedAt": "2018-05-19T15:58:16Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Prompted by @estark37's feedback on this, we discussed this in person during IETF 101.  The minutes don't capture this, but no one objected to the outcome that was proposed, except that @mnot hasn't uploaded his slides to httpwg/wg-materials, so I can't remember exactly what that was.",
          "createdAt": "2018-04-06T01:35:06Z",
          "updatedAt": "2018-04-06T01:35:06Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Her summary:\r\n\r\n> No major changes to the Expect-CT draft in a while -- only some minor tweaks to reporting (https://github.com/httpwg/http-extensions/issues/416, https://github.com/httpwg/http-extensions/issues/417). The open design issue is whether the header should have includeSubdomains support (https://github.com/httpwg/http-extensions/issues/420). I am not inclined to add this at the moment unless another implementer comes along and wants it. We are unlikely to implement it in Chrome because it's a moderately complex implementation and the marginal value is somewhat small considering that the full CT enforcement date is coming up so soon (April).",
          "createdAt": "2018-04-06T02:01:21Z",
          "updatedAt": "2018-04-06T02:01:21Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing per https://github.com/httpwg/http-extensions/issues/420#issuecomment-379127529",
          "createdAt": "2018-05-19T15:58:16Z",
          "updatedAt": "2018-05-19T15:58:16Z"
        }
      ]
    },
    {
      "number": 433,
      "id": "MDU6SXNzdWUyNzcyMzI1ODY=",
      "title": "Length limits on types",
      "url": "https://github.com/httpwg/http-extensions/issues/433",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "The current draft puts specific size limits on each type (e.g., lengths of strings, number of items in an array).\r\n\r\nThe rationale for including (generous) limits is that header authors often don't specify any limits, which puts implementations in an awkward position of deciding how much is \"too much\", leading to interoperability problems.\r\n\r\nIdeally each header author would define their own limits, tighter limits where necessary, making these a catch-all. \r\n\r\nWith that said, two questions:\r\n\r\n1)  Should we have such limits?\r\n\r\n2) If so, are the current limits correct? ",
      "createdAt": "2017-11-28T02:01:35Z",
      "updatedAt": "2018-05-23T02:37:29Z",
      "closedAt": "2018-05-23T02:37:29Z",
      "comments": [
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The limits allow fixed-space implementations, which is a good thing from a security point of view.\r\n\r\nWe should examine how long min/typ/max headers going up to the proposed limits come out.",
          "createdAt": "2018-02-17T20:42:31Z",
          "updatedAt": "2018-02-17T20:42:31Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in London; see:\r\n  https://github.com/httpwg/wg-materials/blob/gh-pages/ietf101/minutes.md#header-common-structure---mark-nottingham\r\n\r\nI think the most relevant question is whether we want to limit individual structures (beyond numbers, which are a special case; e.g., string length, number of items in a list, etc.), or whether we just want to limit header size. \r\n\r\n",
          "createdAt": "2018-03-28T06:20:21Z",
          "updatedAt": "2018-03-28T06:20:21Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "My main worry here is where this limit is allowed to be imposed. If someone goes beyond this limit, is there still a guarantee that the header can be obtained through a non-structured API? Or would implementations be allowed to have header-specific knowledge in the network stack and drop these headers on the floor there?",
          "createdAt": "2018-03-28T07:15:33Z",
          "updatedAt": "2018-03-28T07:15:33Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Leave that up to the individual header definitions? An implementation that knows whether a header is structured or not can know more specific semantics for that header.",
          "createdAt": "2018-03-28T08:25:51Z",
          "updatedAt": "2018-03-28T08:25:51Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Stepping back - to me, a large part of the motivation for including limits IMO is two things:\r\n\r\n1. To assure that there aren't arbitrary differences between the capabilities / built-in limits of implementations (thereby causing interop or even security issues).\r\n2. To provide fallback limits for authors who forget to specify them.\r\n\r\nI'd also observe that overall header length limits are imposed by HTTP implementations themselves, which is often going to be separate from structured header implementations.\r\n\r\nI think this convinces me that if we define limits, we should keep them  in their current form, and that they should probably be made pretty big (esp. strings) so that they are hit less often.\r\n\r\nCurrent limits / what I propose:\r\n\r\n* Dictionary - 1024 members / 4096 members\r\n* List - 1024 members / 4096 members\r\n* Parameterised Lists (items) - 256 items / 1024 items\r\n* Parameterised Lists (parameters per item) - 256 parameters / 256 parameters\r\n* Strings - 1024 characters / 8192 characters\r\n* Identifiers - 256 characters / 256 characters\r\n* Binary Content -  16384 bytes / 16384 bytes\r\n\r\nThat said, another approach would be to require parsers to support at least so many characters / items / etc., rather than fixing maximums. That would address (1) above but not (2). That might be OK, since overall header length will probably kick in as an abuse control before many of these.\r\n\r\nI think I like that latter approach, but am still getting used to it.\r\n\r\n@annevk - I think an implementation (whether server or client) *could* drop what it knows to be a structured header onto the floor if it violated the limits, but it wouldn't be required; the only requirement is on someone actually running as a parser.\r\n",
          "createdAt": "2018-03-30T00:46:08Z",
          "updatedAt": "2018-03-30T00:47:13Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Of course, if take that second approach, we'll be pretty much walking the same path as JSON numbers; good interop below the specified minimum, unknowable interop above it.",
          "createdAt": "2018-04-02T06:41:05Z",
          "updatedAt": "2018-04-02T06:41:05Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "> but it wouldn't be required\r\n\r\nI'm somewhat surprised that there's still that much optional behavior that in the long term can trip folks up.",
          "createdAt": "2018-04-02T12:21:32Z",
          "updatedAt": "2018-04-02T12:21:32Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@annevk you asked\r\n\r\n> Or would implementations be allowed to have header-specific knowledge in the network stack and drop these headers on the floor there?\r\n\r\n_allowed_ implies optionality. \r\n\r\nMy assumption was that you were asking (for example) if a HTTP-aware middle box (let's say it's a WAF / \"HTTP Firewall\") could be made aware of what headers are structured (side channel, pre-configured, whatever), and decide to drop non-conforming messages as a result.\r\n\r\nThat's going to be the case -- if someone wants to do that, they're going to do it, and there's not much we can do about it. By the same token, we can't require everyone to deploy these things. So, it's optional.\r\n\r\nWe *can* require certain behaviours when software parses HTTP headers that refer to this specification, and that's what this issue is about. We can't require every piece of software in the path that sees the HTTP header to pay attention to this spec, however; some of them are going to just see it as a \"dumb\" string, i.e., a current HTTP/1.1 header.\r\n\r\nA new version of HTTP might change that, if we can figure out how. But we're not doing that (yet).\r\n",
          "createdAt": "2018-04-02T23:32:42Z",
          "updatedAt": "2018-04-02T23:32:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK, my inclination is to take the second approach -- namely add some text that explains that what we specify are minimums, up to which interop is guaranteed, and beyond which is anybody's guess. \r\n\r\nThat allows implementations to do fixed-size implementations if they want, and future serialisations to make assumptions about sizes as well, without requiring failure if a limit is hit. \r\n\r\nDoes that make sense?",
          "createdAt": "2018-04-10T03:50:07Z",
          "updatedAt": "2018-04-10T03:50:07Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "See PR #578; comments / suggestions most welcome.",
          "createdAt": "2018-04-12T02:08:23Z",
          "updatedAt": "2018-04-12T02:08:23Z"
        }
      ]
    },
    {
      "number": 434,
      "id": "MDU6SXNzdWUyNzcyMzI5MTU=",
      "title": "Number(s)",
      "url": "https://github.com/httpwg/http-extensions/issues/434",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "There's been a wide-ranging discussion of numbers on-list.\r\n\r\nI *think* the current proposal is to define separate int and float type, with the former probably being 64 bits, and the latter probably being something like what's in the current draft. Both probably signed (?).\r\n\r\nFuture number types might be defined, but these should catch the majority of cases.",
      "createdAt": "2017-11-28T02:03:29Z",
      "updatedAt": "2018-02-01T07:25:42Z",
      "closedAt": "2018-02-01T07:25:42Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing as a proposal is in the draft; let's see if it sticks.",
          "createdAt": "2018-02-01T07:25:42Z",
          "updatedAt": "2018-02-01T07:25:42Z"
        }
      ]
    },
    {
      "number": 435,
      "id": "MDU6SXNzdWUyNzcyMzQ0MzE=",
      "title": "Ordering on parameters",
      "url": "https://github.com/httpwg/http-extensions/issues/435",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Should parameters on parameterised labels be ordered or unordered?",
      "createdAt": "2017-11-28T02:12:39Z",
      "updatedAt": "2018-02-01T06:56:39Z",
      "closedAt": "2018-02-01T06:56:39Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "See discussion on #281.",
          "createdAt": "2018-01-30T00:39:30Z",
          "updatedAt": "2018-01-30T00:39:30Z"
        }
      ]
    },
    {
      "number": 436,
      "id": "MDU6SXNzdWUyNzcyMzQ2OTA=",
      "title": "Trailing garbage",
      "url": "https://github.com/httpwg/http-extensions/issues/436",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "From Alex R on list:\r\n\r\nAFAICT, the top-level parsing algorithm in Section 3 is missing a\r\ncatch-all rule for trailing garbage. For example, right now, the\r\nfollowing malformed Item header field will pass all checks and return a\r\n\"valid\" String to the caller. It should throw a \"trailing garbage\" error\r\ninstead.\r\n\r\n Foo: \"valid\" garbage!\r\n\r\nWhen fixing that, tolerating trailing BWS may be a good idea.",
      "createdAt": "2017-11-28T02:14:05Z",
      "updatedAt": "2018-02-01T07:35:29Z",
      "closedAt": "2018-02-01T07:35:29Z",
      "comments": []
    },
    {
      "number": 437,
      "id": "MDU6SXNzdWUyNzcyMzQ3ODk=",
      "title": "Combining headers and list length",
      "url": "https://github.com/httpwg/http-extensions/issues/437",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "From Alex R on list:\r\n\r\nI understand the desire to limit this specification to parsing a single\r\nheader field or equivalent, leaving the Pandora box of combining\r\nsame-name fields closed. However, this honorable approach complicates\r\nplacing interoperability limits on the number of list members: An\r\napplication that parses individual fields (and possibly never combines\r\nthe results!) may not hit the limit that an application combining raw\r\nvalue strings before parsing would hit.\r\n\r\nIMHO, we should explicitly say something (conservative) about this\r\nproblem so that header generators know how the limits may be applied.\r\n",
      "createdAt": "2017-11-28T02:14:46Z",
      "updatedAt": "2018-02-01T07:23:37Z",
      "closedAt": "2018-02-01T07:23:37Z",
      "comments": []
    },
    {
      "number": 438,
      "id": "MDU6SXNzdWUyNzc0Njk5Njc=",
      "title": "ORIGIN-compliant clients and legacy servers",
      "url": "https://github.com/httpwg/http-extensions/issues/438",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The text in 2.4 says....\r\n\r\n> Once an Origin Set has been initialized... [lots of stuff]\r\n>\r\n> Additionally, clients MAY avoid consulting DNS to establish the connection\u2019s authority for new requests; however, those that do so face new risks, as explained in Section 4.\r\n\r\nI think part of our issue with how Edge implemented coalescing without considering DNS arises from the fact that this \"Additionally\" isn't clearly tied to being something that clients do \"Once an Origin Set has been initialized\" versus something that clients do in addition to the above behavior.",
      "createdAt": "2017-11-28T17:27:21Z",
      "updatedAt": "2017-11-29T00:32:11Z",
      "closedAt": "2017-11-29T00:32:11Z",
      "comments": []
    },
    {
      "number": 441,
      "id": "MDU6SXNzdWUyNzgxODQ5MzM=",
      "title": "Shouldn't the browser evict non-HttpOnly cookies first to avoid overwrite from JavaScript?",
      "url": "https://github.com/httpwg/http-extensions/issues/441",
      "state": "OPEN",
      "author": "securitybits",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "The current draft prevents cookies marked as 'Secure' from being overwritten or evicted from a non-secure origin (e.g., section 5.4), but it does nothing to prevent JavaScript from overwriting a cookie marked as 'HttpOnly' by evicting it from the cookie store. In current browsers it's therefore possible to tamper with the integrity of cookies marked with HttpOnly from JavaScript (e.g., XSS attack) despite the specification stating access should be restricted from non-HTTP APIs. \r\n\r\nIn my view we should protect both confidentiality and integrity for HttpOnly cookies, which could be done by adding a condition that cookies without the HttpOnly attribute should be evicted first when set from a non-HTTP API (e.g., JavaScript).",
      "createdAt": "2017-11-30T16:30:13Z",
      "updatedAt": "2020-01-30T12:23:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We now have SameSite cookies to consider too. Perhaps we should have a strict ordering of priority for these attributes and combinations of them?",
          "createdAt": "2018-12-18T17:50:32Z",
          "updatedAt": "2018-12-18T17:50:32Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I'm wary of changing eviction rules more than we already have. We ended up breaking some Google sites with our `Secure` prioritization, and ended up with a somewhat complicated scheme to use https://tools.ietf.org/html/draft-west-cookie-priority-00 to solve the problem. I'm a bit reluctant to go through that again without some commitment from Apple and Mozilla that they'd be willing to do the same in much the same timeframe.\r\n\r\n@johnwilander, @mozmark/@annevk: Is this something you could find out whether folks internally were interested in doing?",
          "createdAt": "2020-01-30T12:23:50Z",
          "updatedAt": "2020-01-30T12:23:50Z"
        }
      ]
    },
    {
      "number": 443,
      "id": "MDU6SXNzdWUyNzkxNDMzOTU=",
      "title": "Algorithm to parse lists doesn't allow parameterised values",
      "url": "https://github.com/httpwg/http-extensions/issues/443",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "http://httpwg.org/http-extensions/header-structure.html#parsing-a-list-from-textual-headers only parses items, while http://httpwg.org/http-extensions/header-structure.html#list says it should allow parameterised labels too.",
      "createdAt": "2017-12-04T20:46:26Z",
      "updatedAt": "2018-03-14T11:44:55Z",
      "closedAt": "2018-03-14T11:44:55Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Flipping to design, because this has some design implications.\r\n\r\nOne of my goals for processing is that a generic processor should be able to take any input and produce the appropriate structure (this isn't true at the very top level, which probably deserves a separate issue).\r\n\r\nSo, we need a way to distinguish parameterised labels from \"ordinary\" labels for parsers.\r\n\r\nThe most obvious way to do this would be to use a sigil, and the most obvious candidate is \";\" -- e.g.,\r\n\r\n    PLabelExample: ;foo; bar=baz; bat\r\n\r\nThat would make lists of plabels look like:\r\n\r\n    PLabelListExample: ;foo;bar, baz;bat=1\r\n\r\nI'm not crazy about the leading `;`, but I don't see any way to avoid having something there. Alternative approaches, or alternative syntax anyone?",
          "createdAt": "2018-02-01T23:12:12Z",
          "updatedAt": "2018-02-01T23:12:35Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "If you mark the entire list (so either: all its members are plabels, or all its members are items) that doesn't match the current design, which allows a mix of item / parameterised within the one list.  This is a reduction in capability, but not sure if YAGNI.\r\n\r\nAlternatively we could make the indication on a per-item basis; either as an extension to the list syntax (effectively marking up the separator), or modifying the types (so label and plabel are always unambiguously distinct.)  Which they are according the the ABNF, though not easily distinguished by the algorithm.\r\n\r\nSo another alternative is: don't provide algorithms. Or at least, not algorithms that are drastically different from the ABNF (branching on prefixes vs whole pattern matching.)  This is unambiguous, if ugly as sin, and stuff we've been dealing with for decades:\r\n\r\n```\r\nstructured_header = dictionary / list / parameterised / item\r\n\r\ndictionary        = dictionary_member *1023( OWS \",\" OWS dictionary_member )\r\ndictionary_member = label \"=\" item\r\n\r\nlist              = list_member 0*1023( OWS \",\" OWS list_member )\r\nlist_member       = item / parameterised\r\n\r\nparameterised     = label *256( OWS \";\" OWS label [ \"=\" item ] )\r\n\r\nitem              = integer / float / string / label / binary\r\n\r\ninteger           = [\"-\"] 1*19DIGIT\r\n\r\nfloat             = [\"-\"] (\r\n                      ; not copy-pasting the whole thing\r\n                    )\r\nstring            = DQUOTE 0*1024(char) DQUOTE\r\nchar              = unescaped / escape ( DQUOTE / \"\\\" )\r\nunescaped         = %x20-21 / %x23-5B / %x5D-7E\r\nescape            = \"\\\"\r\n\r\nlabel             = lcalpha *255( lcalpha / DIGIT / \"_\" / \"-\"/ \"*\" / \"/\" )\r\nlcalpha           = %x61-7A ; a-z\r\n\r\nbinary            = \"*\" 0*21846(base64) \"*\"\r\nbase64            = ALPHA / DIGIT / \"+\" / \"/\"\r\n```",
          "createdAt": "2018-02-04T03:21:09Z",
          "updatedAt": "2018-02-04T03:21:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Ah, sorry, my intent was to mark each plabel, but I messed up the list example.\r\n\r\nI'm not excited about dropping the algorithms; we've been dealing with the mess for a long time, yes, but it *is* a mess. But we'll see; for the time being, having the algorithms helps us clarify our intent really well, I think.",
          "createdAt": "2018-02-04T22:48:50Z",
          "updatedAt": "2018-02-04T22:48:50Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "`PLabelListExample: ;foo;bar, ;baz;bat=1` ?",
          "createdAt": "2018-02-05T01:23:30Z",
          "updatedAt": "2018-02-05T01:23:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes.",
          "createdAt": "2018-02-05T06:02:17Z",
          "updatedAt": "2018-02-05T06:02:17Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "If we replace 2.1 with a branch (\"if input_string starts with lcalpha then parse as plist, otherwise parse as item\") bare labels will fall out as plabels like `[foo, {}]`. Would that hurt anything? ",
          "createdAt": "2018-02-05T06:57:36Z",
          "updatedAt": "2018-02-05T06:57:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Bare labels are also used as the keys in dictionaries and parameters, so that seems... awkward. Also, it'd force everyone using labels to say \"take the first member of the tuple...\".\r\n\r\nAnother solution would be to serialise the label of PLABELs as uppercase on the wire.\r\n\r\nE.g., a mixed list could look like:\r\n\r\n> MixedListExample: 1, \"foo\", bar, BAZ;bat\r\n\r\n.. containing an integer, string, label and plabel with one empty parameter.\r\n\r\nDoes that seem too hacky? I kind of like the visual emphasis of the \"main\" label, but discriminating data structures based on case... hm.",
          "createdAt": "2018-02-16T03:10:31Z",
          "updatedAt": "2018-02-16T03:10:31Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> Bare labels are also used as the keys in dictionaries and parameters, so that seems... awkward.\r\n\r\nThis is only the algorithm for lists, and lists are the only structures where a label or a plabel could exist in the same place. (?)\r\n\r\n> Also, it'd force everyone using labels to say \"take the first member of the tuple...\".\r\n\r\nEveryone using *lists of* labels.  But then, don't they already have to do some extra work in this space, since `list_member = item / parameterised`?\r\n\r\n> Does that seem too hacky?\r\n\r\n```\r\nFoo-Bar: TEXT/HTML; charset=utf-8\r\n```\r\n:worried:\r\n\r\n```\r\nList-Of-Foo: TEXT/HTML; charset=utf-8, TEXT/PLAIN; charset=utf-8\r\nReference-To-Foo: text/html\r\n```\r\n:grimacing:",
          "createdAt": "2018-02-16T04:08:07Z",
          "updatedAt": "2018-02-16T04:08:07Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In addition to @phluid61's great points, the draft says a goal is to be useful for \"revisions of existing header field specifications\". Changing the spelling of parameterised labels would seem to give up on that.\r\n\r\nRe \"take the first member of the tuple\", I suspect the right wording for specifications is to talk about the label and its parameter map, not the tuple that the current parsing algorithm currently returns. Web specs would likely use [\"structs\"](https://infra.spec.whatwg.org/#structs) for this.",
          "createdAt": "2018-02-16T16:39:58Z",
          "updatedAt": "2018-02-16T16:39:58Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we should retain the algorithms, because if *we* cannot write concise readable code for parsing this stuff, we have already failed before we reached the door.\r\n\r\nWith respect to label and plabel I think the close naming messes with our brains: \"label\" is an identifier, \"plabel\" is more like a function call with parameters.  Maybe \"label\" should be renamed to \"ident\" ?\r\n\r\nThe fact that the parser cannot tell them apart until it sees the ';' or something else, is not different from telling integer/float apart until we spot the '.'",
          "createdAt": "2018-02-17T21:00:01Z",
          "updatedAt": "2018-02-17T21:00:01Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "It is different, though, because a float must contain a `.` and an integer must not; a plabel (whatever it's called) can have zero parameters, in which case it's indistinguishable from an item/label.  No matter how you rationalise it, the algorithm will have to choose whether to return a scalar or a tuple as long as it could be either.",
          "createdAt": "2018-02-18T22:04:46Z",
          "updatedAt": "2018-02-18T22:09:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@jyasskin I don't think that changing the serialisation gives up on existing headers, if the existing header is case-insensitive. And, at any rate, that's an aspirational goal -- there are many existing headers where that won't be possible already (because of subtle error handling that can't be changed).\r\n\r\nI think the heart of the issue is that all other non-top-level structures can be unambiguously identified, but because both label and plabel (or whatever we call it) can't, it's ambiguous.\r\n\r\nI think that means that we need to either a) make them unambiguous, or b) disallow plablels (or whatever we call them) in lists.",
          "createdAt": "2018-02-18T22:35:05Z",
          "updatedAt": "2018-02-18T22:35:05Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> or b) disallow plablels (or whatever we call them) in lists.\r\n\r\nOr b(ii): split list into list-of-items and list-of-parameterised.\r\n\r\nIf top-level structures already have side-channel information about their type, it doesn't matter that the two lists are potentially indistinguishable; and it means we can still recreate the `Accept` header with q-values[*].  To quote myself up-thread, this is a reduction in capability, but not sure if YAGNI. (By which I mean: will anybody ever need both a label and a plabel in the same list?)\r\n\r\n[*]: except for `*/*`",
          "createdAt": "2018-02-18T22:43:13Z",
          "updatedAt": "2018-02-18T22:44:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Good point, @phluid61. That seems viable; still not sure what I prefer :)",
          "createdAt": "2018-02-18T22:44:29Z",
          "updatedAt": "2018-02-18T22:44:29Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I feel I should point out, the two _list_ examples in the current text are for a \"list of ~~labels~~ identifiers\" and a \"list of parameterised labels\".  While theoretical future use-case loving me appreciates supporting mixed-type arrays, I wonder how far we need to take it.",
          "createdAt": "2018-02-20T03:43:54Z",
          "updatedAt": "2018-02-20T03:43:54Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "What do other folks think about @phluid61's @b(ii)? @bsdphk?",
          "createdAt": "2018-02-20T04:42:37Z",
          "updatedAt": "2018-02-20T04:42:37Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "b(ii) WFM",
          "createdAt": "2018-02-22T08:18:30Z",
          "updatedAt": "2018-02-22T08:18:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@bsdphk @phluid61 have a quick look at the commit above? Would like to publish a new draft soon.",
          "createdAt": "2018-03-01T02:43:23Z",
          "updatedAt": "2018-03-01T02:43:23Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "(btw as I did this, I came to really like this approach)",
          "createdAt": "2018-03-01T02:43:55Z",
          "updatedAt": "2018-03-01T02:43:55Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me, once you fix the number problems @jyasskin pointed out.",
          "createdAt": "2018-03-01T05:13:59Z",
          "updatedAt": "2018-03-01T05:13:59Z"
        }
      ]
    },
    {
      "number": 445,
      "id": "MDU6SXNzdWUyODAxNDEwODI=",
      "title": "secondary certs: references in abstract",
      "url": "https://github.com/httpwg/http-extensions/issues/445",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "...are not supposed to be there:\r\n\r\nhttps://tools.ietf.org/idnits?url=https://tools.ietf.org/id/draft-ietf-httpbis-http2-secondary-certs-00.txt",
      "createdAt": "2017-12-07T14:03:58Z",
      "updatedAt": "2017-12-09T07:54:50Z",
      "closedAt": "2017-12-09T07:54:50Z",
      "comments": []
    },
    {
      "number": 449,
      "id": "MDU6SXNzdWUyODE2MDEzMTg=",
      "title": "Editor draft links are broken (404)",
      "url": "https://github.com/httpwg/http-extensions/issues/449",
      "state": "CLOSED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [
        "martinthomson",
        "MikeBishop"
      ],
      "labels": [
        "meta"
      ],
      "body": "On https://github.com/httpwg/http-extensions, pointers to editor drafts all return 404s:\r\n\r\n- http://httpwg.org/http-extensions/rand-access-live.html\r\n- http://httpwg.org/http-extensions/client-hints.html\r\n- http://httpwg.org/http-extensions/key.html\r\n- ...\r\n\r\nDid something change / break recently?",
      "createdAt": "2017-12-13T02:09:28Z",
      "updatedAt": "2017-12-13T07:01:28Z",
      "closedAt": "2017-12-13T07:01:28Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes, see #448 *ahem* \r\n\r\n/cc @MikeBishop @martinthomson ",
          "createdAt": "2017-12-13T02:10:34Z",
          "updatedAt": "2017-12-13T02:10:34Z"
        }
      ]
    },
    {
      "number": 450,
      "id": "MDU6SXNzdWUyODE2NDQ3OTE=",
      "title": "Remove the \"Fork me on Github\" banner on editors' drafts",
      "url": "https://github.com/httpwg/http-extensions/issues/450",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [
        "martinthomson",
        "MikeBishop"
      ],
      "labels": [
        "meta"
      ],
      "body": "As it's repellant. ",
      "createdAt": "2017-12-13T07:03:00Z",
      "updatedAt": "2017-12-13T21:18:48Z",
      "closedAt": "2017-12-13T21:18:48Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hmm, still seems to be there after a build...",
          "createdAt": "2017-12-13T20:57:08Z",
          "updatedAt": "2017-12-13T20:57:08Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This should be OK now based on the changes I made in the template repo.",
          "createdAt": "2017-12-13T21:18:48Z",
          "updatedAt": "2017-12-13T21:18:48Z"
        }
      ]
    },
    {
      "number": 453,
      "id": "MDU6SXNzdWUyODE5NTQ0MTI=",
      "title": "Examples",
      "url": "https://github.com/httpwg/http-extensions/issues/453",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis",
        "editorial"
      ],
      "body": "Examples should include HTTP/1.1 headers, with both the request and response.",
      "createdAt": "2017-12-14T01:40:14Z",
      "updatedAt": "2018-02-13T04:25:34Z",
      "closedAt": "2018-02-13T04:25:34Z",
      "comments": []
    },
    {
      "number": 454,
      "id": "MDU6SXNzdWUyODE5NTQ1NTc=",
      "title": "Pervasive Monitoring is not the only reason",
      "url": "https://github.com/httpwg/http-extensions/issues/454",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis",
        "editorial"
      ],
      "body": "The bcp56bis draft currently says:\r\n\r\n\u201chttps\u201d is preferred to mitigate pervasive monitoring attacks [RFC7258].\r\nThis implies that this is the only reason. The best reasons are not even mentioned: authentication, confidentiality, and integrity.\r\n\r\n(from @martinthomson)",
      "createdAt": "2017-12-14T01:41:12Z",
      "updatedAt": "2018-01-30T01:42:49Z",
      "closedAt": "2018-01-30T01:42:49Z",
      "comments": []
    },
    {
      "number": 455,
      "id": "MDU6SXNzdWUyODE5NTQ2ODc=",
      "title": "Advice on transport ports",
      "url": "https://github.com/httpwg/http-extensions/issues/455",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "> Applications that use HTTP SHOULD use the default port for the URL scheme in use. \r\n\r\nThis isn't really necessary.  I would instead say that the port number is in the URL and cite [Initial URL Discovery](https://mnot.github.io/I-D/bcp56bis/#initial-url-discovery) for details.\r\n\r\nThen explain that if you are bootstrapping from a bare hostname with `.well-known`, then this should assume the use of the default port for the scheme unless there are very good reasons.  In particular, when it comes to using port numbers other than the default, you can note that there are privacy implications (it makes your protocol distinguishable) and deployment implications (some middleboxes might interfere with the operation of your protocol).\r\n\r\n(from @martinthomson)",
      "createdAt": "2017-12-14T01:42:12Z",
      "updatedAt": "2018-02-22T05:09:49Z",
      "closedAt": "2018-02-22T05:09:49Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Does anything stop someone from saying \"my application looks up the well-known HTTPS url on  port nnnn...\"?\r\n\r\nShould it? (doing wellknownbis now...).",
          "createdAt": "2018-02-13T04:25:37Z",
          "updatedAt": "2018-02-13T04:25:37Z"
        }
      ]
    },
    {
      "number": 456,
      "id": "MDU6SXNzdWUyODE5NTQ4MTU=",
      "title": "Any room for 6648",
      "url": "https://github.com/httpwg/http-extensions/issues/456",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis",
        "editorial"
      ],
      "body": "bcp56bis says\r\n\r\n> In particular, if a header field is specific to an application, an identifier for that application SHOULD form a prefix to the header field name, separated by a \u201c-\u201c.\r\n\r\nThis might tempered by a reference to RFC 6648 so that people don't get the mistaken impression that prefixing is a universal good.  The important qualification here is that the header field is specific to that application, which probably needs emphasis.",
      "createdAt": "2017-12-14T01:43:03Z",
      "updatedAt": "2018-02-05T00:25:59Z",
      "closedAt": "2018-02-05T00:25:59Z",
      "comments": []
    },
    {
      "number": 457,
      "id": "MDU6SXNzdWUyODE5NTQ5MzM=",
      "title": "Digest Auth",
      "url": "https://github.com/httpwg/http-extensions/issues/457",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Digest authentication is laughably weak; anything that uses it over HTTP is asking for trouble.\r\n\r\n(from @martinthomson)",
      "createdAt": "2017-12-14T01:43:54Z",
      "updatedAt": "2018-03-01T01:47:40Z",
      "closedAt": "2018-03-01T01:47:40Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Reopening; forgot that 7616 added algorithm agility.",
          "createdAt": "2018-02-14T01:35:15Z",
          "updatedAt": "2018-02-14T01:35:15Z"
        }
      ]
    },
    {
      "number": 458,
      "id": "MDU6SXNzdWUyODE5NTUwNDY=",
      "title": "Connections",
      "url": "https://github.com/httpwg/http-extensions/issues/458",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Don't depend on state in connection\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/ietf/SF3k5e76DmMjwtPz9Zt342Q0GSc",
      "createdAt": "2017-12-14T01:44:36Z",
      "updatedAt": "2018-02-13T04:44:25Z",
      "closedAt": "2018-02-13T04:44:25Z",
      "comments": []
    },
    {
      "number": 459,
      "id": "MDU6SXNzdWUyODE5NTU1MTg=",
      "title": "Size checks",
      "url": "https://github.com/httpwg/http-extensions/issues/459",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "Many of the algorithms in structured-headers are defined as taking input_string and returning a parsed X after modifying input_string to remove the X.  This is a pretty common way of building an inline parser.\r\n\r\nTake label, which describes an initial step of:\r\n\r\n> If input_string contains more than 256 characters, throw an error.\r\n\r\nBut a label can be followed by other things that will cause the overall string to exceed this length.  So this check is invalid.\r\n\r\nI'd recommend moving the size checks into the algorithm body.  If X exceeds length maxlen(X), then throw as you are scrubbing through.\r\n\r\n\r\n(from @martinthomson)",
      "createdAt": "2017-12-14T01:47:32Z",
      "updatedAt": "2018-02-01T07:25:08Z",
      "closedAt": "2018-02-01T07:25:08Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Depends on #433 ",
          "createdAt": "2018-01-30T01:01:52Z",
          "updatedAt": "2018-01-30T01:01:52Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Fixed by fa11bed7eaa2, I think. We may still omit length limits (see #433).",
          "createdAt": "2018-02-01T07:25:08Z",
          "updatedAt": "2018-02-01T07:25:08Z"
        }
      ]
    },
    {
      "number": 460,
      "id": "MDU6SXNzdWUyODE5NTU3Mjc=",
      "title": "URL schemes",
      "url": "https://github.com/httpwg/http-extensions/issues/460",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis",
        "editorial"
      ],
      "body": "> The resources identified by the new scheme will still be available with \"http\" and/or \"https\" URLs to clients. While it is possible to define the relationship between these resources in the new scheme's specification, existing HTTP software (such as clients, caches, intermediaries and servers) will not be available, so there is a danger of confusion when the \"wrong\" URL is used.\r\n\r\nI don't understand this statement, particularly \"existing HTTP software will not be available\". I think it's just a word or two missing but I don't know what's appropriate.\r\n\r\n(from @LPardue)",
      "createdAt": "2017-12-14T01:49:04Z",
      "updatedAt": "2018-02-05T00:25:59Z",
      "closedAt": "2018-02-05T00:25:59Z",
      "comments": []
    },
    {
      "number": 468,
      "id": "MDU6SXNzdWUyODYwNjM2Mjk=",
      "title": "Reuse of Exported Authenticator Context fields",
      "url": "https://github.com/httpwg/http-extensions/issues/468",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "The Request-ID and Cert-ID fields are currently matched with the Exported Authenticator context value.  These values are subject to certain randomness requirements:\r\n\r\n> The certificate_request_context MUST be unique within the scope of this connection (thus preventing replay of authenticators). The certificate_request_context SHOULD be chosen to be unpredictable to the peer (e.g., by randomly generating it) in order to prevent an attacker who has temporary access to the peer's private key from pre-computing valid authenticators.\r\n\r\nIn the current draft, Cert-ID and Request-ID are sender-local and required to be unique over the lifetime of a connection, but there's no randomizing/unpredictability requirement.  The simplest way to be unique is to be a counter, which is highly predictable.  To what extent do we need this property and how should we best accomplish it?  (Or do we just declare that it should be unpredictable and leave the issue to implementations?)",
      "createdAt": "2018-01-04T17:49:51Z",
      "updatedAt": "2018-04-09T20:07:23Z",
      "closedAt": "2018-04-09T20:07:23Z",
      "comments": [
        {
          "author": "grittygrease",
          "authorAssociation": "NONE",
          "body": "I'm fine with just declaring that it should be unpredictable.",
          "createdAt": "2018-01-05T19:54:24Z",
          "updatedAt": "2018-01-05T19:54:24Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems to be OBE.  The certificate_request_context in the current draft (stated in #481) is `the two-octet Request-ID as well as at least 96 bits of additional entropy.`  This seems sufficiently unpredictable, and the Request-ID is required to be unique, so even if it's a counter the combination should be both unique and unpredictable.\r\n\r\nCert-ID doesn't appear to be passed to the Exported Authenticator API at all, so that's a moot point.\r\n\r\n@grittygrease, @martinthomson, please re-open if you think there's more required to meet these requirements.",
          "createdAt": "2018-04-09T20:07:23Z",
          "updatedAt": "2018-04-09T20:07:23Z"
        }
      ]
    },
    {
      "number": 470,
      "id": "MDU6SXNzdWUyODgyNDUwNTk=",
      "title": "h2 net::ERR_SPDY_PROTOCOL_ERROR",
      "url": "https://github.com/httpwg/http-extensions/issues/470",
      "state": "CLOSED",
      "author": "1265578519",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\r\n![qq 20180113044248](https://user-images.githubusercontent.com/6442439/34895015-b5d4bd1c-f81e-11e7-8d41-2fc739d1023a.png)\r\n![3](https://user-images.githubusercontent.com/6442439/34895016-b6084402-f81e-11e7-82c7-3c8f45c53cfb.png)\r\n![4](https://user-images.githubusercontent.com/6442439/34895017-b637afc6-f81e-11e7-9e4a-100fe9110427.jpg)\r\n\r\n\r\n![qq 20180113044248](https://user-images.githubusercontent.com/6442439/34895011-b1dead08-f81e-11e7-8d87-9ddeea427f03.png)\r\n",
      "createdAt": "2018-01-12T21:00:50Z",
      "updatedAt": "2018-01-13T01:43:23Z",
      "closedAt": "2018-01-13T01:43:23Z",
      "comments": [
        {
          "author": "1265578519",
          "authorAssociation": "NONE",
          "body": "\u4e92\u8054\u7f51\u4e0a\u975e\u5e38\u591a\u7684http2.0\u542f\u7528\u540e\u51fa\u73b0net::ERR_SPDY_PROTOCOL_ERROR\uff0c\u4f46\u662f\u90fd\u6ca1\u6709\u89e3\u51b3\u65b9\u6cd5",
          "createdAt": "2018-01-12T21:01:22Z",
          "updatedAt": "2018-01-12T21:01:22Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "This repository is for the specification, not implementation bugs.",
          "createdAt": "2018-01-13T01:43:23Z",
          "updatedAt": "2018-01-13T01:43:23Z"
        }
      ]
    },
    {
      "number": 471,
      "id": "MDU6SXNzdWUyODkwODk0NjE=",
      "title": "CONNECT: consider using ALPN registry for the :protocol values.",
      "url": "https://github.com/httpwg/http-extensions/issues/471",
      "state": "CLOSED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "h2-websockets"
      ],
      "body": "Please consider using the [ALPN protocol IDs registry] instead of the [HTTP Upgrade token registry] for the `:protocol` values in HTTP/2 extended CONNECT method, since it's more appropriate for the use case.\r\n\r\nThe only downside is that there is no `\"websocket\"` ALPN value, but that could be easily added.\r\n\r\nAlso, we should add `\"bytes\"` / `\"bytestream\"` to the registry, for the purpose of proxying arbitrary TCP connections over HTTP/2.\r\n\r\n[ALPN protocol IDs registry]: https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids\r\n[HTTP Upgrade token registry]: https://www.iana.org/assignments/http-upgrade-tokens/http-upgrade-tokens.xhtml\r\n\r\ncc @mcmanus ",
      "createdAt": "2018-01-16T23:17:35Z",
      "updatedAt": "2018-03-24T17:14:34Z",
      "closedAt": "2018-03-21T11:07:09Z",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "IMHO this would not be logical. CONNECT and Upgrade are really similar in that they are used to transport something over HTTP, and that something may very well be a TLS stream which itself contains its own ALPN.\r\n\r\nAnyway this should be discussed on the mailing list, not via issues here.",
          "createdAt": "2018-01-17T06:02:07Z",
          "updatedAt": "2018-01-17T06:02:07Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "discussed in london/101 and decided to not make a change",
          "createdAt": "2018-03-21T11:07:09Z",
          "updatedAt": "2018-03-21T11:07:09Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good, thanks for bringing this up to the forum!",
          "createdAt": "2018-03-23T03:05:48Z",
          "updatedAt": "2018-03-23T03:05:48Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Though, reading [IETF101 meeting notes](https://github.com/httpwg/wg-materials/blob/gh-pages/ietf101/minutes.md#bootstrapping-websockets) (sorry for missing it!), it seems that discussion was around using ALPN for negotiating WebSocket-over-HTTP/2 and not about `:protocol` values.",
          "createdAt": "2018-03-23T03:15:44Z",
          "updatedAt": "2018-03-23T03:15:44Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@PiotrSikora, those are the same topic.  The `:protocol` extension to CONNECT was defined for the primary purpose of using WebSockets over an HTTP/2 stream; it just happens to be a general-purpose mechanism we can use for other things too.  And I think the Upgrade registry, being an existing registry which contains protocols that HTTP can upgrade to is probably the right choice when defining a new sort of upgrade within HTTP.\r\n\r\nHowever, if we were redefining the Upgrade registry now, I'd argue for using the ALPN registry for both of these.  Fundamentally, they are both registries of tokens which identify an application-layer protocol which can run over a bytestream.  (Or collection of bytestreams, when used with QUIC.)  The only real restriction is that Upgrade requires that the protocol be able to answer the original HTTP request in the new protocol, which means there has to be a defined mapping between HTTP requests and whatever the new protocol is.\r\n\r\nThe currently-registered values are disjoint, but I wonder if perhaps HTTPter should consider merging the two registries?",
          "createdAt": "2018-03-24T17:14:34Z",
          "updatedAt": "2018-03-24T17:14:34Z"
        }
      ]
    },
    {
      "number": 473,
      "id": "MDU6SXNzdWUyOTAwNzkwNDI=",
      "title": "Non-canonical base64",
      "url": "https://github.com/httpwg/http-extensions/issues/473",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "http://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#binary says to \r\n> Let binary_content be the result of Base 64 Decoding [RFC4648] b64_content, synthesising padding if necessary.\r\n\r\nHowever, https://tools.ietf.org/html/rfc4648#section-3.5 says\r\n> decoders MAY chose to reject an encoding if the pad bits have not been set to zero.\r\n\r\nStructured headers should specify whether to reject these encodings. For example, do both `iZ` and `iQ` decode to 0x89 or is `iZ` an error?",
      "createdAt": "2018-01-19T19:17:00Z",
      "updatedAt": "2018-06-28T07:02:35Z",
      "closedAt": "2018-06-28T07:02:35Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Belatedly, I'd propose matching https://infra.spec.whatwg.org/#forgiving-base64-decode, which ignores pad bits and explicitly says that having 1 base64 character left over is an error.",
          "createdAt": "2018-01-30T17:13:19Z",
          "updatedAt": "2018-01-30T17:13:19Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see why we need to leave IETF land here. Just specify something that is well-defined and based on RFC 4648.",
          "createdAt": "2018-01-30T17:33:15Z",
          "updatedAt": "2018-01-30T17:33:15Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, matching the WHATWG spec doesn't mean we have to reference it. Just copy its behavior so web developers have only 1 thing to learn.",
          "createdAt": "2018-01-30T17:45:51Z",
          "updatedAt": "2018-01-30T17:45:51Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I don't particularly want to specify the algorithm for decoding base64 in detail here, since that's the purview of RFC4648 (and whatever follows it). I think we can address this by saying something like:\r\n\r\n> Decoders MUST NOT reject base64 encoded data if pad bits have not been set to zero; see [RFC4648], Section 3.5. Therefore, both \"YQ\" and \"YR\" decode to \"a\" (for example).\r\n\r\nDoes that work?",
          "createdAt": "2018-01-31T00:40:36Z",
          "updatedAt": "2018-01-31T00:40:36Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why would we want to be forgiving?  That's an end state you reach when [your ecosystem has rotted](https://martinthomson.github.io/postel-was-wrong/draft-thomson-postel-was-wrong.html).",
          "createdAt": "2018-01-31T03:31:53Z",
          "updatedAt": "2018-01-31T03:31:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It's worth noting that the rest of structured headers is currently pretty draconian, so as to prevent such rot. Not sure that having one thing to learn is worth the tradeoff -- especially when the vast majority will be using tools that *should* get this right.",
          "createdAt": "2018-01-31T04:02:42Z",
          "updatedAt": "2018-01-31T04:02:42Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My main goal is to define *something*, so being strict is fine with me.",
          "createdAt": "2018-01-31T04:06:06Z",
          "updatedAt": "2018-01-31T04:06:06Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "See how that works - happy to reopen.",
          "createdAt": "2018-02-01T06:42:12Z",
          "updatedAt": "2018-02-01T06:42:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Reopening, as a spot check of Python and NodeJS lead me to believe that it's common to be forgiving here in the language-provided base64 implementations. While someone *could* write a strict implementation (e.g., in a browser), it's going to be an uphill battle to require it with so many defaulting to not enforce this.",
          "createdAt": "2018-02-19T23:18:44Z",
          "updatedAt": "2018-02-19T23:18:44Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Re-reopening, as implementation feedback and a quick look through common b64 libraries suggests that it's hard to get many of them to produce an error upon non-zero pad bits, and AFAICT all of them can be configured to allow non-zero pad bits. \r\n\r\nThis suggests that for interop, it's best to require that non-zero pad bits be allowed.",
          "createdAt": "2018-06-13T06:18:38Z",
          "updatedAt": "2018-06-13T06:18:38Z"
        }
      ]
    },
    {
      "number": 474,
      "id": "MDU6SXNzdWUyOTI4NjE5Nzk=",
      "title": "0-length binary content?",
      "url": "https://github.com/httpwg/http-extensions/issues/474",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "https://tools.ietf.org/html/draft-yasskin-http-origin-signed-responses-02#section-3.8.3 would like to allow clients to pass a 0-length binary string (as a prefix that matches anything), but https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-02#section-4.5 requires at least 1 base64 character. Does it make sense to allow 0-length content?\r\n\r\n(If not, you should at least start with 2 characters, since 1 character isn't valid base64 since it doesn't specify a whole octet.)",
      "createdAt": "2018-01-30T17:05:15Z",
      "updatedAt": "2018-02-01T23:32:47Z",
      "closedAt": "2018-02-01T23:32:47Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Fixed in 9b495e31.",
          "createdAt": "2018-02-01T23:32:46Z",
          "updatedAt": "2018-02-01T23:32:46Z"
        }
      ]
    },
    {
      "number": 475,
      "id": "MDU6SXNzdWUyOTM0MjUyMjg=",
      "title": "Number algorithm",
      "url": "https://github.com/httpwg/http-extensions/issues/475",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "doesn't enforce syntactic limits.",
      "createdAt": "2018-02-01T07:08:35Z",
      "updatedAt": "2018-04-02T23:26:39Z",
      "closedAt": "2018-04-02T23:26:39Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Could be related to #479 (the higher-order issue being that algorithms and ABNF aren't exactly 1:1), in which case it's probably part of #477.",
          "createdAt": "2018-02-04T02:48:59Z",
          "updatedAt": "2018-02-04T02:48:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I just meant that what's there is only a sketch :)",
          "createdAt": "2018-02-16T03:11:40Z",
          "updatedAt": "2018-02-16T03:11:40Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Just call me the problem dwarf.  (I dig too deep.)\r\n\r\nInteger is a weird one, though.  The ABNF limits input to 19 characters (plus hyphen), the prose restricts output values, and the algorithm glosses the actual transformation of characters to value.  So the authoritative specification is all over the place.\r\n\r\nDo you have to choose which part is more authoritativer (#477) before you can work out how to flesh out the sketch?",
          "createdAt": "2018-02-16T04:32:44Z",
          "updatedAt": "2018-02-16T04:32:44Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Both integer and float ABNF allows leading zeros.  Do we want that ?",
          "createdAt": "2018-02-17T21:34:53Z",
          "updatedAt": "2018-02-17T21:34:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Probably not.",
          "createdAt": "2018-02-18T21:37:17Z",
          "updatedAt": "2018-02-18T21:37:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@bsdphk said: \"Does step 3 & 4 need to say something explicit about failing if they get \"22-22-22-22\" as input ?\"",
          "createdAt": "2018-03-05T23:07:14Z",
          "updatedAt": "2018-03-05T23:07:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "WRT leading zeros -- I suspect they'll be allowed in almost all environments, so disallowing them invites differences in implementation. Is there a good reason for disallowing them, given we have overall length limits?",
          "createdAt": "2018-04-02T06:28:31Z",
          "updatedAt": "2018-04-02T06:28:31Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@phluid61 #477 is closed, so please take a crack if you'd like.",
          "createdAt": "2018-04-02T06:32:40Z",
          "updatedAt": "2018-04-02T06:32:40Z"
        }
      ]
    },
    {
      "number": 476,
      "id": "MDU6SXNzdWUyOTM3MjA2NTY=",
      "title": "Identifying top-level data types",
      "url": "https://github.com/httpwg/http-extensions/issues/476",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Right now, Structured Headers allows the following types at the top level:\r\n\r\n* Dictionaries\r\n* Lists\r\n* Parameterised Labels\r\n* Items\r\n\r\nItems' types can be identified by inspecting their first character, and #443 covers parameterised labels.\r\n\r\nHowever, there isn't any easy way for a parser to identify whether the top-level data type is a dictionary or a list. As a result, a parser will need a hint as to what kind of top-level data type is expected for a given header.\r\n\r\nIt seems like the options are:\r\n\r\n1) Make it possible to distinguish these data types on the wire; e.g., dictionaries start with `{`, lists start with `[`.\r\n\r\n2) Require parsers to have external information about what's being parsed, at least at the top level. E.g., the parser could expose four functions, `parseList`, `parseDict`, `parsePlabel`, `parseItem`.\r\n",
      "createdAt": "2018-02-01T23:26:06Z",
      "updatedAt": "2018-03-28T06:25:09Z",
      "closedAt": "2018-02-22T08:21:01Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Personally, I'm leaning towards (2). Someone using a parser for a given header is going to need more information about its structure and semantics to use it anyway. \r\n\r\nI _think_ the only reason we'd want to do (1) is if we have a strong use case for being able to parse the header without any such context. I suppose one could write a linter or debugger that wants to check structured headers for correctness (e.g., <https://redbot.org/>), but I don't know that it's worth the discontinuity with \"traditional\" HTTP header syntax (which so far we've largely maintained).",
          "createdAt": "2018-02-01T23:28:48Z",
          "updatedAt": "2018-02-01T23:28:48Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I wrote a very quick Ruby script the other day to try out the algorithms, and I went with the extra top-level metadata. For a header value to get fed into this parser, either: something already knows it's a common structure header value, so there's no reason it wouldn't know _which_ structure; or: it's throwing things at the wall to see what sticks, in which case it can already deal with backtracking/trying other types/etc.",
          "createdAt": "2018-02-04T02:45:52Z",
          "updatedAt": "2018-02-04T02:45:52Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Incidentally:\r\n\r\n> Items' types can be identified by inspecting their first character\r\n\r\nA bare lowercase word is either a parameterised label or an item (label), so it's not just list/dict.  However this is true even if you match against the entire ABNF.",
          "createdAt": "2018-02-04T11:40:39Z",
          "updatedAt": "2018-02-04T11:41:28Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One argument against 2 is that it robs future HPACK-oids of a clue to what they're being asked to compress.\r\n\r\nOne argument against 1 is that not having a type-marker reduces the chance of somebody defining a header as \"Either a list or a dict\".\r\n\r\nI don't think I could personally make the call without a coin.\r\n\r\n",
          "createdAt": "2018-02-17T20:37:58Z",
          "updatedAt": "2018-02-17T20:37:58Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another argument against 1:\r\n\r\nYes, \"items\" can be spotted by looking at the first char.\r\n\r\nBut you cannot tell integer from float until you run into a '.' or something else later.\r\n\r\nSimilarly label/plabel cannot be told apart until you run into a ';' or something else later.\r\n\r\nSo the real question seems to me to be if we want to be able to tell all the types apart from the first char ?\r\n\r\nGiven how simple our parsing rules are, I tend to say no, and thus no prefix-char on list/dict.\r\n",
          "createdAt": "2018-02-17T21:08:56Z",
          "updatedAt": "2018-02-17T21:08:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@bsdphk I don't understand the argument against 1; how does that prevent someone from saying \"list or dict\"? (not that I think that's going to be common, or even desirable).\r\n\r\nAs @phluid61 mentioned elsewhere, label/plabel is the \"special\" one, and something we need to fix. Otherwise, it's not *necessarily* the first character, but it does need to be deterministic (e.g., you can't reliably identify a structure if doing so relies on an optional part of the structure, which is currently the case with plabel).\r\n\r\nSame with list/dict; e.g., currently, I can't examine a header without external information and tell whether something is an item or a single-member list. \r\n\r\nThat matters if the consumer is expecting a particular structure.",
          "createdAt": "2018-02-18T22:42:22Z",
          "updatedAt": "2018-02-18T22:42:22Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"list or dict\":  If your parser insist you tell you which up front, 'or' is not possible. (Well, retries etc, but)\r\n\r\nAnd yes, a parser can tell if it is a dict or list as is, just not from the first non-OWS char, but we can't tell integer and float apart either that way, so I don't think that matters.\r\n\r\nsingle-item list vs item:  Keep it simple:  Remove the text about headers being an item and force people to use either dict or list and note explicitly that lists can be restricted to length==1 ?\r\n\r\n",
          "createdAt": "2018-02-19T09:38:34Z",
          "updatedAt": "2018-02-19T09:38:34Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "That's attractive, but it shifts the burden to those specifying single-item header fields; they now need to say what to do when the field value doesn't have exactly one member, whereas before saying it's an item (of whatever sort) took care of that.\r\n\r\nFor me, *the* major goal of this spec is to leave as few traps for the unwary as possible.\r\n\r\nTo be clear, I think that having parsers expose multiple functions is fine, and I don't think we need to prefix lists or dicts; IMO we can close this issue with no action. The real issue to fix that we're bleeding into is #443.",
          "createdAt": "2018-02-19T23:04:02Z",
          "updatedAt": "2018-02-19T23:04:02Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "WFM",
          "createdAt": "2018-02-22T08:14:40Z",
          "updatedAt": "2018-02-22T08:14:40Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "FWIW, I think the main downside of this is that we cannot offer a simple JavaScript API in the form of `.get(headerName)` that returns the appropriate object. Instead callers will always have to supply the expected type as well (i.e., `get(headerName, headerType)`). (Or we'd have to have built-in support for header name <> type mapping, but that doesn't scale and will lead to all kinds of interoperability issues.)",
          "createdAt": "2018-03-28T06:25:08Z",
          "updatedAt": "2018-03-28T06:25:08Z"
        }
      ]
    },
    {
      "number": 477,
      "id": "MDU6SXNzdWUyOTM3MjE0MDg=",
      "title": "Talk about conformance requirements",
      "url": "https://github.com/httpwg/http-extensions/issues/477",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "In particular, the relationship between 2119 requirements, ABNF and algorithms.",
      "createdAt": "2018-02-01T23:29:46Z",
      "updatedAt": "2018-04-02T06:32:28Z",
      "closedAt": "2018-04-02T06:32:28Z",
      "comments": []
    },
    {
      "number": 479,
      "id": "MDU6SXNzdWUyOTQwNjI2MTg=",
      "title": "Dictionary parsing - trailing comma",
      "url": "https://github.com/httpwg/http-extensions/issues/479",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "The dict parsing algorithm currently allows a trailing comma (and OWS). \r\n\r\nIs the comma intentional?",
      "createdAt": "2018-02-03T00:20:44Z",
      "updatedAt": "2018-02-16T03:15:16Z",
      "closedAt": "2018-02-16T03:15:16Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "The ABNF doesn't allow it.",
          "createdAt": "2018-02-04T02:34:08Z",
          "updatedAt": "2018-02-04T02:34:08Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Could just change \"2. While input_string is not empty:\" to \"2. In a loop:\"\r\n\r\nI think that also makes steps 3 and 4 unreachable.",
          "createdAt": "2018-02-04T02:38:23Z",
          "updatedAt": "2018-02-04T02:38:23Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "My plan was to add a step at the bottom of the loop \"if input_string is empty, fail parsing.\"\r\n\r\nQuestion is whether we want to be tolerant of trailing commas. Based upon the approach we seem to be taking elsewhere, I think we probably don't want to be. That means that this would fail:\r\n\r\n> FooHeader: bar,baz,\r\n\r\n... and this would as well:\r\n\r\n> FooHeader: bar, baz\r\n> FooHeader:\r\n\r\nI think I'm comfortable with that.",
          "createdAt": "2018-02-04T22:54:11Z",
          "updatedAt": "2018-02-04T22:54:11Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "+1",
          "createdAt": "2018-02-05T07:18:31Z",
          "updatedAt": "2018-02-05T07:18:31Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "(The ticket talks about dictionaries, but you're talking about lists. The same rule/fix should apply to both.) ",
          "createdAt": "2018-02-05T07:21:27Z",
          "updatedAt": "2018-02-05T07:21:27Z"
        }
      ]
    },
    {
      "number": 482,
      "id": "MDU6SXNzdWUyOTQ0OTgwNjE=",
      "title": "Frames on Closed Streams",
      "url": "https://github.com/httpwg/http-extensions/issues/482",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "As highlighted by #480, the Secondary Certs draft currently involves sending frames on closed streams.  This is poor form in HTTP/2, but impossible in HTTP/QUIC (where we hope this will be easily portable).  We should find an alternative.\r\n\r\nThis may mean that on-stream frames actually move to Stream 0 and simply carry a stream number as part of the frame.  Loses a few bytes, but seems like the best path forward.",
      "createdAt": "2018-02-05T18:37:46Z",
      "updatedAt": "2018-04-13T17:26:47Z",
      "closedAt": "2018-04-13T17:26:47Z",
      "comments": []
    },
    {
      "number": 483,
      "id": "MDU6SXNzdWUyOTQ0OTg2NzA=",
      "title": "Request-ID Unpredictability",
      "url": "https://github.com/httpwg/http-extensions/issues/483",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "In comments on https://github.com/MikeBishop/http2-certs/pull/18, @martinthomson pointed out that the context inside an exported authenticator/request is supposed to be unpredictable.  We should look at the use in Secondary Certs and how we can avoid compromising security goals with the exported authenticator.",
      "createdAt": "2018-02-05T18:39:51Z",
      "updatedAt": "2018-02-06T00:10:18Z",
      "closedAt": "2018-02-06T00:10:18Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have a suggestion for #481 that should fix this problem.",
          "createdAt": "2018-02-05T21:56:51Z",
          "updatedAt": "2018-02-05T21:56:51Z"
        }
      ]
    },
    {
      "number": 484,
      "id": "MDU6SXNzdWUyOTQ1ODk3NjE=",
      "title": "Include pictures for all frames",
      "url": "https://github.com/httpwg/http-extensions/issues/484",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "The pictures are great anchors for finding frames.  Omitting them makes it harder to read the document.",
      "createdAt": "2018-02-06T00:23:33Z",
      "updatedAt": "2018-04-13T17:26:47Z",
      "closedAt": "2018-04-13T17:26:47Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was following the convention that frames with a single field don't get a picture.  However, I see that QUIC is now only omitting for frames that don't have a payload at all, or are exact duplicates of a different frame.  Perhaps HTTP/QUIC should do likewise.",
          "createdAt": "2018-02-06T00:34:31Z",
          "updatedAt": "2018-02-06T00:34:31Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Right, and I started doing that because it's easier to scan the document to find what you need when you have nice pictures breaking things up.",
          "createdAt": "2018-02-06T00:42:06Z",
          "updatedAt": "2018-02-06T00:42:06Z"
        }
      ]
    },
    {
      "number": 485,
      "id": "MDU6SXNzdWUyOTQ1OTA5MzI=",
      "title": "Explain identifiers better",
      "url": "https://github.com/httpwg/http-extensions/issues/485",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "CERTIFICATE_NEEDED and USE_CERTIFICATE use different identifiers.  The potential for confusion about these is immense.\r\n\r\nAs I understand it, there is no direct need for correlation between these.  This is largely because we hope that a response (or acceptance thereof) is largely conditioned on the set of certificates available, not the way that those certificate were requested, and so correlating CERTIFICATE_NEEDED isn't important.  (In light of this, the text on confusion of clients the the description of CERTIFICATE_NEEDED is just confusing to me.)\r\n\r\n* CERTIFICATE_NEEDED includes a Request-ID, which is also used in a CERTIFICATE_REQUEST.\r\n* CERTIFICATE_REQUEST includes an authenticator request, which also includes the Request-ID (and some extra entropy now).\r\n* CERTIFICATE includes a Cert-ID.  This is bound back to a CERTIFICATE_REQUEST using the contents of the authenticator itself (the exported authenticator \"get context\" API).\r\n* USE_CERTIFICATE includes a Cert-ID.\r\n\r\nThus, it is possible to follow the process full-circle, but it is generally not necessary.  A server should determine what response it wants to provide based on the certificates it has, not on how they were requested.  The same goes for a client that is accepting a response.",
      "createdAt": "2018-02-06T00:30:24Z",
      "updatedAt": "2018-05-29T17:35:11Z",
      "closedAt": "2018-05-29T17:35:11Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson, I believe this is improved by #566.  If you think this is still an issue, please reopen.",
          "createdAt": "2018-05-29T17:35:11Z",
          "updatedAt": "2018-05-29T17:35:11Z"
        }
      ]
    },
    {
      "number": 486,
      "id": "MDU6SXNzdWUyOTQ1OTEyNDA=",
      "title": "Add Request-ID to CERTIFICATE",
      "url": "https://github.com/httpwg/http-extensions/issues/486",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "I think that it would be better to explicitly reference CERTIFICATE_REQUEST in the cases where a CERTIFICATE is generated directly in response to one.  Using the \"get context\" API from exported authenticators is ugly.\r\n\r\nThis is more important now that exported authenticators folds the request into the response.\r\n\r\nWe probably want to use a flag for whether this is spontaneous so that we can avoid reserving a Request-ID for spontaneous CERTIFICATE messages.",
      "createdAt": "2018-02-06T00:32:11Z",
      "updatedAt": "2019-04-25T19:25:13Z",
      "closedAt": "2019-04-25T19:25:13Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm a little dubious about this.  Having the same value transported in two different fields and then checking that they're equal seems potentially more error-prone than just transporting it in one place, even if that one place is by calling into a library to interpret for you.",
          "createdAt": "2018-04-09T20:11:55Z",
          "updatedAt": "2018-04-09T20:11:55Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For posterity, discussion in Montreal:  Nice not to have to dig out the Request-ID.  However, if you duplicate it, then you have to compare and check that they're equal, so you're still calling into TLS.  There is an existing duplication in the CERTIFICATE_REQUEST, where the Request-ID is carried outside the EA.",
          "createdAt": "2018-10-23T20:10:36Z",
          "updatedAt": "2018-10-23T20:10:36Z"
        }
      ]
    },
    {
      "number": 491,
      "id": "MDU6SXNzdWUyOTY5ODc0MDI=",
      "title": "Client capabilities / expectations",
      "url": "https://github.com/httpwg/http-extensions/issues/491",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "The capabilities of client regarding things like automatic handling of redirects varies widely; while it's assumed in Web browsers, it's much less clear what's expected for other applications.\r\n",
      "createdAt": "2018-02-14T06:14:53Z",
      "updatedAt": "2018-03-01T02:11:43Z",
      "closedAt": "2018-03-01T02:11:43Z",
      "comments": []
    },
    {
      "number": 492,
      "id": "MDU6SXNzdWUyOTY5ODgyNzI=",
      "title": "Protocols based upon HTTP and IANA registries",
      "url": "https://github.com/httpwg/http-extensions/issues/492",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Michael Sweet pointed out IPP, which uses HTTP POST and status codes (very basically) to get its job done, and it doesn't register anything new.\r\n\r\nWhen this is the case, it doesn't seem harmful to say that they can use HTTP registries. What's harmful is when a non-HTTP protocol puts something into HTTP's registries, creating confusing about what can be used where.\r\n\r\nIs it sensible to drop the aspect of \"using HTTP\" that is:\r\n\r\n> The message formats described in {{RFC7230}} and/or {{RFC7540}} are used in conjunction with the IANA registries defined for HTTP.\r\n\r\n... and add a requirement that protocols that are based upon HTTP MUST not register anything in HTTP's registries, but instead define their own registries if they want to add new protocol artefacts?",
      "createdAt": "2018-02-14T06:20:36Z",
      "updatedAt": "2018-03-01T01:48:13Z",
      "closedAt": "2018-03-01T01:48:13Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's a fine line; I'd go one step further.  It's okay if they use the entries *unchanged*.  They MUST NOT register anything new, and they MUST NOT modify the semantics of existing entries.",
          "createdAt": "2018-02-14T15:54:52Z",
          "updatedAt": "2018-02-14T15:54:52Z"
        }
      ]
    },
    {
      "number": 493,
      "id": "MDU6SXNzdWUyOTY5ODgzNTQ=",
      "title": "Requirements",
      "url": "https://github.com/httpwg/http-extensions/issues/493",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis",
        "editorial"
      ],
      "body": "Is it good practice to use RFC2119 requirements in a BCP like this?",
      "createdAt": "2018-02-14T06:21:07Z",
      "updatedAt": "2018-03-29T23:37:09Z",
      "closedAt": "2018-03-29T23:37:09Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Going through the existing requirements, I think it's appropriate. Individual requirements might need adjustment, of course.",
          "createdAt": "2018-03-29T23:37:09Z",
          "updatedAt": "2018-03-29T23:37:09Z"
        }
      ]
    },
    {
      "number": 494,
      "id": "MDU6SXNzdWUyOTczMDQ0Mjc=",
      "title": "Cookie removal algorithm",
      "url": "https://github.com/httpwg/http-extensions/issues/494",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "This foremost relates to the arbitrary limits that cookie stores place on cookies, both globally and per-domain.\r\n\r\nRFC 6265 says the following:\r\n\r\n>   At any time, the user agent MAY \"remove excess cookies\" from the\r\n>   cookie store if the number of cookies sharing a domain field exceeds\r\n>   some implementation-defined upper bound (such as 50 cookies).\r\n>\r\n>   At any time, the user agent MAY \"remove excess cookies\" from the\r\n>   cookie store if the cookie store exceeds some predetermined upper\r\n>   bound (such as 3000 cookies).\r\n>\r\n>   When the user agent removes excess cookies from the cookie store, the\r\n>   user agent MUST evict cookies in the following priority order:\r\n>\r\n>   1.  Expired cookies.\r\n>\r\n>   2.  Cookies that share a domain field with more than a predetermined\r\n>       number of other cookies.\r\n>\r\n>   3.  All cookies.\r\n>\r\n>   If two cookies have the same removal priority, the user agent MUST\r\n>   evict the cookie with the earliest last-access date first.\r\n\r\nWe did some investigation into this and discovered some problems with this process as implemented.  Browsers tend to remove a fixed number of cookies once they hit storage limits.  From what I can tell, browsers sort by last-access, but remove up to a fixed number of cookies.\r\n\r\nThis is bad for the integrity of storage.  Retaining some, but not all cookies is a great recipe for getting incomplete state. That can be a security exposure. That was part of what made some of the attacks in [this paper](https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-zheng.pdf) possible and motivated the the [leave-secure-cookies-alone](https://tools.ietf.org/html/draft-west-leave-secure-cookies-alone) fix.\r\n\r\nWhen we looked at this we first concluded on the following algorithm:\r\n\r\n1. If cookies exceed the limit, remove all cookies for other domains (for `foo.example.com`, remove `(!foo).example.com` cookies, but not example.com cookies).\r\n2. If cookies still exceed the limit, remove all cookies for other paths (for `foo.example.com/foo`, remove `foo.example.com/(!foo)`).\r\n3. If cookies still exceed the limit, remove all related cookies (for `foo.example.com`, remove anything ending in `example.com`).\r\n\r\nOn review, I think that we can continue to use last-access date to drive this, with a much smaller change.  I'm proposing two small changes:\r\n\r\n* Require that last-access is set to the same value for every accessed cookie when constructing the Cookie header field (the text currently says the \"current date and time\".\r\n\r\n* Require that when an unexpired cookie is removed, require that all cookies that share a domain and have the same (or older) last-access date also be removed.\r\n\r\nThis ensures that if a site receives incomplete cookie state, then it is at least an incomplete state that might reasonably have been created by an adjacent site.  For example, say that `foo.example.com` installs and depends on cookies at `example.com`, then if `bar.example.com` triggers deletion, then it will remove only `foo.example.com` cookies.  It can't be perfect because there is a risk that `example.com` cookies are actually specific to `foo.example.com` and have an interdependency on `foo.example.com` cookies, but that's a risk we're already exposed to.\r\n\r\nThis can result in the same results as the algorithm I described above, but it also might allow for more granular removal.  For instance, if `1.example.com` through `9.example.com` are visited in that order and `9.example.com` causes cookies to exceed the limit, then cookies will be removed for `1.example.com` first The algorithm above would cause cookies for 1 through 8 to be removed at once, which is more severe than we need.\r\n\r\nAs the people driving this no longer work for Mozilla, I thought that I would record our conclusions.  I don't know if we have the resources to continue to investigate implementation, but I'm happy to create a PR for the relevant section if the WG thinks that this is a reasonable change.\r\n\r\nI understand that @mikewest still prefers [cookie priorities](https://tools.ietf.org/html/draft-west-cookie-priority), but no one at Mozilla has any interest in that solution and it didn't seem to get any traction when we discussed it before.",
      "createdAt": "2018-02-15T01:34:08Z",
      "updatedAt": "2019-09-17T05:44:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Sorry I didn't see this when you first filed it.\r\n\r\n> I understand that @mikewest still prefers cookie priorities, but no one at Mozilla has\r\n> any interest in that solution and it didn't seem to get any traction when we discussed\r\n> it before.\r\n\r\nI'd rephrase this a bit. :) The relevant claim here is less that I prefer `Priority` (though I do), and more that Chrome has been shipping the `Priority` attribute for years and I have personal knowledge of Google's internal dependency on the attribute for the corporate intranet. I have anecdotal stories of similar dependency in other companies, but nothing I can point to public statements to justify.\r\n\r\nI recognize that other vendors are unlikely to ship the attribute. I'm very open to reviewing the results of y'all's experimentation to see if the results in other browsers show that we're making the wrong choice in Chrome, but my (biased) opinion at the moment is that `Priority` solves this problem in a way that puts developers more directly in control of the eviction process, and that that control is concretely valuable in scenarios that run up against the vendor-specified limits on a regular basis.",
          "createdAt": "2018-04-09T08:59:02Z",
          "updatedAt": "2018-04-09T08:59:02Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm circulating this with some coworkers at Apple to gather input.",
          "createdAt": "2018-12-10T17:47:52Z",
          "updatedAt": "2018-12-10T17:47:52Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "This seems like it's out of scope for 6265bis; it wasn't in the list of proposals we accepted, and isn't a low-level interop / clarification issue. I'd suggest we punt this until a future revision.",
          "createdAt": "2019-09-17T05:44:55Z",
          "updatedAt": "2019-09-17T05:44:55Z"
        }
      ]
    },
    {
      "number": 495,
      "id": "MDU6SXNzdWUyOTgwMzkzMjE=",
      "title": "binary content, non-paddability",
      "url": "https://github.com/httpwg/http-extensions/issues/495",
      "state": "CLOSED",
      "author": "bsdphk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "I'm not sure I understand the ban on '=' in binary content, how can that confuse dictionaries, when the binary content doesn't end until the final '*' ?",
      "createdAt": "2018-02-17T21:48:21Z",
      "updatedAt": "2018-02-22T08:20:21Z",
      "closedAt": "2018-02-22T08:20:21Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It's from when there wasn't a final delimiter. I think you're right; we should accept  `=`. I *think* we should also accept without.",
          "createdAt": "2018-02-18T21:36:55Z",
          "updatedAt": "2018-02-18T21:36:55Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we should just rely on whatever the B64 rfc says, without inventing anything new.  (Postel Was Wrong and all that.)",
          "createdAt": "2018-02-19T09:32:57Z",
          "updatedAt": "2018-02-19T09:32:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It says:\r\n\r\n> Implementations MUST include appropriate pad characters at the end of encoded data unless the specification referring to this document explicitly states otherwise.\r\n\r\nI think we want to make it easy to conform to whatever we require with shipping implementations of base64. Spot-checking Python and Node, it seems like Python enforces the requirement, whereas Node does not. \r\n\r\nGiven that, it seems like the sensible thing to do is to require the padding to be produced with a MUST, but only require parsers to reject content without padding as a SHOULD.\r\n\r\nSee also #473.",
          "createdAt": "2018-02-19T23:21:03Z",
          "updatedAt": "2018-02-19T23:21:03Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "WFM",
          "createdAt": "2018-02-22T08:13:29Z",
          "updatedAt": "2018-02-22T08:13:29Z"
        }
      ]
    },
    {
      "number": 496,
      "id": "MDU6SXNzdWUyOTg4NTc4MjI=",
      "title": "Relationship between Vary and new headers",
      "url": "https://github.com/httpwg/http-extensions/issues/496",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "",
      "createdAt": "2018-02-21T06:39:41Z",
      "updatedAt": "2018-02-22T05:04:58Z",
      "closedAt": "2018-02-22T05:04:58Z",
      "comments": []
    },
    {
      "number": 497,
      "id": "MDU6SXNzdWUyOTk1OTY0NzU=",
      "title": "Negotiation vs. pre-arrangement",
      "url": "https://github.com/httpwg/http-extensions/issues/497",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Applications should allow features negotiated by HTTP to operate normally, rather than require pre-arranged behaviours. E.g., conneg.",
      "createdAt": "2018-02-23T04:36:37Z",
      "updatedAt": "2018-03-01T02:11:43Z",
      "closedAt": "2018-03-01T02:11:43Z",
      "comments": []
    },
    {
      "number": 501,
      "id": "MDU6SXNzdWUzMDEyNTU4NDM=",
      "title": "Error handling",
      "url": "https://github.com/httpwg/http-extensions/issues/501",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Mention HTTP problems RFC?",
      "createdAt": "2018-03-01T02:27:03Z",
      "updatedAt": "2018-04-02T05:06:26Z",
      "closedAt": "2018-04-02T05:06:26Z",
      "comments": []
    },
    {
      "number": 502,
      "id": "MDU6SXNzdWUzMDEyNTU5NDA=",
      "title": "Standard APIs are different",
      "url": "https://github.com/httpwg/http-extensions/issues/502",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis",
        "editorial"
      ],
      "body": "- multiple implementations\r\n- multiple instances\r\n- multiple versions\r\n\r\nall co-existing",
      "createdAt": "2018-03-01T02:27:47Z",
      "updatedAt": "2018-03-29T23:57:00Z",
      "closedAt": "2018-03-29T23:57:00Z",
      "comments": []
    },
    {
      "number": 504,
      "id": "MDU6SXNzdWUzMDI1MDM1NTg=",
      "title": "Impact of Combining headers",
      "url": "https://github.com/httpwg/http-extensions/issues/504",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Kari points out [on list](https://www.w3.org/mid/20180305184510.66F8B4792D@welho-filter2.welho.com):\r\n\r\n3. [Parsing Text into Structured Headers](https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-04#section-3)\r\n\r\n~~~\r\nGiven an ASCII string input_string that represents the chosen\r\nheader's field-value, return the parsed header value.  When\r\ngenerating input_string, parsers MUST combine all instances of the\r\ntarget header field into one comma-separated field-value, as per\r\n[RFC7230], Section 3.2.2; this assures that the header is processed\r\ncorrectly.\r\n\r\nNote that in the case of lists, parameterised lists and dictionaries,\r\nthis has the effect of coalescing all of the values for that field.\r\nHowever, for singular items, parsing will fail if more than instance\r\nof that header field is present.\r\n~~~\r\n\r\nI think that this is not true for a String, if header field is mailformed\r\nenough.\r\n\r\nConsider following\r\n\r\n~~~\r\nFoo: \"xxss\r\nFoo: xxxx\"\r\n~~~\r\n\r\nThis gives\r\n\r\n> Foo: \"xxss,xxxx\"\r\n\r\nThis passes\r\n\r\n[4.7.1.  Parsing a String from Text](https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-04#section-4.7.1)\r\n\r\n[4.7.  Strings](https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-04#section-4.7)\r\n\r\n~~~\r\n string    = DQUOTE 0*1024(char) DQUOTE\r\n char      = unescaped / escape ( DQUOTE / \"\\\" )\r\n unescaped = %x20-21 / %x23-5B / %x5D-7E\r\n escape    = \"\\\"\r\n~~~\r\n\r\nComma is allowed here as unescaped.\r\n\r\nOther singular items does not allow comma, so combining causes parse error.",
      "createdAt": "2018-03-05T23:22:05Z",
      "updatedAt": "2018-04-09T23:32:16Z",
      "closedAt": "2018-04-09T23:32:16Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think the right answer here is to adjust the text to say that splitting structures across headers can lead to unpredictable/unfortunate results.",
          "createdAt": "2018-03-28T06:21:47Z",
          "updatedAt": "2018-03-28T06:21:47Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The other approach would be to require commas to be escaped in strings.",
          "createdAt": "2018-03-28T06:24:24Z",
          "updatedAt": "2018-03-28T06:24:24Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "It would be really nice if we defined an operation that basically gets the value of a particular header for an entire header list.\r\n\r\nAnd then once and for all defined what happens with duplicates, relative order, etc.",
          "createdAt": "2018-03-28T06:42:20Z",
          "updatedAt": "2018-03-28T06:42:20Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "To clarify, having syntax for header values is great, but if we don't deal with multiple headers, we'll continue to have a large set of problems we have with the current setup. Do you use the first or last? Do you combine and then parse? Do you parse independently and then use the resulting values? Do you error on multiple headers? By ignoring it or treating it as a network error?\r\n\r\n(I've seen most of these trying to figure out how existing headers are implemented.)",
          "createdAt": "2018-03-28T06:45:15Z",
          "updatedAt": "2018-03-28T06:45:15Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Anne, I think we've got that covered. The question here is whether a string split over multiple headers should be silently handled (including the comma, I suppose), or reliably raise an error.",
          "createdAt": "2018-03-28T06:53:53Z",
          "updatedAt": "2018-03-28T06:53:53Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Thanks (I'm assuming it's covered somewhere that \"field value\" is obtained after stripping whitespace).\r\n\r\nSince intermediaries can combine, you cannot really disallow it, can you?\r\n\r\nI think that's why some folks defining headers try to outlaw the comma I think; so they can detect header injection.",
          "createdAt": "2018-03-28T07:05:43Z",
          "updatedAt": "2018-03-28T07:05:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The easiest way to make it reliably raise an error would be to require commas to be escaped in strings. Would that be offensive?",
          "createdAt": "2018-03-30T00:48:16Z",
          "updatedAt": "2018-03-30T00:48:16Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Kari points out that wouldn't help (as the commas could be escaped by a dangling `\\` at the end of the first header instance).\r\n\r\nI don't think we can reliably fail, given that in some implementations, multiple instances of a header field are folded before they get to the parser.",
          "createdAt": "2018-04-09T05:31:39Z",
          "updatedAt": "2018-04-09T05:31:39Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I think reliably not failing is fine. If you don't want header injection you need to disallow commas.",
          "createdAt": "2018-04-09T06:24:20Z",
          "updatedAt": "2018-04-09T06:24:20Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Makes sense - we can mention that in Security Considerations.",
          "createdAt": "2018-04-09T06:26:22Z",
          "updatedAt": "2018-04-09T06:26:22Z"
        }
      ]
    },
    {
      "number": 505,
      "id": "MDU6SXNzdWUzMDI1MDUzNjQ=",
      "title": "Strings, Identifiers and Items",
      "url": "https://github.com/httpwg/http-extensions/issues/505",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "We've designed structured headers so that it's easy to deterministically parse a given header into the appropriate data types. \r\n\r\nHowever, it seems like there's likely to be ambiguity about taking a given data structure in common programming languages and creating the correct data types, without a significant amount of metatdata.\r\n\r\nWhile most languages can distinguish floats from integers, as well as binary content from other content, identifiers are a strict subset of strings.\r\n\r\nFor example, if a value is \"foo\",  and I need to serialise it as an Item, I have no idea whether it should be:\r\n\r\n> ExampleHeader: foo\r\n\r\nor \r\n\r\n> ExampleHeader: \"foo\"\r\n\r\nwithout extra metadata. Same problem where items can appear inside lists, dict values, etc.\r\n\r\nOne way to address this would be to remove identifiers from items.\r\n\r\nThoughts?",
      "createdAt": "2018-03-05T23:30:09Z",
      "updatedAt": "2018-03-28T06:18:25Z",
      "closedAt": "2018-03-28T06:18:25Z",
      "comments": [
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure I understand the problem ?\r\n\r\nYou need to know the specification for the header to produce it correctly, and that will tell you if you are supposed to produce an identifier or a string ?\r\n",
          "createdAt": "2018-03-05T23:47:42Z",
          "updatedAt": "2018-03-05T23:47:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Imagine that you're creating a generic API for serialising structured headers, say from JS or Python.\r\n\r\nWe've accepted that it's necessary for the calling code to identify the top-level type, so the function might be `generateStructuredItem(data)` or similar. \r\n\r\nHowever, what you pass in `data` is ambiguous if it contains a string; is that to be serialised as an identifier, or a string?\r\n\r\nOne way to fix this would be to pass along extra metadata inside / alongside `data`. However, if we can omit Identifiers from Item, I *think* it becomes unambiguous.",
          "createdAt": "2018-03-06T00:01:27Z",
          "updatedAt": "2018-03-06T00:01:27Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "So...\r\n\r\nA list-of-identifiers (e.g. `Vary`) becomes a param-list (with the \"no parameters\" profile)?\r\n\r\nA single identifier (e.g. `Content-Encoding`) becomes param-list (with the \"only one item\", and \"no parameters\" profiles)??\r\n\r\nAmusingly, the one example in the draft for *list* is a list of identifiers, which suggests that that's the most useful type of list.  Which in turn suggests making a new first class \"list-of-identifiers\" type.\r\n\r\nThe set of types starts to look a bit .. um.. :\r\n\r\n* list of {identifier => identifier} pairs\r\n* list of {identifier => other primitive scalar} pairs\r\n* parameterised list of identifiers *\r\n* list of identifiers\r\n* list of other primitive scalars\r\n* identifier\r\n* other primitive scalar\r\n\r\n\\* this is actually more complicated, because of `foo;bar=baz` vs `foo;bar=\"baz\"`\r\n\r\nI can kind of see how we're getting here, but it seems like maybe you've opened up a tiny little crack which might make the whole thing fall apart.",
          "createdAt": "2018-03-13T02:41:59Z",
          "updatedAt": "2018-03-13T02:41:59Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> While most languages can distinguish floats from integers, as well as **binary content from other content** ...\r\n\r\nWait, can they?  How would my API to know whether to generate `\"hello\"` or `*aGVsbG8=*`?  What you say only works if those two values are completely interchangeable, which means they're the same data type.  ~~But that's not stated (or even implied) in the current text.~~ (nvm, I can't read; it *is* implied)\r\n\r\nIn Ruby there are String and Symbol objects, which means it's actually *easier* for my Ruby API to choose between strings vs identifiers than strings vs binary content.\r\n\r\nMaybe the extra metadata is the way to go.  We already have those in every other serialisation library in existence (e.g. [PHP json_decode's `assoc` parameter](https://secure.php.net/manual/en/function.json-decode.php), [Ruby's JSON opts](https://ruby-doc.org/stdlib-2.5.0/libdoc/json/rdoc/JSON.html#method-i-parse), etc.) so it's not something completely foreign to developers.",
          "createdAt": "2018-03-13T02:58:53Z",
          "updatedAt": "2018-03-13T03:00:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hm. In Python3, I have `b\"...\"` for binary. Ruby has stringio objects. JS has Blob. I *think* binary is pretty well-covered and natural in most languages (even if it requires a wrapper object, that is \"the\" way it's done in that language).\r\n\r\nIt's much less clear to me that there's always such a natural mapping for identifiers. It's true that a library could define a wrapper object for them; I just wonder if it would end up being confusing to use (because it's not the natural convention for that language).\r\n\r\nE.g., in Python, I don't think there's a natural mapping, so my library would have to define an Identifier object that would need to be consistently used in all data to/from headers. That object would become a dependency for all code that works with that header.\r\n\r\nNot sure that's a big deal, just working through it.",
          "createdAt": "2018-03-14T11:53:40Z",
          "updatedAt": "2018-03-14T11:53:40Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, I didn't know Python 3 had separated serialisation from strings and exposed 'bytes' as its own type. \r\n That's cool.  In Ruby a String is always a String, even if you access it using StringIO\\*;  and a string with `.encoding == Encoding::ASCII_8BIT` isn't special in any way.\r\n\r\nBut yeah, my big hangup is that `param_id` has `[ \"=\" item ]` in its definition.  That's the one place, in all the potential header definitions, where I can see a strong argument for allowing mixed strings and identifiers in the same context.  Which means even if you were to carve *identifier* out of *item*, you'd probably have to expand the param_id rule to bring it back in there, which means a generic encoder would still need that extra metadata to know whether to write `=\"foo\"` or `=foo`\r\n\r\n(\\* *but you can use `bytes`/`each_byte` or `unpack` to get the octet values out*)",
          "createdAt": "2018-03-14T14:39:59Z",
          "updatedAt": "2018-03-14T14:39:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Right. In a perfect world, we could map native datatypes 1:1 with header datatypes, but as a stopgap, we can use objects (whether they're provided by the language like `StringIO` or by the header mapping itself). I still think it would be cool if we could minimise that.\r\n\r\nSo I think the heart of this question is: does the usefulness of using Identifiers in places like parameter and dictionary values outweigh the inconvenience/extra abstraction of using wrapper objects/types?",
          "createdAt": "2018-03-14T14:44:16Z",
          "updatedAt": "2018-03-14T14:44:16Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> So I think the heart of this question is: does the usefulness of using Identifiers in places like parameter and dictionary values outweigh the inconvenience/extra abstraction of using wrapper objects/types?\r\n\r\nHow much would it matter if we couldn't reproduce `content-type: text/html;charset=utf-8`?",
          "createdAt": "2018-03-14T15:08:58Z",
          "updatedAt": "2018-03-14T15:08:58Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes. If we don't allow identifiers in types, it'd have to be serialised as:\r\n\r\n> Content-Type: text/html;charset=\"utf-8\"\r\n\r\n... if it was a parameterised list.\r\n\r\n",
          "createdAt": "2018-03-14T15:10:38Z",
          "updatedAt": "2018-03-14T15:10:38Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Aye, so, given that content-type is never ever going to have a different serialisation, if the eventual goal of this structure isn't to conquer the world (of existing headers) then there's no problem.\r\n\r\nAlso, it fits nicely with some of my more radical ideology to never use an identifier on the right of an equals sign.",
          "createdAt": "2018-03-14T22:28:33Z",
          "updatedAt": "2018-03-14T22:28:33Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think I'm going to try to take identifiers out of the next draft and see how that goes. We can always re-add them.",
          "createdAt": "2018-03-28T06:15:21Z",
          "updatedAt": "2018-03-28T06:15:21Z"
        }
      ]
    },
    {
      "number": 510,
      "id": "MDU6SXNzdWUzMDU5NTY5ODc=",
      "title": "bcp56bis section ref to HTML",
      "url": "https://github.com/httpwg/http-extensions/issues/510",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis",
        "editorial"
      ],
      "body": "\"Unmodified Web browsers will not support the new scheme. While it is possible to register new URL schemes with Web browsers (e.g. registerProtocolHandler() in [HTML5] Section 8.7.1.3, as well as several proprietary approaches), support for these mechanisms is not shared by all browsers, and their capabilities vary.\"\r\n\r\nAs HTML5 refers to the \"living spec\", the section number reference might be instable. Either use s stable version (W3C?), or rephrase the reference (potentially by just dropping the section number, or by directly linking to https://html.spec.whatwg.org/#custom-handlers)\r\n\r\nAlso, in any case, please insert a comma between reference and \"Section...\".",
      "createdAt": "2018-03-16T14:49:36Z",
      "updatedAt": "2018-03-30T00:00:21Z",
      "closedAt": "2018-03-30T00:00:21Z",
      "comments": []
    },
    {
      "number": 513,
      "id": "MDU6SXNzdWUzMDU5NjEwMDU=",
      "title": "bcp56bis: CORS reference",
      "url": "https://github.com/httpwg/http-extensions/issues/513",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis",
        "editorial"
      ],
      "body": "The spec currently cites both FETCH and the W3C CORS spec for CORS. One should be sufficient.",
      "createdAt": "2018-03-16T14:59:39Z",
      "updatedAt": "2018-03-30T05:41:14Z",
      "closedAt": "2018-03-30T05:41:10Z",
      "comments": [
        {
          "author": "ylafon",
          "authorAssociation": "NONE",
          "body": "You should use FETCH.",
          "createdAt": "2018-03-22T10:58:03Z",
          "updatedAt": "2018-03-22T10:58:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@ylafon yes, that's the intent. However if I could give feedback to the W3C, Fetch is effectively an implementer's recipe; it's horribly impenetrable for people who just want to understand what's happening. It would be extremely valuable if WebAppSec would publish [CORS for Developers](https://w3c.github.io/webappsec-cors-for-developers/) or similar, so we could use it as a reference.",
          "createdAt": "2018-03-22T14:41:51Z",
          "updatedAt": "2018-03-22T14:41:51Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Is it? I've pointed folks to https://fetch.spec.whatwg.org/#http-cors-protocol before on Stack Overflow and to the extent I got feedback on that it's been fairly positive.",
          "createdAt": "2018-03-27T12:30:45Z",
          "updatedAt": "2018-03-27T12:30:45Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@Reschke, where do you see it citing W3C CORS?",
          "createdAt": "2018-03-30T00:01:22Z",
          "updatedAt": "2018-03-30T00:01:28Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "End of https://tools.ietf.org/html/draft-ietf-httpbis-bcp56bis-02#section-4.11. It's a normative reference even.",
          "createdAt": "2018-03-30T03:58:59Z",
          "updatedAt": "2018-03-30T03:58:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks (I missed it thanks to case-sensitive search).",
          "createdAt": "2018-03-30T05:41:14Z",
          "updatedAt": "2018-03-30T05:41:14Z"
        }
      ]
    },
    {
      "number": 516,
      "id": "MDU6SXNzdWUzMDYyMzUyOTA=",
      "title": "Remove ETag from the digest key calculations",
      "url": "https://github.com/httpwg/http-extensions/issues/516",
      "state": "CLOSED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "Having ETags as part of the digest key adds a lot of complexity to the Cache Digest implementation both on the client and the server:\r\n* Clients may not have the ETag readily available at removal time, which would mean removal from the digest introduces I/O operations and slowness.\r\n* Servers may not have the ETag readily available when they want to send down push promises, forcing them to make those conditional on I/O operations (and again, slowness).\r\n\r\nI [ran an HTTPArchive analysis](https://discuss.httparchive.org/t/cacheability-of-render-critical-resources/1278) and it seems that from the render-critical resources that are push candidates, 77.26% of them are cacheable for at least 24 hours.\r\nSame query with 30 days minimal freshness gives us 52.32% of the resources.\r\n\r\nSo it seems that servers can in many cases have enough render-critical resources to push even without the ETag info.\r\nTherefore I suggest removing it, to simplify implementations. If we'd see that it becomes an issue in the future, we could add it back as optional.\r\n\r\nThoughts?",
      "createdAt": "2018-03-18T12:17:43Z",
      "updatedAt": "2018-07-16T21:32:51Z",
      "closedAt": "2018-07-01T15:50:20Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> So it seems that servers can in many cases have enough render-critical resources to push even without the ETag info.\r\n\r\nI agree.\r\n\r\nNote also that it is difficult to use a digest of freshly cached responses that uses ETag due to lack of agreement on if we can push a response to replace a freshly cached object within the client's cache. See the chart on https://datatracker.ietf.org/meeting/101/materials/slides-101-httpbis-cache-digest-00 page 7.\r\n\r\n> Therefore I suggest removing it, to simplify implementations. If we'd see that it becomes an issue in the future, we could add it back as optional.\r\n\r\nThe reason we allow the use of ETag is to support sending a digest of stale responses. When a server receives a digest of stale responses, a server needs to decide if it pushes a 200 or \"not modified\", based on the value of ETag.\r\n\r\nIn other words, removal of ETag support needs to come along with removing support for stale digests. That said, I do not oppose to removing them altogether (means that we will only allow sending a digest of freshly-cached responses that uses HASH(URL) as the key), considering the fact that how to push a \"not modified\" signal is not something that the community has agreed.",
          "createdAt": "2018-03-20T10:19:39Z",
          "updatedAt": "2018-03-20T10:19:39Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm a little sad about this, so I feel it's important to explain my use-case for h2 push + cache digests.\r\n\r\nI'm mainly concerned with building REST API's. Traditionally when building API's there's often been a need to be able to express a 'collection' and an 'item'.\r\n\r\nA big reason for needing this, is that we can't ask the client to do a GET request for every individual item in a collection, so they get bunched together into some kind of collection resource.\r\n\r\nHowever, those collection resources still contain some kind of representation of the item in the collection, and can often indicate to the client what real item they refer to.\r\n\r\nA real example of this is [HAL](http://stateless.co/hal_specification.html). If you're unfamiliar with HAL, it actually expresses collections though an \"_embedded\" format. It almost literally expresses:\r\n\r\n> \"Here is a collection. To save you time and bandwidth, we're embedding the representations of all the resources that are contained within the collection\"\r\n\r\nMany formats will have some variation of this idea. But the idea is not perfect. Specifically:\r\n\r\n* HTTP caches will not be aware or understand embedded items, and will not invalidate embedded items if they got a new copy.\r\n* It's often only possible to embed items that are identical to the parent format (in my case HAL).\r\n* It's often possible to include additional request/response headers.\r\n\r\nThe more I've been thinking about this and generic clients, I feel that HTTP/2 push is a great solution for this. A conforming client can just pretend do GET requests that come from the push-cache. I've started testing with this, and conceptually I think it works really well.\r\n\r\nThis could all be done without cache-digest, but the ability to only push resource states that have changed is just such a powerful idea to me.\r\n\r\nHowever, in my mind ETag is the right mechanism for this. I think the statistics you cited are right, but HTTP/2 push and Cache-Digests can be an enabler for this type of technology. Rarely APIs will know in advance how long resources should be cacheable, because changes are usually based on user actions.",
          "createdAt": "2018-07-04T00:23:30Z",
          "updatedAt": "2018-07-04T00:23:30Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@evert Thank you for the comment. I will share your comment at IETF 102.",
          "createdAt": "2018-07-16T21:28:11Z",
          "updatedAt": "2018-07-16T21:28:11Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you @kazuho , I appreciate!",
          "createdAt": "2018-07-16T21:32:51Z",
          "updatedAt": "2018-07-16T21:32:51Z"
        }
      ]
    },
    {
      "number": 520,
      "id": "MDU6SXNzdWUzMDYyNDA0Mzk=",
      "title": "\"_\" is invalid in ABNF rule names, also: rule names are case-insensitive",
      "url": "https://github.com/httpwg/http-extensions/issues/520",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "...so we can't have both CHAR and char.",
      "createdAt": "2018-03-18T13:29:30Z",
      "updatedAt": "2018-03-27T03:06:55Z",
      "closedAt": "2018-03-27T03:06:55Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, the ABNF below would work:\r\n\r\n~~~\r\n\r\ndictionary        = dictionary-member 0*1023( OWS \",\" OWS dictionary-member )\r\ndictionary-member = identifier \"=\" item\r\n\r\nlist = list-member 0*1023( OWS \",\" OWS list-member )\r\nlist-member = item\r\n\r\nparam-list = param-id 0*255( OWS \",\" OWS param-id )\r\nparam-id   = identifier 0*256( OWS \";\" OWS identifier [ \"=\" item ] )\r\n\r\nitem = integer / float / string / identifier / binary\r\n\r\ninteger   = [\"-\"] 1*19DIGIT\r\n\r\nfloat    = [\"-\"] (\r\n             DIGIT \".\" 1*14DIGIT /\r\n            2DIGIT \".\" 1*13DIGIT /\r\n            3DIGIT \".\" 1*12DIGIT /\r\n            4DIGIT \".\" 1*11DIGIT /\r\n            5DIGIT \".\" 1*10DIGIT /\r\n            6DIGIT \".\" 1*9DIGIT /\r\n            7DIGIT \".\" 1*8DIGIT /\r\n            8DIGIT \".\" 1*7DIGIT /\r\n            9DIGIT \".\" 1*6DIGIT /\r\n           10DIGIT \".\" 1*5DIGIT /\r\n           11DIGIT \".\" 1*4DIGIT /\r\n           12DIGIT \".\" 1*3DIGIT /\r\n           13DIGIT \".\" 1*2DIGIT /\r\n           14DIGIT \".\" 1DIGIT )\r\n\r\nstring    = DQUOTE 0*1024(character) DQUOTE\r\ncharacter = unescaped / escape ( DQUOTE / \"\\\" )\r\nunescaped = %x20-21 / %x23-5B / %x5D-7E\r\nescape    = \"\\\"\r\n\r\nidentifier = lcalpha 0*255( lcalpha / DIGIT / \"_\" / \"-\"/ \"*\" / \"/\" )\r\nlcalpha    = %x61-7A ; a-z\r\n\r\nbinary = \"*\" 0*21846(base64) \"*\"\r\nbase64 = ALPHA / DIGIT / \"+\" / \"/\" / \"=\"\r\n~~~",
          "createdAt": "2018-03-18T14:48:32Z",
          "updatedAt": "2018-03-18T14:48:32Z"
        }
      ]
    },
    {
      "number": 522,
      "id": "MDU6SXNzdWUzMDY5NDMyOTA=",
      "title": "Issues with server detection of attacks",
      "url": "https://github.com/httpwg/http-extensions/issues/522",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "ORIGIN removed the need for DNS lookups for servers, and IP connectivity.  Servers can look for bad DNS records or BGP hijacking to detect attacks without ORIGIN, but now those techniques don't work.  In particular, key compromise is a concern; misissuance is perhaps less of a concern.\r\n\r\nSecondary certificates makes the entire situation worse.\r\n\r\nIn particular, it means that you can get a standalone certificate for the victim.  Previously, with coalescing, you would need to have a certificate that has both your own origin and the victim's origin, so that would be visible in a CT log.\r\n\r\nSubcerts can help with this (they have much shorter lifetimes).",
      "createdAt": "2018-03-20T16:32:15Z",
      "updatedAt": "2019-04-25T19:24:05Z",
      "closedAt": "2019-04-25T19:24:05Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From Kyle N: We could annotate the certificate to enable opt-in.",
          "createdAt": "2018-03-20T16:35:31Z",
          "updatedAt": "2018-03-20T16:35:31Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I assume annotation would just be an OID on the certificate?  It makes me a little sad to say that all current certificates are invalid for this purpose, but there's definitely value in limiting the scope of a key compromise.",
          "createdAt": "2018-04-09T20:25:15Z",
          "updatedAt": "2018-04-09T20:25:15Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah.  The standard approach is to include a critical extension and reject attempts to use an EE cert that doesn't include the extension.  We would probably only levy that requirement on servers though.",
          "createdAt": "2018-04-10T00:51:35Z",
          "updatedAt": "2018-04-10T00:51:35Z"
        }
      ]
    },
    {
      "number": 523,
      "id": "MDU6SXNzdWUzMDY5NDQwNDI=",
      "title": "If you have multiple connections",
      "url": "https://github.com/httpwg/http-extensions/issues/523",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "What do you do?  What certificates apply to these?  Are the connections independent.\r\n\r\nWhat if these are resumptions?  What from the previous connection do you use in that context?\r\n\r\n",
      "createdAt": "2018-03-20T16:34:02Z",
      "updatedAt": "2018-03-20T17:17:15Z",
      "closedAt": "2018-03-20T17:17:15Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Draft currently says:\r\n\r\n> As a result, clients MUST NOT assume that because one origin was previously colocated with another, those origins will be reachable via the same endpoints in the future. Clients MUST NOT consider previous secondary certificates to be validated after TLS session resumption. However, clients MAY proactively query for previously-presented secondary certificates.\r\n\r\nWhile that was originally talking about future session resumption, I think it's equally applicable to parallel connections.  The only certificate that applies to a connection when it begins is the one proven in TLS.  Anything else has to be bound to that specific connection.  You can remember interesting things you want to send a request for, but you can't assume.",
          "createdAt": "2018-03-20T16:58:21Z",
          "updatedAt": "2018-03-20T16:58:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ahh yes, that seems totally adequate (I was just trying to capture concerns that I heard during the meeting).  Closing.",
          "createdAt": "2018-03-20T17:17:15Z",
          "updatedAt": "2018-03-20T17:17:15Z"
        }
      ]
    },
    {
      "number": 524,
      "id": "MDU6SXNzdWUzMDY5NDc1NjE=",
      "title": "netinfo still mentioned in client-hints",
      "url": "https://github.com/httpwg/http-extensions/issues/524",
      "state": "CLOSED",
      "author": "npdoty",
      "authorAssociation": "NONE",
      "assignees": [
        "igrigorik"
      ],
      "labels": [
        "client-hints"
      ],
      "body": "It looks like the network information hints (Downlink) were removed, but there are still a couple references to network information, particularly in security considerations discussion, since there were security/privacy issues related to exposing network information through this. Should we just remove those references to network information?\r\n\r\n(`Save-Data` is potentially network-related, but I'm less concerned about that as a network information property that users might not realize is being disclosed.)",
      "createdAt": "2018-03-20T16:42:42Z",
      "updatedAt": "2018-04-10T16:09:22Z",
      "closedAt": "2018-04-10T16:09:22Z",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Yep, that makes sense! Assigning to myself.",
          "createdAt": "2018-03-27T00:48:46Z",
          "updatedAt": "2018-03-27T00:48:46Z"
        }
      ]
    },
    {
      "number": 525,
      "id": "MDU6SXNzdWUzMDY5NTI4MjE=",
      "title": "Security consideration: origins unable to restrict non-HTTP APIs cookie setting",
      "url": "https://github.com/httpwg/http-extensions/issues/525",
      "state": "OPEN",
      "author": "enygren",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "The security issues motivating CSP Cookie Controls (https://www.w3.org/TR/csp-cookies/) still exist.   We at a minimum we should list this as a security consideration.   In particular, an origin is unable to restrict non-HTTP APIs from setting cookies on a host or domain.  While perhaps this is a nice-to-have for hosts (APIs operating in the origin context can do lots of other things), it is a major problem unique to cookies for domains.  \r\n\r\nA multi-tenant domain (with independent origins under it) has no in-band way to prevent cookies from being set on the entire domain (ie, to restrict cookies to same-site).  The only option available there is to put the domain on a public-suffix list which isn't always scale-able or operationally maintainable.\r\n\r\nIt may also be worth considering a response header that servers could send to constrain all cookies to same-site as part of this, either with \"Content-Security-Policy: cookie-scope host\" or as a separate response header specific to this use-case.  For example, a \"Restrict-Cookies\" response header with tokens matching the new features of 6265bis (same-site, secure-only, none) that would constrain behaviors of non-HTTP APIs.\r\n",
      "createdAt": "2018-03-20T16:55:50Z",
      "updatedAt": "2018-10-21T01:24:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "michael-oneill",
          "authorAssociation": "NONE",
          "body": "What would it take to re-invigorate CSP Cookie Controls? Given the current visibility of online privacy this might be a good time to revisit it.",
          "createdAt": "2018-04-04T11:36:23Z",
          "updatedAt": "2018-04-04T11:36:23Z"
        }
      ]
    },
    {
      "number": 527,
      "id": "MDU6SXNzdWUzMDcyMTk2NTM=",
      "title": "bcp56bis - 4.9 is scheme the right scope",
      "url": "https://github.com/httpwg/http-extensions/issues/527",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "4.9 rightfully discourages digest and basic on \"http\" scheme.. but is \"scheme\" the right scope, or should that be language about secure transports (as http can of course carry a variety of schemes).",
      "createdAt": "2018-03-21T12:11:43Z",
      "updatedAt": "2018-03-30T00:08:03Z",
      "closedAt": "2018-03-30T00:08:03Z",
      "comments": []
    },
    {
      "number": 528,
      "id": "MDU6SXNzdWUzMDcyMjA0MzM=",
      "title": "bcp56bis 4.9 - stateless",
      "url": "https://github.com/httpwg/http-extensions/issues/528",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "> Applications MUST NOT make assumptions about the relationship between\r\n   separate requests on a single transport connection; doing so breaks\r\n   many of the assumptions of HTTP as a stateless protocol, and will\r\n   cause problems in interoperability, security, operability and\r\n   evolution.\r\n\r\ngood paragraph! But I think it deserves its own headline instead of being mushed in with authentication (which is just one related subset of the problem).\r\n\r\nIt would be good to also point out that HTTP isn't a reliable messaging protocol -> ATLS is currently confused about that.",
      "createdAt": "2018-03-21T12:14:25Z",
      "updatedAt": "2018-03-30T00:11:20Z",
      "closedAt": "2018-03-30T00:11:20Z",
      "comments": []
    },
    {
      "number": 529,
      "id": "MDU6SXNzdWUzMDc2NTAxMjE=",
      "title": "Expand upon CORS",
      "url": "https://github.com/httpwg/http-extensions/issues/529",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "DOH ran into it.",
      "createdAt": "2018-03-22T13:46:47Z",
      "updatedAt": "2018-04-03T06:53:05Z",
      "closedAt": "2018-04-03T00:35:16Z",
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Do you have a pointer about the DOH thing? Somewhat curious.",
          "createdAt": "2018-04-03T06:32:20Z",
          "updatedAt": "2018-04-03T06:32:20Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Someone implemented DOH in a browser and was surprised to see an OPTIONS request.  Basically, CORS worked as intended.",
          "createdAt": "2018-04-03T06:53:05Z",
          "updatedAt": "2018-04-03T06:53:05Z"
        }
      ]
    },
    {
      "number": 530,
      "id": "MDU6SXNzdWUzMDc2NTAzNTQ=",
      "title": "GET / POST equivalence",
      "url": "https://github.com/httpwg/http-extensions/issues/530",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Talk about the pitfalls, mitigations\r\n\r\ne.g., doh\r\n\r\n",
      "createdAt": "2018-03-22T13:47:16Z",
      "updatedAt": "2018-04-02T05:00:35Z",
      "closedAt": "2018-04-02T05:00:35Z",
      "comments": []
    },
    {
      "number": 532,
      "id": "MDU6SXNzdWUzMDg4MDM4Njc=",
      "title": "Fetch?",
      "url": "https://github.com/httpwg/http-extensions/issues/532",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "one thing that came up at the WHATWG Bar BoF was the possibility of referencing Fetch as one way to specify how a client should behave.",
      "createdAt": "2018-03-27T02:54:16Z",
      "updatedAt": "2018-04-02T05:12:50Z",
      "closedAt": "2018-04-02T05:12:50Z",
      "comments": []
    },
    {
      "number": 533,
      "id": "MDU6SXNzdWUzMDg5MjQzNjY=",
      "title": "Specifying Structured Headers",
      "url": "https://github.com/httpwg/http-extensions/issues/533",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "> \"foo\" MUST be between 0 and 10, inclusive; other values MUST be ignored.\r\n\r\nIt seems you want to say that other values MUST cause the header to be ignored?",
      "createdAt": "2018-03-27T11:12:52Z",
      "updatedAt": "2018-03-28T06:12:47Z",
      "closedAt": "2018-03-28T06:12:47Z",
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "> If a member of barURLs is not a valid URI-reference, it MUST be ignored.\r\n\r\nSame goes for this (although I'll note that browsers have no such algorithm).",
          "createdAt": "2018-03-27T11:13:45Z",
          "updatedAt": "2018-03-27T11:13:45Z"
        }
      ]
    },
    {
      "number": 534,
      "id": "MDU6SXNzdWUzMDg5MjY2MDY=",
      "title": "Parsing Text into Structured Headers",
      "url": "https://github.com/httpwg/http-extensions/issues/534",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "The text makes it appear as if this algorithm takes a header value, but then it branches on arguments not explicitly given. It would be better if the algorithm stated upfront that you need to have (side channel) knowledge about the header to get a structured representation about it.\r\n\r\n(This is also what I dislike about this proposal. That it requires knowledge about the header names to do something useful. That doesn't work well for generic processors or APIs.)",
      "createdAt": "2018-03-27T11:20:17Z",
      "updatedAt": "2018-03-28T06:05:09Z",
      "closedAt": "2018-03-28T06:03:59Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "What you dislike is covered in #476. Feel free to comment over there.",
          "createdAt": "2018-03-28T06:05:09Z",
          "updatedAt": "2018-03-28T06:05:09Z"
        }
      ]
    },
    {
      "number": 535,
      "id": "MDU6SXNzdWUzMDg5Mjc1NjM=",
      "title": "Parsing a Dictionary from Text",
      "url": "https://github.com/httpwg/http-extensions/issues/535",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Step 2.1 (and generally any sub-invocations) doesn't deal with failure.",
      "createdAt": "2018-03-27T11:23:32Z",
      "updatedAt": "2018-03-28T06:09:13Z",
      "closedAt": "2018-03-28T06:09:13Z",
      "comments": []
    },
    {
      "number": 536,
      "id": "MDU6SXNzdWUzMDg5Njk3OTY=",
      "title": "\"confused deputy\"",
      "url": "https://github.com/httpwg/http-extensions/issues/536",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "> to avoid the \"confused deputy\" problem\r\n\r\nNo, it's to avoid leaking private information. Servers can still be susceptible to the confused deputy problem with CORS. They need to address that independently.",
      "createdAt": "2018-03-27T13:30:52Z",
      "updatedAt": "2018-03-30T00:12:53Z",
      "closedAt": "2018-03-30T00:12:53Z",
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "(This was about https://tools.ietf.org/html/draft-ietf-httpbis-bcp56bis-02. Well, -00, but the latest contains the same problem elsewhere.)",
          "createdAt": "2018-03-27T13:31:50Z",
          "updatedAt": "2018-03-27T13:31:50Z"
        }
      ]
    },
    {
      "number": 537,
      "id": "MDU6SXNzdWUzMDkyMjMyNjk=",
      "title": "UTF-8",
      "url": "https://github.com/httpwg/http-extensions/issues/537",
      "state": "CLOSED",
      "author": "evert",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "I noticed the structured headers proposal strictly ignores UTF-8, because it's not used much. The recommendation is to use the binary format instead.\r\n\r\nI thought that [RFC8187](https://tools.ietf.org/html/rfc8187) was fairly good for this.\r\n\r\nI can see structured-headers to be a super useful generic way to describe new standard and proprietary headers, but ignoring UTF-8 means we're limited in what categories of data probably unsafe for the purpose of a header.\r\n\r\nIs there a possibility to merge the syntax of RFC8187? It's true that it might not be used as much in practice, but it might expand the potential use-cases. Furthermore, as an implementor I don't have to worry about what someone might encode. The binary format doesn't quite cut it, because it doens't provide a hint as to how a generic client might decode it.  ",
      "createdAt": "2018-03-28T05:11:38Z",
      "updatedAt": "2019-03-28T10:20:53Z",
      "closedAt": "2018-04-02T05:57:00Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "This has been discussed a fair amount; non-ASCII payloads in headers is pretty rare (since headers are generally not displayed to users).\r\n\r\nYou could encode it as binary, or you could use percent-encoding inside a string.\r\n\r\nIf there's significant demand for it, we could add a new type, but then we need to be able to discriminate it from ascii strings -- both on the wire and in APIs.",
          "createdAt": "2018-03-28T05:59:54Z",
          "updatedAt": "2018-03-28T05:59:54Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "It'd be good to have use cases indeed. The only case I've seen folks make for this is URLs, which end up being ASCII-compatible once parsed, so are not that compelling.\r\n\r\nIf we do this a variant on binary makes the most sense to me, where we run https://encoding.spec.whatwg.org/#utf-8-decode-without-bom-or-fail on the bytes before returning the value.",
          "createdAt": "2018-03-28T06:39:05Z",
          "updatedAt": "2018-03-28T06:39:05Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One thing I'm running into is providing a Title for a link. Basically the specification is saying right now is that headers are strictly identifiers for computers, and never information for humans. Is that the right assumption? \r\n",
          "createdAt": "2018-03-29T06:38:58Z",
          "updatedAt": "2018-03-29T06:39:31Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I think it's saying that UI is the exceptional case and that in such exceptional cases you can use \"binary\" plus UTF-8 processing on top.",
          "createdAt": "2018-03-29T06:45:04Z",
          "updatedAt": "2018-03-29T06:45:04Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While I understand the argument that it might not be an extremely common case, I am kind of left wondering what the specific argument *against* UTF-8 support, especially in light of the fact that an established mechanism for this exists. ",
          "createdAt": "2018-03-29T17:39:11Z",
          "updatedAt": "2018-03-29T17:39:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Because developers have been trained to use it, and if it's available as a \"native\" option, will use it out of habit / cargo culting.\r\n\r\nWhile in most places UTF-8 is clearly the right thing to do, this is not at all true in protocols; years of experience has shown that it causes performance overhead, bloat, imprecision, confusion, and sometimes security issues.\r\n\r\nIt's better to make the right thing easier to do (strings) and make the usually not-right thing harder to do (utf-8). One of the objectives for Structured Headers is to leave as few foot guns lying around as possible.",
          "createdAt": "2018-03-29T22:24:55Z",
          "updatedAt": "2018-03-29T22:24:55Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds like a solid reason. At least we still have the other syntax for anything else.",
          "createdAt": "2018-03-30T07:36:11Z",
          "updatedAt": "2018-03-30T07:36:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK, closing. ",
          "createdAt": "2018-04-02T05:57:00Z",
          "updatedAt": "2018-04-02T05:57:00Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "FWIW, I disagree with the conclusion. The only compelling reason I can think of to move structured header fields forward on the standards track is if it provides a means to communicate more than the existing HTTP generic parsing algorithm. Basically, that means providing a safe way to introduce UTF-8 and/or standard date/delta formats. Both have been excluded from SH, so \ud83d\udc4e ",
          "createdAt": "2019-03-28T10:20:53Z",
          "updatedAt": "2019-03-28T10:20:53Z"
        }
      ]
    },
    {
      "number": 538,
      "id": "MDU6SXNzdWUzMDkyMjM4NDE=",
      "title": "structured-headers: Has JSON been considered?",
      "url": "https://github.com/httpwg/http-extensions/issues/538",
      "state": "CLOSED",
      "author": "evert",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "This is a question I got after publishing a first stab at [an implementation](http://github.com/evert/structured-header/). Was JSON considered as an alternative for this?\r\n\r\nAt least some reasons why I can think of why it wouldn't be good are:\r\n\r\n* It doesn't encode binary data\r\n* It's not as aesthetically pleasing, especially considering how HTTP headers generally 'look'.\r\n\r\nHowever, parsers are everywhere and JSON has some properties that structured-headers doesn't have, such as deeper nesting, encoding `null` and it also solves #534",
      "createdAt": "2018-03-28T05:15:20Z",
      "updatedAt": "2018-03-28T05:58:05Z",
      "closedAt": "2018-03-28T05:56:49Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes - there's a long history behind that, and we originally had a JSON-based approach.\r\n\r\nBesides the reason you mention, there was a lot of discomfort around the imprecision of numbers in JSON, and also about enabling arbitrary nesting of data structures.",
          "createdAt": "2018-03-28T05:56:49Z",
          "updatedAt": "2018-03-28T05:56:49Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the feedback. I'm gonna try to dig into the discussions",
          "createdAt": "2018-03-28T05:58:05Z",
          "updatedAt": "2018-03-28T05:58:05Z"
        }
      ]
    },
    {
      "number": 539,
      "id": "MDU6SXNzdWUzMDkyMzczOTk=",
      "title": "base64 dialect",
      "url": "https://github.com/httpwg/http-extensions/issues/539",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "@martinthomson gave me the impression somewhere that new base64 usage should use the base64url.\r\n\r\nhttps://tools.ietf.org/html/draft-ietf-httpbis-header-structure-04#section-4.9 doesn't, which makes me worry browsers would use https://infra.spec.whatwg.org/#forgiving-base64 here leading to the interoperability issues already anticipated by that section.",
      "createdAt": "2018-03-28T06:32:09Z",
      "updatedAt": "2018-04-19T07:53:14Z",
      "closedAt": "2018-04-19T07:29:33Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson thoughts?",
          "createdAt": "2018-03-30T00:28:48Z",
          "updatedAt": "2018-03-30T00:28:48Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There are good reasons to use a single, less permissive syntax in this context.  On the assumption that the forgiving parser is mostly an unfortunate consequence of having poor specifications in the past, the move to base64url has several reasons:\r\n\r\n1. it's simpler\r\n2. it's smaller\r\n3. it's more secure\r\n\r\nThe last one is the one I care about.  If we are going to put secrets in header fields, as is our wont, then the encoding and decoding processes need to be constant time.  Now, we don't really know how to do that perfectly, but a limited grammar makes it more likely that we get it right.\r\n\r\nNow, the forgiving algorithms aren't actually all that forgiving.  As far as I can tell, they are lax about padding and trailing bits. Given that, they would be perfectly good in this context.\r\n\r\nFWIW, I generally prefer the URL-safe variants because you get the following sort of thing less often, which is not good from a security perspective:\r\n\r\n```js\r\nbase64.encode(x).replace(/\\+/g, '-').replace(/\\//g, '_')\r\n```",
          "createdAt": "2018-04-03T06:09:16Z",
          "updatedAt": "2018-04-03T06:09:16Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "A quick look (JavaScript, Python, Ruby) shows that most \"url-safe base64\" implementations _in the standard libraries_ do exactly that. Also, it appears to be less available than straight base64.\r\n\r\nSo I'm not sure that specifying `base64url` is going to have the intended effect. I'm more inclined to leave the spec as-is and assure that the test cases (coming any day!) explore the dark corners here.\r\n\r\nIs that sufficient?",
          "createdAt": "2018-04-09T23:40:15Z",
          "updatedAt": "2018-04-09T23:40:15Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That is a fine answer.",
          "createdAt": "2018-04-10T00:52:41Z",
          "updatedAt": "2018-04-10T00:52:41Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I'd rather browsers only have a single base64 implementation and a single base64url implementation. Having two different base64 variants would be slightly annoying.",
          "createdAt": "2018-04-10T06:27:13Z",
          "updatedAt": "2018-04-10T06:27:13Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@annevk where is the browser implementation of base64url specified? I.e., how to do we know that it has the properties we're looking for?\r\n\r\nAlso, given that there are a small number of browser vendors and they're highly motivated, and there are many people using many different server-side implementation libraries, I'm not sure we should be optimising for the browser makers.",
          "createdAt": "2018-04-10T06:44:52Z",
          "updatedAt": "2018-04-10T06:44:52Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "@mnot if I'm to believe @martinthomson browsers match the base64url definition defined by the RFCs. It's base64 that's divergent.\r\n\r\n(I'll note that the argument you present there was also frequently cited for URLs and other data types. Unfortunately it doesn't really work since nobody is that on the ball and pays attention to all the details, so implementations leak and get copy-and-pasted and end up in the wrong spot affecting the larger ecosystem.)",
          "createdAt": "2018-04-10T06:49:37Z",
          "updatedAt": "2018-04-10T06:49:37Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think that is right, or I apologize if that is an impression I gave.  My understanding matches that @mnot gained.  base64 is widely implemented, base64url less so and often just wrapping base64 in a hacky fashion.  But it will depend on context as to what is good and what isn't.\r\n\r\n(Not sure what is implied by \"divergent\".)",
          "createdAt": "2018-04-11T01:45:19Z",
          "updatedAt": "2018-04-11T01:45:19Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@annevk does that address your concern?",
          "createdAt": "2018-04-11T02:53:12Z",
          "updatedAt": "2018-04-11T02:53:12Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "@martinthomson see https://github.com/w3c/push-api/issues/280.\r\n\r\n@mnot I'm just more confused now.",
          "createdAt": "2018-04-11T03:33:04Z",
          "updatedAt": "2018-04-11T03:33:04Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@annevk as I read it, we can close this with no action. I understand your confusion, but I don't think it currently affects this spec (at least, until we get more information).",
          "createdAt": "2018-04-12T02:10:04Z",
          "updatedAt": "2018-04-12T02:10:04Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I guess as long as you write tests that demonstrate how it works differently from `data:` URLs you might be okay, but I'm still doubtful implementations have multiple base64 variants (other than base64url) and it's rather questionable that they should have. (I disagree with your rationale that implementers with a large code base should be able to tolerate shoddy architecture. That just hinders competition, refactoring, etc.)",
          "createdAt": "2018-04-12T04:31:19Z",
          "updatedAt": "2018-04-12T04:31:19Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> I disagree with your rationale that implementers with a large code base should be able to tolerate shoddy architecture\r\n\r\nThat is not my rationale, and I'm not sure how emotive words like \"shoddy architecture\" help.\r\n\r\nIf `base64url` is a genuinely different codebase that has the properties we want, that's great; however, from what I saw, it's generally a wrapper around `base64` implementations.\r\n\r\n> I'm still doubtful implementations have multiple base64 variants (other than base64url)\r\n\r\nQuick spot-check shows broad support for \"variants\" along the lines of what we're looking for:\r\n\r\n* [Python](https://docs.python.org/3.5/library/base64.html#base64.b64decode) - `validate` flag\r\n* [Ruby](https://ruby-doc.org/stdlib-2.5.0/libdoc/base64/rdoc/Base64.html) -  `strict_decode64` function\r\n* [Go](https://golang.org/pkg/encoding/base64/#Encoding.Decode) - raises `CorruptInputError` on non-b64 characters.\r\n* [PHP](https://secure.php.net/manual/en/function.base64-decode.php) - `$strict` argument\r\n* [Swift](https://developer.apple.com/documentation/foundation/nsdata.base64decodingoptions) - `ignoreUknownCharacters` constant\r\n* [Java](https://docs.oracle.com/javase/8/docs/api/java/util/Base64.html) - rejects characters outside the b64 alphabet by default",
          "createdAt": "2018-04-12T06:31:23Z",
          "updatedAt": "2018-04-12T06:31:23Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing for now, but happy to reopen if there's more data / thoughts.",
          "createdAt": "2018-04-19T07:29:33Z",
          "updatedAt": "2018-04-19T07:29:33Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I think the main thing you want to do here is make sure the testsuite really covers all the various angles. In particular the differences in processing with https://github.com/w3c/web-platform-tests/blob/master/fetch/data-urls/resources/base64.json.",
          "createdAt": "2018-04-19T07:53:14Z",
          "updatedAt": "2018-04-19T07:53:14Z"
        }
      ]
    },
    {
      "number": 540,
      "id": "MDU6SXNzdWUzMDkyMzc3Mjg=",
      "title": "Example headers are not using hyphens",
      "url": "https://github.com/httpwg/http-extensions/issues/540",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "In https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-04 the various example headers do not use the naming I'd expect of typical HTTP headers which is somewhat confusing.",
      "createdAt": "2018-03-28T06:33:57Z",
      "updatedAt": "2018-03-30T00:26:49Z",
      "closedAt": "2018-03-30T00:26:49Z",
      "comments": []
    },
    {
      "number": 544,
      "id": "MDU6SXNzdWUzMDk5NDE5Nzk=",
      "title": "Expand \"Co-Existing with Web Browsing\"",
      "url": "https://github.com/httpwg/http-extensions/issues/544",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "e.g., specific security headers, best practices. ",
      "createdAt": "2018-03-30T00:18:54Z",
      "updatedAt": "2018-04-03T00:51:57Z",
      "closedAt": "2018-04-03T00:51:57Z",
      "comments": []
    },
    {
      "number": 545,
      "id": "MDU6SXNzdWUzMDk5NDI0NzY=",
      "title": "Caching",
      "url": "https://github.com/httpwg/http-extensions/issues/545",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "- generic caching can't be modified by application-specific extensions / controls\r\n- remember intermediary caches / reverse caches / CDN caches / server caches\r\n- sometimes a separate expiration is needed\r\n- invalidation",
      "createdAt": "2018-03-30T00:22:34Z",
      "updatedAt": "2018-04-03T02:13:41Z",
      "closedAt": "2018-04-03T02:13:41Z",
      "comments": []
    },
    {
      "number": 546,
      "id": "MDU6SXNzdWUzMDk5NDI1NzE=",
      "title": "GET w/body",
      "url": "https://github.com/httpwg/http-extensions/issues/546",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "it comes up.",
      "createdAt": "2018-03-30T00:23:15Z",
      "updatedAt": "2018-04-02T05:00:34Z",
      "closedAt": "2018-04-02T05:00:34Z",
      "comments": []
    },
    {
      "number": 547,
      "id": "MDU6SXNzdWUzMDk5NDI2MTY=",
      "title": "POST is special",
      "url": "https://github.com/httpwg/http-extensions/issues/547",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "",
      "createdAt": "2018-03-30T00:23:30Z",
      "updatedAt": "2018-04-02T05:55:30Z",
      "closedAt": "2018-04-02T05:55:30Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Nah.",
          "createdAt": "2018-04-02T05:55:30Z",
          "updatedAt": "2018-04-02T05:55:30Z"
        }
      ]
    },
    {
      "number": 548,
      "id": "MDU6SXNzdWUzMTAzNzQ4MzA=",
      "title": "Multiple Variant-Keys",
      "url": "https://github.com/httpwg/http-extensions/issues/548",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "Allow a response to associate itself with more than one variant.\r\n\r\n_(moved from mnot/I-D)_",
      "createdAt": "2018-04-02T02:06:13Z",
      "updatedAt": "2018-04-19T07:28:46Z",
      "closedAt": "2018-04-19T07:28:46Z",
      "comments": []
    },
    {
      "number": 549,
      "id": "MDU6SXNzdWUzMTAzNzQ5MDE=",
      "title": "Cookies",
      "url": "https://github.com/httpwg/http-extensions/issues/549",
      "state": "OPEN",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "Would an algorithm to key the cache on a cookie by name work?\r\n\r\n_(moved from mnot/I-D)_",
      "createdAt": "2018-04-02T02:06:55Z",
      "updatedAt": "2019-11-25T11:38:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think the basic use case here is \"a request with a cookie named X whose value matches Y can use this response,\" where `X` is nominated in the Variants header, and `Y` is matched in the request (and Variant-Key).\r\n\r\nE.g.,\r\n\r\n~~~\r\nVariants: cookie; foo\r\nVariant-Key: 1\r\n~~~\r\n\r\nCould be used to match a request with:\r\n\r\n~~~\r\nCookie: foo=1\r\n~~~\r\n\r\nTBD:\r\n\r\n* [ ] Is that enough? Other use cases?\r\n* [ ] See how the actual algorithm / serialisation works\r\n* [ ] Handle cases where the cookie isn't present\r\n* [ ] How does it work with multiple cookies? Combining with other headers?",
          "createdAt": "2018-11-13T05:14:44Z",
          "updatedAt": "2018-11-13T05:14:44Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That looks like a different meaning for `Variants` than the spec defines. Specifically, the ABNFs are:\r\n\r\n```abnf\r\nVariants        = 1#variant-item\r\nvariant-item    = field-name *( OWS \";\" OWS available-value )\r\navailable-value = ...\r\nVariant-Key      = 1#available-values\r\navailable-values = available-value *( \";\" available-value )\r\n```\r\n\r\nYour suggestion for cookies has `Variants` formatted like `field-name *(\";\" subfield-name)` instead. That'll lead to the result of https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#cache never matching the normalized Variant-Keys value, and the cache will never return one of these responses.\r\n\r\nIf you want to select particular cookies, I think you need to mess with the `field-name` part of the `Variants` header, perhaps by delimiting subfields by a non-tchar.",
          "createdAt": "2018-12-13T21:52:40Z",
          "updatedAt": "2018-12-13T21:52:40Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes, that was from a previous syntax - thanks for the reminder.",
          "createdAt": "2019-02-06T07:22:32Z",
          "updatedAt": "2019-02-06T07:22:32Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "See proposal roughed in above; @jyasskin I'm curious to know if this seems sensible to you.",
          "createdAt": "2019-08-30T10:18:42Z",
          "updatedAt": "2019-08-30T10:18:42Z"
        },
        {
          "author": "essen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The current text for [cookies](https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#cookie) does not work with structured headers, more specifically this part:\r\n\r\n```\r\nNote that if more than one cookie-name serves as a cache key,\r\nthey\u2019ll need to be listed in separate Variants members, like this:\r\n\r\nVariants: Cookie=(user_priority), Cookie=(user_region)\r\nVariant-Key: (gold europe)\r\nVary: Cookie\r\n```\r\n\r\nThe problem is that in https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-14#section-3.2 it says:\r\n\r\n```\r\nThere can be zero or more members, and their names are required to be\r\nunique within the scope of the dictionary they occur within.\r\n```\r\n\r\nSo unless I'm mistaken we cannot have `cookie` twice. And you can't really put the cookie name as the member name due to syntax restrictions (lowercase plus a small set of allowed characters). Maybe a special variant header for cookies would work better?",
          "createdAt": "2019-11-25T09:53:04Z",
          "updatedAt": "2019-11-25T09:53:04Z"
        },
        {
          "author": "essen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This one is probably wrong as well because `0` is not a string or token, it's an integer. It probably should be `\"0\"`.\r\n\r\n```\r\n   Variants: Cookie=(logged_in)\r\n   Variant-Key: (0)\r\n   Vary: Cookie\r\n```",
          "createdAt": "2019-11-25T11:38:03Z",
          "updatedAt": "2019-11-25T11:38:03Z"
        }
      ]
    },
    {
      "number": 550,
      "id": "MDU6SXNzdWUzMTAzOTc2MjY=",
      "title": "Refer to http-core",
      "url": "https://github.com/httpwg/http-extensions/issues/550",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis",
        "editorial"
      ],
      "body": "... when available.",
      "createdAt": "2018-04-02T05:19:28Z",
      "updatedAt": "2018-11-11T02:24:42Z",
      "closedAt": "2018-11-11T02:24:42Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the first section references 7230.. which immediately begs the question of what about 7540.\r\n\r\nassuming http-core won't be an rfc before this is published (and its not worth waiting for it) it would probably be good to have a paragraph just saying that 7230 defines both semantics and wire protocol, and 7540 is an alternative wire protocol for those same semantics (ummm.. plus push.).. and that your text in bcp56bis is generally scoped to the semantics unless otherwise noted. That might at least sort things out a bit.\r\n\r\nthis might also be a place to say that best practices of using http limit themselves to the semantics.. 4.1 kinda says that - not sure about a specific suggestion\r\n",
          "createdAt": "2018-05-04T22:20:23Z",
          "updatedAt": "2018-05-04T22:20:23Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "My assumption has been that once core settles down, we'll change references appropriately, and this will sit in the queue depending on core.",
          "createdAt": "2018-05-05T03:38:13Z",
          "updatedAt": "2018-05-05T03:38:13Z"
        }
      ]
    },
    {
      "number": 554,
      "id": "MDU6SXNzdWUzMTA2MjI0MTI=",
      "title": "Quality Values in Representation Variants",
      "url": "https://github.com/httpwg/http-extensions/issues/554",
      "state": "CLOSED",
      "author": "thpts",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "I had previous asked about this [during the WG session during IETF 101](https://youtu.be/RaNy8HewRqM?t=8911).\r\n\r\nI believe this specification should explicitly declare if servers are obligated to honor quality value prioritisation as given to them from clients. The [example provided in the introduction](https://tools.ietf.org/html/draft-ietf-httpbis-variants-00#section-1) shows the server serving the French version of the content despite having the English variant available and the user agent setting preference for it. Does this imply that quality values are to be ignored?",
      "createdAt": "2018-04-02T21:46:32Z",
      "updatedAt": "2018-04-09T06:28:42Z",
      "closedAt": "2018-04-09T06:28:42Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can you clarify how you conclude that the server possesses an English variant and ignores the quality values?  The text explicitly says that, because the cache observed the request for `en;q=1.0, fr;q=0.5` got a response in French, it \"might be able to infer that an English representation is *not* available.\" (Emphasis added.)",
          "createdAt": "2018-04-02T21:51:37Z",
          "updatedAt": "2018-04-02T21:51:37Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, never mind.  In the second example with Variants, the server claims possession of an English variant.  I think this is just a bug in the second example.",
          "createdAt": "2018-04-02T21:52:52Z",
          "updatedAt": "2018-04-02T21:52:52Z"
        },
        {
          "author": "thpts",
          "authorAssociation": "NONE",
          "body": "Sorry, I should have explicitly stated the second example. Bug in the example or not, I still believe this specification should make a clear position.",
          "createdAt": "2018-04-02T22:00:18Z",
          "updatedAt": "2018-04-02T22:00:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hi Thomas,\r\n\r\nStep 2 of each of the algorithms for `Accept`, `Accept-Language` and `Accept-Encoding` already accounts for this; for example, in [A.1](http://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#content-type):\r\n\r\n> 2. Let preferred-types be a list of the types in the request-value, ordered by their weight, highest to lowest, as per [RFC7231] Section 5.3.2 (omitting any coding with a weight of 0). If \u201cAccept\u201d is not present or empty, preferred-types will be empty. If a type lacks an explicit weight, an implementation MAY assign one.\r\n\r\nI see the bug in the examples; will fix.\r\n\r\nOrdering by weight is applying the `q` value. \r\n\r\nIt's not appropriate to make a blanket statement, because not all headers that use `Variants` will define its use (e.g., the various [Client Hints](http://httpwg.org/http-extensions/draft-ietf-httpbis-client-hints.html)). It's up to each individual header to decide how its semantics get mapped into `Variants`.\r\n\r\n",
          "createdAt": "2018-04-02T22:57:49Z",
          "updatedAt": "2018-04-02T22:57:49Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing; if you feel this hasn't been addressed, please comment.",
          "createdAt": "2018-04-09T06:28:42Z",
          "updatedAt": "2018-04-09T06:28:42Z"
        }
      ]
    },
    {
      "number": 556,
      "id": "MDU6SXNzdWUzMTA3NjU1Nzg=",
      "title": "Headers",
      "url": "https://github.com/httpwg/http-extensions/issues/556",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "- [x] refer to 7231 section on considerations for new headers (point out the most important?)\r\n- [x] refer to structured headers?",
      "createdAt": "2018-04-03T09:45:22Z",
      "updatedAt": "2018-04-10T05:48:30Z",
      "closedAt": "2018-04-10T05:48:30Z",
      "comments": []
    },
    {
      "number": 557,
      "id": "MDU6SXNzdWUzMTA3NjYxMDg=",
      "title": "Redirects",
      "url": "https://github.com/httpwg/http-extensions/issues/557",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "- mention that message bodes are removed\r\n- when redirects are handled, request header forwarding is... interesting",
      "createdAt": "2018-04-03T09:46:52Z",
      "updatedAt": "2018-04-12T00:20:18Z",
      "closedAt": "2018-04-12T00:20:18Z",
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "You might want to mention Fetch here, since if the user agent has any kind of origin policy, they better enforce it for redirects too. Also, there's a bunch of message body forwarding happening too; they're only dropped for a couple of status codes / request methods.",
          "createdAt": "2018-04-05T06:41:30Z",
          "updatedAt": "2018-04-05T06:41:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "This is already covered in \"Specifying Client Behaviours\". I'm tempted to break out a separate \"redirects\" section, but let's see.",
          "createdAt": "2018-04-12T00:20:18Z",
          "updatedAt": "2018-04-12T00:20:18Z"
        }
      ]
    },
    {
      "number": 558,
      "id": "MDU6SXNzdWUzMTA3NjY1MzI=",
      "title": "no-cache, no-store",
      "url": "https://github.com/httpwg/http-extensions/issues/558",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Point out the common trap that `no-cache` responses can still be cached.",
      "createdAt": "2018-04-03T09:48:06Z",
      "updatedAt": "2018-04-04T00:46:45Z",
      "closedAt": "2018-04-04T00:46:45Z",
      "comments": []
    },
    {
      "number": 560,
      "id": "MDU6SXNzdWUzMTA4ODI2MDE=",
      "title": "Values for available-value by reference?",
      "url": "https://github.com/httpwg/http-extensions/issues/560",
      "state": "CLOSED",
      "author": "hvdsomp",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "For memento datetime negotiation using the `Accept-Datetime` header, as specified in [RFC7089](https://tools.ietf.org/html/rfc7089), the list of values for `available-value` would typically be too large to convey by-value in the `Variants` header. That is because resource versions with many different datetimes can exist in both resource versioning systems and web archives. In order to convey all  datetime values that could be used for datetime negotiation, an approach to provide these values by-reference rather than by-value would be required. Currently, I assume that datetime negotiation is the only negotiation for which this problem exists but with explorations of other negotiation dimensions on the way (e.g. [fine grained content negotiation](https://ruben.verborgh.org/articles/fine-grained-content-negotiation/)) that may change.",
      "createdAt": "2018-04-03T15:20:27Z",
      "updatedAt": "2018-04-06T07:21:13Z",
      "closedAt": "2018-04-06T07:21:13Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hi Herbert,\r\n\r\nI think it's possible to do this with Variants; the algorithm for `Accept-Datetime` would ignore `available-values` and consult another header for the URL, look it up and use the retrieved values.\r\n\r\nHaving said that, I don't think any cache would implement it, because the overhead would be spectacular. Even served from cache, it's looking up a separate URL and doing some non-trivial parsing.\r\n\r\nDoes that make sense? I know it's not terribly satisfying, but it _could_ be accommodated -- and I think that's good.",
          "createdAt": "2018-04-04T00:42:30Z",
          "updatedAt": "2018-04-04T00:42:30Z"
        },
        {
          "author": "hvdsomp",
          "authorAssociation": "NONE",
          "body": "Hi Mark,\r\n\r\n2 things:\r\n\r\n- My suggestion was not to have a cache ignore `available-value` (and look at another header), but rather to allow a URL as a value of `available-value` (or another param, e.g. `available-value-url`). \r\n- As I indicated,  Memento's datetime negotiation is currently the only negotiation with a potentially large namespace of possible values for `available-value`. I wonder whether that will remain the case, though (see e.g.  [fine grained content negotiation](https://ruben.verborgh.org/articles/fine-grained-content-negotiation/)) and as such I also wonder whether a new mechanism to support content negotiation - `Variants` - shouldn't be future proof with this regard?",
          "createdAt": "2018-04-05T15:44:39Z",
          "updatedAt": "2018-04-05T15:44:39Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "1) Understood. However, the specified syntax for `available-value` is a token, and URLs can't fit into that, so that's the effect -- it has to come from somewhere else. Not a big deal, just how we'd do it.\r\n\r\n2) Variant isn't that ambitious; it's just trying to encompass current practice on the Web, and near-future uses like Client Hints. It's definitely going to be inappropriate for some use cases, and this limitation is already documented.\r\n\r\nThanks!",
          "createdAt": "2018-04-06T07:21:13Z",
          "updatedAt": "2018-04-06T07:21:13Z"
        }
      ]
    },
    {
      "number": 562,
      "id": "MDU6SXNzdWUzMTE4MjE1Mjk=",
      "title": "The abstract is really an introduction",
      "url": "https://github.com/httpwg/http-extensions/issues/562",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "5 paragraphs is probably too much.  We should check to see if anything needs to be salvaged and then shorten to:\r\n\r\nA use of TLS exported authenticators is described that enables HTTP/2 clients and servers to offer additional certificate-based credentials after the connection is established.  The means by which these credentials are use with requests is defined.",
      "createdAt": "2018-04-06T01:29:11Z",
      "updatedAt": "2018-04-13T17:14:43Z",
      "closedAt": "2018-04-13T17:14:43Z",
      "comments": []
    },
    {
      "number": 563,
      "id": "MDU6SXNzdWUzMTIwOTQyNDI=",
      "title": "on status codes",
      "url": "https://github.com/httpwg/http-extensions/issues/563",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "I think FOH (foo over http), has a tendency to encourage \"when x happens, use http code xxx\"... the draft talks about not minting new xxx, but doesn't explore why specifying xxx is an iffy idea.\r\n\r\nyou can really only control what the server emits.. and even then it might be in conflict with some other possible return codes.. but the client needs to be prepared to deal with anything because the server might not be a FOH server.\r\n\r\nto generalize - a received error code isn't a strong signal of what actually happened.\r\n",
      "createdAt": "2018-04-06T19:41:30Z",
      "updatedAt": "2018-04-11T23:24:12Z",
      "closedAt": "2018-04-11T23:24:12Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@mcmanus ^^",
          "createdAt": "2018-04-10T05:25:05Z",
          "updatedAt": "2018-04-10T05:25:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing; if you aren't happy please comment / reopen.",
          "createdAt": "2018-04-11T23:24:11Z",
          "updatedAt": "2018-04-11T23:24:11Z"
        }
      ]
    },
    {
      "number": 564,
      "id": "MDU6SXNzdWUzMTIxNDUzMTk=",
      "title": "Client probes for server certificates are awkward",
      "url": "https://github.com/httpwg/http-extensions/issues/564",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "In the current draft, the client ties up a stream for a pending request on an unproven domain so that it can send a `NEEDED` frame, permitting the server to respond with `USE`.  This is rather awkward.\r\n\r\nHowever, the alternative is also somewhat unappealing.  In the process of updating #480, I'm adding a suggestion that servers SHOULD respond to `REQUEST` with an appropriate certificate if they have one, which makes this flow much cleaner.  However, there's current no way to *reject* a certificate request without a request stream.",
      "createdAt": "2018-04-06T23:09:10Z",
      "updatedAt": "2018-06-13T23:56:02Z",
      "closedAt": "2018-06-13T23:56:02Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One possibility:  Since the solution to #482 involves moving `USE`/`NEEDED` onto the control stream, perhaps it should be valid for clients to send those frames in reference to the connection itself?",
          "createdAt": "2018-04-06T23:10:06Z",
          "updatedAt": "2018-04-06T23:10:06Z"
        }
      ]
    },
    {
      "number": 565,
      "id": "MDU6SXNzdWUzMTIxNTE1MjU=",
      "title": "ORIGIN is an RFC now",
      "url": "https://github.com/httpwg/http-extensions/issues/565",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "Need to update the references here; not doing it in my current PR, so issue to keep me from forgetting.",
      "createdAt": "2018-04-06T23:57:07Z",
      "updatedAt": "2018-04-13T17:31:27Z",
      "closedAt": "2018-04-13T17:31:27Z",
      "comments": []
    },
    {
      "number": 567,
      "id": "MDU6SXNzdWUzMTIxODQ1NDY=",
      "title": "OPTIONS",
      "url": "https://github.com/httpwg/http-extensions/issues/567",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Explain the pitfalls of OPTIONS.",
      "createdAt": "2018-04-07T08:06:26Z",
      "updatedAt": "2018-04-11T23:39:30Z",
      "closedAt": "2018-04-11T23:39:30Z",
      "comments": []
    },
    {
      "number": 568,
      "id": "MDU6SXNzdWUzMTIxODUyOTg=",
      "title": "HTTPS",
      "url": "https://github.com/httpwg/http-extensions/issues/568",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "TAG feedback: this needs to be strengthened:\r\n\r\n> \u201chttps\u201d is preferred to provide authentication, integrity and confidentiality, as well as mitigate pervasive monitoring attacks",
      "createdAt": "2018-04-07T08:18:52Z",
      "updatedAt": "2018-04-12T00:21:58Z",
      "closedAt": "2018-04-12T00:21:58Z",
      "comments": []
    },
    {
      "number": 569,
      "id": "MDU6SXNzdWUzMTI0MDMxNjM=",
      "title": "Generic Semantics",
      "url": "https://github.com/httpwg/http-extensions/issues/569",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "... needs some tweaking.",
      "createdAt": "2018-04-09T05:57:24Z",
      "updatedAt": "2018-04-10T05:38:33Z",
      "closedAt": "2018-04-10T05:38:33Z",
      "comments": []
    },
    {
      "number": 570,
      "id": "MDU6SXNzdWUzMTI0MDM4OTQ=",
      "title": "Adopt Structured Headers",
      "url": "https://github.com/httpwg/http-extensions/issues/570",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "",
      "createdAt": "2018-04-09T06:01:09Z",
      "updatedAt": "2019-01-07T02:52:41Z",
      "closedAt": "2019-01-07T02:52:41Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "* `Variants` looks like a parameterised list\r\n* `Variant-Key` is currently a list of strings, but if #548 is adopted, its syntax will need to be changed, as it doesn't fit into parameterised list particularly well (although I guess it could).",
          "createdAt": "2018-04-10T07:08:15Z",
          "updatedAt": "2018-04-10T07:08:15Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Currently waiting on resolution of #721.",
          "createdAt": "2018-11-13T04:48:53Z",
          "updatedAt": "2018-11-13T04:48:53Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot #721 is closed now. Any hints?",
          "createdAt": "2018-12-04T17:51:33Z",
          "updatedAt": "2018-12-04T17:51:33Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hi @ioggstream - getting to it. Are you planning on implementing or using?",
          "createdAt": "2018-12-07T06:26:45Z",
          "updatedAt": "2018-12-07T06:26:45Z"
        }
      ]
    },
    {
      "number": 577,
      "id": "MDU6SXNzdWUzMTMwMTMyNTk=",
      "title": "HTTPwg.org Redirect fails to surface branch builds",
      "url": "https://github.com/httpwg/http-extensions/issues/577",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "For active branches, the template builds copies of the documents as they appear on each branch.  (For example, [This link](http://httpwg.github.io/http-extensions/off-streams/draft-ietf-httpbis-http2-secondary-certs.html) would point to the version of Secondary Certs if #566 were merged.)  It appears that anything under httpwg.github.io/http-extensions redirects to httpwg.org/http-extensions, but not all content is actually mirrored there, as I get a 404 when following the redirect.\r\n\r\nNot sure how the mirroring is currently accomplished, so I'm not sure how to suggest fixing it.",
      "createdAt": "2018-04-10T17:10:31Z",
      "updatedAt": "2018-04-10T17:12:09Z",
      "closedAt": "2018-04-10T17:12:09Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Nevermind, it's simpler than that.  `-` versus `_` in branch name.  \ud83e\udd26\u200d\u2642\ufe0f ",
          "createdAt": "2018-04-10T17:12:09Z",
          "updatedAt": "2018-04-10T17:12:09Z"
        }
      ]
    },
    {
      "number": 579,
      "id": "MDU6SXNzdWUzMTM1NTE1MDM=",
      "title": "Server Push",
      "url": "https://github.com/httpwg/http-extensions/issues/579",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Do we feel confident enough to say anything about Push yet? Or conversely, should we warn that we don't know if it's going to be useful?",
      "createdAt": "2018-04-12T02:16:34Z",
      "updatedAt": "2018-05-17T12:04:24Z",
      "closedAt": "2018-04-30T06:16:55Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure.  There is a risk that this dates the document, but then we're committing to maintaining this more actively in the next few years anyway.  I think we probably want to say something like.\r\n\r\nUsefulness for web performance: questionable, see 103.\r\nUsefulness for other applications: maybe.\r\nAvailability of APIs: patchy.",
          "createdAt": "2018-04-12T02:25:36Z",
          "updatedAt": "2018-04-12T02:25:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson see 9985fa930be5",
          "createdAt": "2018-04-19T08:03:00Z",
          "updatedAt": "2018-04-19T08:03:00Z"
        },
        {
          "author": "sebdeckers",
          "authorAssociation": "NONE",
          "body": "(See also: comments on the commit)\r\n\r\nThis language sounds very strange in the light of recent(ly improved) implementations of Server Push in major web development frameworks (e.g. Node.js v10) and servers (Nginx). Most CDNs also have support for Server Push so that claim is dubious. All major browsers support it.",
          "createdAt": "2018-05-17T12:04:24Z",
          "updatedAt": "2018-05-17T12:04:24Z"
        }
      ]
    },
    {
      "number": 580,
      "id": "MDU6SXNzdWUzMTM1NTQzMDE=",
      "title": "PATCH",
      "url": "https://github.com/httpwg/http-extensions/issues/580",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "perhaps along the lines of https://www.mnot.net/blog/2012/09/05/patch",
      "createdAt": "2018-04-12T02:30:21Z",
      "updatedAt": "2018-05-04T02:14:36Z",
      "closedAt": "2018-05-04T02:14:36Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "This doesn't seem like we've formed best practice about it; punting for now.",
          "createdAt": "2018-05-04T02:14:36Z",
          "updatedAt": "2018-05-04T02:14:36Z"
        }
      ]
    },
    {
      "number": 581,
      "id": "MDU6SXNzdWUzMTM1NTQzOTI=",
      "title": "Versioning",
      "url": "https://github.com/httpwg/http-extensions/issues/581",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "*sigh*\r\n\r\nSources:\r\n* https://www.mnot.net/blog/2011/10/25/web_api_versioning_smackdown\r\n* https://www.mnot.net/blog/2012/07/11/header_versioning",
      "createdAt": "2018-04-12T02:30:57Z",
      "updatedAt": "2018-05-04T02:13:09Z",
      "closedAt": "2018-05-04T02:13:09Z",
      "comments": []
    },
    {
      "number": 582,
      "id": "MDU6SXNzdWUzMTM1NTQ1MTQ=",
      "title": "More about linking?",
      "url": "https://github.com/httpwg/http-extensions/issues/582",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Source: https://www.mnot.net/blog/2013/06/23/linking_apis",
      "createdAt": "2018-04-12T02:31:27Z",
      "updatedAt": "2018-04-30T06:21:03Z",
      "closedAt": "2018-04-30T06:21:03Z",
      "comments": []
    },
    {
      "number": 583,
      "id": "MDU6SXNzdWUzMTM1NTQ2NDI=",
      "title": "Validation",
      "url": "https://github.com/httpwg/http-extensions/issues/583",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Source: https://www.mnot.net/blog/2007/08/07/etags",
      "createdAt": "2018-04-12T02:32:16Z",
      "updatedAt": "2018-04-30T06:20:53Z",
      "closedAt": "2018-04-30T06:20:53Z",
      "comments": []
    },
    {
      "number": 584,
      "id": "MDU6SXNzdWUzMTM1NTQ3NDg=",
      "title": "Expires",
      "url": "https://github.com/httpwg/http-extensions/issues/584",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Source: https://www.mnot.net/blog/2007/05/15/expires_max-age",
      "createdAt": "2018-04-12T02:32:57Z",
      "updatedAt": "2018-04-19T07:45:42Z",
      "closedAt": "2018-04-19T07:45:42Z",
      "comments": []
    },
    {
      "number": 587,
      "id": "MDU6SXNzdWUzMTQ0NjY0MDg=",
      "title": "Minimum version",
      "url": "https://github.com/httpwg/http-extensions/issues/587",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Should applications using HTTP be allowed to specify a minimum version? If so, what are the criteria / limits?",
      "createdAt": "2018-04-16T00:18:43Z",
      "updatedAt": "2018-04-30T06:16:22Z",
      "closedAt": "2018-04-30T06:16:22Z",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The DoH WG answered this by saying \"no\" - applications are supposed to be defined at the semantic layer. (although I would quibble and say 56bis and the word 'allow' don't go too well together - its advice).\r\n\r\nMost of the discussion centered around how it is impossible to really leverage the ecosystem and actually know what versions are available. (mitm, load balancers, browser portabiity, etc..) so this would be very fragile.\r\n\r\nThis conclusion was reached for DoH even though there was agreement  DoH really requires multiplexing to work well. DoH did end up documenting this relationship and SHOULDing h2, but not requiring it.\r\n",
          "createdAt": "2018-04-16T12:28:17Z",
          "updatedAt": "2018-04-16T12:28:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@mcmanus how does that look?",
          "createdAt": "2018-04-19T07:45:55Z",
          "updatedAt": "2018-04-19T07:45:55Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do we actually still have a concept of \"maximum\"? What would be the relation between HTTP/QUIC vs HTTP/2?",
          "createdAt": "2018-04-19T08:17:26Z",
          "updatedAt": "2018-04-19T08:17:26Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "sgtm",
          "createdAt": "2018-04-19T12:12:34Z",
          "updatedAt": "2018-04-19T12:12:34Z"
        }
      ]
    },
    {
      "number": 588,
      "id": "MDU6SXNzdWUzMTQ3Njg1NjA=",
      "title": "network quality related client hints",
      "url": "https://github.com/httpwg/http-extensions/issues/588",
      "state": "CLOSED",
      "author": "tarunban",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "We should update spec to include 3 network quality related client hints:\r\n\"rtt\", \"downlink\", \"ect\".\r\n\r\nThe values of the client hints matches the value provided by the JavaScript API (navigator.connection.rtt, navigator.connection.downlink, navigator.connection.effectiveType respectively):\r\nhttps://wicg.github.io/netinfo/",
      "createdAt": "2018-04-16T18:29:58Z",
      "updatedAt": "2018-04-18T15:45:14Z",
      "closedAt": "2018-04-18T15:45:14Z",
      "comments": [
        {
          "author": "tarunban",
          "authorAssociation": "NONE",
          "body": "cc @igrigorik ",
          "createdAt": "2018-04-16T18:30:17Z",
          "updatedAt": "2018-04-16T18:30:17Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "These headers will be defined in NetInfo, same as `Save-Data`. PR: https://github.com/WICG/netinfo/pull/69. Let's continue discussion there.",
          "createdAt": "2018-04-18T15:45:14Z",
          "updatedAt": "2018-04-18T15:45:14Z"
        }
      ]
    },
    {
      "number": 593,
      "id": "MDU6SXNzdWUzMTc2ODAwNzk=",
      "title": "Same-Site cookies - clarify \"site for cookies\" in the case of redirects",
      "url": "https://github.com/httpwg/http-extensions/issues/593",
      "state": "OPEN",
      "author": "mozmark",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis",
        "samesite"
      ],
      "body": "Following a conversation the other day, I think we need to clarify what the \"site for cookies\" is in the case of redirects.\r\n\r\nThe relevant section of the specification reads:\r\n\r\n> If \"request\"'s client is \"null\", return \"same-site\".\r\n> \r\n>        Note that this is the case for navigation triggered by the user\r\n>        directly (e.g. by typing directly into a user agent's address\r\n>        bar).\r\n\r\nI take this to mean that for the *first* request (the request that the user initiated) the client is null and, therefore, same-site - but for subsequent requests, since they're initiated by the redirect, they may be treated as cross-site requests (if 'target' differs from 'site').\r\n\r\nThis differs from the Chrome implementation's current behavior. I think, for strict same site cookies at least, this perhaps needs tightening up.\r\n\r\nThoughts?",
      "createdAt": "2018-04-25T15:29:33Z",
      "updatedAt": "2020-01-29T13:33:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Could you provide the examples you're thinking of for request chains starting out non-null and becoming null, please? Is iframe sandboxing at play here? Or are we talking about redirects to schemes such as about:, javascript: etc? Are there cases outside web browsing contexts?",
          "createdAt": "2018-12-11T17:11:01Z",
          "updatedAt": "2018-12-11T17:11:01Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "A request's `client` does not change during redirects. It's generally `null` during navigation from the address bar, and remains `null` through the redirect chain (e.g. navigating to `http://bit.ly/31ZtzXa` is considered strictly `same-site` to https://github.com/w3c/webappsec/blob/master/meetings/2019/2019-09-TPAC-minutes.md upon which it lands). That behavior seems reasonable to me, if only because of the variety of places I've worked that have internal redirect servers that allow you to type something exciting like `go/somewhere-useful` to go somewhere useful. It would be unfortunate, I think, if users weren't signed in after using such a service.\r\n\r\nIt looks like there's disagreement between Firefox and Chrome here (Chrome sends `SameSite=Strict` cookies, Firefox only sends `SameSite=Lax`). I don't have Safari in front of me to test, but I can probably check it tonight.",
          "createdAt": "2020-01-29T13:33:02Z",
          "updatedAt": "2020-01-29T13:33:02Z"
        }
      ]
    },
    {
      "number": 594,
      "id": "MDU6SXNzdWUzMTc3NzY1MDM=",
      "title": "Setting samesite cookies when not same site context",
      "url": "https://github.com/httpwg/http-extensions/issues/594",
      "state": "CLOSED",
      "author": "aliams",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "What happens when a page tries to set a samesite cookie when we are not in a samesite context? For instance, a top-level a.com has an iframe to b.com and b.com tries to set a cookie with the samesite attribute. It sounds like we would want the cookie to not be writeable since it's not readable in that case.\r\n\r\ncc @mikewest",
      "createdAt": "2018-04-25T20:11:36Z",
      "updatedAt": "2019-05-04T04:28:06Z",
      "closedAt": "2019-05-04T04:28:06Z",
      "comments": [
        {
          "author": "fmarier",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In Firefox, we [prevent same-site cookies from being set in a third-party context](https://bugzilla.mozilla.org/show_bug.cgi?id=1452496).",
          "createdAt": "2018-04-26T07:37:41Z",
          "updatedAt": "2018-04-26T07:37:41Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I vaguely remember discussions on this, i.e. whether the whole cookie should be dropped or just the SameSite attribute. Anyone on this thread who remembers? (Part of what I remember is that Mozilla changed their mind.)",
          "createdAt": "2018-12-11T17:13:00Z",
          "updatedAt": "2018-12-11T17:13:33Z"
        },
        {
          "author": "ericlaw1979",
          "authorAssociation": "NONE",
          "body": "Blocking SameSite cookie creation in cross-origin POST contexts means that an OAuth cookie that is set as a result from a POST from the auth provider site will fail. This seems undesirable. ",
          "createdAt": "2019-04-29T23:41:15Z",
          "updatedAt": "2019-04-29T23:41:15Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I think it's pretty clear that we ought to be blocking the creation of `SameSite={Lax,Strict}` cookies in cross-site subresource requests. Firefox does that today, and Chrome [just landed a patch](https://chromium-review.googlesource.com/c/chromium/src/+/1534237) to do the same.\r\n\r\nNavigations are more interesting. We send `SameSite=Lax` cookies along with \"safe\" HTTP methods (e.g. `GET`, but not `POST`). Chrome's implementation applies the same restriction to `SameSite=Lax` creation. I assumed that Firefox's implementation did the same, but @ericlaw1979 suggests in https://bugs.chromium.org/p/chromium/issues/detail?id=837412#c18 that it doesn't. That seems strange to me, though perhaps justifiable given the use case Eric's pointing to.\r\n\r\nI think I could live with a world in which top-level navigations (regardless of method) are empowered to _create_ `SameSite` cookies (but keep the rules around _sending_ them as they are). Would that address your concerns, Eric? Does it open us up to attacks I'm not thinking about?\r\n\r\n/cc @mozmark @morlovich",
          "createdAt": "2019-04-30T07:11:16Z",
          "updatedAt": "2019-04-30T07:11:16Z"
        },
        {
          "author": "ericlaw1979",
          "authorAssociation": "NONE",
          "body": "I've built a reduced repro for this scenario at https://webdbg.com/test/cookie/samesite/post.aspx .\r\n\r\nFirefox Nightly ignores the attempt to set the SameSite cookie for the cross-origin image, but permits the cookie to be set during the form post.\r\n\r\nI believe that the proposed fix (matching Firefox) unblocks the OAuth scenario regression we've found, although I do wonder about the notion that a context shouldn't be able to set cookies that it, itself, cannot read (e.g. a page can currently set  `secure` or  `path=` to which the context itself does not belong).\r\n\r\n\r\n",
          "createdAt": "2019-04-30T15:47:33Z",
          "updatedAt": "2019-04-30T18:04:44Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> Firefox Nightly ignores the attempt to set the SameSite cookie for the cross-origin image, but permits the cookie to be set during the form post.\r\n\r\nYeah, that does seem to be Firefox's behavior. I'm curious about how they landed on that, and how exactly they're determining whether to allow the cookie to be set. Are they just ignoring the \"safe method\" bit? Do nested navigations work as well? @mozmark, WDYT?\r\n\r\n> I do wonder about the notion that a context shouldn't be able to set cookies that it, itself, cannot read (e.g. a page can currently set secure or path= to which the context itself does not belong).\r\n\r\nYou're right about `path`, but a page cannot set `secure` unless it's capable of reading secure cookies by virtue of being delivered over secure transport.",
          "createdAt": "2019-05-01T07:43:05Z",
          "updatedAt": "2019-05-01T07:43:05Z"
        },
        {
          "author": "ericlaw1979",
          "authorAssociation": "NONE",
          "body": "> a page cannot set secure unless it's capable of reading secure cookies by virtue of \r\n> being delivered over secure transport.\r\n\r\nAh, I'd forgotten that this was added in [leave-secure-cookies-alone](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-alone-01) and further confused myself by running my test case in a Edge Spartan window (IE and old Edge never implemented that update).\r\n",
          "createdAt": "2019-05-01T11:39:23Z",
          "updatedAt": "2019-05-01T11:39:23Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Assuming @mozmark doesn't object in the near future, I'd suggest running with the proposal to remove the \"safe\" method check for storage. I'll put up a PR at some point soonish.",
          "createdAt": "2019-05-02T14:16:36Z",
          "updatedAt": "2019-05-02T14:16:36Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "PR in https://github.com/httpwg/http-extensions/pull/800.",
          "createdAt": "2019-05-02T17:13:50Z",
          "updatedAt": "2019-05-02T17:13:50Z"
        }
      ]
    },
    {
      "number": 595,
      "id": "MDU6SXNzdWUzMTkxMTI4NjI=",
      "title": "Title",
      "url": "https://github.com/httpwg/http-extensions/issues/595",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "I've had some feedback that the current title is unwieldy.\r\n\r\nSuggestion: \"Building Protocols with HTTP\".",
      "createdAt": "2018-05-01T04:30:15Z",
      "updatedAt": "2018-05-04T02:13:09Z",
      "closedAt": "2018-05-04T02:13:09Z",
      "comments": []
    },
    {
      "number": 596,
      "id": "MDU6SXNzdWUzMTkyODEyNzg=",
      "title": "Relationship to the ABNF #Rule",
      "url": "https://github.com/httpwg/http-extensions/issues/596",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "As @reschke points out in https://lists.w3.org/Archives/Public/ietf-http-wg/2018JanMar/0209.html, https://tools.ietf.org/html/rfc7230#section-3.2.2 says:\r\n\r\n> A sender MUST NOT generate multiple header fields with the same field\r\n> name in a message unless either the entire field value for that\r\n> header field is defined as a comma-separated list [i.e., #(values)]\r\n> or the header field is a well-known exception (as noted below).\r\n\r\ndraft-ietf-httpbis-header-structure should explicitly override that prohibition for lists, dictionaries, and parameterised lists. It could do this by using the # construct in the ABNF for those types, but because the parsing algorithm in structured headers isn't actually driven by the ABNF, I'm not sure that's the right approach.\r\n\r\nThe parsing side is already handled by http://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#text.",
      "createdAt": "2018-05-01T18:24:55Z",
      "updatedAt": "2018-08-20T07:19:27Z",
      "closedAt": "2018-08-19T06:28:45Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "-1 on \"overriding\" anything the base spec says.\r\n\r\nIf you want list semantics, use the matching ABNF notation.",
          "createdAt": "2018-05-01T19:43:16Z",
          "updatedAt": "2018-05-01T19:43:16Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To be clear, I have no objection to using the `#` ABNF notation if that's what folks think is best.",
          "createdAt": "2018-05-01T19:52:15Z",
          "updatedAt": "2018-05-01T19:52:15Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I don't think we should tie requirements for handling of HTTP extensions into what convention is used to define their syntax. Will raise an issue against httpwg/http-core.",
          "createdAt": "2018-05-01T22:30:32Z",
          "updatedAt": "2018-05-01T22:30:32Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe, but the core question is the behavior, not the syntax (handling empty elements, for instance).",
          "createdAt": "2018-05-02T04:43:27Z",
          "updatedAt": "2018-05-02T04:43:27Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Why is empty special? I'd expect\r\n```\r\nA-SH-That-Takes-A-String: \"Hello\r\na-SH-That-takes-a-string: \r\na-sh-that-takes-a-string: World\"\r\n```\r\nto yield `Hello,,World`. Might be worth adding some explicit examples if they're not already there of course.",
          "createdAt": "2018-06-04T09:57:42Z",
          "updatedAt": "2018-06-04T09:58:01Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Nope. It would yield `Hello,World`. See https://greenbytes.de/tech/webdav/rfc7230.html#rfc.section.7.p.4",
          "createdAt": "2018-06-04T10:08:29Z",
          "updatedAt": "2018-06-04T10:08:29Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think this can be closed, as the current draft recommends the use of ABNF, and the core issue seems to be heading in the direction of not tying those semantics to the # rule.\r\n\r\nDo we need specific text to handle the situation outlined above (with a blank header line) to assure that it's handled correctly? If so please open an issue dedicated to that.",
          "createdAt": "2018-08-19T06:28:45Z",
          "updatedAt": "2018-08-19T06:28:45Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Filed #686 on that, seems useful especially as I suspect that not many implementations get that right.",
          "createdAt": "2018-08-20T07:19:27Z",
          "updatedAt": "2018-08-20T07:19:27Z"
        }
      ]
    },
    {
      "number": 597,
      "id": "MDU6SXNzdWUzMTk0Mjg5OTE=",
      "title": "Number validation",
      "url": "https://github.com/httpwg/http-extensions/issues/597",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "The prose defines precise ranges for numbers (explicitly for integers, implicitly for floats), yet the algorithm doesn't yet enforce them.",
      "createdAt": "2018-05-02T06:47:28Z",
      "updatedAt": "2018-06-28T07:17:20Z",
      "closedAt": "2018-06-28T07:17:20Z",
      "comments": []
    },
    {
      "number": 599,
      "id": "MDU6SXNzdWUzMTk0Njk0ODU=",
      "title": "variants: why update RFC 7234",
      "url": "https://github.com/httpwg/http-extensions/issues/599",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "Does it really *update* RFC 7234? If it really does, it should say how exactly.",
      "createdAt": "2018-05-02T09:00:28Z",
      "updatedAt": "2018-05-04T02:45:07Z",
      "closedAt": "2018-05-04T02:45:07Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I put that in there because it relaxes the requirements around Vary handling when present. Will mention.",
          "createdAt": "2018-05-04T02:21:03Z",
          "updatedAt": "2018-05-04T02:21:03Z"
        }
      ]
    },
    {
      "number": 607,
      "id": "MDU6SXNzdWUzMTk5MjA2NDI=",
      "title": "[cache digests] Eliminate requirement that the digest size is a power of 2",
      "url": "https://github.com/httpwg/http-extensions/issues/607",
      "state": "OPEN",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "During the implementation of the [Cache Digests reference implementation](https://github.com/yoavweiss/cache-digests-cuckoo) I [realized](https://github.com/yoavweiss/cache-digests-cuckoo/commit/3ee4a45bf0bc03ea47ae7125e409b41d57acb198) that the digest size has to be a power of 2. Otherwise the `xor` operation on the primary index can lead to an out-of-bounds write, resulting in memory and correctness issues.\r\n\r\nAn alternative to that approach would be to:\r\n* Do an out-of-bounds check to the `xor` operation and if it is out-of-bounds, take as an index the out-of-bounds value minus the digest size.\r\n* Add a bit to the fingerprint which indicates that the alternative index was out-of-bounds.\r\n* In the future, when a fingerprint is displaced and need to be returned to the primary index, the \"out-of-bounds\" bit can be used as an indication that the original `xor` operation was out-of-bounds, and instead of the index, the `xor` operation now can use the original out-of-bounds index.\r\n\r\n@kazuho - Does that make sense?\r\n\r\nIt will cost us a bit more space (extra bit per fingerprint), but will make the digest size significantly more flexible.\r\n",
      "createdAt": "2018-05-03T13:28:09Z",
      "updatedAt": "2018-07-02T09:21:30Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@yoavweiss Thank you for noticing and raising the issue.\r\n\r\nI think the proposed solution is plausible. OTOH, I am not sure if we need the flexibility.\r\n\r\nI'd assume that a client would not resize the hash every time it adds / removes an entry. I'd rather expect it to resize it based on exponential backoff. That means that in the average case, we will not be transferring a optimally-sized Cuckoo hash anyways. Considering that, I fear having 1-bit overhead for every entry might actually lead us to seeing a bigger hash in practice.\r\n\r\nNote also that allowing a table size other than power-of-two increases the CPU cost since it means that we cannot rely on bit operations for calculating modulo.",
          "createdAt": "2018-05-03T22:19:08Z",
          "updatedAt": "2018-05-03T22:19:08Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You're right that implementations may choose sizes that are larger than their immediate needs, and therefore, power-of-two may make sense anyway.\r\n\r\nAlternatively to my approach which adds an extra bit, @bdupras and @beala have an alternative [approach](https://github.com/bdupras/guava-probably/blob/10a738234de3830c8bb0dd8d1617e0df123607cf/src/main/java/com/duprasville/guava/probably/CuckooStrategyMurmurBealDupras32.java#L134-L169) for Guava-Probably, which seems to be providing the same benefits without the overhead.\r\n\r\nEssentially (IIUC), they calculate a predicable but randomly distributed number from the fingerprint and use that as an offset from the original index. They make sure that it doesn't fall on the original index by requiring that the offset is odd and that the size of the digest is even.\r\n\r\n\r\n\r\n\r\n> Note also that allowing a table size other than power-of-two increases the CPU cost since it means that we cannot rely on bit operations for calculating modulo.\r\n\r\nThat's a good point, and implementations can choose to stick with power-of-two digest sizes. But figuring out a way to remove that as a requirement seems like a win. (especially if we don't have to pay the \"extra bit per fingerprint\" tax after all)",
          "createdAt": "2018-05-04T10:07:09Z",
          "updatedAt": "2018-05-04T10:52:05Z"
        },
        {
          "author": "bdupras",
          "authorAssociation": "NONE",
          "body": "I'm curious, what digest sizes are you anticipating from implementations?",
          "createdAt": "2018-05-05T12:06:50Z",
          "updatedAt": "2018-05-05T12:06:50Z"
        },
        {
          "author": "beala",
          "authorAssociation": "NONE",
          "body": "I thought it might be useful to post a plain english explanation of the indexing strategy @bdupras and I proposed:\r\n\r\nThe property that we need to maintain is that the primary and secondary indices can be calculated in terms of each other (ie, the only info we have available is their position in the table, and the fingerprint). We maintain this property in the following way. \r\n\r\nFirst, we calculate an offset, which is based on the fingerprint. Crucially, this offset is always odd: `offset = makeOdd(hash(fingerprint))`. \r\n\r\nThis offset is then either subtracted or added to the current position to get the other index. If the current index is odd, it's subtracted. If it's even, it's added. Since the offset is always the same, this jumps between the two possible indices. Further, because adding or subtracting an odd number always flips the evenness or oddness of a number, this guarantees that one position is always even and one is always odd.\r\n\r\nOne additional detail is that this property is maintained under modular arithmetic so long as the modulus is even, which is why the table size must be even.\r\n\r\nIn pseudo code, it looks like this:\r\n\r\n```\r\nmakeOdd(x) = x    [if x is odd]\r\n             x+1  [if x is even]\r\n\r\nflipIndex(currentIndex) = currentIndex - makeOdd(hash(fingerprint)) % tableSize   [if currentIndex is odd]\r\n                          currentIndex + makeOdd(hash(fingerprint)) % tableSize   [if currentIndex is even]\r\n```",
          "createdAt": "2018-05-05T16:10:24Z",
          "updatedAt": "2018-05-05T16:13:58Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bdupras \r\n> I'm curious, what digest sizes are you anticipating from implementations?\r\n\r\nThe anticipation is that we would have typically up to hundreds (but not thousands) of entries. Please refer to https://github.com/httpwg/wg-materials/blob/gh-pages/ietf100/cache-digest.pdf.",
          "createdAt": "2018-05-09T05:46:24Z",
          "updatedAt": "2018-05-09T05:46:24Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@beala That's interesting. Thank you for the explanation.\r\n\r\nOTOH, I am not sure if it is actually optimal compared to using XOR for a table having a size of power-of-two.\r\n\r\nThe approach you described distributes the secondary index to N / 2 entries where N is the size of the table. IMO, it is essentially the same as omitting the last bit of the fingerprint (and hard-coding it as `1` instead) when we use XOR-based approach.\r\n\r\nWhat I am trying to state here is that while I can understand the potential benefit of using the approach for tables that do not have the size of power-of-two, I do not see a benefit for the cache-digest use-case adopting that approach, under the assumption that the clients would resize the table using exponential backoff.",
          "createdAt": "2018-05-09T05:55:36Z",
          "updatedAt": "2018-05-09T05:55:36Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yet another alternative, is to (again *sigh*) switch filter methods to one that doesn't have a power-of-two requirement, and does enable resizing, which may significantly reduce the memory requirements.\r\nThere was a recent paper about a [Counting Quotient Filter](https://blog.acolyer.org/2017/08/08/a-general-purpose-counting-filter-making-every-bit-count/), which seems promising on that front.\r\n\r\nI'm not super excited about changing the filter algorithm once again, but it may be the right call if it'd make implementations on both clients and servers more flexible. Performance-wise and from a digest-size perspective, the Quotient Filter paper claims it's on par with Cuckoo filters.",
          "createdAt": "2018-07-02T08:09:53Z",
          "updatedAt": "2018-07-02T08:09:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It's starting to sound like we should put the filter algorithm into the frame type name, to future-proof...",
          "createdAt": "2018-07-02T08:19:56Z",
          "updatedAt": "2018-07-02T08:19:56Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot beat me to it, it sounds like you might want to make the algorithm selectable. Then you could externalise the work on changing filter in order to make progress",
          "createdAt": "2018-07-02T08:27:12Z",
          "updatedAt": "2018-07-02T08:27:31Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We want to avoid having too many stabs at this, otherwise it's not going to be useful, because you'll have to figure out what kind of digest the server wants (although I suppose if you have cached state, we could figure something out).",
          "createdAt": "2018-07-02T08:32:18Z",
          "updatedAt": "2018-07-02T08:32:18Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It's starting to sound like we should put the filter algorithm into the frame type name, to future-proof...\r\n\r\nThat may be the right call. Otherwise, maybe include a flag which will enable algorithm changes in the future.",
          "createdAt": "2018-07-02T08:54:21Z",
          "updatedAt": "2018-07-02T08:54:21Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We want to avoid having too many stabs at this, otherwise it's not going to be useful, because you'll have to figure out what kind of digest the server wants (although I suppose if you have cached state, we could figure something out).\r\n\r\nIt's true that different frame names for different algorithms would probably make digest negotiation easier.",
          "createdAt": "2018-07-02T08:58:04Z",
          "updatedAt": "2018-07-02T08:58:12Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IIUC, the reason we did not ship the draft with Golomb-coded sets as experimental was because we thought that having a browser that implements Cache Digests is important.\r\n\r\nConsidering that, my preference is to wait for a working H2 client implementation that uses whatever algorithm that fits it's needs, then consider if we can adopt the implemented algorithm as-is, or adjust it if necessary.\r\n\r\nChanging the digest algorithm is something that can always be done later.",
          "createdAt": "2018-07-02T09:21:30Z",
          "updatedAt": "2018-07-02T09:21:30Z"
        }
      ]
    },
    {
      "number": 608,
      "id": "MDU6SXNzdWUzMjA0NTAxNTU=",
      "title": "bcp56bis: rich functionality - maybe focus on uri granularity",
      "url": "https://github.com/httpwg/http-extensions/issues/608",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Much of the text of \"3.3 Rich Functionality\" discusses the merits of granular uris, but in one fell swoop it dismisses post/single-uri pattern as benefiting from only a very short and finite list of features: message framing, and availability of implementations.\r\n\r\nI find the former convincing, but the latter dismissal rather unconvincing.. it gives the air of being a complete argument but leaves out a lot of valuable other things even in a mere tunnel case - e.g. proxy support, varied authentication schemes, content negotiation, language negotiation, multiplexing  in h2, alt-service routing, coalsecing, and cross-origin policy enforcement in a browser, etc... These are reasonable motivators and you might be underselling the value of high quality available implementations for all aspects of the ecosystem including load balancers.\r\n\r\nI wonder if this could be more focused on the merits of URI design rather than saying - if you don't find that a match don't use http.\r\n\r\nand the bullet about \"The ability to interact with the application easily using a Web browser\" might be clarified to mean in a linkable/browsable/discoverable sense rather than excluding a fetch based API for it..",
      "createdAt": "2018-05-04T22:39:41Z",
      "updatedAt": "2018-05-07T11:50:33Z",
      "closedAt": "2018-05-07T11:50:33Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@mcmanus ^^",
          "createdAt": "2018-05-07T01:58:37Z",
          "updatedAt": "2018-05-07T01:58:37Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "lgtm - thanks",
          "createdAt": "2018-05-07T11:50:13Z",
          "updatedAt": "2018-05-07T11:50:13Z"
        }
      ]
    },
    {
      "number": 612,
      "id": "MDU6SXNzdWUzMjA5MzYyODU=",
      "title": "shout out to cert checking",
      "url": "https://github.com/httpwg/http-extensions/issues/612",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "> Certificates - Applications using HTTP MUST specify that TLS certificates are to be checked according to [RFC2818] when HTTPS is used.\r\n\r\nwhy is this more special than any of the other 2818 rules (it is a MUST there I believe)? This doesn't seem to square with the optional theme of cookies and redirects.\r\n\r\ncool btw that https is RECCOMMENDED",
      "createdAt": "2018-05-07T20:01:19Z",
      "updatedAt": "2018-05-08T17:02:05Z",
      "closedAt": "2018-05-08T17:02:04Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Not sure I understand; the intent is to require clients to check certificates; is there a more clear way to say that?",
          "createdAt": "2018-05-07T23:29:12Z",
          "updatedAt": "2018-05-07T23:29:12Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "sorry that wasn't very clear.\r\n\r\nThe section was on stuff that normally isn't mandatory (like chasing redirects) - I was having trouble seeing how certificate checking fit in there. Its a mandatory part of https so it might not even rate mention - is there confusion on it?\r\n\r\n",
          "createdAt": "2018-05-08T07:44:05Z",
          "updatedAt": "2018-05-08T07:44:05Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just reread 2818 - and I think want to retract the issue now.. the 2818 language is restricted to validating server identity afaict.",
          "createdAt": "2018-05-08T17:02:04Z",
          "updatedAt": "2018-05-08T17:02:04Z"
        }
      ]
    },
    {
      "number": 613,
      "id": "MDU6SXNzdWUzMjA5MzgzNjY=",
      "title": "consider hsts",
      "url": "https://github.com/httpwg/http-extensions/issues/613",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "section 4.3.2\r\n\r\n> HTTP-specific features such as cookies [RFC6265], authentication [RFC7235], caching [RFC7234], and CORS [FETCH] might or might not work correctly, depending on how they are defined and implemented. Generally, they are designed and implemented with an assumption that the URL will always be \u201chttp\u201d or \u201chttps\u201d.\r\n\r\nlikely worth working HSTS into that list.. we've seen it fail to provide its security benefit when mixed on hosts that provide ftp resources\r\n",
      "createdAt": "2018-05-07T20:07:43Z",
      "updatedAt": "2018-05-07T23:26:39Z",
      "closedAt": "2018-05-07T23:26:39Z",
      "comments": []
    },
    {
      "number": 614,
      "id": "MDU6SXNzdWUzMjA5ODc3NDM=",
      "title": "References",
      "url": "https://github.com/httpwg/http-extensions/issues/614",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "expect-ct"
      ],
      "body": "All of the references are currently normative. After a quick read, I think the following can be moved to Informative:\r\n\r\n* HTML / HTML5\r\n* FETCH\r\n* RFC5246\r\n",
      "createdAt": "2018-05-07T23:02:51Z",
      "updatedAt": "2018-05-31T03:25:19Z",
      "closedAt": "2018-05-31T03:25:19Z",
      "comments": []
    },
    {
      "number": 615,
      "id": "MDU6SXNzdWUzMjEwMDE3MDk=",
      "title": "Client authentication with certificates",
      "url": "https://github.com/httpwg/http-extensions/issues/615",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "This isn't mentioned in the client authentication section.  It's a practice that is used quite often, so it should be mentioned.  That naturally means addressing some of the (many) shortcomings though.",
      "createdAt": "2018-05-08T00:19:48Z",
      "updatedAt": "2018-06-05T12:01:26Z",
      "closedAt": "2018-06-05T12:01:26Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Do we have best practices for that, or is it just something that should be mentioned in passing? (I'm trying not to have this become a compendium of everything HTTP, and perhaps already failing at that).",
          "createdAt": "2018-05-08T00:21:06Z",
          "updatedAt": "2018-05-08T00:21:06Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In passing would suffice.  As in, \"With HTTPS, clients might also be authenticated using certificates.\"  If you want to avoid the compendium problem, avoid getting into the shortcomings.",
          "createdAt": "2018-05-08T00:42:47Z",
          "updatedAt": "2018-05-08T00:42:47Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Probably want a reference to TLS in there for further reading.",
          "createdAt": "2018-05-08T23:09:13Z",
          "updatedAt": "2018-05-08T23:09:13Z"
        }
      ]
    },
    {
      "number": 617,
      "id": "MDU6SXNzdWUzMjE3ODU3OTU=",
      "title": "MitM detection",
      "url": "https://github.com/httpwg/http-extensions/issues/617",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "Secondary certs depends on there not being a MitM.  And sadly, they still exist in some places.\r\n\r\nNow, as an advisory extra, the failure mode isn't fatal to the connection, but it could mean a lot of wasted effort.  So we could pack the setting with 32 bits extracted from the exporter as confirmation that the mechanism works, or design a new mechanism to reduce the chance that we waste effort on creating authenticators that we can't use.\r\n\r\nEither way, it's probably worth mentioning this possibility.",
      "createdAt": "2018-05-10T02:15:33Z",
      "updatedAt": "2018-06-13T23:50:39Z",
      "closedAt": "2018-06-13T23:50:39Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thirty-two bits from the exporter seems like a reasonable mitigation.  That's fairly low cost.",
          "createdAt": "2018-05-11T19:14:04Z",
          "updatedAt": "2018-05-11T19:14:04Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The only wrinkle is that they might be all zero.  If settings parsers return 0 and the exporter returns an all zero 32-bit value, then there is a possibility of a false positive.\r\n\r\nI think that we can either force a bit to one and lose a bit, or emphasize that endpoints have to check for the *presence* of the setting as well as its value.",
          "createdAt": "2018-05-12T00:42:09Z",
          "updatedAt": "2018-05-12T00:42:09Z"
        }
      ]
    },
    {
      "number": 623,
      "id": "MDU6SXNzdWUzMjI2ODU3NzQ=",
      "title": "Header fields that are valid SH, but invalid according to the definition of that field",
      "url": "https://github.com/httpwg/http-extensions/issues/623",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "If a header field is valid according to SH, but invalid according to some additional constraints that are included in the definition of the specific header field, what happens?\r\n\r\n* it needs to be dropped because malformed header fields are dropped according to SH\r\n\r\n* the definition of the specific header field needs to define what happens in this case",
      "createdAt": "2018-05-14T06:20:44Z",
      "updatedAt": "2018-05-23T03:03:55Z",
      "closedAt": "2018-05-23T03:03:55Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Current text:\r\n\r\n> However, header field authors are encouraged to clearly state additional constraints upon the syntax, as well as the consequences when those constraints are violated. When Structured Headers parsing fails, the header is discarded (see {{text}}); in most situations, header-specific constraints should do likewise.\r\n\r\nIs that sufficient?",
          "createdAt": "2018-05-23T02:36:37Z",
          "updatedAt": "2018-05-23T02:36:37Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes. ",
          "createdAt": "2018-05-23T03:03:55Z",
          "updatedAt": "2018-05-23T03:03:55Z"
        }
      ]
    },
    {
      "number": 627,
      "id": "MDU6SXNzdWUzMjU2NTQ5NjA=",
      "title": "Serialization for structured headers.",
      "url": "https://github.com/httpwg/http-extensions/issues/627",
      "state": "CLOSED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "I've started sketching out a feature that intends to deliver a structured header as part of an HTTP request, and I find myself doing a little more hand-waving than I'd like in step 6 of https://mikewest.github.io/sec-metadata/#abstract-opdef-set-the-sec-metadata-header-for-a-request.\r\n\r\nThe end of https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-04#section-1 suggests that:\r\n\r\n>   Those abstract types can be serialised into textual headers - such as those used in HTTP/1 and HTTP/2 - using the algorithms described in Section 3.\r\n\r\nSection 3, however, seems to be the opposite: parsing a string into a Structured Header. I don't actually see a serialization algorithm in the document. Each type hints at how it might be serialized, but it would be nice to have an algorithm to point to.",
      "createdAt": "2018-05-23T11:01:20Z",
      "updatedAt": "2018-06-05T11:54:58Z",
      "closedAt": "2018-06-05T11:54:58Z",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "(For example, can we assume any ordering in the serialization of a dictionary? :) )",
          "createdAt": "2018-05-23T11:13:19Z",
          "updatedAt": "2018-05-23T11:13:19Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Makes sense, will do in the next round.\r\n\r\nOne hitch is that *eventually*, we want to be able to define alternative serialisations of the header field in new versions of HTTP, so we'll have to be careful in how we do this. Or just admit that there will be some residual hand-waving.",
          "createdAt": "2018-05-23T23:52:39Z",
          "updatedAt": "2018-05-23T23:52:39Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> Makes sense, will do in the next round.\r\n\r\nThanks, no rush. :)\r\n\r\n> One hitch is that eventually, we want to be able to define alternative serialisations of the header field in new versions of HTTP, so we'll have to be careful in how we do this. Or just admit that there will be some residual hand-waving.\r\n\r\nSome level of hand-waving seems fine, though I'd prefer that it be constrained to this document, and not all the documents that wish to define structured headers. If we can end up with a single algorithm, no matter how complicated, that takes a structured header object and outputs a string, I'll be happy to use it!",
          "createdAt": "2018-05-24T06:53:35Z",
          "updatedAt": "2018-05-24T06:53:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Nod - but the hitch is \"outputs a string\" -- in that future world, it might be binary...",
          "createdAt": "2018-05-24T23:07:11Z",
          "updatedAt": "2018-05-24T23:07:11Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "How about \"outputs a thing that might be a string, and might be binary, and might be trinary, or might be anything else I can hand to Fetch's `header list` [`set`](https://fetch.spec.whatwg.org/#concept-header-list-set) algorithm\"? Fetch talks about it in terms of a https://infra.spec.whatwg.org/#byte-sequence. Would that work for you?",
          "createdAt": "2018-05-25T11:41:30Z",
          "updatedAt": "2018-05-25T11:41:30Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I love it: \"A byte sequence is a sequence of bytes, represented as a space-separated sequence of bytes.\"\r\n\r\nMaybe: \"...represented as a space-separated sequence of byte representations\"?",
          "createdAt": "2018-05-25T13:10:13Z",
          "updatedAt": "2018-05-25T13:14:37Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot - actually, what's in a HTTP/1.1 message should also be better considered a byte sequence, not a string\r\n\r\n@mikewest - I would prefer to have SH not to rely on FETCH in any way",
          "createdAt": "2018-05-25T13:13:27Z",
          "updatedAt": "2018-05-25T13:13:27Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> I would prefer to have SH not to rely on FETCH in any way\r\n\r\nPedantic nit: Byte sequence isn't defined in Fetch, but in Infra. :)\r\n\r\nI would like SH to define a serialization algorithm in such a way that I can explain to web browsers what they ought to do with the result. It would be unfortunate if it was difficult to integrate SH and Fetch, as that makes my goals more difficult.\r\n\r\nI think all I'm asking for is a clearly defined serialization algorithm that returns a result that Fetch can accept as a header value. I'm happy to leave details up to y'all and @annevk to work out who depends on whom and why amongst yourselves. :)",
          "createdAt": "2018-05-25T13:22:30Z",
          "updatedAt": "2018-05-25T13:22:30Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, that gets us back to the data model. I assume FETCH considers header field values as JavaScript strings (?), while in an HTTP/1.1 message it's really a sequence of bytes, usually restricted to values <= 127.\r\n\r\nIt's the edge case (non-ASCII) that makes this all interesting, but I believe it's a non-issue for SH.",
          "createdAt": "2018-05-25T13:32:55Z",
          "updatedAt": "2018-05-25T13:32:55Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "@reschke no, byte sequences with restrictions: https://fetch.spec.whatwg.org/#concept-header. (The API does convert these back and forth from JavaScript strings, using IDL's `ByteString` primitive.)",
          "createdAt": "2018-05-25T13:40:54Z",
          "updatedAt": "2018-05-25T13:40:54Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK.\r\n\r\nRight now we have only one serialization, so it's hard to discuss future ones.\r\n\r\nThe one that we have uses US-ASCII, which can be trivially encoded in octet sequences, and shouldn't have any issues with FETCH. So maybe we just need to write down this more clearly?",
          "createdAt": "2018-05-25T13:59:57Z",
          "updatedAt": "2018-05-25T13:59:57Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "For my own understanding, the problem is that you want to create a structured header using types, but then pass that into Fetch, with Fetch only taking byte sequences, and exact byte sequences being exposed through H/1 and H/2 and probably QUIC.\r\n\r\nIdeally you keep the types around until you hit a point where you need to serialize. That would require HTTP offering some abstraction in front of H/1, H/2 and probably QUIC that takes headers where the values can be either byte sequences or types and then serializes them as appropriate for the eventual chosen transport.\r\n\r\nFetch could then change its \"header\" primitive so values would be either byte sequences or types and pass that on to the new HTTP abstraction. And also use the H/1 / H/2 serialization for its API, which isn't typed.\r\n\r\nAs an alternative, proposed by @mikewest I think, structured headers could define how to obtain a byte sequence from a type. We'd continue passing byte sequences around. Then a future H/N could eagerly parse those bytes to see if it can represent them as a type instead. You'd end up with a redundant serialize/parse, but all the interfaces don't have to be changed. Implementations could optimize the serialize/parse away. And this would also allow representing byte sequences as types that weren't types to begin with, which might be beneficial.",
          "createdAt": "2018-05-25T14:11:32Z",
          "updatedAt": "2018-05-25T14:12:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@mikewest see PR above; will that work for you (ignoring the alternative serialisations issue for now?)\r\n",
          "createdAt": "2018-06-01T03:34:22Z",
          "updatedAt": "2018-06-01T03:34:22Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "My assumption has been that if a future H/n defines an alternative serialisation (or if it's done in an extension like a H2 SETTING), a separate API would have to be exposed for applications to call to set headers (even if that's a bump on the current API that adds information about the encoding being sent, plus a way for the application to detect that it's available).\r\n\r\nOtherwise, there'd have to be either a needless encode/decode (if the application emitted H1 headers), or some nasty heuristics on the payload (if the application emitted the new format). \r\n\r\nSame for parse; otherwise, the implementation will have to translate the new encoding to H1 for applications, which doesn't make sense if they just want the data structure and associated SH handling.\r\n\r\n",
          "createdAt": "2018-06-01T03:52:50Z",
          "updatedAt": "2018-06-01T03:52:50Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I wasn't talking about a JavaScript API, to be clear. I was talking about the low-level interface for the HTTP standard that Fetch in some (hand-wavy) way wraps. If you were too, I suppose a distinct interface would work, but it seems nicer if we could exchange a single header list that contains both byte sequence values and typed values.",
          "createdAt": "2018-06-01T06:01:34Z",
          "updatedAt": "2018-06-01T06:01:53Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "(I don't see a link to a PR btw, just a commit on a branch that contains many other commits. Comments on those would probably easily get lost.)",
          "createdAt": "2018-06-01T06:03:04Z",
          "updatedAt": "2018-06-01T06:03:04Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Sorry, see https://github.com/httpwg/http-extensions/pull/636",
          "createdAt": "2018-06-01T06:12:16Z",
          "updatedAt": "2018-06-01T06:12:16Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I suspect that implementations aren't going to want to hand around byte sequences, because that makes potential optimisations that they'll find attractive more expensive.  If it's a byte sequence, that means they have to parse it for structure and figure out what to do with it. It'd be better if they hand around representations of the actual structures.\r\n\r\n",
          "createdAt": "2018-06-01T06:16:02Z",
          "updatedAt": "2018-06-01T06:16:02Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "@mnot I think you still misunderstand me. The \"byte sequence values\" are only for the legacy headers that do not have a typed representation. The \"typed values\" are for the new headers.",
          "createdAt": "2018-06-01T06:19:22Z",
          "updatedAt": "2018-06-01T06:19:22Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Ah, indeed I do then; I shouldn't answer bug mail when I'm sick :-/\r\n\r\nThat seems reasonable to me.",
          "createdAt": "2018-06-01T06:20:57Z",
          "updatedAt": "2018-06-01T06:20:57Z"
        }
      ]
    },
    {
      "number": 628,
      "id": "MDU6SXNzdWUzMjYwMzQ0MzI=",
      "title": "Clarify behaviour on page refresh for SameSite cookies",
      "url": "https://github.com/httpwg/http-extensions/issues/628",
      "state": "OPEN",
      "author": "mozmark",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis",
        "samesite"
      ],
      "body": "There seems to be some ambiguity around same-site-ness for requests from refreshes. See https://bugzilla.mozilla.org/show_bug.cgi?id=1459321 ",
      "createdAt": "2018-05-24T09:20:26Z",
      "updatedAt": "2019-12-27T10:18:58Z",
      "closedAt": null,
      "comments": [
        {
          "author": "april",
          "authorAssociation": "NONE",
          "body": "Some things to think about:\r\n\r\n- Do `location.reload()`, `window.location = ...` and other non-user initiated requests count as redirects? Should they send `SameSite` cookies?\r\n- Should POST data be sent on a refresh?",
          "createdAt": "2018-05-24T18:44:22Z",
          "updatedAt": "2018-05-24T18:44:22Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We've got the meta refresh too.",
          "createdAt": "2018-12-11T17:16:12Z",
          "updatedAt": "2018-12-11T17:16:12Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The Mozilla issue mentions web platform tests. Were any ever written?",
          "createdAt": "2018-12-11T17:18:00Z",
          "updatedAt": "2018-12-11T17:18:00Z"
        }
      ]
    },
    {
      "number": 629,
      "id": "MDU6SXNzdWUzMjYxMDAzNDg=",
      "title": "Identifiers",
      "url": "https://github.com/httpwg/http-extensions/issues/629",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "@mikewest suggested using structured headers for Cross-Origin-Resource-Policy in https://github.com/whatwg/fetch/pull/733 which makes sense, but requiring origins to be embedded in strings seems rather awkward and doesn't have precedent with the existing headers.",
      "createdAt": "2018-05-24T12:32:58Z",
      "updatedAt": "2018-10-08T07:46:20Z",
      "closedAt": "2018-10-08T07:46:20Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In fact, several existing header fields use angle brackets as delimiters for URI (references)  (Link, Dav, If). SH tries to get away with one delimiter syntax, so quoted-string it is.\r\n",
          "createdAt": "2018-05-24T13:33:07Z",
          "updatedAt": "2018-05-24T13:33:51Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Given how common URLs and origins seem to be as primitive components of headers headers, perhaps splitting them out into a type distinct from \"string\" might make sense. The initial serialisation might even be the same, but perhaps an eventual binary format could do more interesting tricks given knowledge of the format.",
          "createdAt": "2018-05-25T12:58:42Z",
          "updatedAt": "2018-05-25T12:58:42Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "An alternative way of stating OP would be asking why identifiers are as restricted as they are in the proposal?\r\n\r\n(I'm not entirely convinced either origin or URL is common enough to warrant its own type, FWIW.)",
          "createdAt": "2018-05-29T08:56:18Z",
          "updatedAt": "2018-05-29T08:56:18Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "origin *is* a URI (reference), no?\r\n\r\nIt's quite common that certain delimiters are not allowed in identifiers. I assume we're discussing characters such as \":\" and \"/\"?\r\n",
          "createdAt": "2018-05-29T10:26:59Z",
          "updatedAt": "2018-05-29T10:26:59Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "If you parse an origin as a URL and then serialize it, it would not be equal to the original input (it would have a trailing slash). And an opaque origin serializes as `null` which can't parse as a URL.\r\n\r\nAs for what's under discussion: \"/\" is already allowed. So \":\" and \".\", mainly, I think, but I'd have to double check if that's all.",
          "createdAt": "2018-05-29T10:30:47Z",
          "updatedAt": "2018-05-29T10:30:47Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If you parse an origin as a URL and then serialize it\r\n\r\nDepends on what you parse and serialize it with. FWIW, how does that matter in this context?\r\n\r\n> And an opaque origin serializes as null which can't parse as a URL.\r\n\r\nIt parses as URI reference.\r\n\r\n> As for what's under discussion: \"/\" is already allowed. So \":\" and \".\", mainly, I think, but I'd have to double check if that's all.\r\n\r\nHmm. <https://greenbytes.de/tech/webdav/draft-ietf-httpbis-header-structure-04.html#identifier>:\r\n\r\n~~~\r\nIdentifiers are short (up to 256 characters) textual identifiers; their abstract model is identical to their expression in the textual HTTP serialisation.\r\n\r\nidentifier = lcalpha *255( lcalpha / DIGIT / \"_\" / \"-\"/ \"*\" / \"/\" )\r\nlcalpha    = %x61-7A ; a-z\r\n\r\nNote that identifiers can only contain lowercase letters.\r\n~~~\r\n\r\nSo I don't see \":\" and \".\" here.",
          "createdAt": "2018-05-29T10:42:49Z",
          "updatedAt": "2018-05-29T10:42:49Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Right, that's the issue.",
          "createdAt": "2018-05-29T10:46:07Z",
          "updatedAt": "2018-05-29T10:46:07Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, you'd need more characters to be allowed so that an origin always is an identifier, no? (for instance: \",\")",
          "createdAt": "2018-05-29T10:51:37Z",
          "updatedAt": "2018-05-29T10:51:37Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Maybe, see https://github.com/whatwg/url/issues/390. I agree that if we need to continue to allow \",\" in hosts we better stick to strings.\r\n\r\nEven then I'm still interested in hearing the rationale behind the characters allowed in identifiers.",
          "createdAt": "2018-05-29T10:56:18Z",
          "updatedAt": "2018-05-29T10:56:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Identifiers aren't intended for payload; note that in the latest draft, they're only used for parameters and dictionaries. Everything else that's string-y needs to be quoted strings.\r\n\r\nIf we added an URL type, it would almost certainly be delimited with angle brackets, since DQUOTE is already taken, and it needs to be both signalled and delimited in some fashion.\r\n\r\nIt sounds like the underlying requirement here is \"it has to look exactly like previous headers\", which is a difficult bar to meet. What's the actual problem with using a string?\r\n\r\n",
          "createdAt": "2018-05-31T06:50:29Z",
          "updatedAt": "2018-05-31T06:50:29Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I guess that answers one question I had for `Cross-Origin-Resource-Policy`. Namely that using `same-origin` / `same-site` as byte-for-byte compared values would not be forward compatible with structured headers...\r\n\r\nWhich is also the problem. Using identifiers requires a very simple parser. And when we use origins we don't want to parse them as origins, but we want to compare them byte-for-byte. So all we'd need is split on \",\" and trim HTTP whitespace. With strings it's a little more involved and they would be harder to adopt now without all the structured header infrastructure in place. (And unfortunately as these things go everyone wants to ship stuff now.)",
          "createdAt": "2018-05-31T06:59:08Z",
          "updatedAt": "2018-05-31T06:59:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Shipping code that doesn't implement SH but specifying it as SH seems pretty bad, both for your spec and for SH interop.\r\n\r\nRe-adding identifiers (or something like them) to the possible types in SH is certainly possible, though.  ",
          "createdAt": "2018-05-31T07:03:33Z",
          "updatedAt": "2018-05-31T07:03:33Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "That's why I said forward compatible. I'm not specifying it as SH as that's still somewhat in flux, but ideally if we extend `Cross-Origin-Resource-Pollicy` to accept more than two values going forward, we can adopt SH for it.\r\n\r\nAnd I was also thinking that if identifiers were broad enough, we could use them for a variety of CORS headers too, as pretty much all have a very basic syntax where they just take one or more identifier-likes.",
          "createdAt": "2018-05-31T07:10:22Z",
          "updatedAt": "2018-05-31T07:11:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK. Happy to re-add them if there's desire (although I might distinguish between those we use for dicts and params and those that are allowed in item; will see) -- just ask.",
          "createdAt": "2018-06-05T09:38:49Z",
          "updatedAt": "2018-06-05T09:38:49Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I think if we could make all of https://fetch.spec.whatwg.org/#http-new-header-syntax structured headers that'd be great.",
          "createdAt": "2018-06-05T09:54:13Z",
          "updatedAt": "2018-06-05T09:54:13Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@annevk we took identifiers out of payload because of #505. Would be very keen to hear your thoughts there (or here).",
          "createdAt": "2018-06-28T07:06:02Z",
          "updatedAt": "2018-06-28T07:06:02Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "The way I solved that in https://mimesniff.spec.whatwg.org/#serializing-a-mime-type is by serializing as identifier if there are no problematic code points and as a string otherwise. The parser would always produce a string, too.\r\n\r\nI think that's what I'd recommend doing, provided there's agreement to uplift some existing (and recently defined) headers to this scheme.",
          "createdAt": "2018-07-21T14:51:27Z",
          "updatedAt": "2018-07-21T14:51:27Z"
        }
      ]
    },
    {
      "number": 630,
      "id": "MDU6SXNzdWUzMjYxMDEzNjE=",
      "title": "Parsing string from text is lenient",
      "url": "https://github.com/httpwg/http-extensions/issues/630",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Is it intentional that `\"test\"test` does not fail and returns `test`? Might be worth a note if so.",
      "createdAt": "2018-05-24T12:35:38Z",
      "updatedAt": "2018-05-25T06:16:15Z",
      "closedAt": "2018-05-25T06:16:14Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "How so? If there's input left over after Parsing an Item from Text, step 7 of Parsing Textual Header Fields fails.",
          "createdAt": "2018-05-25T00:07:57Z",
          "updatedAt": "2018-05-25T00:07:57Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Ah, I was thinking later that might be what I was missing. I was just looking at string parsing in isolation.",
          "createdAt": "2018-05-25T06:16:14Z",
          "updatedAt": "2018-05-25T06:16:14Z"
        }
      ]
    },
    {
      "number": 632,
      "id": "MDU6SXNzdWUzMjcxNzg3MDg=",
      "title": "secondary-certs: misleading citation",
      "url": "https://github.com/httpwg/http-extensions/issues/632",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "MikeBishop"
      ],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "<https://tools.ietf.org/html/draft-ietf-httpbis-http2-secondary-certs-01#section-1>:\r\n\r\n~~~\r\n   HTTP clients need to know that the content they receive on a\r\n   connection comes from the origin that they intended to retrieve in\r\n   from.  The traditional form of server authentication in HTTP has been\r\n   in the form of a single X.509 certificate provided during the TLS\r\n   RFC5246 [I-D.ietf-tls-tls13] handshake.\r\n~~~\r\n\r\nThis makes it  look as if RFC5246 *is* [I-D.ietf-tls-tls13].",
      "createdAt": "2018-05-29T05:55:05Z",
      "updatedAt": "2018-05-29T21:43:20Z",
      "closedAt": "2018-05-29T21:43:20Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "True; I think this was originally intended to cite both, but the first one stopped being special at some point, if it ever was.  Once TLS 1.3 hits RFC, we may want to trim some of the RFC 5246 references unless we're specifically talking about the older version, too.",
          "createdAt": "2018-05-29T17:28:01Z",
          "updatedAt": "2018-05-29T17:28:01Z"
        }
      ]
    },
    {
      "number": 635,
      "id": "MDU6SXNzdWUzMjgwMDM2NjI=",
      "title": "Input validation",
      "url": "https://github.com/httpwg/http-extensions/issues/635",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "... isn't yet good enough.\r\n\r\n* [x] \"no ... is present\" is ambiguous (several locations\r\n* [x] numbers don't check for non-numeric characters explicitly\r\n* [x] strings don't check for disallowed characters\r\n* [x] base64 doesn't check for disallowed characters\r\n\r\n",
      "createdAt": "2018-05-31T05:56:31Z",
      "updatedAt": "2018-06-13T06:04:33Z",
      "closedAt": "2018-06-13T06:04:33Z",
      "comments": []
    },
    {
      "number": 637,
      "id": "MDU6SXNzdWUzMjg2OTAxNDE=",
      "title": "Reconsider allowing user overrides on certificate errors for Expect-CT sites",
      "url": "https://github.com/httpwg/http-extensions/issues/637",
      "state": "CLOSED",
      "author": "estark37",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "estark37"
      ],
      "labels": [
        "expect-ct"
      ],
      "body": "Paragraph 1 of Section 2.4 was cribbed from HSTS and HPKP, but probably doesn't make sense for Expect-CT, especially while CT is young and misconfigurations may be common. (Chrome doesn't actually implement this, either.)",
      "createdAt": "2018-06-01T23:41:09Z",
      "updatedAt": "2018-06-04T21:17:45Z",
      "closedAt": "2018-06-04T21:17:45Z",
      "comments": []
    },
    {
      "number": 638,
      "id": "MDU6SXNzdWUzMjg2OTQwNzI=",
      "title": "Clarify use of \"host\" vs \"server\"",
      "url": "https://github.com/httpwg/http-extensions/issues/638",
      "state": "CLOSED",
      "author": "estark37",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "estark37"
      ],
      "labels": [
        "editorial",
        "expect-ct"
      ],
      "body": "In section 1.2, note that \"host\" is meant to be equivalent to \"server\", and not a client.",
      "createdAt": "2018-06-02T00:11:56Z",
      "updatedAt": "2018-06-04T21:17:45Z",
      "closedAt": "2018-06-04T21:17:45Z",
      "comments": []
    },
    {
      "number": 639,
      "id": "MDU6SXNzdWUzMjg2OTQyNjc=",
      "title": "Correct typo'ed instances \"Known CT Host\" -> \"Known Expect-CT Host\"",
      "url": "https://github.com/httpwg/http-extensions/issues/639",
      "state": "CLOSED",
      "author": "estark37",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "estark37"
      ],
      "labels": [
        "editorial",
        "expect-ct"
      ],
      "body": "",
      "createdAt": "2018-06-02T00:13:31Z",
      "updatedAt": "2018-06-04T20:59:14Z",
      "closedAt": "2018-06-04T20:59:14Z",
      "comments": []
    },
    {
      "number": 640,
      "id": "MDU6SXNzdWUzMjg2OTQ2NTM=",
      "title": "Drop SHOULD from 2.2.1",
      "url": "https://github.com/httpwg/http-extensions/issues/640",
      "state": "CLOSED",
      "author": "estark37",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "estark37"
      ],
      "labels": [
        "editorial",
        "expect-ct"
      ],
      "body": "\"2.2.1, the \"SHOULD\" here isn't a real requirement.  You can drop it\r\nand just say \"an Expect-CT host includes exactly one Expect-CT header\r\nfield in its response\".  A host that isn't Expect-CT won't include the\r\nheader field.\" (http://lists.w3.org/Archives/Public/ietf-http-wg/2018AprJun/0238.html)",
      "createdAt": "2018-06-02T00:16:15Z",
      "updatedAt": "2018-06-04T21:04:32Z",
      "closedAt": "2018-06-04T21:04:32Z",
      "comments": []
    },
    {
      "number": 641,
      "id": "MDU6SXNzdWUzMjg3MTc0NDU=",
      "title": "Mark httpbis-cookie-same-site as superseded if possible",
      "url": "https://github.com/httpwg/http-extensions/issues/641",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It took me quite long to find httpbis-rfc6265bis.",
      "createdAt": "2018-06-02T06:03:56Z",
      "updatedAt": "2018-06-04T10:18:38Z",
      "closedAt": "2018-06-04T09:31:48Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Done.",
          "createdAt": "2018-06-04T09:31:48Z",
          "updatedAt": "2018-06-04T09:31:48Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Cool, I guess it'll take some time to propagate before https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site is updated?",
          "createdAt": "2018-06-04T09:33:31Z",
          "updatedAt": "2018-06-04T09:33:31Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes.",
          "createdAt": "2018-06-04T09:43:27Z",
          "updatedAt": "2018-06-04T09:43:27Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You can see it in the [datatracker](https://datatracker.ietf.org/doc/draft-ietf-httpbis-cookie-same-site/).",
          "createdAt": "2018-06-04T10:18:38Z",
          "updatedAt": "2018-06-04T10:18:38Z"
        }
      ]
    },
    {
      "number": 642,
      "id": "MDU6SXNzdWUzMjkyMTI1MzI=",
      "title": "Cite JSON",
      "url": "https://github.com/httpwg/http-extensions/issues/642",
      "state": "CLOSED",
      "author": "estark37",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "estark37"
      ],
      "labels": [
        "editorial",
        "expect-ct"
      ],
      "body": "",
      "createdAt": "2018-06-04T20:52:40Z",
      "updatedAt": "2018-06-04T21:18:06Z",
      "closedAt": "2018-06-04T21:18:05Z",
      "comments": [
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed in c46d27c2ce015ed133f93a9ce70c23d4ef0396fb",
          "createdAt": "2018-06-04T21:18:05Z",
          "updatedAt": "2018-06-04T21:18:05Z"
        }
      ]
    },
    {
      "number": 643,
      "id": "MDU6SXNzdWUzMjkyMTI4MDM=",
      "title": "Section 3.1: fix date-time to Zulu time zone",
      "url": "https://github.com/httpwg/http-extensions/issues/643",
      "state": "CLOSED",
      "author": "estark37",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "estark37"
      ],
      "labels": [
        "editorial",
        "expect-ct"
      ],
      "body": "",
      "createdAt": "2018-06-04T20:53:26Z",
      "updatedAt": "2018-06-04T21:21:31Z",
      "closedAt": "2018-06-04T21:21:31Z",
      "comments": []
    },
    {
      "number": 644,
      "id": "MDU6SXNzdWUzMjkyMTMyNjc=",
      "title": "Reorganize Sections 2.3 and 2.4",
      "url": "https://github.com/httpwg/http-extensions/issues/644",
      "state": "CLOSED",
      "author": "estark37",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "estark37"
      ],
      "labels": [
        "editorial",
        "expect-ct"
      ],
      "body": "Suggestions from http://lists.w3.org/Archives/Public/ietf-http-wg/2018AprJun/0238.html:\r\n\r\n> 2.3.1 contains two lead-ins to the list.  I think that the processing\r\n> order is a little misleading.  In particular, the second lead-in\r\n> doesn't say that Expect-CT is present.  You want to say something like\r\n> \"If a host is CT-qualified, then process a response that contains a\r\n> Expect-CT header field in one of the two following ways:\"\r\n> \r\n> Overall, I think that 2.3 could be structured differently.  This\r\n> section includes cases for when the Expect-CT header field is\r\n> malformed (equivalent to not being present) as well as for when the\r\n> host is CT-qualified.  I would move the processing for absent and\r\n> invalid Expect-CT header fields into another section that simply says\r\n> that no change is made to the value of \"Expect-CT metadata\" for that\r\n> host.  Then you only have to worry about updating Expect-CT metadata -\r\n> which can be moved to 2.3.2, and reporting, which deserves its own\r\n> section.\r\n> \r\n> Something like:\r\n> \r\n> - Responses Without Expect-CT\r\n>   When the header is absent or malformed, the status of the host is\r\n> unchanged.  That is, any Expect-CT metadata for the host is unchanged.\r\n> \r\n> - Updating Expect-CT Metadata\r\n>   The Expect-CT header field is ignored if a connection is not\r\n> CT-qualified (see previous section), but it might generate a report\r\n> (see next section).\r\n>   If the connection is CT-qualified, then CT-metadata is created or\r\n> updated for the corresponding host based on the value of the Expect-CT\r\n> header field.\r\n> \r\n> - Reporting Expect-CT Problems\r\n>   If a connection is not CT-qualified, but the Expect-CT header field\r\n> is present and contains a report-uri, then a report is generated\r\n> (Section 3).\r\n\r\n> For 2.4, I would start by saying that when evaluating a connection,\r\n> the UA determines if the UA is a Known Expect-CT Host.  It does this\r\n> by looking for records that aren't expired.  Then talk about the extra\r\n> checks.  The current arrangement of paragraphs doesn't have a\r\n> consistent flow, it's currently: extra-checks, expiration, not\r\n> CT-qualified, more on reporting for not-CT-qualified hosts,\r\n> extra-checks again, disabling CT.  The bit on disabling CT belongs\r\n> elsewhere, I think, because it risks being missed.",
      "createdAt": "2018-06-04T20:54:56Z",
      "updatedAt": "2018-06-04T21:56:55Z",
      "closedAt": "2018-06-04T21:56:55Z",
      "comments": []
    },
    {
      "number": 655,
      "id": "MDU6SXNzdWUzMzMyOTgyODU=",
      "title": "bcp56bis privacy guidelines section",
      "url": "https://github.com/httpwg/http-extensions/issues/655",
      "state": "CLOSED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "the doh wg is dicsussing privacy implications of using http as a substrate.\r\n\r\nthat made me realize that this is ground bcp56bis could cover to help applications realize the implications of generic http from that perspective.",
      "createdAt": "2018-06-18T14:38:23Z",
      "updatedAt": "2018-06-29T01:58:19Z",
      "closedAt": "2018-06-29T01:57:51Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Had the same thought; on it.",
          "createdAt": "2018-06-18T23:02:46Z",
          "updatedAt": "2018-06-18T23:02:46Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "_straw-man; needs references_\r\n\r\n## Privacy Considerations \r\n\r\nHTTP clients can expose a variety of information to servers. Besides information that's explicitly sent as part of an application's operation (for example, names and other user-entered data), other information can be gathered through less obvious means -- often by connecting activities of a user over time. \r\n\r\nThis includes session information, tracking the client through fingerprinting, and mobile code.\r\n\r\n**Session information** includes things like the IP address of the client, TLS session tickets, Cookies, ETags stored in the client's cache, and other stateful mechanisms. Applications SHOULD avoid using session mechanisms unless they are unavoidable or necessary for operation; these risks SHOULD be documented and implementations SHOULD be encouraged to allow clearing such state.\r\n\r\n**Fingerprinting** uses unique aspects of a client's messages and behaviours to connect disparate requests and connections. For example, the `User-Agent` request header conveys specific information about the implementation; the `Accept-Language` request header conveys the users' preferred language. In combination, a number of these markers can be used to uniquely identify a client, impacting its control over its data. As a result, applications SHOULD only emit the information they need to function in requests.\r\n\r\nFinally, if an application exposes the ability to run **mobile code**, great care needs to be taken, since any ability to observe its environment can be used as an opportunity to both fingerprint the client and to obtain and manipulate private data (including session information). For example, access to high-resolution timers (even indirectly) can be used to profile the underlying hardware, creating a unique identifier for the system. Applications SHOULD avoid allowing the use of mobile code where possible; when it cannot be avoided, the resulting system's security properties MUST be deeply scrutinised.\r\n",
          "createdAt": "2018-06-28T07:35:51Z",
          "updatedAt": "2018-06-29T00:13:57Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I assume that this assumes https. Otherwise this would need to be broader. ",
          "createdAt": "2018-06-28T12:03:29Z",
          "updatedAt": "2018-06-28T12:03:29Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We recommend HTTPS elsewhere, but it can be reinforced here.",
          "createdAt": "2018-06-29T00:13:31Z",
          "updatedAt": "2018-06-29T00:13:31Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Happy to take additional changes / suggestions, etc., either as a PR or separate issue.",
          "createdAt": "2018-06-29T01:58:19Z",
          "updatedAt": "2018-06-29T01:58:19Z"
        }
      ]
    },
    {
      "number": 657,
      "id": "MDU6SXNzdWUzMzY0OTY5ODU=",
      "title": "Combining headers",
      "url": "https://github.com/httpwg/http-extensions/issues/657",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "SH should specify how two headers should be combined by parsers (acknowledging that upstream may have already combined them, in a different fashion).",
      "createdAt": "2018-06-28T07:00:18Z",
      "updatedAt": "2018-08-19T05:57:05Z",
      "closedAt": "2018-08-19T05:57:05Z",
      "comments": []
    },
    {
      "number": 658,
      "id": "MDU6SXNzdWUzMzY0OTc0Nzg=",
      "title": "Reconsider padding",
      "url": "https://github.com/httpwg/http-extensions/issues/658",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "#473 flipped handling for non-zero padding; the same should be considered for == padding.",
      "createdAt": "2018-06-28T07:02:19Z",
      "updatedAt": "2018-08-19T06:26:14Z",
      "closedAt": "2018-08-19T06:26:14Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In particular, in https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#parse-binary\r\n\r\n> As per [RFC4648], Section 3.2, it is RECOMMENDED that parsers reject encoded data that is not properly padded, although this might not be possible in some base64 implementations.\r\n>\r\n> Because some implementations of base64 do not allow rejection of encoded data that has non-zero pad bits (see [RFC4648], Section 3.5), parsers SHOULD NOT fail when it is present, unless they cannot be configured to handle it.\r\n\r\nhas the same justification for two opposite SHOULDs.",
          "createdAt": "2018-07-24T23:19:44Z",
          "updatedAt": "2018-07-24T23:19:44Z"
        }
      ]
    },
    {
      "number": 659,
      "id": "MDU6SXNzdWUzMzY0OTk1NjY=",
      "title": "Ordered dictionaries",
      "url": "https://github.com/httpwg/http-extensions/issues/659",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Should dicts be ordered? It might be a bit harder to surface them in some APIs, but still possible, and it would allow some use cases (this has come up once or twice).\r\n\r\nOther option would be to have an explicitly ordered dict as a separate type.",
      "createdAt": "2018-06-28T07:10:33Z",
      "updatedAt": "2018-08-19T06:20:48Z",
      "closedAt": "2018-08-19T06:20:48Z",
      "comments": [
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can't you do the same thing with a list with attributes ?",
          "createdAt": "2018-06-28T08:13:16Z",
          "updatedAt": "2018-06-28T08:13:16Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Lists can only contain items, and items don't have anything like an attribute.",
          "createdAt": "2018-06-29T00:15:20Z",
          "updatedAt": "2018-06-29T00:15:20Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "IIRC we discussed in Montreal; there seemed to be support in the room. Will give it a try.",
          "createdAt": "2018-08-19T05:58:09Z",
          "updatedAt": "2018-08-19T05:58:09Z"
        }
      ]
    },
    {
      "number": 660,
      "id": "MDU6SXNzdWUzMzY4MTM4MTA=",
      "title": "Accidentally failing to change providers",
      "url": "https://github.com/httpwg/http-extensions/issues/660",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "Suppose a site is hosted on a particular provider (or CDN, equally).  The customer flips the DNS entry to point to a new provider.  However, the old provider doesn't know that and might continue to serve traffic via ORIGIN + Secondary Certificates for requests that originally reach the provider via other DNS records.\r\n\r\nIt's current industry practice to leave the old provider configured and hot during a transition to ensure the graceful cutover.  However, the DNS record change is considered to be sufficent.  We might want to recommend that servers periodically ensure the DNS record points to them before serving Secondary Certificates / ORIGIN references.\r\n\r\nI think this is Security Considerations prose, not protocol elements or requirements, however.",
      "createdAt": "2018-06-28T23:30:21Z",
      "updatedAt": "2019-04-25T19:26:23Z",
      "closedAt": "2019-04-25T19:26:23Z",
      "comments": []
    },
    {
      "number": 662,
      "id": "MDU6SXNzdWUzMzc3NDUzNzM=",
      "title": "Handling Non-ASCII Content",
      "url": "https://github.com/httpwg/http-extensions/issues/662",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "From [Kari](https://www.w3.org/mid/20180702190902.6769054978@welho-filter1.welho.com):\r\n\r\nBut parsing algorith seems missing text:\r\n\r\n\tIf non-ASCII characters seen, fail parsing.\r\n\r\nAll algrithm have text\r\n\r\n\t\"Given an ASCII string input_string\"\r\n\r\nso they do not apply situation when there is non-ASCII characters.\r\n\r\nSo there seems to missing top level algorithm, which is\r\n\r\n   Given an string input_string, return parsed context.\r\n\r\n   1. Check input_string character values.\r\n\r\n      1. If all characters are on range %x00-%x7f,\r\n         let output be the result of \r\n         Parsing HTTP/1 Header Fields into Structured Headers\r\n         (Section 4.2)\r\n\r\n      2. Otherwise, fail parsing.",
      "createdAt": "2018-07-03T04:55:10Z",
      "updatedAt": "2019-07-03T14:22:00Z",
      "closedAt": "2019-07-03T03:55:17Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "All of the parsing algorithms seem to have checks for the range of characters they allow; closing with no action.",
          "createdAt": "2018-08-19T06:15:11Z",
          "updatedAt": "2018-08-19T06:15:11Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "For my own clarity: what do you expect callers of this algorithm to do? The text Kari points out does give me the impression that you require ASCII encoding, which doesn't match the expectations that Fetch has for header values. In particular, the algorithms in https://fetch.spec.whatwg.org/#terminology-headers do not make any assumptions about the character set.\r\n\r\nShould we be checking whether the string we're passing into the parsing algorithm is ASCII before doing so?\r\n\r\n(See the conversation in https://github.com/whatwg/html/issues/4175#issuecomment-503991995 for context).",
          "createdAt": "2019-06-21T07:01:44Z",
          "updatedAt": "2019-06-21T07:01:44Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Yeah, note that this can lead to vastly different results for quoted strings. I think it would be preferable if these parser algorithms operated on a byte sequence (or the result of https://infra.spec.whatwg.org/#isomorphic-decode).",
          "createdAt": "2019-06-21T13:04:07Z",
          "updatedAt": "2019-06-21T13:04:07Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We can add a step to convert a byte stream to characters on parsing (and vice versa for serialisation) if it makes things easier for you.\r\n\r\nWe could add an explicit step to check that the input is ASCII, but like I said above, that would be an optimisation; the terminal types all check their input.\r\n\r\n",
          "createdAt": "2019-07-01T03:16:24Z",
          "updatedAt": "2019-07-01T03:16:24Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "What is a terminal type?\r\n\r\nI think @mikewest and I have been looking at https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-10#section-4.2 which assumes an ASCII string as input.\r\n\r\n(As an aside, I wonder what the eventual specification contract should look like here. I guess a \"header list\" should be able to store typed values and there's a typed-value getter that either returns the typed-value for a given header, parses a legacy-value into one if there's no typed-value, or returns none if there's neither, or failure if parsing failed. And if we start setting these values we'd always pass on typed values to the HTTP subsystem which then decides based the connection how to serialize these.)",
          "createdAt": "2019-07-01T11:45:19Z",
          "updatedAt": "2019-07-01T11:45:19Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "terminal types are items; i.e., something that isn't a container.",
          "createdAt": "2019-07-02T04:22:33Z",
          "updatedAt": "2019-07-02T04:22:33Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "WRT 4.2, we can be more explicit there; will do a PR.",
          "createdAt": "2019-07-02T04:23:15Z",
          "updatedAt": "2019-07-02T04:23:15Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "PTAL at the commit above.",
          "createdAt": "2019-07-03T03:13:26Z",
          "updatedAt": "2019-07-03T03:13:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing; if that's not what you needed, please complain and will reopen.",
          "createdAt": "2019-07-03T03:55:17Z",
          "updatedAt": "2019-07-03T03:55:17Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Okay, so if there's a byte in the range 0x80-0xFF, inclusive, anywhere for a particular header, it'll fail parsing. That seems fine.\r\n\r\nHTTP still needs to define this interface where it accepts a header list where the header values can be typed values, but I guess that'll take a while.",
          "createdAt": "2019-07-03T14:22:00Z",
          "updatedAt": "2019-07-03T14:22:00Z"
        }
      ]
    },
    {
      "number": 663,
      "id": "MDU6SXNzdWUzNDAwODMzNjQ=",
      "title": "More expressive Variant-Key for multiple values",
      "url": "https://github.com/httpwg/http-extensions/issues/663",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "_from the list_\r\n\r\nMaybe we should be talking about a Variant-Key syntax that lets you specify alternative sets of values, e.g.,\r\n\r\n~~~\r\nVariants: DPR;1;2, Viewport;300;600, Save-Data;on;off\r\nVariant-Key: 2;300;off, 1;600;off, 2;600;on\r\n~~~\r\n",
      "createdAt": "2018-07-11T03:59:18Z",
      "updatedAt": "2018-10-23T01:11:09Z",
      "closedAt": "2018-10-23T01:11:09Z",
      "comments": []
    },
    {
      "number": 664,
      "id": "MDU6SXNzdWUzNDExNjk4OTg=",
      "title": "draft-ietf-httpbis-header-structure.md#parse-string incorrectly references VCHAR",
      "url": "https://github.com/httpwg/http-extensions/issues/664",
      "state": "CLOSED",
      "author": "twifkak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "#parse-string Step 4.4 equates \"the range %x00-1f or %x7f\" to \"not in VCHAR\", but VCHAR doesn't include %x20.\r\n\r\n#ser-string Step 0 says to fail serialization if the input \"contains characters outside the range allowed by VCHAR or SP\".",
      "createdAt": "2018-07-13T21:51:03Z",
      "updatedAt": "2018-07-15T15:02:49Z",
      "closedAt": "2018-07-15T15:02:49Z",
      "comments": []
    },
    {
      "number": 668,
      "id": "MDU6SXNzdWUzNDE2MTk2OTE=",
      "title": "Ambiguity in 4.2.6, Structured Headers Draft v07",
      "url": "https://github.com/httpwg/http-extensions/issues/668",
      "state": "CLOSED",
      "author": "sharma95",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Section 4.2.6 (Parsing a Number from Text) is ambiguous. It makes no mention of the exit condition from the while loop in step 7 on parsing a number from an input buffer.",
      "createdAt": "2018-07-16T18:08:50Z",
      "updatedAt": "2018-08-16T08:15:52Z",
      "closedAt": "2018-08-16T08:15:52Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't see it. The loop terminates with \"fail parsing\" in 7.4 (invalid character), or 7.5/7.6 (too many digits); or terminates successfully by virtue of \"input_string is not empty\" becoming untrue.",
          "createdAt": "2018-07-27T02:03:20Z",
          "updatedAt": "2018-07-27T02:03:20Z"
        },
        {
          "author": "sharma95",
          "authorAssociation": "NONE",
          "body": "An example might clarify what I find ambiguous. Let us suppose that the input string is \"-11-1, 4, 3\", and that we are parsing a list. We'd call parseItem(), which would then invoke parseNumber(). When should parseNumber() stop reading in characters? Should it read in \"-11\" and then leave the rest to the next parsing function, or should it read in \"-11-1\" and then fail parsing? The other sections are unambiguous as to when to stop reading in characters (for instance, section 4.2.7 step 4.3 states that parsing of a string would stop when you encounter a DQUOTE, and section 4.2.9 step 3 states that parsing of binary content would stop when you encounter an ending asterisk).",
          "createdAt": "2018-07-30T18:16:17Z",
          "updatedAt": "2018-07-30T18:16:17Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh I see what you're saying.  Yes, step 7.4 shouldn't be so aggressive.",
          "createdAt": "2018-07-31T03:33:48Z",
          "updatedAt": "2018-07-31T03:33:48Z"
        }
      ]
    },
    {
      "number": 669,
      "id": "MDU6SXNzdWUzNDE2MjAxMjQ=",
      "title": "Ambiguity in 4.1.1 Structured Headers Draft v07",
      "url": "https://github.com/httpwg/http-extensions/issues/669",
      "state": "CLOSED",
      "author": "sharma95",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Section 4.1.1 (Serialising a Dictionary) seems inaccurate. It makes no mention of where the delimiter between successive key-value pairs (a comma) should be placed when serializing a dictionary, and how much whitespace to add before/after the delimiter",
      "createdAt": "2018-07-16T18:09:55Z",
      "updatedAt": "2018-08-01T01:11:39Z",
      "closedAt": "2018-08-01T01:11:39Z",
      "comments": []
    },
    {
      "number": 670,
      "id": "MDU6SXNzdWUzNDIzMjEzNDc=",
      "title": "Questions over examples for Variants",
      "url": "https://github.com/httpwg/http-extensions/issues/670",
      "state": "CLOSED",
      "author": "bazzadp",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "I'm confused with the examples in https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html\r\n```\r\nGET /foo HTTP/1.1\r\nHost: www.example.com\r\nAccept-Language: en;q=0.5, fr;q=1.0 \r\n```\r\nMy (limited!) understand of this is it means \"I'd prefer French, but next preference is English if French is not available\".\r\n\r\nThe example response is this:\r\n```\r\nHTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Language: en\r\nVary: Accept-Language\r\nTransfer-Encoding: chunked\r\n\r\n[French content]\r\n```\r\nWhy is the `Content-Language: en` but the content in French? The only way this would make sense is if it was French content aimed at English speakers (e.g. a French course for English speakers) but that's a bit of an edge case so presume that is that the intention here? Shouldn't the Content-Language either be fr, or the Content be in English so they match? It looks like it was in previous drafts but then it was flipped around, so not sure if this got missed or if I'm completely missing the point.\r\n\r\nMoving on we have the new example using the same request:\r\n```\r\nGET /foo HTTP/1.1\r\nHost: www.example.com\r\nAccept-Language: en;q=0.5, fr;q=1.0\r\n```\r\nand the new response with the additional proposed syntax:\r\n```\r\nHTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Language: en\r\nVary: Accept-Language\r\nVariants: Accept-Language;de;en;jp\r\nVariant-Key: en\r\nTransfer-Encoding: chunked\r\n\r\n[French content]\r\n```\r\nHere it says there are German, English and Japanese versions (and no French version), and I've decided to send you the English version, and then it gives French content? Again should this be `[English content]`?\r\n",
      "createdAt": "2018-07-18T13:09:24Z",
      "updatedAt": "2018-10-08T08:04:04Z",
      "closedAt": "2018-10-08T08:04:04Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "You're correct. I fixed this a while back but forgot to update this bug; please have a look again and if you still see an issue, please comment here.\r\n\r\nThanks!",
          "createdAt": "2018-10-08T08:04:04Z",
          "updatedAt": "2018-10-08T08:04:04Z"
        }
      ]
    },
    {
      "number": 671,
      "id": "MDU6SXNzdWUzNDQyMzg3Njg=",
      "title": "Consider aligning Structured Headers terminology with Infra",
      "url": "https://github.com/httpwg/http-extensions/issues/671",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#parse-binary talks about returning \"binary content\" where Infra would say \"[byte sequence](https://infra.spec.whatwg.org/#byte-sequence)\". I think this is the only one where pedantic readers might wonder whether there's a semantic difference.\r\n\r\nhttps://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#string uses \"String\" where Infra would use \"[ASCII string](https://infra.spec.whatwg.org/#ascii-string)\".\r\n\r\nAdopting #659 would match Infra's [ordered maps](https://infra.spec.whatwg.org/#maps), but I'm happy to keep the semantic argument out of this issue. :smiley: ",
      "createdAt": "2018-07-24T23:27:49Z",
      "updatedAt": "2018-08-19T06:20:49Z",
      "closedAt": "2018-08-19T06:20:49Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Seems reasonable; will have a deeper look when I get a chance. Thanks!",
          "createdAt": "2018-07-24T23:35:25Z",
          "updatedAt": "2018-07-24T23:35:25Z"
        }
      ]
    },
    {
      "number": 680,
      "id": "MDU6SXNzdWUzNDg1ODY3ODU=",
      "title": "Expect-CT header using comma delimiter instead of semicolon",
      "url": "https://github.com/httpwg/http-extensions/issues/680",
      "state": "CLOSED",
      "author": "leonklingele",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In contract to headers like `Content-Type`, `Content-Security-Policy`, `Feature-Policy`, `Public-Key-Pins`, `Strict-Transport-Security`, etc., the `Expect-CT` header uses a comma delimiter instead of a semicolon. What's the reason for that?\r\n\r\n```\r\nContent-Type: text/html; charset=UTF-8\r\n                       ^ Semicolon\r\n\r\nContent-Security-Policy: default-src 'none'; script-src 'self'\r\n                                           ^ Semicolon\r\n\r\nStrict-Transport-Security: max-age=31536000; includeSubDomains; preload\r\n                                           ^ Semicolon        ^ Semicolon\r\n\r\nExpect-CT: enforce, max-age=86400\r\n                  ^ Comma\r\n```",
      "createdAt": "2018-08-08T06:04:32Z",
      "updatedAt": "2018-08-09T04:06:14Z",
      "closedAt": "2018-08-09T04:06:14Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Commas are used to separate different values.  Those other header fields are comprised of a single value (with multiple parts).  Expect-CT, like Cache-Control, includes multiple separate directives.\r\n\r\nYou could also say that Expect-CT fails to replicate the mistakes of those other header fields, but some of those - like CSP - are explicitly designed to have a single directive.",
          "createdAt": "2018-08-08T06:12:23Z",
          "updatedAt": "2018-08-08T06:12:23Z"
        }
      ]
    },
    {
      "number": 681,
      "id": "MDU6SXNzdWUzNDg5MDEyNTI=",
      "title": "IANA registry for Variant-able Content Negotiation Mechanisms",
      "url": "https://github.com/httpwg/http-extensions/issues/681",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "https://tools.ietf.org/html/draft-ietf-httpbis-variants-03 should define a registry to specify which content negotiation mechanisms are usable with `Variants`.\r\n\r\nhttps://tools.ietf.org/html/draft-ietf-httpbis-variants-03#section-6 has most of the requirements for putting something in that registry, and https://tools.ietf.org/html/draft-ietf-httpbis-variants-03#appendix-A has the initial entries.",
      "createdAt": "2018-08-08T21:37:15Z",
      "updatedAt": "2018-11-20T23:30:42Z",
      "closedAt": "2018-11-20T23:30:42Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hi Jeffrey,\r\n\r\nMy initial reaction is that we don't really use registries like this; they're for managing a name space, not just for convenience like that (that's more like developer documentation, blog entries, etc.).\r\n\r\nLet met talk to a few grey beards and see what they think.",
          "createdAt": "2018-10-08T08:05:38Z",
          "updatedAt": "2018-10-08T08:05:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Bangkok. The sense of the room was that recording this elsewhere -- e.g., a wiki -- was sufficient. ",
          "createdAt": "2018-11-11T03:58:58Z",
          "updatedAt": "2018-11-11T03:58:58Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks. I'm concerned about how folks find that wiki page when they're starting from either Variants or the other header's definition, but it'll probably work out.",
          "createdAt": "2018-11-20T23:30:42Z",
          "updatedAt": "2018-11-20T23:30:42Z"
        }
      ]
    },
    {
      "number": 683,
      "id": "MDU6SXNzdWUzNTE0NjQzNTk=",
      "title": "Boolean type",
      "url": "https://github.com/httpwg/http-extensions/issues/683",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "This could be useful.",
      "createdAt": "2018-08-17T05:46:04Z",
      "updatedAt": "2018-08-21T02:30:15Z",
      "closedAt": "2018-08-19T06:44:59Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "`%x79.65.61.68.2d.6e.6f / %6e.61.68.2d.79.65.70`",
          "createdAt": "2018-08-20T03:49:58Z",
          "updatedAt": "2018-08-20T03:49:58Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Wait, `!T` means true? Not... not-true?",
          "createdAt": "2018-08-20T03:51:09Z",
          "updatedAt": "2018-08-20T03:52:57Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It would be easier to use `?T`.",
          "createdAt": "2018-08-20T05:55:56Z",
          "updatedAt": "2018-08-20T05:55:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I like \"?\"",
          "createdAt": "2018-08-21T02:30:15Z",
          "updatedAt": "2018-08-21T02:30:15Z"
        }
      ]
    },
    {
      "number": 684,
      "id": "MDU6SXNzdWUzNTE0NjU4Mzc=",
      "title": "Strictness for multi-party headers",
      "url": "https://github.com/httpwg/http-extensions/issues/684",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "currently:\r\n\r\n> If parsing fails \u2013 including when calling another algorithm \u2013 the entire header field\u2019s value MUST be discarded. This is intentionally strict, to improve interoperability and safety, and specifications referencing this document cannot loosen this requirement.\r\n\r\nThis might not be setting up the right incentive structure for cases where multiple parties are adding to a single header field value. The right thing to do in that case might be to discard the offending value (or replace it with an empty value, to preserve cardinality) while preserving others.",
      "createdAt": "2018-08-17T05:54:29Z",
      "updatedAt": "2018-11-12T06:18:09Z",
      "closedAt": "2018-11-12T06:18:09Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This depends on how header fields are consumed.  If you have a process that parses each as it arrives, adding to a list of multiple header fields are encountered, that will work fine.\r\n\r\nOn the other hand, isn't it possible to join multiple values with a comma and then parse?  This would have the effect of prohibiting that style of API.",
          "createdAt": "2018-08-17T06:34:45Z",
          "updatedAt": "2018-08-17T06:34:45Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "You'd just discard the erroneous value, provided you could delimit it from those following. Hmm.",
          "createdAt": "2018-08-19T06:20:18Z",
          "updatedAt": "2018-08-19T06:20:18Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "If there's a 7230-compatible (but not SH-compatible) thing in the middle, it could concatenate them naively.  Which means the burden has to be on the final recipient.  No matter what, I can't think of a particularly graceful way to deal with something like this:\r\n\r\n~~~\r\nmy-list-header: \"hop1\"\r\nmy-list-header: \"buggy-hop\r\nmy-list-header: \"hop3\"\r\n~~~",
          "createdAt": "2018-08-20T03:34:03Z",
          "updatedAt": "2018-08-20T03:34:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I wonder if it's worth specifying that for list headers, each individual header field MUST contain one or more valid values; if not, it's discarded rather than raising an error.\r\n\r\nThe problem is that even then, you could get in situations where the missing information is important. \r\n\r\nThe motivation for this was the `CDN-Loop` header. I'm not sure it's a particularly good example for SH...",
          "createdAt": "2018-10-08T07:53:41Z",
          "updatedAt": "2018-10-08T07:53:41Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Bangkok. Seemed to be agreement that there's not much we can do here beyond documenting the issue.",
          "createdAt": "2018-11-11T03:05:08Z",
          "updatedAt": "2018-11-11T03:05:08Z"
        }
      ]
    },
    {
      "number": 685,
      "id": "MDU6SXNzdWUzNTE4ODExMjY=",
      "title": "Date type",
      "url": "https://github.com/httpwg/http-extensions/issues/685",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "It would get some use, if we could figure out how to back port.",
      "createdAt": "2018-08-19T07:25:55Z",
      "updatedAt": "2018-11-12T06:02:57Z",
      "closedAt": "2018-11-12T06:02:57Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The main issue would be reliably recognising the date in text. If it starts with one of `MTWFS` (uppercase) that would work, but it would preclude expanding identifiers to start with any of these uppercase letters. ",
          "createdAt": "2018-10-08T07:33:57Z",
          "updatedAt": "2018-10-08T07:33:57Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "If you want to make back-porting easiest, that would mean accepting RFC850 and `ctime()` formats \\[[*](https://tools.ietf.org/html/rfc7231#section-7.1.1.1)\\].  Then it would be trivial to say that `Date` and `If-Modified-Since` and the rest are \"structured headers whose value is a Date\".\r\n\r\nA middle ground would be to deny the legacy formats -- only allow IMF-fixdate with a single 'GMT' zone -- which for the most part is real-world-compatible but goes against an RFC7231 MUST.\r\n\r\nBut if you're making a new syntax like that, you might as well go all in and wrap it in `[]` or something.\r\n\r\nIn either case, I think it's an interesting idea, especially if it can be sorted out before something like HTTP-QUIC really solidifies where there's an opportunity to encode dates more efficiently.",
          "createdAt": "2018-10-14T04:03:37Z",
          "updatedAt": "2018-10-14T04:03:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thing is, if it's new syntax, it can just be specified as an integer number of seconds delta from a/the epoch. ",
          "createdAt": "2018-10-23T01:32:47Z",
          "updatedAt": "2018-10-23T01:32:47Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Using integer seconds makes me very wary about introducing/encouraging new things that will encounter Y2038 protocols, especially in wire protocols.  (Yes, we can be clear that implementations must be 64-bit but it still seems like it could encourage more implementations to use signed 32-bit integers.)",
          "createdAt": "2018-11-08T03:06:51Z",
          "updatedAt": "2018-11-08T03:06:51Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From the httpbis chat, Jonathan Lennox also points out:\r\n\r\n\"The problem with seconds-since-the-epoch is you run into leap second issues. ISO 8601 might be better?\"",
          "createdAt": "2018-11-08T03:12:59Z",
          "updatedAt": "2018-11-08T03:12:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@enygren we're not specifically defining how to serialise a date in SH here, I think we just want to convince ourselves that we don't need a dedicated Date type.\r\n\r\nHaving said that -- integers in SH are required to be 64-bit already. WRT leap seconds, I strongly suspect that it's an issue with existing implementations for things like freshness calculation anyway. WDYT?",
          "createdAt": "2018-11-11T03:18:59Z",
          "updatedAt": "2018-11-11T03:18:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing with no action, per discussion in Bangkok. If you have new information / disagree, please ask for reopening.",
          "createdAt": "2018-11-12T06:02:57Z",
          "updatedAt": "2018-11-12T06:02:57Z"
        }
      ]
    },
    {
      "number": 686,
      "id": "MDU6SXNzdWUzNTIwMDYxNTQ=",
      "title": "Point out blank header special case in an example",
      "url": "https://github.com/httpwg/http-extensions/issues/686",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "We should point out that if there are multiple headers of the same name, any blank header among them will be ignored.\r\n\r\nI should really add some API tests for this as well as I kinda doubt this is how they work...",
      "createdAt": "2018-08-20T06:51:33Z",
      "updatedAt": "2018-10-23T05:03:31Z",
      "closedAt": "2018-10-23T04:58:11Z",
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I now actually think there may be an issue here.\r\n```\r\nSH: \"start\r\nSH: \r\nSH: end\"\r\n```\r\nneeds to become `SH: \"start, , end\"` and then parsing should start. If empty/whitespace values were to be removed when combining you'd end up with different strings due to ignorant intermediaries. That doesn't seem acceptable.\r\n\r\nhttps://github.com/httpwg/http-core/issues/148 has some on this as well.",
          "createdAt": "2018-10-16T09:03:35Z",
          "updatedAt": "2018-10-16T09:03:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I suspect what we'll need to say is that splitting values across headers will lead to unpredictable results, depending on who combines them where.\r\n\r\nProbably in 4.2. Parsing HTTP/1 Header Fields into Structured Headers.",
          "createdAt": "2018-10-23T04:51:19Z",
          "updatedAt": "2018-10-23T04:51:19Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Yeah, that seems fine, though for browsers I'd want to specifically mandate combining (without omitting empties) before parsing. I guess Fetch would have to define that then.",
          "createdAt": "2018-10-23T05:03:30Z",
          "updatedAt": "2018-10-23T05:03:30Z"
        }
      ]
    },
    {
      "number": 687,
      "id": "MDU6SXNzdWUzNTIwNTE2NTQ=",
      "title": "Early Hints's relationship to CSP",
      "url": "https://github.com/httpwg/http-extensions/issues/687",
      "state": "OPEN",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "early-hints"
      ],
      "body": "See https://github.com/w3c/preload/issues/114.\r\n\r\nIt seems like Early Hints could potentially violate policies. Or perhaps 1xx responses need to be recommended to also include CSP policies?",
      "createdAt": "2018-08-20T09:23:18Z",
      "updatedAt": "2018-10-18T07:11:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Would you mind elaborating on how it could violate a policy?\r\n\r\n103 only allows speculative evaluation of the header fields, meaning that a client must not apply the header field found in the 103 response in a way that it affects how the final response is processed.\r\n\r\nConsidering that, I would argue that it would be a bug of a client if a header field of a 103 response causes a policy violation.\r\n\r\nOr are you arguing about a case where that approach makes the header fields of 103 response unapplicable in practice?",
          "createdAt": "2018-08-20T10:01:22Z",
          "updatedAt": "2018-08-20T10:01:22Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Early Hints allows bypassing the policy stated in the final response. I think that's a problem of sorts.",
          "createdAt": "2018-08-20T10:15:27Z",
          "updatedAt": "2018-08-20T10:15:27Z"
        },
        {
          "author": "bazzadp",
          "authorAssociation": "NONE",
          "body": "Is the concern than the early hint includes a different policy (or no policy at all)?\r\n\r\nOr is the concern that a hint could include a resource that would be blocked by the final policy?\r\n\r\nFor the latter the resource could potentially be downloaded but then not be used if the ultimate policy blocks it. So this shouldn\u2019t cause an XSS is ur but may cause a privacy issue and/or information leakage (e.g. a blocked image is downloaded when it shouldn\u2019t be, or a resource is downloaded over insecure http despite the ultimate presence of upgrade-insecure-requests).\r\n\r\nHowever since both the Early Hint and the CSP are served by the same server, and any attacker with access to change either has complete control, I\u2019m not sure how much of a problem this really is?",
          "createdAt": "2018-08-20T10:34:03Z",
          "updatedAt": "2018-08-20T10:34:03Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Both are a concern. And in complex setups not all aspects of the server are administered by the same person, so this kind of mismatch can result in issues.",
          "createdAt": "2018-08-20T10:44:22Z",
          "updatedAt": "2018-08-20T10:44:22Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "(It's not clear if an Early Hint can include a policy btw, that's not defined. Perhaps I should raise a new issue for that?)",
          "createdAt": "2018-08-20T10:44:51Z",
          "updatedAt": "2018-08-20T10:44:51Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@annevk Thank you for your comments. Could you please check if my understanding (stated below) is correct?\r\n\r\nWhen evaluating a link rel=preload header, the browser blocks the preload depending on the value of the \"as\" attribute. For example, loading of a image specified by the link header field is blocked, if the URL being contained is not allowed by the img-src property of the CSP header field.\r\n\r\nBy reading https://github.com/w3c/preload/issues/37, I think that that is the expected behavior of preload.\r\n\r\nAssuming that the above is correct, I agree with you that the specs should be interpreted that they ban fetching certain types of resources until the CSP value gets fixed in the final response. Such types includes images and fonts (the spec talks about blocking \"loads\"). OTOH, the rule does not apply to scripts or stylesheets, because CSP deals about \"executing\" or \"applying\" them.\r\n\r\nHaving said that, based on my understanding about CSP (stated above), I wonder preload referring to CSP has any value in terms of security (even though I think that it is a good optimization), because a server can always lie the value of the \"as\" attribute. For example, a server could send a link rel=preload header with as=style to initiate a load of a \".jpg\" file, even in case CSP is set to \"img-src=none\".\r\n\r\nTo summarize, I would argue that the specs do not prevent us from fetching scripts or stylesheets designated by link rel=preload headers in a 103 response. I also argue that there is no need to block fetching other types of resources found in the 103 response.",
          "createdAt": "2018-08-20T23:41:51Z",
          "updatedAt": "2018-08-21T05:44:23Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "CSP governs all fetches. So a policy that disables all cross-origin fetches could be circumvented if CSP is not applied.",
          "createdAt": "2018-08-21T06:41:22Z",
          "updatedAt": "2018-08-21T06:41:22Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@annevk My read of https://www.w3.org/TR/CSP3/ is that CSP \"controls the resources which a particular page can fetch **or** execute\" (emphasis mine), and that scripts and stylesheets are allowed to be fetched, regardless of the value of the CSP header field.\r\n\r\nAre you suggesting that I am interpreting the text incorrectly (it could be), or that browsers do not implement that way?\r\n\r\nOr do you agree with the interpretation that scripts and stylesheets can be speculatively fetched regardless of the value of the CSP, but consider fetching other resources by observing the value of the link rel=preload headers without consulting CSP a security concern?",
          "createdAt": "2018-08-21T07:33:54Z",
          "updatedAt": "2018-08-21T07:36:38Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "It controls both fetching and execution, but that doesn't mean it doesn't control the fetching of scripts (it does).",
          "createdAt": "2018-08-21T07:42:56Z",
          "updatedAt": "2018-08-21T07:42:56Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@annevk Thank you for the answer. So CSP as a spec disallows fetching scripts or stylesheets.\r\n\r\nThen, the issue seems to be in the hands of preload spec; I might suggest bypassing CSP rules when processing link rel=preload headers when processing a 103 response for the following reasons:\r\n* CSP rules are applied when the browser sees a tag that loads the resources; link preloads can be considered a way to speculatively start fetching them\r\n* considering the fact that the CSP header field and the link rel=preload header field are sent by the same entity, I do not think that there would be a security concern if the client starts fetching the resources designated by the link header prior tor receiving the CSP settings.",
          "createdAt": "2018-08-21T22:06:34Z",
          "updatedAt": "2018-08-21T22:06:34Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "To quibble, CSP rules are applied whenever the browser fetches something in the context of a web page. I'd argue that includes 103, especially when we get origin-wide CSP policies.\r\n\r\nIt's a security concern in that a server operator now needs to be aware that CSP can be circumvented. So they would need to monitor all 103 responses somehow.",
          "createdAt": "2018-08-22T07:18:05Z",
          "updatedAt": "2018-08-22T07:18:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Anne, if a 103 response had both a `preload` Link header and a `Content-Security-Policy` header, would you think that workable?",
          "createdAt": "2018-10-18T00:12:25Z",
          "updatedAt": "2018-10-18T00:12:25Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Yeah, the problem still remains that server operators have to be aware of it. If one team deploys 103 without telling the security team, ... Anyway, that's what I suggested in OP and I still think that'd be acceptable.\r\n\r\nOrigin Manifest/Policy would make this less of a problem, but that doesn't seem to be happening anytime soon.",
          "createdAt": "2018-10-18T07:11:54Z",
          "updatedAt": "2018-10-18T07:11:54Z"
        }
      ]
    },
    {
      "number": 688,
      "id": "MDU6SXNzdWUzNTIzNjQxOTQ=",
      "title": "[SH] algorithm to parse boolean doesn't consume 'T' or 'F' character",
      "url": "https://github.com/httpwg/http-extensions/issues/688",
      "state": "CLOSED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-08-21T02:41:54Z",
      "updatedAt": "2018-08-21T02:50:23Z",
      "closedAt": "2018-08-21T02:50:23Z",
      "comments": []
    },
    {
      "number": 691,
      "id": "MDU6SXNzdWUzNTMxOTkzMjE=",
      "title": "Refer to HTTP method registry",
      "url": "https://github.com/httpwg/http-extensions/issues/691",
      "state": "CLOSED",
      "author": "DanilSuits",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "The HTTP Methods section (4.5) requires that an application use registered http methods.  The HTTP Method Registry, defined by [RFC 7231](https://tools.ietf.org/html/rfc7231#section-8.1), is not mentioned as a source for candidate methods.\r\n\r\nThe second paragraph of the section includes the following text \r\n> they are required to be registered with IETF Review \r\n\r\nwhich I had expected to see linked to RFC 7231; but the actual link in the text is to RFC 7232.\r\n\r\nI suspect this is a spelling error.",
      "createdAt": "2018-08-23T02:41:38Z",
      "updatedAt": "2018-10-08T08:02:38Z",
      "closedAt": "2018-10-08T08:02:31Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2018-10-08T08:02:37Z",
          "updatedAt": "2018-10-08T08:02:37Z"
        }
      ]
    },
    {
      "number": 692,
      "id": "MDU6SXNzdWUzNTM3MzM3OTU=",
      "title": "Picking up Linked Cache Invalidation",
      "url": "https://github.com/httpwg/http-extensions/issues/692",
      "state": "CLOSED",
      "author": "evert",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi everyone,\r\n\r\nI have an interest in this draft:\r\n\r\nhttps://tools.ietf.org/html/draft-nottingham-linked-cache-inv-04\r\n\r\nUnfortunately it seems abandoned. Is there something I might be able to do to revive this? I think it's still a very useful specification. I'm happy to put the work in to revive in, but I'm not entirely sure how to go about this.",
      "createdAt": "2018-08-24T10:42:58Z",
      "updatedAt": "2018-08-25T12:36:38Z",
      "closedAt": "2018-08-25T01:58:57Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hi Evert. I'm planning on doing something similar, but starting a fresh spec, to integrate the current \"Cache-Tag\" / \"Surrogate-Key\" headers used by CDNs. Shouldn't be long.\r\n\r\nBTW - Best place to ask this sort of thing is on-list.",
          "createdAt": "2018-08-25T01:58:57Z",
          "updatedAt": "2018-08-25T01:58:57Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you, will ask on the list in the future",
          "createdAt": "2018-08-25T12:36:38Z",
          "updatedAt": "2018-08-25T12:36:38Z"
        }
      ]
    },
    {
      "number": 697,
      "id": "MDU6SXNzdWUzNjQ1MTI0MTY=",
      "title": "Purpose of the Content-DPR hint is not entirely clear.",
      "url": "https://github.com/httpwg/http-extensions/issues/697",
      "state": "CLOSED",
      "author": "malchata",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "I have personally had an especially difficult time tying the purpose and usefulness of the `Content-DPR` client hint to a specific use case, and I don't think I'm alone in this. While the spec at large is straightforward and reads well, I think `Content-DPR` could benefit from a concrete example of how it might be used by the client. Currently, the spec says the following of `Content-DPR` in [section 4](https://tools.ietf.org/html/draft-ietf-httpbis-client-hints-06#section-4):\r\n\r\n> The client can use this information to perform additional processing on the resource - for example, calculate the appropriate intrinsic size of the image resource such that it is displayed at the correct resolution.\r\n\r\nThis seems a bit vague to me. Does Chrome act on this response header a specific way? Are implementing browsers _expected_ to? And what's a specific example where that may be the case? Does any suboptimal behavior result when DPR is _not_ confirmed with `Content-DPR`, and if so, what instances?",
      "createdAt": "2018-09-27T14:45:02Z",
      "updatedAt": "2019-05-18T15:05:53Z",
      "closedAt": "2019-05-18T15:05:53Z",
      "comments": [
        {
          "author": "eeeps",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll add one concrete example of un-clear-ness \u2013 my employer, Cloudinary, implemented (and still implements) `Content-DPR` incorrectly. We echo back the `DPR` on the request, no matter how the width of the returned resource matches up with the requested `Width` and `DPR`. The example in section 4 could use some fleshing-out!\r\n\r\nJeremey\u2019s questions are all about describing how `Content-DPR` is actually used on the front end \u2013 I'll add that I think there should be more about how the server in the example calculated the `Content-DPR: 1` that it sends back. I assume that the resource it responded with had a width of 160 pixels? That should be added to the example, along with a general formula that:\r\n\r\n`Content-DPR` should = response resource width, in pixels \u00f7 ( request `Width` \u00f7 request `DPR` )\r\n\r\nRelated question that the spec may be able to shed some light on\u00a0\u2013 what should servers do, if they don't have both a `Width` and a `DPR`?",
          "createdAt": "2018-09-27T14:48:16Z",
          "updatedAt": "2018-09-27T15:03:04Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we'd have a hard time explaining the purpose of Content-DPR as part of an IETF draft that's fairly removed from the concepts that govern its impact: The density of the impacted images which then take part in the calculation of their density-corrected intrinsic dimensions. That one more reason why we might be better off defining the image specific bits closer to Fetch and HTML.\r\n\r\n> Does Chrome act on this response header a specific way?\r\n\r\nVery much like requesting an image using a srcset `x` descriptor, `Content-DPR` will mean that the image's intrinsic dimensions are being corrected by the `Content-DPR` value. E.g. sending down a 200x200 image with `Content-DPR: 2` and no other layout information, would mean the image is laid out ass a 100x100 image.\r\n\r\n> Does any suboptimal behavior result when DPR is _not_ confirmed with `Content-DPR`, and if so, what instances?\r\n\r\nYeah, the wrong density corrected intrinsic dimensions. In order to notice that, you'd need your images layout to not be constrained by other means (e.g. CSS).\r\n\r\n> what should servers do, if they don't have both a `Width` and a `DPR`?\r\n\r\nThat depends on the server. Servers should restrict the image dimensions to `Viewport-Width` as images are typically not wider than that, but lacking more specific width information, it's tricky to restrict the images further.",
          "createdAt": "2018-12-24T13:58:28Z",
          "updatedAt": "2018-12-24T13:58:28Z"
        },
        {
          "author": "malchata",
          "authorAssociation": "NONE",
          "body": "> I think we'd have a hard time explaining the purpose of Content-DPR as part of an IETF draft that's fairly removed from the concepts that govern its impact: The density of the impacted images which then take part in the calculation of their density-corrected intrinsic dimensions.\r\n\r\nI think it's possible to use language which talks about potential outcomes of failing to adhere to the specification. For nascent or underdocumented technologies, it's not uncommon for developers to seek out specs to understand how they work.\r\n\r\nI claim ignorance of the nuanced interactions between specifications and implementations. Yet, I can't see how improving clarity around this in the specification itself could be bad for developers _or_ implementors. In a spec that clearly and superbly explains the vast majority of concepts and behaviors surrounding client hints, I personally felt this (and the issue raised in #698) lacked clarity in authoritative sources. While I understand now how `Content-DPR` works (as well as the concepts referenced in #698), the knowledge was hard-won in my initial research.\r\n\r\nThat said, if it makes sense to define this behavior elsewhere, I'm supportive. Feel free to tag me in any related issue(s).",
          "createdAt": "2018-12-24T17:19:30Z",
          "updatedAt": "2018-12-24T17:19:30Z"
        },
        {
          "author": "eeeps",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@yoavweiss are you hoping to move all of the individual Hint definitions to other specs, so that the central CH spec doesn't define (or even mention?) them (except perhaps as examples? and/or within a simple registry?)",
          "createdAt": "2018-12-27T21:26:50Z",
          "updatedAt": "2018-12-27T21:26:50Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, that's the intent.",
          "createdAt": "2019-01-15T16:17:43Z",
          "updatedAt": "2019-01-15T16:17:43Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Content-DPR is now living in the Fetch spec, closing.\r\n\r\nRef: https://github.com/yoavweiss/client-hints-infrastructure/blob/master/specification_situation.md",
          "createdAt": "2019-05-18T15:05:53Z",
          "updatedAt": "2019-05-18T15:05:53Z"
        }
      ]
    },
    {
      "number": 698,
      "id": "MDU6SXNzdWUzNjQ1MjI4ODE=",
      "title": "Relationship between `sizes` and `Width` could be explained",
      "url": "https://github.com/httpwg/http-extensions/issues/698",
      "state": "CLOSED",
      "author": "eeeps",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "`sizes` isn\u2019t mentioned in the spec, and many people dealing in Client Hints from within HTML do not know that it is required in order for clients to send a `Width` hint.\r\n\r\nI've seen a lot of [confusion](https://github.com/ojanvafai/intrinsicsize-attribute/issues/7#issuecomment-416764898) about the relationship between the two elements. Is there value to keeping it vague?",
      "createdAt": "2018-09-27T15:08:07Z",
      "updatedAt": "2019-05-18T15:06:29Z",
      "closedAt": "2019-05-18T15:06:28Z",
      "comments": [
        {
          "author": "malchata",
          "authorAssociation": "NONE",
          "body": "FWIW, I plan to cover this in a client hints piece for Google Web Fundamentals, but having this in the spec would be a valuable piece of information that I believe would reduce confusion as to how the `Width` hint gets sent to the server.",
          "createdAt": "2018-09-27T15:10:17Z",
          "updatedAt": "2018-09-27T15:23:14Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Similarly to #697, this may be better explained closer to HTML and Fetch.",
          "createdAt": "2018-12-24T14:00:51Z",
          "updatedAt": "2018-12-24T14:00:51Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Closing, this logic has been moved to HTML+Fetch.\r\n\r\nRef: https://github.com/yoavweiss/client-hints-infrastructure/blob/master/specification_situation.md",
          "createdAt": "2019-05-18T15:06:28Z",
          "updatedAt": "2019-05-18T15:06:28Z"
        }
      ]
    },
    {
      "number": 699,
      "id": "MDU6SXNzdWUzNjQ5NTk2MzY=",
      "title": "CH deletion wording",
      "url": "https://github.com/httpwg/http-extensions/issues/699",
      "state": "CLOSED",
      "author": "thiemonagel",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "> Implementers [...] MUST clear persisted opt-in preferences when site data, browsing history, browsing cache, or similar, are cleared.\r\n\r\n@igrigorik I think that sentence can be read in two ways: \"opt-ins must be deleted whenever any of [site data, browsing history, browsing cache, or similar] are cleared\" or \"there must be at least one out of [site data, browsing history, browsing cache, or similar] whose deletion also triggers the deletion of CH opt-ins\". Could you please clarify?\r\n",
      "createdAt": "2018-09-28T16:30:51Z",
      "updatedAt": "2018-10-02T08:14:08Z",
      "closedAt": "2018-10-02T08:14:08Z",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> when any one of site data, browsing...\r\n\r\nWould that do the trick? ",
          "createdAt": "2018-09-29T21:12:27Z",
          "updatedAt": "2018-09-29T21:12:27Z"
        },
        {
          "author": "thiemonagel",
          "authorAssociation": "NONE",
          "body": "In my opinion, yes. Thank you!",
          "createdAt": "2018-10-01T09:02:53Z",
          "updatedAt": "2018-10-01T09:02:53Z"
        }
      ]
    },
    {
      "number": 700,
      "id": "MDU6SXNzdWUzNjUxNzIwODM=",
      "title": "Clarify behavior for multiple values for CH headers",
      "url": "https://github.com/httpwg/http-extensions/issues/700",
      "state": "CLOSED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [
        "igrigorik"
      ],
      "labels": [
        "client-hints"
      ],
      "body": "Migrating [feedback from Kari Hurtta](https://lists.w3.org/Archives/Public/ietf-http-wg/2018JulSep/0137.html).. \r\n\r\n> On Wed, Jul 25, 2018 at 9:14 AM HTTP Working Group <ietf-http-wg@w3.org>\r\n> wrote:\r\n> \r\n> > |   If DPR occurs in a message more than once, the last value overrides\r\n> > |   all previous occurrences.\r\n> \r\n> So is that saying that if there is several DPR values on\r\n> > DPR Header Field, last value is used ?\r\n> >\r\n> \r\n> Yes, that's the intent.\r\n> \r\n> If that in interpreted only that if last DPR header field is used,\r\n> > and header field is ignored if it does not fit\r\n> >\r\n> >    DPR = 1*DIGIT [ \".\" 1*DIGIT ]\r\n> >\r\n> > syntax, result is different is recipient combines multiple\r\n> > DPR headers.\r\n> \r\n> \r\n> The intent was to specify that last valid value (regardless if it is within\r\n> a combined or separate header) is the one that should be used by the\r\n> client. My read of the current wording is that it matches this intent, but\r\n> I'll defer to the experts here on how to best word this if that's not the\r\n> case.\r\n> \r\n> Mark, Julian: any guidance on this one?\r\n> \r\n> \r\n> > |   If <X> occurs in a message more than once, the last value\r\n> > |   overrides all previous occurrences.\r\n> >\r\n> > So it should mention that on these header fields also last value\r\n> > is used when values are ',' -separated.\r\n> >\r\n> \r\n> My understanding is that this is implicit, but if that's not the case,\r\n> happy to rework the wording.\r\n\r\n--- \r\n\r\nJulian:\r\n> No, it's not implicit, so yes, a clarification would be good. I don't think we have good text yet.",
      "createdAt": "2018-09-29T22:28:31Z",
      "updatedAt": "2019-07-25T14:32:50Z",
      "closedAt": "2019-07-25T14:32:50Z",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@reschke @mnot per https://github.com/httpwg/http-core/issues/111#issuecomment-422822770, how about...\r\n\r\n> The \u201cDPR\u201d request header field is a number that indicates the client\u2019s current Device Pixel Ratio (DPR), which is the ratio of physical pixels over CSS px (Section 5.2 of [CSSVAL]) of the layout viewport (Section 9.1.1 of [CSS2]) on the device.\r\n>\r\n>>  DPR = 1*DIGIT [ \".\" 1*DIGIT ]\r\n>\r\n> **The last valid value of the aggregated DPR field value overrides all previous occurrences.**\r\n\r\nDoes that make sense? Would appreciate your guidance on this one :)\r\n\r\n",
          "createdAt": "2018-09-29T22:29:15Z",
          "updatedAt": "2018-09-29T22:29:15Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'm starting to wonder if Client Hints should adopt Structured Headers to avoid having to deal with these sorts of questions. Ilya, WDYT?",
          "createdAt": "2018-10-01T06:42:33Z",
          "updatedAt": "2018-10-01T06:42:33Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@mnot that would hit a major reset on all existing CH implementations and set us back another couple years, I don't think this is the right call for CH. /cc @yoavweiss \r\n\r\nSurely CH is not the first instance where we had to spell out behavior for selecting one out of N header values? That said, if we don't have established verbiage for this, I'm happy to just make up some language ourselves to clarify how it should behave.. what we're aiming for ain't rocket science. :)",
          "createdAt": "2018-10-02T08:12:03Z",
          "updatedAt": "2018-10-02T08:12:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I wouldn't want to set CH back that much (although it is lingering on :). \r\n\r\nI only mention it because all of the defined syntax seems like it would easily fit into SH, and Chrome already has a good start on a SH parser, thanks to @jyasskin's work on signed exchanges, etc.",
          "createdAt": "2018-10-02T08:17:09Z",
          "updatedAt": "2018-10-02T08:17:09Z"
        },
        {
          "author": "colinbendell",
          "authorAssociation": "NONE",
          "body": "As an aside, the same clarification should also apply to `content-dpr` response headers. Currently Chrome treats multiple `content-dpr` responses headers as an error and ignores both. ",
          "createdAt": "2018-10-04T18:59:31Z",
          "updatedAt": "2018-10-04T18:59:31Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@mnot my preference is to get this over the finish line without introducing dependency on SH. For one, we're also relying on Feature-Policy for delegation and we decided against SH there.\r\n\r\nWDYT of suggested text in https://github.com/httpwg/http-extensions/issues/700#issuecomment-425679600 \u2014 warmer?\r\n\r\n@colinbendell ack.",
          "createdAt": "2018-10-05T02:43:01Z",
          "updatedAt": "2018-10-05T02:43:01Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@igrigorik I hear you. My thinking is:\r\n\r\n* We've already waited a good while for CH, and it's not clear that it's really really done yet (I suspect we have at least one more round of doc review).\r\n\r\n* People are already using CH as a framework for new hints, so getting SH in would be best now if it's going to get in.\r\n\r\n* If CH are going to be commonly sent, having well-defined parsing behaviour and the possibility of better serialisations (which SH gives us) is very attractive.\r\n\r\nTo be clear -- this is me as me, not me as chair.",
          "createdAt": "2018-10-05T03:02:01Z",
          "updatedAt": "2018-10-05T03:02:01Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot - could you clarify what you mean by CH adopting SH?\r\n\r\nDo you mean that the `DPR`/`Content-DPR` headers would be defined as `sh-item`/`sh-flat`? Or that they'd be define as `sh-list` with extended processing model (which guarantees that the last item in the list \"wins\")? Or something else altogether? ",
          "createdAt": "2018-10-07T16:08:49Z",
          "updatedAt": "2018-10-07T16:08:49Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Both `DPR` and `Content-DPR` could be `sh-float`s.\r\n\r\n`Accept-CH` would be a `sh-list` of `sh-identifier`s. \r\n\r\nBoth `Width` and `Viewport-Width` would be `sh-integer`s.\r\n\r\n`Accept-CH-Lifetime` would be a `sh-integer`. I'm not really sure why its current ABNF is a list. @igrigorik?\r\n\r\nConsidering that parsing and serialisation algorithms for these haven't been defined yet at all, I don't think it would take a lot of work (and would be happy to do a PR).",
          "createdAt": "2018-10-08T08:12:49Z",
          "updatedAt": "2018-10-08T08:13:31Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> Accept-CH-Lifetime would be a sh-integer. I'm not really sure why its current ABNF is a list. \r\n\r\nGood catch, I think that's an oversight and we can fix that.\r\n\r\n---\r\n\r\nStepping back, my preference is (still) to proceed at this stage without introducing dependency on SH. First off, introducing SH does not address the issue we're actually trying to solve in this bug. Second, it adds another significant dependency to CH adoption that I would like to avoid at this stage, as it's yet another reason for a browser vendor to drag their feet and delay integrating support for SH. \r\n\r\nTo get CH over the last call barrier, I believe we have two outstanding tasks:\r\n\r\n1. Clarify Accept-CH-Lifetime definition, per above.\r\n1. Provide some minimum guidance on how to deal with aggregated values \u2014 see https://github.com/httpwg/http-extensions/issues/700#issuecomment-425679600.\r\n\r\nI don't think we'll land on perfect text for (2), but this is *not* a unique or new gap vs other and existing specs, and I don't think we should block on this. \r\n\r\n@mnot does this sound reasonable? ",
          "createdAt": "2018-10-10T18:29:08Z",
          "updatedAt": "2018-10-10T18:29:08Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "*friendly bump* :-)\r\n\r\n@mnot @reschke PTAL, any thoughts or guidance on the above text?\r\n\r\n",
          "createdAt": "2018-10-17T20:07:29Z",
          "updatedAt": "2018-10-17T20:07:29Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> The last valid value of the aggregated DPR field value overrides all previous occurrences.\r\n\r\nThe issue is that it's defined to only have one value. I think you'd need to say something like:\r\n\r\n> if more than one DPR header field is present (either because multiple header instances exist, or because they've been folded into comma-separated values)...\r\n\r\nOr, to *really* define it, define an algorithm.",
          "createdAt": "2018-11-03T03:09:58Z",
          "updatedAt": "2018-11-03T03:09:58Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was discussed at the HTTPWG meeting today and it was decided to go ahead with Structured Headers!",
          "createdAt": "2019-07-22T22:32:03Z",
          "updatedAt": "2019-07-22T22:32:03Z"
        }
      ]
    },
    {
      "number": 701,
      "id": "MDU6SXNzdWUzNjY5MTkwNTg=",
      "title": "Consider adding Downlink-Max as a client hint header?",
      "url": "https://github.com/httpwg/http-extensions/issues/701",
      "state": "CLOSED",
      "author": "malchata",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Pretty much all of what's available in [netinfo](https://wicg.github.io/netinfo/) has been brought into client hints, _except_ for the `downlinkMax` attribute. Is this a reason this hasn't occurred? Is it targeted for eventual removal in netinfo? If not, it may be worth bringing this hint into client hints as `Downlink-Max` so we can determine on the server side what the fastest recorded downlink speed is for that page load cycle.",
      "createdAt": "2018-10-04T18:39:58Z",
      "updatedAt": "2018-10-18T06:39:26Z",
      "closedAt": "2018-10-18T06:39:26Z",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is there a particular use case you have in mind that `downlinkMax` would solve and `downlink` cannot?\r\n\r\n\r\n\r\n> Is it targeted from eventual removal in netinfo?\r\n\r\nI don't think we discussed it much, but I'm not sure it has any use-cases that it enables, now that `downlink` is around (`downlinkMax` predated the more recent `downlink`, `rtt` and `ect`). In that light, seems like removal can be reasonable and reduce confusion.",
          "createdAt": "2018-10-08T12:26:34Z",
          "updatedAt": "2018-10-08T12:26:34Z"
        },
        {
          "author": "malchata",
          "authorAssociation": "NONE",
          "body": "> `downlinkMax` predated the more recent `downlink`, `rtt` and `ect`\r\n\r\nGood to have that context. Thanks!\r\n\r\nThe only case I can make for `downlinkMax` might be that it would be useful for knowing when downstream conditions improve for the client. Such as a client starts off with a low downstream speed on the navigation request, but subsequent resource requests show an improvement in `downlink` values. But in all honesty, if pressed to defend `downlinkMax` (or `Downlink-Max` as I've suggested here), applications can track `downlink` values across all resource requests and figure that out on their own.\r\n\r\nA better title for this issue might be \"Consider making network-related client hints congruent with netinfo\", since congruency between the two would reduce confusion and allow spec readers to readily see a 1:1 relationship between hints available in netinfo and network hints available in CH.",
          "createdAt": "2018-10-08T12:54:59Z",
          "updatedAt": "2018-10-08T16:45:12Z"
        },
        {
          "author": "tarunban",
          "authorAssociation": "NONE",
          "body": "I remember there were even discussions around removing `downlinkMax`. It's also not supported on any of the desktop platforms.",
          "createdAt": "2018-10-08T16:43:45Z",
          "updatedAt": "2018-10-08T16:43:45Z"
        },
        {
          "author": "malchata",
          "authorAssociation": "NONE",
          "body": "Can you clarify what you mean by that, @tarunban? I can access `navigator.connection.downlinkMax` in my desktop version of Chrome on High Sierra (though it populates with `Infinity`).",
          "createdAt": "2018-10-08T16:46:28Z",
          "updatedAt": "2018-10-08T16:46:28Z"
        },
        {
          "author": "tarunban",
          "authorAssociation": "NONE",
          "body": "Yeah, that's what I meant. On desktop platforms, it returns `Infinity` in all cases (regardless of actual capacity of the last hop WiFi or ethernet connection).",
          "createdAt": "2018-10-08T17:10:14Z",
          "updatedAt": "2018-10-08T17:10:47Z"
        },
        {
          "author": "malchata",
          "authorAssociation": "NONE",
          "body": "Thanks for clarifying, @tarunban! I had wondered why that was the case (and now I know).",
          "createdAt": "2018-10-08T17:11:24Z",
          "updatedAt": "2018-10-08T17:11:24Z"
        },
        {
          "author": "tarunban",
          "authorAssociation": "NONE",
          "body": "The relevant code is here: https://cs.chromium.org/chromium/src/content/child/runtime_features.cc?rcl=01bde77cb05eaab1ce10ec5dbf797fca2d2c333c&l=76\r\n\r\nI believe part of the reasoning is that there were (are?) not enough APIs exposed by operating systems (Windows, Mac OS etc.) for the Chrome to determine the capacity of the last hop.",
          "createdAt": "2018-10-08T17:15:05Z",
          "updatedAt": "2018-10-08T17:15:05Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "As a brief aside.. Can we move this discussion to https://github.com/WICG/netinfo/issues? If we want to define the header, we should be doing so in NetInfo spec, same as others.",
          "createdAt": "2018-10-17T20:09:40Z",
          "updatedAt": "2018-10-17T20:09:40Z"
        },
        {
          "author": "malchata",
          "authorAssociation": "NONE",
          "body": "Got it, @igrigorik! I'm still figuring out how the different parts of CH are structured and didn't think to put it there. Feel free to close this if you want.",
          "createdAt": "2018-10-17T20:12:29Z",
          "updatedAt": "2018-10-17T20:12:29Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "sg, closing, let's continue this on netinfo repo.",
          "createdAt": "2018-10-18T06:39:26Z",
          "updatedAt": "2018-10-18T06:39:26Z"
        }
      ]
    },
    {
      "number": 702,
      "id": "MDU6SXNzdWUzNjc2NjYwMDk=",
      "title": "Identifier range",
      "url": "https://github.com/httpwg/http-extensions/issues/702",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Looking through existing headers, it seems like it would be good to consider expanding the range of characters allowable in identifiers. \r\n\r\n- [x] `.` -- gives us hostnames like in `Origin` and `Host`\r\n- [x] `:` -- gives us host:port structures like in `Alt-Used` and `Access-Control-Allow-Origin`, as well as IPv6 addresses\r\n- [x] `%` -- gives us percent-encoded data like in `ALPN`\r\n- [ ] uppercase alpha -- gives us methods, like in `Access-Control-Request-Method`, `Access-Control-Allow-Methods`\r\n\r\nThe main constraint here is making it possible to reliably recognise identifiers. Currently they're denoted by a starting `lcapha`. It may be possible to expand that to include uppercase but continue to preclude other characters from the starting character without affecting too many use cases.\r\n",
      "createdAt": "2018-10-08T07:28:23Z",
      "updatedAt": "2018-11-27T09:15:11Z",
      "closedAt": "2018-11-27T09:15:11Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@annevk any other characters you can think of?\r\n\r\nI'm least excited about uppercase alpha here, as it would preclude things like #685.\r\n\r\n(to be clear: this is about what existing syntaxes we can accommodate in SH without modification; it's not critical we get them all, just want to get as many as possible).",
          "createdAt": "2018-10-08T07:55:48Z",
          "updatedAt": "2018-10-08T07:55:48Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Not immediately. I'm not sure if `Origin` or `Host` are as tightly restricted as we'd like. As registrars are not in control over subdomains there's a fair amount of weirdness that can be used there and is somewhat supported by browsers (including over HTTPS due to wildcards), but I haven't investigated in detail.",
          "createdAt": "2018-10-08T09:24:49Z",
          "updatedAt": "2018-10-08T09:24:49Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Sure, but the point here is to make sure that `identifier` can accommodate them, not exactly reflect their constraints. Unless we want to define a `hostname` datatype that exactly reflects the constraints of that structure.",
          "createdAt": "2018-10-08T22:20:13Z",
          "updatedAt": "2018-10-08T22:20:13Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "We might be talking past each other. The problem I have is that I'm not sure what the actual scope is. E.g., perhaps `+` or `!` are allowed at times, even though they really shouldn't be. (Similar to how `_` is grandfathered in for certificates of non-wildcard subdomains despite not being allowed by RFCs.)",
          "createdAt": "2018-10-09T08:54:41Z",
          "updatedAt": "2018-10-09T08:54:41Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Ah. Would be good to get some tests in, then.\r\n\r\nWorst case, if characters are precluded and then it turns out they're needed they can be encoded, but that seems suboptimal.",
          "createdAt": "2018-10-10T23:50:55Z",
          "updatedAt": "2018-10-10T23:50:55Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Bangkok. @martinthomson suggested that we split identifiers that can be values out, to keep the \"normal\" identifiers simple.",
          "createdAt": "2018-11-12T05:30:21Z",
          "updatedAt": "2018-11-12T05:30:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK, they're split out into `key` and `identifier` now, with `key` only to be used internally in SH.\r\n\r\nI'm going to add `.` `:` and `%` to `identifier`, since they seem to meet a number of use cases (see [here for details](https://github.com/httpwg/wiki/wiki/Structured-Header-Mappings)).\r\n\r\nMy first inclination is to keep the first character restricted to `lcalpha`, but I could probably be talked out of it -- we have a number of non-alphanumeric characters left for delimiting new types down the road, and I don't *think* we'll be adding tons more over time (he says...).\r\n\r\nThoughts? ",
          "createdAt": "2018-11-12T05:52:40Z",
          "updatedAt": "2018-11-12T05:52:40Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "(i.e., talked into allowing uppercase alpha and maybe numerics; not all of the special chars).",
          "createdAt": "2018-11-12T05:54:16Z",
          "updatedAt": "2018-11-12T05:54:16Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Also, it would be good if folks had a look at the restrictions on `key` to make sure they're happy. Since it's in a predictable location, we can do things like remove constraints on the first character if we want to.",
          "createdAt": "2018-11-12T05:56:03Z",
          "updatedAt": "2018-11-12T05:56:03Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Can we later change `identifier` if we identify more code points needed for hosts? (I filed an issue on testing that, as I wasn't easily able to do it myself and it's not really a priority for me relative to other things.)",
          "createdAt": "2018-11-12T08:43:30Z",
          "updatedAt": "2018-11-12T08:43:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@annevk nope; once it ships we can't really change it, because some implementations will fail on the characters you add.\r\n\r\nHowever, if you find that a header can't use identifier, you can always use string. If you're back porting to an existing header, you can define a second header that takes the string form and negotiate for it; this is the plan for existing HTTP headers that can't fit into SH.\r\n\r\nFor example, if `Foo` currently looks like:\r\n\r\n~~~\r\nFoo: 1this-is-not-an-identifier!\r\n~~~\r\n\r\nYou can define:\r\n\r\n~~~\r\nSH-Foo: \"1this-is-not-an-identifier!\"\r\n~~~\r\n\r\n... and then use a HTTP/2 SETTING to negotiate (hop-by-hop) for automagically doing the right thing WRT Foo and SH-Foo. I'm expecting to do this in a separate spec soon-ish.",
          "createdAt": "2018-11-12T22:40:18Z",
          "updatedAt": "2018-11-12T22:40:18Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Hmm okay, maybe it's not such a big problem anyway. I've started properly defining the existing headers with parsers and I haven't really run into any major issues thus far other than testing being time consuming.",
          "createdAt": "2018-11-13T08:30:12Z",
          "updatedAt": "2018-11-13T08:30:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks @annevk. If you find a solution to *that*, please tell us.",
          "createdAt": "2018-11-13T23:09:14Z",
          "updatedAt": "2018-11-13T23:09:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think the only remaining questions here are:\r\n\r\n0. Whether to allow uppercase in identifier as the first character\r\n1. Whether to allow uppercase in identifier *after* the first character\r\n\r\nMy inclination is yes on both at this point; but I'd be willing to be talked out of 0 especially.\r\n\r\n(yes, it consumes a lot of characters for identifying new types, but we still have a fair number of special characters left, and I don't think we'll be adding *that* many - famous last words ;)\r\n\r\nThoughts?",
          "createdAt": "2018-11-23T04:50:12Z",
          "updatedAt": "2018-11-23T04:50:12Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I think that's reasonable.",
          "createdAt": "2018-11-23T08:42:24Z",
          "updatedAt": "2018-11-23T08:42:24Z"
        }
      ]
    },
    {
      "number": 703,
      "id": "MDU6SXNzdWUzNjgwMjkzMjE=",
      "title": "Whitespace before Items",
      "url": "https://github.com/httpwg/http-extensions/issues/703",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Step 1 in the loop of \"Parsing a Parameterised Identifier from Text\" is `Discard any leading OWS from input_string.`\r\n\r\nThis effectively permits whitespace at the front of any item, even when `=` precedes it, which is not the intent.\r\n",
      "createdAt": "2018-10-09T03:43:12Z",
      "updatedAt": "2018-11-12T05:27:57Z",
      "closedAt": "2018-11-12T05:27:57Z",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "NONE",
          "body": "It looks 5f074ef disallows whitespace before `;`.\r\n\r\nStep 1 of \"Parsing an Item from Text\" should have been removed instead, I think.\r\n",
          "createdAt": "2018-10-30T09:13:58Z",
          "updatedAt": "2018-10-30T09:13:58Z"
        }
      ]
    },
    {
      "number": 706,
      "id": "MDU6SXNzdWUzNzI4NDExOTg=",
      "title": "better to Use Example Domain",
      "url": "https://github.com/httpwg/http-extensions/issues/706",
      "state": "CLOSED",
      "author": "Jxck",
      "authorAssociation": "NONE",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "> Consider the scenario in which a user reads their email at MegaCorp Inc's webmail provider https://example.com/. They might expect that clicking on an emailed link to https://projects.com/secret/project would show them the secret project that they're authorized to see, but if projects.com has marked their session cookies as SameSite, then this cross-site navigation won't send them along with the request. projects.com will render a 404 error to avoid leaking secret information, and the user will be quite confused.\r\n\r\n\r\n`projects.com` is real domain. (currently not owned)\r\nseems better to use example domain in rfc.",
      "createdAt": "2018-10-23T07:12:11Z",
      "updatedAt": "2020-01-10T07:41:56Z",
      "closedAt": "2020-01-10T07:41:56Z",
      "comments": [
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should we use the .example TLD or stay with example.com? It's easier to contextualize with .example, in this case webmail.example and projects.example.",
          "createdAt": "2018-12-18T17:48:17Z",
          "updatedAt": "2018-12-18T17:48:17Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "SGTM in projects.example, webmail.example etc\r\nalso projects.example.com/net/org are fine too.",
          "createdAt": "2018-12-19T01:57:10Z",
          "updatedAt": "2018-12-19T01:57:10Z"
        }
      ]
    },
    {
      "number": 712,
      "id": "MDU6SXNzdWUzNzYwMzM4MzU=",
      "title": "CERTIFICATE frame has how many flags?",
      "url": "https://github.com/httpwg/http-extensions/issues/712",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "The specification says that there are two flags but only one is defined.\r\n\r\n~~~\r\nThe CERTIFICATE frame defines two flags:\r\n\r\nTO_BE_CONTINUED (0x01):\r\n    Indicates that the exported authenticator spans more than one frame.\r\n\r\n  0                   1                   2                   3\r\n  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\r\n +-------------------------------+-------------------------------+\r\n |          Cert-ID (16)         |   Authenticator Fragment (*)...\r\n +---------------------------------------------------------------+\r\n\r\nFigure 11: CERTIFICATE frame payload\r\n~~~\r\n\r\n",
      "createdAt": "2018-10-31T15:52:54Z",
      "updatedAt": "2019-04-25T19:40:02Z",
      "closedAt": "2019-04-25T19:40:02Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed in #707; there are now in fact two flags.",
          "createdAt": "2019-04-25T19:40:02Z",
          "updatedAt": "2019-04-25T19:40:02Z"
        }
      ]
    },
    {
      "number": 714,
      "id": "MDU6SXNzdWUzNzYwNTQxMDM=",
      "title": "Secondary certs: dangling AUTOMATIC_USE reference",
      "url": "https://github.com/httpwg/http-extensions/issues/714",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "Section 5.4 contains some left over text that refers to the now removed AUTOMATIC_USE flag. Cf. https://github.com/httpwg/http-extensions/pull/480\r\n\r\n\r\n> Client implementations need to carefully consider the impact of setting the AUTOMATIC_USE flag. This flag is a performance optimization, permitting the client to avoid a round-trip on each request where the server checks for certificate authentication.\r\n",
      "createdAt": "2018-10-31T16:34:37Z",
      "updatedAt": "2019-07-22T20:00:51Z",
      "closedAt": "2019-07-22T20:00:51Z",
      "comments": []
    },
    {
      "number": 715,
      "id": "MDU6SXNzdWUzNzYwNTUyMTA=",
      "title": "Secondary certs: hangover mention of non-stream 0 usage",
      "url": "https://github.com/httpwg/http-extensions/issues/715",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "Not sure if this is an issue or not. Emphasis added in the below quote.\r\n\r\n> Failure to provide a certificate **on a stream** after receiving CERTIFICATE_NEEDED blocks processing, and SHOULD be subject to standard timeouts used to guard against unresponsive peers.\r\n\r\nThis seems to have been left out of the change to stream 0 for all frames (https://github.com/httpwg/http-extensions/pull/566)",
      "createdAt": "2018-10-31T16:37:07Z",
      "updatedAt": "2019-07-22T20:00:51Z",
      "closedAt": "2019-07-22T20:00:51Z",
      "comments": []
    },
    {
      "number": 716,
      "id": "MDU6SXNzdWUzNzc3Njc3MDM=",
      "title": "Consider a `Sec-CH-` prefix for client hint headers",
      "url": "https://github.com/httpwg/http-extensions/issues/716",
      "state": "CLOSED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "In https://github.com/w3ctag/design-reviews/issues/320, @annevk (re-)raised the question of Client Hints' integration with CORS. One suggestion in that thread is to prefix headers with `Sec-CH-`, which on the one hand makes them trivial to add _en masse_ to the CORS-safelisted list, and on the other prevents JavaScript from setting their values (which in turn limits the risk associated with adding them to the CORS-safelisted list in the first place).\r\n\r\nI have two concrete proposals for hints ([`UA-*`](https://github.com/mikewest/ua-client-hints) and [`Lang`](https://github.com/mikewest/lang-client-hint)) that adopt this pattern. Perhaps it's one that could be baked more deeply into the Client Hints infrastructure?\r\n\r\n/cc @igrigorik @yoavweiss @arturjanc",
      "createdAt": "2018-11-06T09:51:52Z",
      "updatedAt": "2020-01-20T13:15:55Z",
      "closedAt": "2020-01-20T13:15:54Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please no additional overloading of names.",
          "createdAt": "2018-11-06T10:43:20Z",
          "updatedAt": "2018-11-06T10:43:20Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Please no additional overloading of names.\r\n\r\nOK. Can you expand on that?",
          "createdAt": "2018-11-06T10:44:56Z",
          "updatedAt": "2018-11-06T10:44:56Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Names are names. I realize that there's a precedent with \"Sec-\". But it really doesn't scale.\r\n\r\nIf we're serious about this, it needs to be done with a plan that explains how this would work with the next keyword being added. In particular, if the \"next\" extension is completely orthogonal to this one.",
          "createdAt": "2018-11-06T10:48:59Z",
          "updatedAt": "2018-11-06T10:48:59Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "`Sec-` exists, and has meaning (at least in browsers). Are you objecting to that in itself? Or are you objecting to adding an additional `CH-`?",
          "createdAt": "2018-11-06T11:12:40Z",
          "updatedAt": "2018-11-06T11:12:40Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I object to this unless we have a documented and agreed-upon plan how this scheme would work with future keywords.",
          "createdAt": "2018-11-06T11:18:44Z",
          "updatedAt": "2018-11-06T11:18:44Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "`Sec-CH-Next-`. :)",
          "createdAt": "2018-11-06T11:19:37Z",
          "updatedAt": "2018-11-06T11:19:37Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What if \"Next\" doesn't automatically always have the properties of \"Sec\"?",
          "createdAt": "2018-11-06T11:22:35Z",
          "updatedAt": "2018-11-06T11:23:04Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke apologies, but at least to me, it's still not clear what you're objecting to.\r\nIs it `Sec-` prefixes in general? Adding `CH-` prefixes to the `Sec-` prefix? If it's the latter, would a stand-alone `CH-` prefix (like we used to have) work better?",
          "createdAt": "2018-11-06T11:23:46Z",
          "updatedAt": "2018-11-06T11:23:46Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm objecting to the further abuse of overloading names with semantics without having a plan how this would work with future extensions.\r\n\r\nWe dropped \"CH-\" because we did not need it, right?",
          "createdAt": "2018-11-06T11:26:51Z",
          "updatedAt": "2018-11-06T11:26:51Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The reason we realize now that it is in fact needed is that we want client-hints to get a free-pass when it's comes to the CORS safelist. That is, we don't want to add every new header to the list.\r\nHaving a prefix will enable us to give all these headers the same treatment, but will also enable us to have a clearer mind when doing so, because the prefix reduces the probability that some existing server is already using those request header values in their logic in an unpredicted way.",
          "createdAt": "2018-11-06T11:42:23Z",
          "updatedAt": "2018-11-06T11:42:23Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> we want client-hints to get a free-pass when it's comes to the CORS safelist\r\n\r\nFWIW, I don't actually care about this. It's fine with me if Fetch just lists all the headers, and y'all have to send PRs to Fetch to add them. :)\r\n\r\n> because the prefix reduces the probability that some existing server is already using those request header values in their logic in an unpredicted way.\r\n\r\nI do care about this. And I especially care that we significantly reduce the risk of the headers containing interesting payloads if we block JavaScript access by prefixing them with `Sec-`. The `CH-` bit is just defense in depth/obscurity from my perspective.",
          "createdAt": "2018-11-06T11:48:48Z",
          "updatedAt": "2018-11-06T11:48:48Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Right. I can understand the `Sec-` prefix because that's defined behaviour (but I note @mikewest's comment with interest; I've never really liked that). `CH-` is just sugar here AIUI.\r\n\r\nYou could document that `Sec-` is required and `CH-` is just convention that doesn't actually change recipient behaviour -- just as `Allow-` `Accept-` `Content-` etc. are.",
          "createdAt": "2018-11-11T03:40:16Z",
          "updatedAt": "2018-11-11T03:40:16Z"
        },
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "There seems to be concrete value in adding the `Sec-` prefix for client hints, primarily for the reason Yoav mentioned: it reduces the compatibility concerns associated with sending a new request header. Otherwise, adding a hint header of `Foo` would break applications that currently set a custom header with the same name in a way that's difficult to predict in advance or detect.\r\n\r\nWhen it comes to `CH-`, a common prefix that identifies hints also appeals to me. It would make it slightly easier to see which headers carry hints, helping developers discover their presence, but also allowing middleware to reliably strip them (e.g. in privacy extensions which aim to reduce the amount of information sent by the browser).",
          "createdAt": "2018-11-11T07:43:13Z",
          "updatedAt": "2018-11-11T07:43:13Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Having thought about this a bit more - I'm not very happy with forcing Client Hints to be `Sec-`, because making them unavailable from JS limits the cases they can be used; while the current set of hints are (mostly) automatically set by browsers, it's not hard to imagine future hints where the client-side application might have something to say.\r\n\r\nI could see an argument that each hint should consider whether it needs to be prefixed by `Sec-`, but the criteria needs to be what actual security properties that hint has, not \"we can't be bothered sending PRs to Fetch.\"\r\n\r\nBTW, this is why registries were invented...",
          "createdAt": "2019-03-25T07:01:21Z",
          "updatedAt": "2019-03-25T07:01:21Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I could see an argument that each hint should consider whether it needs to be prefixed by `Sec-`, but the criteria needs to be what actual security properties that hint has, not \"we can't be bothered sending PRs to Fetch.\"\r\n\r\nI may not expressed myself properly before, but the reasoning for `Sec-` is not simply \"we can't be bothered to send Fetch PRs\". The way I see it, the reasoning is:\r\n\r\n* We want to have confidence that those headers do not conflict with current server logic before declaring them CORS-safe. Adding `Sec-` prefix reduces the probability of such collision. The alternative is to add somewhat complex logic to the CORS safety logic, making sure that values that users are setting are \"valid\" ones.\r\n* Making sure these headers can only be set by the User Agent itself will add further confidence to Servers when processing those headers, as attackers won't be able to set them from JS with arbitrary values.\r\n* Preventing SW from adding those headers will also simplify the processing somewhat (although that part is still being [discussed](https://github.com/whatwg/fetch/pull/880)\r\n\r\nDoes that make our motivation for this clearer?",
          "createdAt": "2019-03-26T11:19:14Z",
          "updatedAt": "2019-03-26T11:19:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hi Yoav,\r\n\r\nI think I understood you pretty well. What I'm saying is that whether something is CORS-safe is separable from the original purpose of `Sec-`; you're conflating them (for what looks like convenience). \r\n\r\nSome headers might need confidence that they can't be set from JS, while I strongly suspect some may not. ",
          "createdAt": "2019-03-26T16:16:36Z",
          "updatedAt": "2019-03-26T16:16:36Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "It's not quite convenience. `Sec-` headers are an escape for clients to not have to violate the same-origin policy as arguably sending new request headers cross-origin violates the same-origin policy. This also helps servers in knowing what to expect and where the boundaries are. If clients create new headers that are same-origin policy exceptions and do not use `Sec-` this leaves servers on a slow update cycle exposed to some extent.",
          "createdAt": "2019-03-26T16:24:21Z",
          "updatedAt": "2019-03-26T16:24:21Z"
        },
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "As a specific example of what @annevk is talking about, let's say I'm a server that puts a certain degree of trust in requests with a `Width` header because they can currently only be set same-origin (or via preflighted CORS). Once clients start sending `Width` hints anyone will be able to make a request on behalf of another user with the header set, potentially subverting my security logic.\r\n\r\nWe know that servers frequently use the presence of custom headers for security purposes (e.g. `X-CSRF-Protection: 1` is fairly common). We can hope that hint names would not clash with such sensitive headers, but especially as the list of hints grows, it will be more difficult to guarantee this, and we will quietly make some applications insecure.",
          "createdAt": "2019-03-27T09:53:17Z",
          "updatedAt": "2019-03-27T09:53:17Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke - can you elaborate on \"I object to this unless we have a documented and agreed-upon plan how this scheme would work with future keywords.\"?\r\n\r\nWhat would such agreed plan look like?\r\n\r\nLet's discuss this more next week at the HTTPWG meeting! (or before, if we can)",
          "createdAt": "2019-07-18T12:15:14Z",
          "updatedAt": "2019-07-18T12:15:14Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke - friendly ping :)",
          "createdAt": "2019-07-22T18:24:03Z",
          "updatedAt": "2019-07-22T18:24:03Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I looked at the comments in this issue, and it seems to me everything was already mentioned.\r\n\r\nOverloading the name with semantics doesn't scale, unless there's a agreed-upon way how new prefixes would be added and combined.\r\n\r\nRight now, we seem to conflate:\r\n\r\n- making things ok in CORS (no preflight)\r\n- making things always UA controlled\r\n\r\nand also\r\n\r\n- adding some arbitrary prefix reduces the risk of stepping on somebody else's private use field name\r\n\r\nI need we believe to discuss these issues separetely.\r\n",
          "createdAt": "2019-07-22T19:32:18Z",
          "updatedAt": "2019-07-22T19:32:18Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was discussed at the HTTPWG meeting today. A few highlights:\r\n* If the \"CH-\" part does not impact processing, it should not be a prefix. Maybe a convention that implementing features could follow.\r\n   * One part where a \"CH-\" convention may be helpful is in signaling CDNS that they may not want to log that information, as it may be privacy sensitive as a fingerprinting vector. \r\n   * At the same time, CDNs are likely to use CH values to manipulate content, in which case they are likely to log it as something that impacts their processing.\r\n* Maybe we should consider making the `Sec-` prefix decision on a feature-by-feature basis. However, that may complicate the Fetch processing model and it's not clear it is required.\r\n",
          "createdAt": "2019-07-22T22:30:12Z",
          "updatedAt": "2019-07-22T22:30:12Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by #776 ",
          "createdAt": "2020-01-20T13:15:54Z",
          "updatedAt": "2020-01-20T13:15:54Z"
        }
      ]
    },
    {
      "number": 717,
      "id": "MDU6SXNzdWUzNzg1ODM4NDY=",
      "title": "Cookies and Accept-* interactions",
      "url": "https://github.com/httpwg/http-extensions/issues/717",
      "state": "OPEN",
      "author": "thpts",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "<sup>(@mnot requested a new issue during Thursday's httpbis meeting at IETF 103)</sup>\r\n\r\n#549 suggests the idea of an algorithm to to key the cache on a cookie by name. \r\n\r\nOne consideration in this specification should be the use case where some value in a cookie can override server Accept behaviours. As a known use case, websites that offer multiple languages may allow a user to set a cookie which determines which language. When that value is not present in a cookie, the server falls back to using Accept-Language or some other alternate.\r\n\r\nI think this specification should perhaps make some clarity over Cookies doing this kind of override, even if it may fit into the Vary section (as servers implementing this probably are using `Vary: Cookie`)",
      "createdAt": "2018-11-08T05:24:02Z",
      "updatedAt": "2019-10-30T02:04:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2018-11-08T07:25:28Z",
          "updatedAt": "2018-11-08T07:25:28Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think this would require some sort of \"all\" value (`*`?) in `Variant-Key`; if we had that, it should be fairly straightforward, I _think_.",
          "createdAt": "2019-10-30T02:04:33Z",
          "updatedAt": "2019-10-30T02:04:33Z"
        }
      ]
    },
    {
      "number": 718,
      "id": "MDU6SXNzdWUzNzk0ODM3Mzc=",
      "title": "EAT Cookies",
      "url": "https://github.com/httpwg/http-extensions/issues/718",
      "state": "OPEN",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "When we started 6265bis, we gained WG consensus to incorporate [Expiring Aggressively Those HTTP Cookies](https://tools.ietf.org/html/draft-thomson-http-omnomnom-00). ",
      "createdAt": "2018-11-11T02:50:02Z",
      "updatedAt": "2020-01-12T23:11:39Z",
      "closedAt": null,
      "comments": [
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, this seems to have been one of the main drivers for a new version of the spec. Since this issue was opened just a month ago, I assume no detailed decisions have been made on how the incorporation should happen (I saw the comment that it may be incorporated non-verbatim).",
          "createdAt": "2018-12-18T18:18:14Z",
          "updatedAt": "2018-12-18T18:18:14Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I don't think that any vendor has made substantial progress in this space, and I don't think waiting for someone to ship something is going to meet the goal of finishing this document in Q1.\r\n\r\nWould it be reasonable to add an aspirational section to the Security Considerations that points to @martinthomson's EAT draft, and my https://github.com/mikewest/cookies-over-http-bad as potential directions that user agents should feel encouraged to explore? Or should we punt this further down the road?",
          "createdAt": "2020-01-10T07:48:03Z",
          "updatedAt": "2020-01-10T07:48:03Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was always going to be aspirational.  Recognizing that maximum retention lifetimes are a question of policy means that you are not going to get much out of these specs.  I would prefer to look at the main body of the document though, as your suggestion says.",
          "createdAt": "2020-01-12T23:11:38Z",
          "updatedAt": "2020-01-12T23:11:38Z"
        }
      ]
    },
    {
      "number": 719,
      "id": "MDU6SXNzdWUzNzk2MzA0NTY=",
      "title": "! seems like a poor choice for Boolean",
      "url": "https://github.com/httpwg/http-extensions/issues/719",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "I think either @phluid61 or @LPardue suggested `?`, since `!` will be read as \"NOT\" by many, and therefore confuse...",
      "createdAt": "2018-11-12T05:48:20Z",
      "updatedAt": "2018-11-15T09:31:28Z",
      "closedAt": "2018-11-12T22:15:54Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@jyasskin / @irori will changing this cause trouble for you?",
          "createdAt": "2018-11-12T06:01:22Z",
          "updatedAt": "2018-11-12T06:01:22Z"
        },
        {
          "author": "irori",
          "authorAssociation": "NONE",
          "body": "> @jyasskin / @irori will changing this cause trouble for you?\r\n\r\nNo, we don't use Booleans at the moment. ",
          "createdAt": "2018-11-12T07:06:24Z",
          "updatedAt": "2018-11-12T07:06:24Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thx.",
          "createdAt": "2018-11-12T22:15:54Z",
          "updatedAt": "2018-11-12T22:15:54Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Pinging @mikewest just to make sure this won't cause any pain, and FYI.",
          "createdAt": "2018-11-14T22:47:09Z",
          "updatedAt": "2018-11-14T22:47:09Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I was also surprised at `!` in the doc. `?` is fine, and maybe possibly more semantic if I squint?",
          "createdAt": "2018-11-15T08:23:13Z",
          "updatedAt": "2018-11-15T08:23:13Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't recall making any complaints. However you resolved this SGTM",
          "createdAt": "2018-11-15T09:31:28Z",
          "updatedAt": "2018-11-15T09:31:28Z"
        }
      ]
    },
    {
      "number": 720,
      "id": "MDU6SXNzdWUzODAwNTUzNTc=",
      "title": "Create distinguished names",
      "url": "https://github.com/httpwg/http-extensions/issues/720",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "In some places (e.g., the first identifier in a paramlist), there isn't a term of art that referring specifications can easily use. Doing it in the ABNF is probably the easiest thing.",
      "createdAt": "2018-11-13T04:31:27Z",
      "updatedAt": "2018-11-13T04:43:16Z",
      "closedAt": "2018-11-13T04:43:16Z",
      "comments": []
    },
    {
      "number": 721,
      "id": "MDU6SXNzdWUzODAwNTg2MzI=",
      "title": "List of Lists?",
      "url": "https://github.com/httpwg/http-extensions/issues/721",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Variants needs a structure like this:\r\n\r\n~~~\r\nHeader: foo; bar;baz, bat;brrr;whatever\r\n~~~\r\n\r\ni.e., a list-of-lists.\r\n\r\nParamList isn't suitable because:\r\n\r\n* The discontinuity introduced between the possible syntax for `item` and `key`\r\n* The lack of ordering for parameters\r\n\r\nAdding a list of lists datatype seems pretty straightforward, but I'm conscious that we can't keep on adding stuff if we want people to implement. \r\n\r\nThe other approach would be to remove the discontinuity between `item` and `key` (i.e., revert their split from #702) *and* make parameters into an ordered mapping (as we did for dictionaries).\r\n\r\nThoughts?",
      "createdAt": "2018-11-13T04:48:23Z",
      "updatedAt": "2018-11-28T07:18:05Z",
      "closedAt": "2018-11-28T07:18:05Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "On balance, my inclination here is to add it; the implementation load isn't huge. Anyone feel otherwise?",
          "createdAt": "2018-11-23T04:47:47Z",
          "updatedAt": "2018-11-23T04:47:47Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "It has a use case, and it doesn't seem to add much complexity. Is this the point where we draw the line and say \"no new data structures\"?",
          "createdAt": "2018-11-23T06:26:28Z",
          "updatedAt": "2018-11-23T06:26:28Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think we're getting to the point where we say \"no new data structures in *this* spec\" -- a follow-on can always add something.",
          "createdAt": "2018-11-23T06:38:53Z",
          "updatedAt": "2018-11-23T06:38:53Z"
        }
      ]
    },
    {
      "number": 723,
      "id": "MDU6SXNzdWUzODI1MjU1MjI=",
      "title": "Implementation notes",
      "url": "https://github.com/httpwg/http-extensions/issues/723",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "Editorial things noticed while implementing:\r\n\r\n* [ ] the discontinuity between a single `parse_number` and `ser_integer` / `ser_float` is awkward. Probably want to split `parse_number` into two.\r\n* [x] `ser_item` does an upfront check for type and falls through to byte sequence, whereas `parse_item` falls through to an error.\r\n* [x] \"Insert (param_name, param_value) into parameters\" is a bit odd (parsing parameterised identifier).\r\n* [x] `input` in the algorithms is a bit generic (and likely to clash with builtins); use `input_list` or similar.\r\n* [x] discontinuity between top-level parse and serialise (but maybe that's OK?)\r\n* [x] in top-level serialise, maybe check for paramlist before list\r\n* [x] in top-level parse, have an explicit 'item' type\r\n* [ ] might want to explicitly catch empty list items\r\n* [x] need explicit length for keys\r\n* [x] maybe reconsider length limit for identifiers",
      "createdAt": "2018-11-20T06:56:55Z",
      "updatedAt": "2018-11-23T04:25:13Z",
      "closedAt": "2018-11-23T04:25:13Z",
      "comments": []
    },
    {
      "number": 725,
      "id": "MDU6SXNzdWUzODI5NTE5Mzk=",
      "title": "\"Identifier\"",
      "url": "https://github.com/httpwg/http-extensions/issues/725",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "A bit of an unwieldy name. Perhaps:\r\n\r\n* Token\r\n* Word\r\n* ???",
      "createdAt": "2018-11-21T04:34:36Z",
      "updatedAt": "2018-11-29T06:08:04Z",
      "closedAt": "2018-11-29T06:08:04Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@phluid61 says (on a commit):\r\n\r\n> Speaking as a computer scientist, \"token\" is a worse name than \"identifier\". Any atomic element is a lexical token (identifiers, integers, commas, etc.).\r\n\r\n> The only things I could think of that were as applicable as \"identifier\" were \"bareword\" and \"symbol\", which is why I didn't suggest them\r\n",
          "createdAt": "2018-11-28T22:16:44Z",
          "updatedAt": "2018-11-28T22:16:44Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "My main problem with `Identifier` is how many syllables it has -- which is not a deal killer.\r\n\r\nGoing from [definitions](https://en.wikipedia.org/wiki/Lexical_analysis), I agree that `token` is not terribly apt (although we're not conveying semantics here, so...).\r\n\r\nHowever, HTTP already uses `token` in a [similar way as here](https://httpwg.org/specs/rfc7230.html#rule.token.separators). \r\n\r\nI could see an argument that using `token` in a different way to HTTP \"core\" might be confusing -- on balance, my inclination was that the term would always be used in the context of structured headers, so would not be ambiguous.\r\n\r\nI'm happy to keep it at `token`, move back to `identifier` or choose something else -- @phluid61 does the above change your thinking? If not, let's move back to `identifier`.\r\n\r\nAnd yes, this issue probably deserves a `bike shed` label...",
          "createdAt": "2018-11-28T22:21:55Z",
          "updatedAt": "2018-11-28T22:21:55Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> does the above change your thinking?\r\n\r\nIt expands my thinking, certainly.  I think as long as `sh-token` and (RFC7230) `token` are always clearly distinct there's no problem.  There's precedent, since `sh-string` and `quoted-string` have a similar kind of overlap.  It's just a bit weird that we're drifting away from the \"normal\" meaning of the word.\r\n\r\n\u252c\u2500\u252c\u30ce( \u00ba - \u00ba\u30ce)\r\n\r\n*(unflipped table)*",
          "createdAt": "2018-11-28T23:20:36Z",
          "updatedAt": "2018-11-28T23:20:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hm. How about we leave it at `token` in the next WG draft and see if anyone complains?",
          "createdAt": "2018-11-28T23:27:00Z",
          "updatedAt": "2018-11-28T23:27:00Z"
        }
      ]
    },
    {
      "number": 727,
      "id": "MDU6SXNzdWUzODM3MTcwOTg=",
      "title": "Implementation guidance",
      "url": "https://github.com/httpwg/http-extensions/issues/727",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Seems useful to give, possibly in an appendix?",
      "createdAt": "2018-11-23T06:45:37Z",
      "updatedAt": "2018-11-29T06:04:13Z",
      "closedAt": "2018-11-29T06:04:13Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "And probably separate out top-level types to make it clear they're special.",
          "createdAt": "2018-11-28T06:38:29Z",
          "updatedAt": "2018-11-28T06:38:29Z"
        }
      ]
    },
    {
      "number": 728,
      "id": "MDU6SXNzdWUzODUxMjk1NDA=",
      "title": "Serialising list-of-list allows empty sub-lists",
      "url": "https://github.com/httpwg/http-extensions/issues/728",
      "state": "CLOSED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "The algorithm for serialising a list of lists allows empty sub-lists `[[], []]` => `\", \"`",
      "createdAt": "2018-11-28T07:04:03Z",
      "updatedAt": "2018-11-28T07:43:22Z",
      "closedAt": "2018-11-28T07:43:22Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "That was easier to fix than I thought.",
          "createdAt": "2018-11-28T07:43:22Z",
          "updatedAt": "2018-11-28T07:43:22Z"
        }
      ]
    },
    {
      "number": 730,
      "id": "MDU6SXNzdWUzODU5ODYyMzY=",
      "title": "Key -> Variants",
      "url": "https://github.com/httpwg/http-extensions/issues/730",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Key has been superseded by Variants.",
      "createdAt": "2018-11-30T00:29:16Z",
      "updatedAt": "2019-07-25T14:34:23Z",
      "closedAt": "2019-07-25T14:34:23Z",
      "comments": []
    },
    {
      "number": 731,
      "id": "MDU6SXNzdWUzODY0MDI3NTM=",
      "title": "Cache behavior assumes browser request includes all Variant'ed headers",
      "url": "https://github.com/httpwg/http-extensions/issues/731",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#cache says \"... For each variant in variants-header ... Let request-value be the field-value(s) associated with field-name in incoming-request.\" I don't see any handling of the case where there is no `field-name` header in `incoming-request`. The algorithms in https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#backports then also don't handle the case where request-value is empty.\r\n\r\nSorry if I've just missed where you handle the empty case.",
      "createdAt": "2018-12-01T01:02:37Z",
      "updatedAt": "2019-01-04T04:57:31Z",
      "closedAt": "2019-01-04T04:57:31Z",
      "comments": []
    },
    {
      "number": 734,
      "id": "MDU6SXNzdWUzODg4NDQxNzE=",
      "title": "Variants' incoming-request assumes all content-negotiation systems' Accept headers are lists",
      "url": "https://github.com/httpwg/http-extensions/issues/734",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#cache says:\r\n\r\n> Given incoming-request (a mapping of field-names to lists of field values)\r\n\r\nIt doesn't specify how to calculate this from the HTTP request (https://fetch.spec.whatwg.org/#requests? I don't see a version-independent definition of a request in the HTTP specs.) that the cache actually receives, and it doesn't deal with request headers like https://httpwg.org/http-extensions/client-hints.html#dpr that hold a single value instead of a list.",
      "createdAt": "2018-12-07T23:00:50Z",
      "updatedAt": "2019-07-05T04:06:19Z",
      "closedAt": "2019-07-05T04:06:19Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Are you looking for text that effectively says:\r\n\r\n> If the header is defined to be a single value, take the first instance of the header field and put its value into a list. If the header is defined to be a list (e.g., using the #rule), parse each instance of the header field into a list and combine all of those lists.\r\n\r\n?\r\n\r\nnote that work on http-core might help here; e.g., see https://github.com/httpwg/http-core/issues/116",
          "createdAt": "2019-01-08T02:09:22Z",
          "updatedAt": "2019-01-08T02:09:22Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#735 changed the *use* of `incoming-request` to say\r\n\r\n> Let request-value be the field-value associated with field-name in incoming-request (after being combined as allowed by Section 3.2.2 of [RFC7230])\r\n\r\nwhich I think is good (but I would since I wrote it). The declaration of `incoming-request` could say the same thing.\r\n\r\nI'd rather have this part of this spec not worry about the definition of the header, and instead isolate that to the call into the \"content negotiation mechanism that the implementation supports\". Then headers like DPR can define for themselves how they react to responses that are invalid by including multiple header instances.",
          "createdAt": "2019-01-08T04:41:31Z",
          "updatedAt": "2019-01-08T04:41:45Z"
        }
      ]
    },
    {
      "number": 736,
      "id": "MDU6SXNzdWUzODk4NjEyMTM=",
      "title": "Early Hints and Fetch",
      "url": "https://github.com/httpwg/http-extensions/issues/736",
      "state": "OPEN",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "early-hints"
      ],
      "body": "Currently https://fetch.spec.whatwg.org/#concept-http-network-fetch ignores all 1xx responses, it seems this would have to be changed somehow, assuming this is to be adopted in user agents implementing Fetch.\r\n\r\nIt would also have to be done in such a way that any security checks applying to responses also apply to these responses (also tracked by #687 to some extent).",
      "createdAt": "2018-12-11T17:00:22Z",
      "updatedAt": "2018-12-21T05:24:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Shouldn't this be an issue for whatwg/fetch?",
          "createdAt": "2018-12-13T23:54:17Z",
          "updatedAt": "2018-12-13T23:54:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "/me is looking for a reason to use the GitHub \"Transfer this issue\" beta feature...",
          "createdAt": "2018-12-13T23:54:40Z",
          "updatedAt": "2018-12-13T23:54:40Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I guess I'd like those driving Early Hints to take responsibility for it, so whatever makes that easier.",
          "createdAt": "2018-12-14T06:58:04Z",
          "updatedAt": "2018-12-14T06:58:04Z"
        }
      ]
    },
    {
      "number": 737,
      "id": "MDU6SXNzdWUzOTAwMzIzNTQ=",
      "title": "Integer limits",
      "url": "https://github.com/httpwg/http-extensions/issues/737",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Working on evert/structured-headers, @evert [noticed](https://github.com/httpwg/structured-header-tests/issues/9) that representing the full range of SH integers is [hard](http://2ality.com/2013/10/safe-integers.html), and going beyond it can cause [problems](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER).\r\n\r\nGiven JS's place in the Web ecosystem and the relative rarity of headers that need integers that big (as well as the availability of floats), should we consider limiting the range of integer to match JS?",
      "createdAt": "2018-12-12T01:58:30Z",
      "updatedAt": "2019-04-11T04:04:08Z",
      "closedAt": "2019-04-11T04:04:08Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "JS also now has BigInts as an option: https://developers.google.com/web/updates/2018/05/bigint and https://github.com/tc39/proposal-bigint. This doesn't fix the JSON parse problem, and it's not obvious that a JS implementation would want to use BigInts instead of just limiting the valid range.",
          "createdAt": "2018-12-12T03:28:22Z",
          "updatedAt": "2018-12-12T03:28:22Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Wait, what problem is this proposal actually fixing? Which JS code in particular is affected, in what way?",
          "createdAt": "2018-12-12T23:56:23Z",
          "updatedAt": "2018-12-12T23:56:23Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While I understand the concern, I am not sure if limiting the bounds of structured headers to 52 bits is the correct solution.\r\n\r\nSome filesystems already are capable of handling files larger than that. As @jyasskin points out, there's \"bigint\" in JavaScript and Node.js has started to provide an option to use that for representing file sizes (https://nodejs.org/api/fs.html#fs_class_fs_stats).\r\n\r\nTaking these facts into consideration, I'd prefer sticking to 63 bits in the specification.\r\n\r\nI do not want to see Structured Headers defining two types of integers (much like the Un*x systems in late 20th century that provided fstat and fstat64 calls). In the long run, having one way is better than optimizing for today's implementations.",
          "createdAt": "2018-12-13T07:25:03Z",
          "updatedAt": "2018-12-13T07:25:03Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Way back I limited Floats, or \"Numbers\" as I think I called them,\r\nto 15 digits so they would fit in ieee64 floting point types, this\r\nbecame our \"Float\" type, which still has that restriction.\r\n\r\nIntegers were added, I thought, precisely to give the full\r\n64 bit integer range without that limitation ?\r\n\r\nIf we want to go back and cater to JS implementations, we should\r\nremove Integers again, rename Float back to Number, add the\r\n\"15DIGIT\" variant back and leave it to people to specify \"Number\r\nwithout fraction\" in their usage of SH.\r\n\r\nIt's early in the morning and I fought a server all night, so subject\r\nto me waking up I think my preference probably is to make it a\r\nmandatory parsing error if an Integer cannot be represented precisly\r\nin the target environment, with a pointed caution/footnote about JS ?\r\n",
          "createdAt": "2018-12-13T11:33:30Z",
          "updatedAt": "2018-12-13T11:33:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "For most other types, we guarantee supported lengths / sizes of types by saying \"implementations must support at least...\"\r\n\r\nWhat if we said that implementations MUST support at least a range of -2^53 to 2^53, and MUST fail dependably if they don't support numbers outside that range? \r\n\r\nThat would give us JS interoperability, as well as ability to support larger numbers for cases that need it, with dependable failure by individual implementations.",
          "createdAt": "2018-12-20T02:07:18Z",
          "updatedAt": "2018-12-20T02:07:18Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For most other types, we guarantee supported lengths / sizes of types by saying \"implementations must support at least...\"\r\n> \r\n> What if we said that implementations MUST support at least a range of -2^53 to 2^53, and MUST fail dependably if they don't support numbers outside that range?\r\n\r\nI assume you meant \"MUST fail dependably if they receive a number outside the supported range\"?",
          "createdAt": "2018-12-20T04:15:47Z",
          "updatedAt": "2018-12-20T04:15:47Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "s/the/their/, but yes.",
          "createdAt": "2018-12-20T04:20:13Z",
          "updatedAt": "2018-12-20T04:20:13Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks. SGTM (I've always preferred having no fixed upper-bound in the spec).",
          "createdAt": "2018-12-20T04:21:39Z",
          "updatedAt": "2018-12-20T04:21:39Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What does it mean to fail dependably?  I assume that this is just the \"fail parsing\" clause.",
          "createdAt": "2018-12-20T05:47:34Z",
          "updatedAt": "2018-12-20T05:47:34Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "yes.",
          "createdAt": "2018-12-20T06:10:26Z",
          "updatedAt": "2018-12-20T06:10:26Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The only integers I personally know larger than 53 bits are memory addresses (which should *never* get near JS, but could be blobs) and cryptographic data (which should be blobs) and nonces like CC numbers, SKU numbers, transaction IDs (which {c|sh}ould either be strings or blobs).\r\n\r\nIn other words: People have sound alternatives.\r\n\r\nMaking it parsing error to fail to \"capture the exact numerical value\" would raise the question why we don't also have that note for Numbers, which runs into the binary floating point vs. decimal numbers thing.\r\n\r\nIn all likelihood what will happen is that people won't read what we write anyway, and any 53+ bit integers will simply loose resolution in JS, *just like they would* if they came into JS *any other way*.\r\n\r\nSo all in all:  I think we should just close this issue.\r\n\r\nAt most, we can add a footnote reminding people that JS does not have a native 64 bit integer type.\r\n",
          "createdAt": "2018-12-21T11:15:55Z",
          "updatedAt": "2018-12-21T11:15:55Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, https://tools.ietf.org/html/draft-ietf-httpbis-rand-access-live-03 has the following in the Security Considerations:\r\n> One potential issue with this recommendation is related to the use of very-large last-byte-pos values. Some client and server implementations may not be prepared to deal with byte position values of 2^63 and beyond. So in applications where there's no expectation that the representation will ever exceed 2^63, a value smaller than this value should be used as the very large last-byte-pos in a byte-seek request or content-range response. Also, some implementations (e.g. JavaScript-based clients and servers) are not able to represent all values beyond 2^53. So similarly, if there's no expectation that a representation will ever exceed 2^53 bytes, values smaller than this limit should be used for the last-byte-pos in byte-range requests.\r\n\r\nI think that the decision we make here should be aligned to this.",
          "createdAt": "2018-12-22T02:51:39Z",
          "updatedAt": "2018-12-22T02:51:39Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@kazuho I'm not sure what the practical impact of that is; `Range` and `Content-Range` do not use structured headers. Of course, if they're ever adapted to do so (e.g., with replacement headers whose use is negotiated), that would need to be accounted for, but the proposal above doesn't preclude an approach such as that taken in the current rand-access draft, AFAICT.",
          "createdAt": "2019-01-03T03:10:13Z",
          "updatedAt": "2019-01-03T03:10:13Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@bsdphk:\r\n\r\n> Making it parsing error to fail to \"capture the exact numerical value\" would raise the question why we don't also have that note for Numbers, which runs into the binary floating point vs. decimal numbers thing.\r\n\r\nWe're already there; we have such requirements for other types. I think the way out might be to note that float precision is implementation-dependant. \r\n\r\n> In all likelihood what will happen is that people won't read what we write anyway, and any 53+ bit integers will simply loose resolution in JS, just like they would if they came into JS any other way.\r\n\r\nI agree it's hard to reflect that requirement in the unified test suite, but the fact that our first JS implementer brought this up and asked for help tells me that we should say something; they appear to be listening.\r\n",
          "createdAt": "2019-01-04T00:02:05Z",
          "updatedAt": "2019-01-04T00:02:05Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "How do current JS libraries deal with pathological values? (Can I crash a node script by sending an evil `range` or `content-length` header?)",
          "createdAt": "2019-01-04T02:10:13Z",
          "updatedAt": "2019-01-04T02:10:13Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "For examples, see:\r\n  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER",
          "createdAt": "2019-01-04T02:11:59Z",
          "updatedAt": "2019-01-04T02:11:59Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, right, MAX_VALUE is different.",
          "createdAt": "2019-01-04T02:16:04Z",
          "updatedAt": "2019-01-04T02:16:04Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not sure if this is interesting, but if unsafe integers appear in JSON documents, `JSON.parse()` will simply lose precision.\r\n\r\nExample:\r\n\r\n```\r\n> JSON.parse('9223372036854775807');\r\n9223372036854776000\r\n```\r\n\r\nPerhaps the recommendation for (javascript) implementations is to do the same, and leave it up to end-users to use strings if there is risk of overflow.",
          "createdAt": "2019-01-04T20:35:17Z",
          "updatedAt": "2019-01-04T20:35:17Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Prior art for the JSON specification:\r\n\r\n> Note that when such software is used, numbers that are integers and\r\n   are in the range [-(2\\*\\*53)+1, (2\\*\\*53)-1] are interoperable in the\r\n   sense that implementations will agree exactly on their numeric\r\n   values.\r\n\r\nhttps://tools.ietf.org/html/rfc8259#section-6\r\n\r\nBasically the JSON spec defines a safe range but doesn't forbid larger numbers. It might be interesting to do the same thing here. If defining a safe range is still too aggressive for folks, it could simply be stated as a potential risk that certain implementations may lose precision for larger numbers.",
          "createdAt": "2019-01-04T21:08:10Z",
          "updatedAt": "2019-01-04T21:08:10Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@evert Losing precision is a nightmare for header fields, because it can lead to vulnerabilities (consider the case of content-length (using structured headers) being rounded in HTTP/1; that can be used to mount a response splitting attack).\r\n\r\nI think the \"MUST fail dependably if outside of supported range\" is a must-have, regardless of if we agree on having a safe range.",
          "createdAt": "2019-01-04T21:20:31Z",
          "updatedAt": "2019-01-04T21:20:31Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK, so the minimal change would be to add something like:\r\n\r\n> Implementations MAY only support a subset of values in this range, but MUST fail parsing if they receive a value outside the range of values that they accurately support.\r\n",
          "createdAt": "2019-01-08T01:28:28Z",
          "updatedAt": "2019-01-08T01:28:28Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "... but personally I feel that a guaranteed range (-2^53 to 2^53) is a good thing to promote (and harmless, since JS will choose it, and most everyone else will choose 2^64). It also avoids someone settling for 2^32 and introducing introp problems in that range.",
          "createdAt": "2019-01-08T01:29:51Z",
          "updatedAt": "2019-01-08T01:29:51Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to requiring support for numbers between -2<sup>53</sup>+1 to 2<sup>53</sup>-1. JavaScript is not the only programming language that relies on IEEE 754.",
          "createdAt": "2019-01-08T02:31:57Z",
          "updatedAt": "2019-01-08T02:31:57Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> -2^53 to 2^53\r\n\r\n> -2<sup>53</sup>+1 to 2<sup>53</sup>-1\r\n\r\nPlease get the numbers right.  I think that @kazuho got the real limits right based on there being a 53-bit modulus, though I would observe that it's 2<sup>53</sup> is faithfully represented and it's only n + n*2<sup>-53</sup> that can't be represented.  So either range works, though the smaller range is perhaps easier.",
          "createdAt": "2019-01-08T05:14:46Z",
          "updatedAt": "2019-01-08T05:14:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson I thought that the maximum was 2<sup>53</sup>-1 because the fraction bits are __52__ bits in 64-bit FP, but I might be wrong.",
          "createdAt": "2019-01-08T05:26:55Z",
          "updatedAt": "2019-01-08T05:27:25Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The significand is 52 bits, which produces 0b1.1{52} (i.e., 52 ones), as a maximum value, with an exponent of 52, producing 2<sup>53</sup>-1 as you say.  But 0b1.0{52} (52 zeroes) and an exponent of 53 produces 2<sup>53</sup> precisely as well.",
          "createdAt": "2019-01-08T05:43:13Z",
          "updatedAt": "2019-01-08T05:43:13Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's true, and so does 2<sup>53</sup>+2. But I think we should better refrain from listing all the integers that can be represented using IEEE 754.",
          "createdAt": "2019-01-08T05:50:50Z",
          "updatedAt": "2019-01-08T05:50:50Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PS. The reason to choose +-(2<sup>53</sup>-1) would be that they are the largest (smallest) numbers free from rounding errors.\r\n\r\nAny value exceeding that range is not mapped one-to-one from integral numbers. For example, both 2<sup>53</sup> and 2<sup>53</sup>+1 will be decoded as a double of 2<sup>53</sup> assuming that round-to-nearest zero is used (which is IIRC is the common rounding method).",
          "createdAt": "2019-01-08T06:23:14Z",
          "updatedAt": "2019-01-09T01:00:02Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "Well, I'd personally vote for a range that can be tested with a single AND mask :-)  I.e. I'd like that we can check that (value & 0b011111111110000...000) == 0. This would indeed rule out the extremities hence +/-2^53, but would limit confusion and off-by-one errors. It would also avoid surprises when representing scaled down values in lower bits.",
          "createdAt": "2019-01-08T10:48:55Z",
          "updatedAt": "2019-01-08T10:48:55Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Unfortunately, the test is always going to more complicated than a mask.  A straight integer representation will need a test like `e = (int)((value >> 53) & 0x7ff) - 1023, e > -52 && e < 53`.  You might also need to test that it is an integer by looking at the low bits of the significand, though that test might be avoided with a guarantee that there is no decimal point.  Floating point is just tricky.",
          "createdAt": "2019-01-08T22:47:56Z",
          "updatedAt": "2019-01-08T22:47:56Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "Martin, you're likely talking about mapping the JS representation to an int, that's not what I was suggesting at all :-)   I was speaking about the test we can add in various components supporting native 64-bit integers and which want to check for the limits at a low cost.",
          "createdAt": "2019-01-09T03:23:36Z",
          "updatedAt": "2019-01-09T03:23:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "See PR for proposal.",
          "createdAt": "2019-01-10T00:26:39Z",
          "updatedAt": "2019-01-10T00:26:39Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mark, I'm -1 on your PR, because the same effect can be had by taking the sh-integer type out behind the barn.\r\n\r\nWe introduced sh-integer precisely to escape the 53 bit limitation of IEEE754::64bin and JS, and if we are going to put that restriction also on sh-integer, it serves no purpose any longer and should be removed.\r\n\r\nCollapsing sh-integer and sh-float to sh-number will actually simplify the spec a fair bit, for instance the \"Parsing a Number from Text\" algo, and some old french dude says that gets us closer to perfection than if we add more text.\r\n",
          "createdAt": "2019-01-13T20:49:16Z",
          "updatedAt": "2019-01-13T20:49:41Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have attempted created PR #755.\r\n",
          "createdAt": "2019-01-13T21:15:09Z",
          "updatedAt": "2019-01-13T21:15:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Poul-Henning - remember that the goal here is make headers easier / less error-prone; most headers need an integer type, and forcing them to specify the error conditions if it's not an integer-carried-in-a-float is going to hurt that. \r\n\r\nAdditionally, it's extremely convenient to map existing headers into SH -- one of the reasons we have separate String and Token types. many headers wouldn't be mappable into SH if we didn't have an explicit Integer type.\r\n\r\nIn other words -- while your spec might simplify the *spec* and even *implementations* a bit, it's making the job of people using the spec harder -- and making that job easier is the whole point of this exercise.",
          "createdAt": "2019-01-20T19:55:47Z",
          "updatedAt": "2019-01-20T19:55:47Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Then simply define Integer as \"Number without a decimal point\"\r\n\r\nMy main point is that the 15 digit limitation is much sounder and easier for people to implement, than powers of two.",
          "createdAt": "2019-01-21T08:25:39Z",
          "updatedAt": "2019-01-21T08:26:13Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "But that's syntax; we need an abstract value space too, so we can have alternative serialisations.",
          "createdAt": "2019-01-22T04:30:09Z",
          "updatedAt": "2019-01-22T04:30:09Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Make the abstract value space 15 digits:  -999,999,999,999,999...+999,999,999,999,999",
          "createdAt": "2019-01-24T20:00:57Z",
          "updatedAt": "2019-01-24T20:00:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "That's smaller than the range we've discussed as desirable; a bit smaller than -2^50 to 2^50. We already say:\r\n\r\n> Integers have a range of \u22129,223,372,036,854,775,808 to 9,223,372,036,854,775,807 inclusive (i.e., a 64-bit signed integer).\r\n>\r\n> The ABNF for integers in HTTP/1 headers is:\r\n>\r\n> sh-integer = [\"-\"] 1*19DIGIT",
          "createdAt": "2019-01-24T22:22:58Z",
          "updatedAt": "2019-01-24T22:22:58Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "So we want to have integers for people who can store them in integers, but we want to limit them to what fits in a float for people who have to store them in floats. And write syntax & parsing rules for people who de/serialise them in HTTP/1 (or /2), which can distinguish the two cases.\r\n\r\nMy biggest concern through all of this is what happens when \"fail parsing\". There's no signal, so how do you tell someone you're ignoring the super-important integer header they sent you which is close to 64-bits wide because you're trying to store it in a float and have detected a precision drop?  The whole \"you can send bigger numbers but they might fail silently\" thing is bad.  (This is also true for other types, but is surfacing here now.)",
          "createdAt": "2019-01-24T23:38:45Z",
          "updatedAt": "2019-01-24T23:38:45Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It is true for other types; e.g., if you create a list with more than 1024 members. We came up with the \"implementations must support at least...\" pattern to balance a need for interop on a defined range of values with the need for more extreme values in some (hopefully limited) use cases.\r\n\r\nEffectively, when you go beyond the required range for *any* type, you're outside the guide rails; if your header needs to convey a value like that, you need to be prepared for a failure.\r\n\r\nThe difference here, I think, is that most of the other advertised minimums are typically going to blow out the size of a single header so much that other limits will be seen first, whereas a (say) 62-bit integer will tickle this well inside the size of a \"normal\" header.",
          "createdAt": "2019-01-24T23:47:56Z",
          "updatedAt": "2019-01-24T23:47:56Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A lot of this design is predicated on the notion that these header fields are going to be ignored by peers that don't understand the basic header field.  I think that ignoring the value that goes out of range is fine.  \r\n\r\nThe risk, now that I think about it is in responses: client says \"X\", server supports X and responds with an \"X\" with a too-large value.  That creates a situation where the client might think that X is not supported and so it acts as though it were not, when it was.\r\n\r\nThe fix is to say that servers need to be more conservative about the values they send.  Without a signal that a client supports things outside of the envelope that this spec guarantees, they can't.  That would be general advice, because maybe the consequences aren't that bad for some values of X.\r\n\r\nDoes that need text?\r\n\r\n(Otherwise, I agree with @mnot here.)",
          "createdAt": "2019-01-24T23:50:43Z",
          "updatedAt": "2019-01-24T23:50:43Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That's smaller than the range we've discussed as desirable; a bit smaller than -2^50 to 2^50. We already say:\r\n> \r\n> > Integers have a range of \u22129,223,372,036,854,775,808 to 9,223,372,036,854,775,807 inclusive (i.e., a 64-bit signed integer).\r\n> > The ABNF for integers in HTTP/1 headers is:\r\n> > sh-integer = [\"-\"] 1*19DIGIT\r\n\r\nIt is much easier for to spec and for people to get 15 digits right, than it is to get some strange power of two right, and in terms of range, both values are equally arbitrary.",
          "createdAt": "2019-01-26T10:37:53Z",
          "updatedAt": "2019-01-26T10:37:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@bsdphk AIUI you're saying that this approach:\r\n\r\n1. Count the digits (ignoring the sign) to see if they violate a length limit\r\n2. Parse as an integer\r\n\r\nis easier to get right than:\r\n\r\n1. Parse as an integer\r\n2. Check the integer to see if it's in a pre-defined range\r\n\r\nCorrect? If so, can folks weigh in?",
          "createdAt": "2019-02-11T04:39:40Z",
          "updatedAt": "2019-02-11T04:39:40Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed",
          "createdAt": "2019-02-11T05:03:37Z",
          "updatedAt": "2019-02-11T05:03:37Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot \r\n\r\nYes.  Counting 15 digits is much easier than looking up what 1<<53 is.",
          "createdAt": "2019-02-13T08:06:17Z",
          "updatedAt": "2019-02-13T08:06:17Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Considering that this is about minimum maximum, I tend to agree that 15 digits is better.\r\n\r\nWe want people to implement the boundary checks, and it's beneficial to define it as something that can be implemented easily (e.g., by using regular expression).",
          "createdAt": "2019-02-13T12:12:19Z",
          "updatedAt": "2019-02-13T12:12:19Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "On Wed, Feb 13, 2019 at 04:12:21AM -0800, Kazuho Oku wrote:\n> We want people to implement the boundary checks, and it's beneficial to\n> define it as something that can be implemented easily (e.g., by using regular\n> expression).\n\nWhile I find it a bit sad to lose 3 more bits, I tend to agree on the ease\nof applying length checks when parsing.\n\nIt's a bit sad that after removing so many bits we don't have enough anymore\nto transport a timespec (32+20 bits) though, but I guess it might not be used\nthat much anyway.\n\nMaybe we could extend the range a bit by covering -4999999999999999 to\n+4999999999999999, which are not significantly harder to check especially\nusing regex, and cover a bit more than 52 bits ?\n\n",
          "createdAt": "2019-02-13T13:22:49Z",
          "updatedAt": "2019-02-13T13:22:49Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It's a bit sad that after removing so many bits we don't have enough anymore to transport a timespec (32+20 bits) though, but I guess it might not be used that much anyway.\r\n\r\nI think you meant timeval (microsecond granularity ~ 20 bits) rather than timespec (nanosecond granularity ~30 bits). Anyways, my understanding is that POSIX is obsoleting timeval in favor of timespec. (Un)fortunately, timespec cannot be represented as a IEEE 754 double precision number.",
          "createdAt": "2019-02-13T13:47:29Z",
          "updatedAt": "2019-02-13T13:47:29Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "On Wed, Feb 13, 2019 at 01:47:31PM +0000, Kazuho Oku wrote:\n> I think you meant timeval (microsecond granularity ~ 20 bits) rather than\n> timespec (nanosecond granularity ~30 bits).\n\nIn fact I initially thought about timespec and gave the numbers for timeval!\nSo I mixed them.\n\n> Anyways, my understanding is that\n> POSIX is obsoleting timeval in favor of timespec. (Un)fortunately, timespec\n> cannot be represented as a IEEE 754 double precision number.\n\nYep indeed.\n",
          "createdAt": "2019-02-13T14:51:06Z",
          "updatedAt": "2019-02-13T14:51:06Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  (Un)fortunately, timespec cannot be represented as a IEEE 754 double precision number.\r\n\r\nYou absolutely can, but you only get about \u00bc microsecond resolution until 2038, and then only \u00bd microsecond resolution.  It is surprisingly hard to make that loss of precision matter (said the first person to ever wrangle a UNIX-style kernel at the nanosecond level :-)\r\n\r\n",
          "createdAt": "2019-02-14T08:01:52Z",
          "updatedAt": "2019-02-14T08:01:52Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "On Thu, Feb 14, 2019 at 12:01:55AM -0800, Poul-Henning Kamp wrote:\n> It is surprisingly hard to make that loss of precision matter\n\nIt just depends if you use it for estimation (sort by date) or to transport\nexact information (file timestamp) needed to be retrieved unaltered at\nanother point in time (as a complement to make a unique key for example).\n\nAs an example, I've had a WiFi camera which used to take snapshots, and\nI noticed that certain random files were listed but impossible to retrieve,\nreturning 404. They were all indexed by date, and I suspected that their\nreported dates were inaccurate and didn't match the value presented in the\nlink. The problem was likely deeper as only second-resolution was involved\nbut that was to give an example use case.\n\n",
          "createdAt": "2019-02-14T08:08:57Z",
          "updatedAt": "2019-02-14T08:08:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@bsdphk:\r\n\r\n> Counting 15 digits is much easier than looking up what 1<<53 is.\r\n\r\nSorry to belabour the point, but I want to understand your motivation here.\r\n\r\nAre you saying:\r\n\r\n1) It's easier/less error prone for people to enforce a limit at a base10 boundary because that's how most people think\r\n2) It's easier/less error prone to count digits and then parse, rather than parse and enforce a limit after the fact\r\n3) Something else?\r\n\r\nMy thinking:\r\n\r\n(1) may be true, but it seems like a very weak motivation (people can cut and paste the boundary values from the spec, and we have a test suite), especially if it loses us some capability. If this is really just about saving an implementer a small amount of *effort*, I'm firmly on the side of giving users the most range we reasonably can.\r\n\r\n(2) will catch cases when a parser can process a string that contains a value that's not within bounds, but then somehow ends up with something that is. There are cases where that's demonstrably true (e.g., `3e5`), but we can catch those with a combination of further pre-processing steps (e.g., \"if the string contains anything but a digit, fail parsing\") and tests.\r\n\r\nIs there a case where invalid input will evade those pre-processing steps and still produce a valid output? My understanding that excessive values can cause imprecision once you exceed a threshold, but the returned value is never below that threshold (in the case of JS above 2^53).\r\n",
          "createdAt": "2019-02-14T22:54:19Z",
          "updatedAt": "2019-02-14T22:54:19Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot:\r\n\r\nI'm saying:  If we are to have an arbitrary limit, we should pick the most convenient one, since the precise value does not matter.\r\n\r\n1: Yes, absolutely.\r\n\r\nStrictly speaking, loosing the ability to communicate numbers in the \u00b1 [1000000000000000:9007199254740991] ranges is a \"loss of some capability\" but compared to a simpler specification you can validate by eyeball, it doesn't matter.\r\n\r\n2: Yes, if you prefer to do it that way.\r\n\r\n3: It is a much easier rule to remember and implement, exactly because it does _not_ happen right on the edge of what an ieee754 double can represent faithfully.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-02-15T09:31:36Z",
          "updatedAt": "2019-02-15T09:31:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The other aspect here is that the PR still allows up to 19 digits -- so the range being potentially lost is actually [10,00,000,000,000,000:9,223,372,036,854,775,807] -- if the implementation chooses to support more than the minimum required.\r\n\r\nFolks who need numbers in those ranges would benefit from SH more than small ones, so I suspect rather than serialising them in strings, we'll need to add a BigNum type to SH. \r\n\r\nI'm OK waiting to do that. Mostly, I want to make sure we all understand and agree to what we're doing here.",
          "createdAt": "2019-02-27T05:06:21Z",
          "updatedAt": "2019-02-27T05:06:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "PTAL at the commit above.",
          "createdAt": "2019-04-10T07:50:54Z",
          "updatedAt": "2019-04-10T07:50:54Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Works for me.",
          "createdAt": "2019-04-10T08:37:02Z",
          "updatedAt": "2019-04-10T08:37:02Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "OK as well",
          "createdAt": "2019-04-11T04:00:09Z",
          "updatedAt": "2019-04-11T04:00:09Z"
        }
      ]
    },
    {
      "number": 739,
      "id": "MDU6SXNzdWUzOTA4NjUzMDU=",
      "title": "Missing definition for incoming-request in Check Vary",
      "url": "https://github.com/httpwg/http-extensions/issues/739",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "variants"
      ],
      "body": "https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#check_vary refers to \"incoming-request\" without saying what it refers to. I suspect it intends to use the same-named parameter to https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#cache.",
      "createdAt": "2018-12-13T21:22:23Z",
      "updatedAt": "2019-07-05T04:11:30Z",
      "closedAt": "2019-07-05T04:11:30Z",
      "comments": []
    },
    {
      "number": 740,
      "id": "MDU6SXNzdWUzOTA5MTk0MzQ=",
      "title": "Default values for Language (and others?)",
      "url": "https://github.com/httpwg/http-extensions/issues/740",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "https://github.com/httpwg/http-extensions/compare/master...jyasskin:incomplete-cache-example shows an example of an origin server that contains English, French, and German versions of a resource, a cache that has cached the English and French versions, a request that asks for German or Spanish, and, I believe, permission in the spec for the cache to return the English version instead of asking the origin server for the German version.\r\n\r\nThis happens because https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#content-language appends the first Variant to the list of requested languages even if the list of requested languages overlaps with the available variants. Is this a mistake in the algorithm, or intentional for some reason?",
      "createdAt": "2018-12-14T00:39:01Z",
      "updatedAt": "2019-01-07T02:54:04Z",
      "closedAt": "2019-01-07T02:54:04Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The language algorithm does that so that an origin can denote a 'default' language -- i.e., what to serve if there isn't any overlap between the client's preferences and what's available. \r\n\r\nFor example, if a user configures their browser to send `Accept: de` and the page is only available in English and French, there needs to be a way to say \"send English by default.\"\r\n\r\nI don't know of any use case where someone would want to serve a hard error when the language doesn't match, but if that's in scope, we could figure something out.\r\n\r\nIf you're looking for something more deterministic in caches (here, the distinction between \"these ar the responses that are available and preferred\" and \"here's the default\" is blurred), I'm interested.\r\n\r\nP.S. in that diff, the line with the comment \"prefers French, will accept English(?)\" seems wrong.\r\n```\r\n",
          "createdAt": "2019-01-03T01:48:15Z",
          "updatedAt": "2019-01-03T01:48:15Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think #741 establishes the default language without confusing it with the responses that are available and preferred.\r\n\r\nI am also not interested in a hard error when the language doesn't match.\r\n\r\nAnd thanks, I've fixed the example.",
          "createdAt": "2019-01-03T19:32:22Z",
          "updatedAt": "2019-01-03T19:32:22Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'm not entirely happy with the optionality of behaviour on the cache's part with those MAYs.\r\n\r\nThe most explicit thing we could do would be to break this information out into a separate header (e.g., `Variant-Defaults`), but sticking with the current syntax for the moment, what if we had special values that, when occurring in that first slot, indicate that the default should NOT match?\r\n\r\nE.g.,\r\n\r\n~~~\r\nVariants: Accept-Encoding;gzip;br, Accept-Language;!;en ;fr\r\n~~~\r\n\r\nwhere `!` does the magic.",
          "createdAt": "2019-01-04T04:54:10Z",
          "updatedAt": "2019-01-04T04:54:10Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm personally happy with turning those MAYs into MUSTs. They're MAYs because that's what was in the older RFCs, but I agree that I don't like making things optional. If I do this in my update tomorrow morning, do you still want to explore the `!` token? I don't really like it because it seems like always the wrong thing for a client to send. I also don't see a particular need to pull the defaults out to a separate header.",
          "createdAt": "2019-01-04T05:10:49Z",
          "updatedAt": "2019-01-04T05:10:49Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'm a bit interested in `!`, but not adamant. I think it'd be fine if they flipped to MUST as long as the implications were noted.",
          "createdAt": "2019-01-04T06:04:56Z",
          "updatedAt": "2019-01-04T06:04:56Z"
        }
      ]
    },
    {
      "number": 742,
      "id": "MDU6SXNzdWUzOTE5MDI3MDc=",
      "title": "Mention the difference between an sh-token and a token",
      "url": "https://github.com/httpwg/http-extensions/issues/742",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#token defines a structured-header token as something different from an [HTTP token](https://tools.ietf.org/html/rfc7230#section-3.2.6). Formally, this is fine, since SH defines `sh-token`, while HTTP defines `token`, but I almost missed the difference as a reader. It'd be nice if the text mentioned it.",
      "createdAt": "2018-12-17T21:45:47Z",
      "updatedAt": "2019-01-10T00:17:08Z",
      "closedAt": "2019-01-10T00:17:08Z",
      "comments": []
    },
    {
      "number": 743,
      "id": "MDU6SXNzdWUzOTIzMDcyMTQ=",
      "title": "Cache behavior examples are out of date wrt new Variant-Key format",
      "url": "https://github.com/httpwg/http-extensions/issues/743",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#example-of-cache-behaviour shows a Variant-Key of\r\n\r\n```http\r\nVariant-Key: fr, gzip\r\n```\r\n\r\nBut that's now [spelled](https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#variant-key)\r\n\r\n```http\r\nVariant-Key: fr;gzip\r\n```\r\n\r\nThis also has implications for the https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#gen-variant-key algorithm, which currently ignores semicolons. ",
      "createdAt": "2018-12-18T19:45:35Z",
      "updatedAt": "2019-01-07T02:52:41Z",
      "closedAt": "2019-01-07T02:52:41Z",
      "comments": []
    },
    {
      "number": 745,
      "id": "MDU6SXNzdWUzOTU0MjYyNzU=",
      "title": "Cache behavior when Variants header is absent",
      "url": "https://github.com/httpwg/http-extensions/issues/745",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#cache seems to return an empty result when the freshest stored-response has not Variants header, which seems to disable caching entirely when backends haven't adopted the new spec yet. That's probably not what you meant?",
      "createdAt": "2019-01-03T00:43:24Z",
      "updatedAt": "2019-08-30T09:01:49Z",
      "closedAt": "2019-08-30T09:01:49Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The intent is to fall back to `Vary` processing when the freshest response doesn't have a `Variants` header field.",
          "createdAt": "2019-01-08T03:25:56Z",
          "updatedAt": "2019-01-08T03:25:56Z"
        }
      ]
    },
    {
      "number": 747,
      "id": "MDU6SXNzdWUzOTY3MDU5NDA=",
      "title": "Use of draft Variants",
      "url": "https://github.com/httpwg/http-extensions/issues/747",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "We're looking at shipping a version of Signed Exchanges (https://github.com/WICG/webpackage/issues/350; designed to expect more changes in the future, of course) that uses the draft `Variants` header. In https://tools.ietf.org/html/draft-thomson-http-mice-03#page-4, we specify that implementations of the MICE draft use digests named `mi-sha256-##`, so `mi-sha256-03` for draft-03. Variants does not yet specify anything like this, which introduces a risk that we'll unintentionally introduce uses of the current draft into the wild, which could make it harder to change in the future.\r\n\r\nI'll send a PR to suggest that draft implementations use HTTP headers named `Variants-05` and `Variant-Key-05` later this week, if you don't mind.",
      "createdAt": "2019-01-08T00:41:35Z",
      "updatedAt": "2019-01-10T01:39:08Z",
      "closedAt": "2019-01-10T01:39:08Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Sure.",
          "createdAt": "2019-01-08T04:56:03Z",
          "updatedAt": "2019-01-08T04:56:03Z"
        }
      ]
    },
    {
      "number": 748,
      "id": "MDU6SXNzdWUzOTY3NTg0ODk=",
      "title": "header field",
      "url": "https://github.com/httpwg/http-extensions/issues/748",
      "state": "OPEN",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "From Julian's review.",
      "createdAt": "2019-01-08T05:42:43Z",
      "updatedAt": "2019-01-08T05:42:43Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 751,
      "id": "MDU6SXNzdWUzOTc4NjUxNDA=",
      "title": "HTTP/2 dependency tree is racy",
      "url": "https://github.com/httpwg/http-extensions/issues/751",
      "state": "CLOSED",
      "author": "pmeenan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The way HTTP/2 dependencies work requires the client and server to maintain dependency trees that are (at least somewhat) in sync.\r\n\r\nWhen the client starts a new stream as a child of an existing stream it provides the parent stream ID. If the parent stream ID is unknown to the server then the dependency information is [thrown away and the stream is given a default priority](https://tools.ietf.org/html/rfc7540#section-5.3.1).\r\n\r\nIn practice this is causing racy issues with Chrome's dependency tree and some server implementations. Chrome attempts to build a linear list of streams with each stream exclusively dependent on the stream before it. Higher priority streams are placed in the list ahead of lower priority streams. Each stream is also assigned a weight that maps to Chrome's internal \"priority\" though the weight is largely inconsequential when the dependency ordering is working because each request is always exclusively dependent on the parent in a list.\r\n\r\n![start](https://user-images.githubusercontent.com/444165/50975374-6f48e980-14bb-11e9-85fe-5c17e848f6ff.png)\r\n\r\nWhen a new stream is initiated that is a higher priority than the end of the list it is attached as an exclusive dependent of the last stream in the list with a higher priority (inserting it into the ordered priority list):\r\n\r\n![insert](https://user-images.githubusercontent.com/444165/50975460-a7e8c300-14bb-11e9-9d0b-3cb4af50b687.png)\r\n\r\nThis is where things get racy. If the server has already sent the last part of the new parent stream but the bytes are in-flight and the client doesn't know the stream has closed yet it is possible that the server no longer knows about the parent stream that the new stream is trying to attach to. When that happens, the new stream is given a default priority (weight 16 and attached to the root).\r\n\r\n![after](https://user-images.githubusercontent.com/444165/50975592-f6965d00-14bb-11e9-91c3-797a0f9b9fe8.png)\r\n\r\nAt this point, what was supposed to be a high-priority stream inserted ahead of streams 5-9 is now a parallel stream with a MUCH lower weight, effectively starving it and largely delaying it until all of the requests in the original list complete.\r\n\r\nThis issue was exposed with my initial [HTTP/2 prioritization test](https://github.com/pmeenan/http2priorities) which flagged both Google's and h2o's HTTP/2 implementations as not working because the race condition was being triggered. I don't know how often it happens in the wild.\r\n\r\nh2o has mitigated the issues somewhat by remembering a set number of completed streams, reducing the likelihood that a completed stream will be needed as a parent but it is still possible to trigger depending on the size of in-flight buffers and the size of the high-priority requests (a lot of small streams and large buffers can still exhaust the dead-stream list).\r\n\r\nAdding support for something like a FIN ACK from the client when a stream completes and only deleting streams on the server when ACK'd should at least make it deterministic.\r\n\r\nAs the HTTP/3 spec is being finalized, it might be worth considering if a stateful dependency tree is really needed or if a stateless prioritization scheme more similar to what SPDY originally used might be easier (both for servers and browsers).",
      "createdAt": "2019-01-10T14:50:43Z",
      "updatedAt": "2019-03-12T04:50:16Z",
      "closedAt": "2019-03-12T04:50:15Z",
      "comments": [
        {
          "author": "pmeenan",
          "authorAssociation": "NONE",
          "body": "btw, huge thanks to the Fastly dev team for identifying the root cause of the prioritization issues in h2o. I'm largely just documenting their findings for the working group.",
          "createdAt": "2019-01-10T14:54:35Z",
          "updatedAt": "2019-01-10T14:54:35Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "HTTP/3 attempts to address this by specifying how long closed streams should remain in the priority tree, which helps achieve consistency.  Also, your observation begins to get into what we realized, which is that almost all priority races trace back to the Exclusive flag -- we removed that because it wasn't possible to eliminate races otherwise.\r\n\r\nWe've also had some discussion about extensions to provide alternative priority schemes.  So far no drafts for alternatives, but I expect to see some sooner or later.",
          "createdAt": "2019-01-10T17:26:29Z",
          "updatedAt": "2019-01-10T17:26:29Z"
        },
        {
          "author": "pmeenan",
          "authorAssociation": "NONE",
          "body": "@MikeBishop what is the best way to propose a draft for an alternative priority scheme?\r\n\r\nI'm not sure getting rid of the exclusive flag helps with the raciness of an insert operation.  To Insert stream 11 in the example I assume the client would set stream 11 to depend on stream 3 and send a priority frame for stream 5 to set the parent to stream 11.  If stream 3 and 5 are both in-flight (or otherwise out of sync), stream 11 will still get the default prioritization and stream 5 will not be re-parented and you end up with the same result.",
          "createdAt": "2019-01-15T18:16:35Z",
          "updatedAt": "2019-01-15T18:16:35Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Write an I-D, send it to the HTTPbis list.  (HTTPbis will own extensions to HTTP/3 after publication, so they're probably the right venue.)\r\n\r\nIn your example, B currently depends on A, and the following two instructions are in flight:\r\n- On stream C:  C depends on A\r\n- On control stream:  B depends on C\r\n\r\nThe end state of these is the same, regardless of the order in which they're applied.  It's true that there could be an intermediate state in which B depends on C which depends on the root of the tree -- what we concluded was that the requirement was eventually reaching the same state, and that transient differences were tolerable.\r\n\r\n(Repeating Stream C's prioritization on the control stream before the prioritization of B would ensure this cannot happen, if the client cares.)",
          "createdAt": "2019-01-15T18:41:25Z",
          "updatedAt": "2019-01-15T18:41:25Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing, as this is not about a currently in-progress HTTP extension spec. Please do continue discussion on-list and/or write a draft.",
          "createdAt": "2019-03-12T04:50:15Z",
          "updatedAt": "2019-03-12T04:50:15Z"
        }
      ]
    },
    {
      "number": 752,
      "id": "MDU6SXNzdWUzOTgzODgwNTk=",
      "title": "Clarify difference from chunked",
      "url": "https://github.com/httpwg/http-extensions/issues/752",
      "state": "OPEN",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "rand-access-live"
      ],
      "body": "I know we're late in the document cycle, but some feedback that was relayed to me:  It's not always clear why this mechanism is better than simply using chunked encoding to stream the live content.  I think the answer is in the document title -- this permits the same resource to serve both live content (as chunked) *and* random-access to past content (as a range request).",
      "createdAt": "2019-01-11T17:42:59Z",
      "updatedAt": "2019-01-13T22:09:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "[Thanks for the feedback/thoughts. I actually thought the document cycle was over - but this draft has been on such a slow burn (and I've had so much go into and out of my brain) that the process never crystalized in my head - despite a couple taps with the clue stick by Patrick and company. If there was an IETF dunce cap, I'd nominate myself for it...]\r\n\r\nAnyway, whether the content is transferred as chunked or non-chunked is actually orthogonal to the to whether the content is static or live/aggregating - and also orthogonal to Range - unless there's something I'm missing? (I see Chunked in the \"how to transfer\" category and content type/Range are \"what to transfer\" category)\r\n\r\nSpecifically, for strictly live content (non random-access), you can transfer it chunked or non-chunked. Chunked allows the sender to more explicitly signal the end of the live streaming - and allow the connection to stay open - by sending a 0-length chunk. In non-chunked transfer of live content, the sender has to close the connection when the live streaming is completed (since Content-Length can't be provided). (discussing only HTTP 1.1 here)\r\n\r\nSo yeah - this entire draft is discussing how to support live content that also has random access support - and is titled accordingly. But as is the case with non-random-access live streaming, content transfer of Range responses can be chunked or non-chunked. \r\n\r\nI intentionally left out \"Content-Length\" headers from the examples because that would imply non-chunked responses and I didn't want to confuse people. And while I could discuss both chunked and non-chunked response forms, I was trying to keep the draft focused/short - and I wanted to keep it future-proof by not discussing transfer forms (esp in the world of HTTP/2+). I also didn't discuss non-random-access live content (as a \"remedial/background\" section for similar reasons.\r\n\r\nI'd like to get this (experimental) draft \"out there\" and get some feedback from implementors on what's working/not working (and what need to be better clarified/described). But if there's a real issue with comprehension we should address it in this draft. So let me know if you think this falls into that latter category. (this is all something I need to tell myself or I'll keep editing forever)\r\n\r\nDisclaimer: I'm writing this off the top of my head - and haven't been working in HTTP specs for a while. So please correct me if I missed some rule about chunking, Range, etc.",
          "createdAt": "2019-01-12T00:20:09Z",
          "updatedAt": "2019-01-12T00:20:09Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that Craig's analysis is correct.  Chunked encoding is orthogonal to this.",
          "createdAt": "2019-01-13T22:09:03Z",
          "updatedAt": "2019-01-13T22:09:03Z"
        }
      ]
    },
    {
      "number": 753,
      "id": "MDU6SXNzdWUzOTg2ODgzNTk=",
      "title": "Redundant URL redirections in README.md",
      "url": "https://github.com/httpwg/http-extensions/issues/753",
      "state": "CLOSED",
      "author": "SuriyaaKudoIsc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "All related IETF HTTP Working Group links in [`README.md`](https://github.com/httpwg/http-extensions/blob/master/README.md) redirect from the [httpwg.github.io](https://httpwg.github.io/) domain to [httpwg.org](https://httpwg.org/).\r\n",
      "createdAt": "2019-01-13T19:04:08Z",
      "updatedAt": "2019-01-14T05:57:09Z",
      "closedAt": "2019-01-14T05:57:09Z",
      "comments": []
    },
    {
      "number": 757,
      "id": "MDU6SXNzdWUzOTkzNDM3NzU=",
      "title": "bcp56bis: terminology URL vs URI",
      "url": "https://github.com/httpwg/http-extensions/issues/757",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis",
        "editorial"
      ],
      "body": "See https://lists.w3.org/Archives/Public/ietf-http-wg/2019JanMar/0002.html",
      "createdAt": "2019-01-15T13:25:44Z",
      "updatedAt": "2019-01-23T02:04:04Z",
      "closedAt": "2019-01-23T02:04:04Z",
      "comments": []
    },
    {
      "number": 761,
      "id": "MDU6SXNzdWU0MDMzNzY3MTg=",
      "title": "Client Hints doesn't distinguish clearly between request and response header fields",
      "url": "https://github.com/httpwg/http-extensions/issues/761",
      "state": "CLOSED",
      "author": "dbaron",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "I've been reading Client Hints (both [draft-ietf-httpbis-client-hints-06](https://tools.ietf.org/html/draft-ietf-httpbis-client-hints-06) and the [version in this repository](https://github.com/httpwg/http-extensions/blob/master/draft-ietf-httpbis-client-hints.md)), and I'm having a little trouble understanding how things fit together in terms of which header fields are sent when and lead to what.\r\n\r\nMy confusion started when I looked at the [IANA Considerations](https://tools.ietf.org/html/draft-ietf-httpbis-client-hints-06#section-6) section and noticed (to my surprise) that `Accept-CH` was being registered as *both* a request header field *and* a response header field (when, having read the spec quickly, I was expecting it to be only a response header field, and wasn't sure what it would mean as a request header field).\r\n\r\nThen I looked back over the spec, and noticed that section 2 of the spec is called [Client Hint Request Header Fields](https://tools.ietf.org/html/draft-ietf-httpbis-client-hints-06#section-2) but that the entirety of the section appears (I think) to be about *response* header fields.\r\n\r\nI think it would help the spec be easier to understand if it:\r\n* more carefully distinguished between request header fields and response header fields, and\r\n* more clearly explained what the `Accept-CH` *request* header field is.",
      "createdAt": "2019-01-25T23:55:43Z",
      "updatedAt": "2019-07-25T14:40:58Z",
      "closedAt": "2019-07-25T14:40:58Z",
      "comments": []
    },
    {
      "number": 762,
      "id": "MDU6SXNzdWU0MDM1NzczNDA=",
      "title": "SameSite Cookies and Iframes",
      "url": "https://github.com/httpwg/http-extensions/issues/762",
      "state": "OPEN",
      "author": "devd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis",
        "samesite"
      ],
      "body": "If I have a website that I want to allow framing by trusted third-parties (via CSP frame-ancestors), I can't use SameSite cookies to prevent CSRF attacks. This is unfortunate as it limits adoption of samesite cookies as the standard mechanism to protect against CSRF attacks.  I have run into multiple projects where I can't use same site cookies due to this issue.\r\n\r\nI would love a flag that tells the user agent to treat requests from framed pages as same site.",
      "createdAt": "2019-01-27T17:58:34Z",
      "updatedAt": "2020-04-17T15:17:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not that I like the proliferation of cookies, but can\u2019t you set both SameSite and non-SameSite cookies and then make the decision server-side what to allow in the framed and the non-framed cases? You\u2019re in control of which sites can frame you through CSP.\r\n\r\nIn the case of Safari (default settings), such framing across sites will lead to classification of the domain as having cross-site tracking abilities and thus its cookies will be blocked in third-party contexts. CSRF is then automatically prohibited since the frame needs to call the Storage Access API to get cookie access.",
          "createdAt": "2019-01-27T19:07:40Z",
          "updatedAt": "2019-01-27T19:07:40Z"
        },
        {
          "author": "devd",
          "authorAssociation": "NONE",
          "body": "So, I don't fully understand the Safari setup, but I believe once the Storage access API is requested, the app will still need CSRF protections within the frame, right? I.e., once the user grants permission, it will be very similar to what happens by default in Chrome?\r\n\r\nRe your point in the first paragraph: that's exactly what I want. The problem is: how do you figure out whats coming from your own page when framed vs an actual CSRF attempt from a third party page? Right now, there is no way to do that in a Samesite cookie world. If instead, I put in 2 cookies biscotti and macaron that are both same site but the macaron cookie is sent even in iframes then when my server gets a request, these decisions are easy. Here's the three settings:\r\n\r\n1. biscotti and macaron exist: a same site request when top level page is same site\r\n2. biscotti does not exist but macaron exists: a same site request but page is iframed\r\n3. both biscotti and macaron don't exist: CSRF attempt.\r\n\r\n\r\nRight now, note that what the server sees on number 2 and number 3 above is the same. ",
          "createdAt": "2019-01-28T04:33:30Z",
          "updatedAt": "2019-01-28T04:33:30Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In Safari\u2019s implementation of the Storage Access API you need user interaction in the frame per page. New page with CSRF attack => no cookies. Different iframe with CSRF attack => no cookies. We would like this to become the default way to allow a cross-site iframe to authenticate the user.\r\n\r\nI\u2019m a little rusty on the Origin header. Won\u2019t it be there in the requests you want to accept? That combined with CSP control of which sites can frame you should suffice.\r\n\r\nFor further protection you have the Cross Origin Resource Policy response header.",
          "createdAt": "2019-01-28T05:00:41Z",
          "updatedAt": "2019-01-28T05:00:41Z"
        },
        {
          "author": "devd",
          "authorAssociation": "NONE",
          "body": "Yeah.. I am talking about how the page can protect itself after user\ninteraction and authorization for 3rd party cookie use.\n\nUnfortunately, the origin header isn't reliable for csrf protections. Also,\ndo you have a reference for the cross origin resource policy header for\ncsrf defense? I don't think I understand that.\n\n\nOn Sun, Jan 27, 2019, 9:00 PM John Wilander <notifications@github.com wrote:\n\n> In Safari\u2019s implementation of the Storage Access API you need user\n> interaction in the frame per page. New page with CSRF attack => no cookies.\n> Different iframe with CSRF attack => no cookies. We would like this to\n> become the default way to allow a cross-site iframe to authenticate the\n> user.\n>\n> I\u2019m a little rusty on the Origin header. Won\u2019t it be there in the requests\n> you want to accept? That combined with CSP control of which sites can frame\n> you should suffice.\n>\n> For further protection you have the Cross Origin Resource Policy response\n> header.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/httpwg/http-extensions/issues/762#issuecomment-457999561>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAIXGXYAT-zwkHoBDwvUnQiyu4SQ7Griks5vHoP8gaJpZM4aU2WG>\n> .\n>\n",
          "createdAt": "2019-01-28T05:57:26Z",
          "updatedAt": "2019-01-28T05:57:26Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do you mean the case where your iframe successfully gets storage access and then a CSRF attack happens from the same iframe? Or the CSRF attack calls the Storage Access API?\r\n\r\nCORP doesn\u2019t help with traditional CSRF, but if you worry about CSRF+Spectre attacks reading your users\u2019 content, it does help.",
          "createdAt": "2019-01-28T06:03:19Z",
          "updatedAt": "2019-01-28T06:03:19Z"
        },
        {
          "author": "devd",
          "authorAssociation": "NONE",
          "body": "yup .. iframe gets storage access and now wants to hit CSRF protected\nendpoints. I can't use samesite cookies; I have to do some of the other\noptions (e.g., csrf tokens in session cookie) for csrf defense\n\nOn Sun, 27 Jan 2019 at 22:03, John Wilander <notifications@github.com>\nwrote:\n\n> Do you mean the case where your iframe successfully gets storage access\n> and then a CSRF attack happens from the same iframe? Or the CSRF attack\n> calls the Storage Access API?\n>\n> CORP doesn\u2019t help with traditional CSRF, but if you worry about\n> CSRF+Spectre attacks reading your users\u2019 content, it does help.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/httpwg/http-extensions/issues/762#issuecomment-458008216>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAIXGQOoR-Ul7aQvBOgUoD1oTLY8gvkiks5vHpKpgaJpZM4aU2WG>\n> .\n>\n",
          "createdAt": "2019-01-28T18:06:51Z",
          "updatedAt": "2019-01-28T18:06:51Z"
        },
        {
          "author": "pmhsfelix",
          "authorAssociation": "NONE",
          "body": "Any further information regarding this issue? I believe I've the exact same problem as @devd.\r\nI'm using two cookies:\r\n- A _regular cookie with session data.\r\n- A `SameSite` _marker_ cookie, without any data, that is used only to detect if the request is cross-site or not (some cross-site requests are still allowed to access session data).\r\nHowever, a request sent from an `iframe` hosted on a different site never sends the `SameSite` cookie, even after user interaction and a `Set-Cookie` inside the frame .\r\nIf I understood it correctly, this is the behaviour defined on [https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-5.2.1](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-5.2.1), however it makes it impossible to distinguish a same-site request inside an `iframe` from a real cross-site request.\r\nSo, if I'm not missing something, this makes the `SameSite` mechanism useless for CRSF protection if usage inside frames is required.",
          "createdAt": "2019-06-17T17:48:22Z",
          "updatedAt": "2019-06-17T17:48:22Z"
        },
        {
          "author": "aghassemi",
          "authorAssociation": "NONE",
          "body": "@mikewest @johnwilander @rowan-m \r\nI believe this is an important use-case that deserves consideration or at least some public documentation on best practices on how to handle in. (even despite the fact that Safari has broken iframe-based version of this use-case by default regardless of SameSite, other approaches such as querying authenticated 3P endpoints via `fetch` are still applicable in this discussion)\r\n\r\nAuthenticated embedibility is a common use-case (YouTube, social widgets, etc..), but currently there is no option to protect auth cookies from CSRF via `SameSite` (the main intended value provided by this feature) without breaking authenticated embedibility.\r\n\r\nHas there been discussions on additional values that are more lax than `lax`? Something along the lines of `none-get-strict-post` where all `GET` requests behave as if `none` is set but all `POST` requests follow as if `strict`.\r\n\r\n",
          "createdAt": "2019-08-16T16:28:47Z",
          "updatedAt": "2019-08-16T16:28:47Z"
        },
        {
          "author": "ibolmo",
          "authorAssociation": "NONE",
          "body": "@aghassemi @devd @johnwilander has there been any breakthroughs here. I'm running into the same scenario. ",
          "createdAt": "2020-03-05T14:11:36Z",
          "updatedAt": "2020-03-05T14:11:36Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "These kind of discussions should take obsoletion of third-party cookies into account. We don\u2019t know details of Chrome\u2019s plans but we know the plan is to obsolete them by January 2022.",
          "createdAt": "2020-03-05T23:24:32Z",
          "updatedAt": "2020-03-05T23:24:32Z"
        },
        {
          "author": "som-nitjsr",
          "authorAssociation": "NONE",
          "body": "I am also facing the same issue.\r\ni have site with samesite=strict cookie now i wanted to host this site it in another domain with iframe\r\ni have set the Content-Security-Policy: frame-ancestors 'self'  , other domain. but iframe is not sending the samesite cookie back to server",
          "createdAt": "2020-04-17T15:17:03Z",
          "updatedAt": "2020-04-17T15:17:03Z"
        }
      ]
    },
    {
      "number": 764,
      "id": "MDU6SXNzdWU0MDQzMzQ0NTk=",
      "title": "Refactor CH spec",
      "url": "https://github.com/httpwg/http-extensions/issues/764",
      "state": "CLOSED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Per the [discussion on HTTPWG mailing list](https://lists.w3.org/Archives/Public/ietf-http-wg/2019JanMar/thread.html#msg92), we need to...\r\n\r\n* [ ] Spec the framework in the IETF draft: how to declare which hints you want to receive, how those prefs are stored, expected and recommended cache behaviors\r\n* [ ] Move individual hints into relevant implementation specs: HTML, Fetch, or feature specific specs like NetInfo \u2014 this should resolve #697 and #698.\r\n* [ ] Updated Security and Privacy sections to capture benefits offered by CH against passive fingerprinting (see linked thread)\r\n\r\n@yoavweiss @mikewest please jump in anything if I'm forgetting anything. On a related note, for User-Agent and Accept-Language, we should work on defining those in HTML/Fetch. Does that all make sense?\r\n",
      "createdAt": "2019-01-29T15:04:58Z",
      "updatedAt": "2019-05-18T15:08:06Z",
      "closedAt": "2019-05-18T15:08:06Z",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Closing, as we now have all of the above captured in standalone issues:\r\nhttps://github.com/httpwg/http-extensions/labels/client-hints",
          "createdAt": "2019-05-18T15:08:06Z",
          "updatedAt": "2019-05-18T15:08:06Z"
        }
      ]
    },
    {
      "number": 765,
      "id": "MDU6SXNzdWU0MDQ2MDM1MjI=",
      "title": "Parameters as a set",
      "url": "https://github.com/httpwg/http-extensions/issues/765",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "This is just a reminder to look into this.",
      "createdAt": "2019-01-30T05:03:59Z",
      "updatedAt": "2019-04-10T07:45:23Z",
      "closedAt": "2019-04-10T07:45:23Z",
      "comments": []
    },
    {
      "number": 766,
      "id": "MDU6SXNzdWU0MDcwODU0Njk=",
      "title": "Refactor?",
      "url": "https://github.com/httpwg/http-extensions/issues/766",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "cache-header"
      ],
      "body": "_From Alex R on list:_\r\n\r\nIf we are to standardize X-Cache, then we should be mindful of the trap\r\ncreated by early implementations that thought a single action value can\r\nadequately relay what has happened at the proxy:\r\n\r\n1. The obvious HIT and MISS actions came first.\r\n\r\n2. Then we quickly discovered that a \"we found it in the cache\" HIT\r\naction is often followed by a REFRESH action (and a resulting MISS from\r\nthe proxy-server traffic point of view). HIT_REFRESH... concatenations\r\nwere used to combat this.\r\n\r\n3. Realizing that even fresh cache HITs may become misses due to various\r\nprotocol requirements and internal problems, some added X-Cache-Lookup\r\nthat was dedicated to the first (and often critical for triage) cache\r\nlookup, depicting what happened to that HIT later in X-Cache.\r\n\r\n4. Then flash crowds and collapsed forwarding solutions came along. Now,\r\na single client HIT or MISS request could cause even more transactions,\r\nsome of which could be cache hits, some could be revalidations or even\r\nerrors. Some added COLLAPSED_HIT_REFRESH... and/or other variants. This\r\nconcatenation approach still loses a lot of info, but it highlights the\r\nfact that a lot of info could be lost by including the COLLAPSED tag.\r\n\r\nIf the goal here is to standardize the current status quo, then the\r\ndocument should cover Cache-Lookup and COLLAPSED tags (and/or their\r\nvariations).\r\n\r\nIf the goal here is to standardize a scalable solution based on the\r\ncurrent experience, then we should combine Cache-Lookup and Cache while\r\nenumerating individual cache actions as separate same-node entries\r\n(instead of trying to merge them into a single FOO_BAR_BAZ super-action\r\nsummary for one node).",
      "createdAt": "2019-02-06T05:23:56Z",
      "updatedAt": "2019-11-28T05:03:06Z",
      "closedAt": "2019-11-28T05:03:06Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It's a good question, I think. So far we've been trying to \"pave the cowpath\" of existing practice. If we were to refactor the specification, I think we'd need a number of flags / fields, e.g., something along the lines of (ignore syntax issues for now):\r\n\r\n- `uri-stored` - was there any stored response that matched the request URL?\r\n- `variant-stored` - was the cache able to select one (or more) stored responses based upon `Vary` / `Variants` / local config?\r\n- `server-fresh` - was the selected response fresh, according to its response freshness controls?\r\n- `client-fresh` - was the selected response fresh, according to its request freshness controls (if the cache is paying attention to them)?\r\n- `went-forward` - did the request go forward to an origin server (validating or not)?\r\n- `request-collapsed` - was the request collapsed with one or more other forward requests?\r\n- `forward-validating` - was the forward request a validating request?\r\n- `forward-not-modified` - was the forward response a 304?\r\n\r\nWhat do folks (especially cache implementers!) think?",
          "createdAt": "2019-07-01T08:01:26Z",
          "updatedAt": "2019-07-01T08:01:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Feedback from Jozef - HIT_PASS / NEGATIVE_HIT needs something explicit.",
          "createdAt": "2019-08-02T21:22:06Z",
          "updatedAt": "2019-08-02T21:22:06Z"
        },
        {
          "author": "thpts",
          "authorAssociation": "NONE",
          "body": "I had many months ago [written up a fair deal about existing public implementations](https://gist.github.com/thpts/76530c47609293f5d9a2809c3aa4d2af) and I have concluded a few points:\r\n* Very few cache implementors either have, or expose anything more complicated than \"`HIT`\" or \"`MISS`\".\r\n* Non-public implementations (e.g. CDNs) that I have observed appear to have no consistent caching behaviour, particularly as they are almost always multi-tiered operations - and this specification as I read it does not lend itself towards those.\r\n* It is not clear to me how in 5-10 years time what caching systems may look like with regards to the state automata they operate.\r\n\r\nI understand @mnot you also had some some analysis, is it worth sharing it here to compare?\r\n\r\nTo me it makes more sense to define less cache actions and extend the specification to allow for cache implementors to implement additional actions that allow them to better describe their own systems. How this might be expressed in specification I'm unsure presently but might come up with a pull request.",
          "createdAt": "2019-08-27T19:36:20Z",
          "updatedAt": "2019-08-27T19:36:20Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> Very few cache implementors either have, or expose anything more complicated than \"HIT\" or \"MISS\".\r\n\r\nOh, I disagree; ATS is quite nuanced, and Squid offers a fair amount of state. Nothing documented in the spec right now is really new; it's all exposed by implementations, often more than one.\r\n\r\n>  Non-public implementations (e.g. CDNs) that I have observed appear to have no consistent caching behaviour, particularly as they are almost always multi-tiered operations - and this specification as I read it does not lend itself towards those.\r\n\r\nIt allows multiple hops to add values, so you can see what different caches in the hierarchy have done -- if the CDN wants to expose that information.\r\n\r\n> It is not clear to me how in 5-10 years time what caching systems may look like with regards to the state automata they operate.\r\n\r\nGiven how little it's changed in the last twenty years, at the core, I'm not too concerned about this; we can always extend or add a new header.",
          "createdAt": "2019-08-30T06:18:58Z",
          "updatedAt": "2019-08-30T06:18:58Z"
        }
      ]
    },
    {
      "number": 767,
      "id": "MDU6SXNzdWU0MDk1MzIzMzU=",
      "title": "Client-Hints exposes fingerprint values to additional parties and logging sensitive locations",
      "url": "https://github.com/httpwg/http-extensions/issues/767",
      "state": "CLOSED",
      "author": "pes10k",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "From PING:\r\n\r\nWe're concerned about the privacy implications of moving these attributes to header values, specifically since header values are more likely to wind up in passive / middle man / etc logs. Existing approaches require active techniques, and so (partially) reduce the fingerprinting risk.\r\n\r\nThe most on point issue I can find addressing this issue is https://github.com/httpwg/http-extensions/issues/215, but this isn't quite on point (does not address increased risk from moving to passive collection).\r\n\r\nI see the text added / modified in https://github.com/httpwg/http-extensions/commit/2ba199856ae926284fe868de7c257009f01fe3b8 that mentions that \"implementors can do otherwise for privacy\", but PING is uncomfortable with such text ( such text dissolve the point of the standard; a standard that says \"its w/in this standard to vary arbitrarily\", then all that is introduced is web compatibility problems for privacy oriented parties).\r\n\r\n* What discussion has been had regarding increased information leak into logs? \r\n* What measurements / data exists to suggest this is not a problem?",
      "createdAt": "2019-02-12T22:35:51Z",
      "updatedAt": "2019-11-19T21:32:40Z",
      "closedAt": "2019-11-19T15:51:58Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "HI @snyderp. Be aware that people participate in the IETF as individuals, not organisations; if people in PING (aside for other readers: this is the W3C Privacy Interest Group) want to engage here, they'll need to do so individually. \r\n\r\nMy understanding is that the current thinking around CH considers the requirement for a site to request a specific CH (in the form of the Accept-CH) as effectively \"converting\" passive collection to active collection; a researcher, for example, can measure how many sites are collecting such metrics, and a browser can alert the user when such collection is taking place.\r\n\r\nThere was a substantial amount of discussion around this, including in #215, #372 and elsewhere.\r\n\r\nAre you questioning that, or are you only focusing on information leakage into logs? \r\n\r\nRegarding the latter, can you illustrate how that would happen, and what the impact would be?",
          "createdAt": "2019-02-12T23:46:03Z",
          "updatedAt": "2019-02-12T23:46:03Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "@mnot thank you for your reply.\r\n\r\n> My understanding is that the current thinking around CH considers the requirement for a site to request a specific CH (in the form of the Accept-CH) as effectively \"converting\" passive collection to active collection; a researcher, for example, can measure how many sites are collecting such metrics, and a browser can alert the user when such collection is taking place.\r\n\r\nResearchers and clients already do exactly the things you mentioned.  CH doesn't help make preventing / measuring / notifying of FP & tracking any easier.  I'm similarly not familiar (and don't see any related comment in CH tagged issues) to deprecate / remove the existing methods for retrieving the same information, so the responsibility / burden on privacy focused parities is strictly increased.\r\n\r\n> There was a substantial amount of discussion around this, including in #215, #372 and elsewhere.\r\n\r\nI am aware of this conversation, i referenced a commit in mentioned in #215 above for example :) . But in general, im not sure I understand the connection to the above issues to the concern here, which is \"values in headers get treated categorically differently, and persisted longer, than variables in JS\" :)\r\n\r\n> Are you questioning that, or are you only focusing on information leakage into logs?\r\n> Regarding the latter, can you illustrate how that would happen, and what the impact would be?\r\n\r\nNeither issue addresses the concerns regarding logging (and more broadly, that putting FP sensitive values in headers increases the risk of long term privacy leaks / tracking).\r\n1) middle parties (CDN, proxies, other HTTP terminators) get access to data they would previously would not have had access too\r\n2) that data is more likely to be persisted in long term logs than if its collected \"actively\" in JS\r\n3) HTTP logs, that may now include these values, are often shared with third parties, furthering privacy risk.  \r\n\r\nI can go on :) But i hope this helps explain / motivate the concern further",
          "createdAt": "2019-02-13T01:11:37Z",
          "updatedAt": "2019-02-13T01:11:37Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We're concerned about the privacy implications of moving these attributes to header values, specifically since header values are more likely to wind up in passive / middle man / etc logs.\r\n\r\nI wish you would have raised any of those concerns in the previous meetings we had with the PING (e.g. in the [F2F breakout session](https://docs.google.com/document/d/1gGDY4ckX0NLCpitjpvd3jEbu3t3vHBDZn0F-5X0_4c4/edit)).\r\n\r\n> Existing approaches require active techniques, and so (partially) reduce the fingerprinting risk.\r\n\r\nThe common alternative to CH is origins inspecting those values in JS, and injecting them into URL query parameters. That practice seems significantly more \"loggable\", making Client Hints a clear win on that front.\r\n\r\n> The most on point issue I can find addressing this issue is #215, but this isn't quite on point (does not address increased risk from moving to passive collection).\r\n\r\nClient Hints are *not* \"passive collection\". Getting the hints requires an opt-in, which as @mnot said, is making leak and abuse of that hint data something that can be tracked, monitored and being acted against. (by researchers, extensions or user agents)\r\n\r\n\r\n> I see the text added / modified in [2ba1998](https://github.com/httpwg/http-extensions/commit/2ba199856ae926284fe868de7c257009f01fe3b8) that mentions that \"implementors can do otherwise for privacy\", but PING is uncomfortable with such text ( such text dissolve the point of the standard; a standard that says \"its w/in this standard to vary arbitrarily\", then all that is introduced is web compatibility problems for privacy oriented parties).\r\n\r\nWe are in the process of defining [third-party delegation](https://github.com/w3c/webappsec-feature-policy/issues/129) in the [Fetch](https://github.com/whatwg/fetch/pull/773) and [HTML](https://github.com/whatwg/html/pull/3774) specifications. Perhaps the PING should focus on reviewing that, rather than the IETF draft language, which at least originally was destined for a broader audience, and therefore tends to be more vague.\r\n\r\n> * What discussion has been had regarding increased information leak into logs?\r\n\r\nGiven that those concerns were not raised before in previous encounters with the PING or other privacy-minded folks, not a whole lot.\r\n\r\n> * What measurements / data exists to suggest this is not a problem?\r\n\r\nSince you're the one claiming that this is a significant issue, do you have data to suggest it is a problem?\r\n\r\n\r\n> Researchers and clients already do exactly the things you mentioned.\r\n\r\nI don't think they can see what different services do in their backends with information provided to them by default. For example, with `User-Agent` strings, currently most UAs leak a lot of information by default, which makes its collection passive. With Client Hints, we intend to change that information leak model to make it so origins would have to opt-into that data, making that opt-in observable, measurable and actionable.\r\n\r\n> CH doesn't help make preventing / measuring / notifying of FP & tracking any easier.\r\n\r\nIt does, by turning information (e.g. the UA string or the `Accept-Language` headers) from \"sent by default\" to \"sent only after the server expressed interest\".\r\n\r\n \r\n\r\n> I'm similarly not familiar (and don't see any related comment in CH tagged issues) to deprecate / remove the existing methods for retrieving the same information, so the responsibility / burden on privacy focused parities is strictly increased.\r\n\r\nIf you're not familiar with it, feel free to ask :) @mikewest and I have presented such plans at the [F2F TPAC breakout session](https://docs.google.com/document/d/1gGDY4ckX0NLCpitjpvd3jEbu3t3vHBDZn0F-5X0_4c4/edit), which I believe you attended. This is not mentioned in the IETF draft, as it's a feature that will **use** the CH infrastructure, and as such, is defined [elsewhere](https://github.com/WICG/ua-client-hints).\r\n\r\n> I am aware of this conversation, i referenced a commit in mentioned in #215 above for example :) . But in general, im not sure I understand the connection to the above issues to the concern here, which is \"values in headers get treated categorically differently, and persisted longer, than variables in JS\" :)\r\n\r\nTrackers rarely inspect fingerprinting data using JS APIs and then keep it on the device's memory. They typically send it to their servers, often as URL query parameters, which are arguably an order of magnitude more likely to be persisted in logs than HTTP headers.\r\n\r\n> 1. middle parties (CDN, proxies, other HTTP terminators) get access to data they would previously would not have had access too\r\n\r\nSince Client-Hints are exposed only over secure connections, I suppose you meant \"TLS terminators\" above?\r\n\r\nCDNs do get access to that data, which enables them to perform their duties and use it for content negotiation purposes. They also have full access to the content as TLS terminators, so arguably could also have access to that data by running arbitrary JS on their customers sites. As CDNs are fully trusted by their customers not to do that unless the customer asks them to, I don't think they are the threat model here.\r\n\r\nAlso, anecdotally, I've never heard of a CDN that keeps around the logs of all their customers request and response headers. If they would, cookies are likely to present a bigger concern than fingerprinting bit leakage. But if you have examples to the contrary, I'd love to hear them.\r\n\r\nAs for other TLS terminators (e.g. MITM proxies), they can similarly inject arbitrary JS and leak arbitrary data. I doubt CH increases that attack surface.\r\n\r\n\r\n\r\n\r\n> * that data is more likely to be persisted in long term logs than if its collected \"actively\" in JS\r\n\r\nI'm not convinced that this is in fact the case. And again, acquiring the data in JS does not equate keeping that data in JS. It is leaked over the network, typically as URL params.\r\n\r\n\r\n> 3\\. HTTP logs, that may now include these values, are often shared with third parties, furthering privacy risk.\r\n\r\nAny specific examples of HTTP logs that contain *all header values*? I don't see [Apache logs](https://httpd.apache.org/docs/2.4/logs.html#accesslog) doing that, at least not by default. Similarly for Nginx, I don't see any headers there. I do see the URL though.",
          "createdAt": "2019-02-13T10:57:12Z",
          "updatedAt": "2019-02-13T10:57:12Z"
        },
        {
          "author": "yadij",
          "authorAssociation": "NONE",
          "body": "Squid proxy does have some logging options to record the HTTP headers in full or in part. At least some installations use those as their regular log format, or did so not long ago.\r\n\r\nThat said, having the CH values as opt-in instead of always present is a clear privacy improvement even for these installations. I do not agree with the argument that CH makes logging privacy/security issues worse.",
          "createdAt": "2019-02-13T20:16:08Z",
          "updatedAt": "2019-02-13T20:16:08Z"
        },
        {
          "author": "jumde",
          "authorAssociation": "NONE",
          "body": "@yoavweiss , @yadij: If I understand correctly, the client/user do not have any control over CH opt-in. If the server sends a Accept-CH header requesting DPR, ECT and DeviceMemory. The client has no way to emit all/specific values like DeviceMemory.",
          "createdAt": "2019-02-14T19:00:50Z",
          "updatedAt": "2019-02-14T19:00:50Z"
        },
        {
          "author": "yadij",
          "authorAssociation": "NONE",
          "body": "AIUI the opt-in has to be mutual. The server opts-in by indicating the CH and values it wants to see. The client opt-in is its choice whether to actually send that detail as requested.\r\n The server should treat any absence of details the same as it would that detail being missing without CH.\r\n\r\nFor clients who literally cannot send a datum, there is no way they would have been able to send it regardless of whether CH is supported or not. So the server relying on its presence with a non-nil value is a server design bug.",
          "createdAt": "2019-02-15T04:47:14Z",
          "updatedAt": "2019-02-15T04:47:14Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "To respond to some of the issues mentioned above @yoavweiss @yadij :\r\n\r\nRe: CH (does/does not) makes logging privacy issues worse\r\n\r\nI'm having trouble understanding the claim here.  I am going to see if I can repeat the thinking behind the argument that \"CH aids FP prevention / detection\" argument.  If I am off base here, please kindly correct, I'm making an honest effort to get on the same page.\r\n\r\nThe arguments are:\r\n## 1) Clients can say no easier\r\n* Right now sites use a bunch of JS values to determine things like what images to send\r\n* In a post-CH world, servers will expect clients to respond with headers, and so wont rely on JS values\r\n* Clients can easy detect when these CH values are being requested, and can choose not to respond\r\n* Therefor, CH allows clients to protect their privacy, since its easier to detect and say no, than the status quo\r\n\r\n## 2) logging concerns are a push\r\n* When sites use JS values to determine these kinds of things, they are often put in URLs, and so wind up in logs already\r\n* Middle men can already inject JS\r\n\r\n## 3) Depreciation of current JS end points\r\n* CH is a net win because some JS end points will be deprecated\r\n\r\nAssuming this is a correct understanding of the argument, my concerns are the following\r\n\r\n* I am aware of the suggestion to deprecate UA access in JS (as you mentioned @yoavweiss we discussed it at the F2F), but I am not aware of any suggestion to depreciate the other related JS endpoints (and some of them, like viewport dimensions, seem impossible to hide in JS space).  If there are suggestions to remove `navigator.deviceMemory`, DPR values, etc in some proposal somewhere, I would be very grateful for the link :)\r\n* I understand the claim that clients can say no to a CH request easily, but the likely scenario is that servers ask for the info in CH, and then if the client says no, they extract it in JS.  This is the pattern we see for all sorts of tracking libs; the server / party / JS tries to get as many signals as possible, not just the highest level one.  Adding the info to the CH layer strictly makes the situation no better, and in some cases  worse (since, unless the client says no 100% of the time, values are exposed to parties that otherwise wouldn't have them).\r\n* Point taken that these values can already escape into some URLs.  No question there.  But there is just a world of difference between every website using its own, bespoke URL patterns, and a universal, well structured header field.  There is no need for the client to be complicit and make things _easier_ for the tracking party.\r\n* I appreciate the point that CDN / TLS terminating parties (not HTTP terminating, thank you for the correction :) ) can inject JS.  The concern here is how much tracking information a curious but honest party can see, not a malicious party (since in that case, all bets are off already\u2026).  Its not a matter of the server trusting the CDN, the focus is client information winding up in more, easily extractable places.\r\n\r\nAlso, fwiw, for examples of logs that collect all header data, the mod_log_forensic module, on the website you linked too, is one example. Systems like snort and bro, want full HTTP header logs, etc.  More to the point though, the expectation is that as more track-able information winds up in these headers, more parties will become interested in them.  Such is the way of the web \u00af\\_(\u30c4)_/\u00af",
          "createdAt": "2019-02-16T00:51:19Z",
          "updatedAt": "2019-02-16T00:51:19Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@snyderp it seems like you're arguing that CH should be a net improvement of privacy, as opposed to current practice. While that's a goal that most everyone here shares, it isn't an explicit criteria that we've been applying to the spec; rather, the bar that I think we've held (perhaps implicitly) is that it's _no worse_ than current practice, in any meaningful way.\r\n\r\nIs that the case? If so, it'd probably be best to have a discussion explicitly about the goals, so we can determine consensus and then consequences.",
          "createdAt": "2019-02-19T04:58:32Z",
          "updatedAt": "2019-02-19T04:58:32Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "Howdy @mnot: I am not arguing that CH should be a net improvement of privacy.  My position is that CH is would result in something worse than current practice, for multiple reasons:\r\n\r\n1) Third parties gain access to finger-printable values that they currently don't have access too (finger-printable values would now be in well structured CH headers and seen by CDNs / TLS terminators, where before they were either absent or ay worse sometimes indirectly available in unstructured URLs)\r\n2) Finger-printable values are show up in locations where they are likely to persist for longer (in HTTP logs for above)\r\n3) Finger-printable values are shared to first parties (and delegated parties) in more ways.  Previously browsers needed to defend against JS based determinations, now they need to defend against JS based determinations AND header-extractions.\r\n",
          "createdAt": "2019-02-19T20:39:46Z",
          "updatedAt": "2019-02-19T20:39:46Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the clarification.\r\n\r\nI think you need to qualify (1). As discussed, CH is currently only sent over TLS, and so from the perspective of the web, is communication between two parties. It's true that some sites contract out some of their server capabilities to others (CDNs, cloud hosts, data centres, etc.) but those are generally still considered first-party interactions, because the entity in question is acting on behalf of the owner of the server, and that relationship is typically overseen by a legal agreement, as well as various rights and responsibilities in different jurisdictions.\r\n\r\nAlso, \"third party\" generally is used to refer to off-site services with a different origin; e.g., ads., so it's a bit confusing to use it here.\r\n\r\nTerminology aside, there is some precedent for the argument you're making in (2), but generally when the community has been concerned about sensitive data being logged, it's been because it appears in URLs, which were (originally) designed to be written down, logged, etc. Extending that argument to include headers in an encrypted connection is new. That's not a roadblock, but it would help immensely to establish and get agreement upon the underlying principle.\r\n\r\nFor (3), I think the basis of the decision is likely to be whether the added functionality -- including privacy improvements, as we're seeing discussed in Mike West's `User-Agent` replacement discussion -- balances out the increased complexity. More information on both sides would probably help, although I do note that browsers haven't been terribly shy of complexity to date...\r\n\r\nAre you likely to be coming to the IETF meeting in Prague? That's probably where we're going to try to move this (and similar issues) forward.",
          "createdAt": "2019-02-22T02:52:58Z",
          "updatedAt": "2019-02-22T02:52:58Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "@mnot Thank you for the reply.\r\n\r\nI'm not sure I follow what you're asking for by \"qualifying\" the concern in (1) though.  I'm happy to change terminology if it eases the conversation, but the concern seems pretty straight forward.  User X wants to visit website Y who sits behind CDN (or similar) Z.  Currently, if Z wants to extract these fingerprinting-sensitive values from X's conversation with Y, it requires some out of band communication with Y (access to Y's DB, or something like that, assuming Y is storing them).  In a CH-world, Z gets well-structured access to those values, in a way they don't currently have.  Thats a loss of privacy to X that does not currently exist.\r\n\r\nRe (2) again, happy to contribute anything I can to the conversation here, but not sure what else can be added beyond the original concern.  Is it helpful frame it as: \r\n\r\n> \"privacy on the web, and in the growth of web standards, has been a demonstrable catastrophe.  The first principal when proposing new standards should be \"do no harm\", or failing that, \"here is an _extremely_ compelling goal (e.g. not moderate perf improvements) that justifies further harm to privacy\".  Adding finger-printable values to HTTP headers, in such a way that they can be easily collected, aggregated and shared en mass, is a significant privacy harm.\r\n\r\n(3) The concern here is not about implementation complexity.  Just to try and reach some point of agreement, so that we can discuss further from there:\r\n\r\nSetting aside the UA aspect, and dealing only with viewport height/width, DPR, ECT and DeviceMemory, etc: can we agree that CH is strictly a harm for privacy?  In the best case (user agent declines the server's request for the headers, site falls back to JS based value extraction) its a push, and in all other cases its a loss (fingerprinting values are in more locations than they were before, and accessible by more parties).\r\n\r\nIf we don't agree to the above, i would greatly appreciate it if you could clarify by way of the following: what is a scenario where a) the server / website wants to get access to finger-printable values, and b) the client doesn't want to yield them, that CH helps improve privacy? (keeping in mind that a site that currently gets them through JS, will ask for the in CH, and if they don't get them, continue to ask for the in JS).\r\n\r\nIf I could better understand a case that fit the above scenario, it might help me much better understand where ya'll are coming from, and where I may be misunderstanding things :)\r\n\r\nUnfortunately, I will not be able to join ya'll in Prague this year",
          "createdAt": "2019-02-22T23:06:49Z",
          "updatedAt": "2019-02-22T23:06:49Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm not sure I follow what you're asking for by \"qualifying\" the concern in (1) though. I'm happy to change terminology if it eases the conversation, but the concern seems pretty straight forward. User X wants to visit website Y who sits behind CDN (or similar) Z. Currently, if Z wants to extract these fingerprinting-sensitive values from X's conversation with Y, it requires some out of band communication with Y (access to Y's DB, or something like that, assuming Y is storing them). In a CH-world, Z gets well-structured access to those values, in a way they don't currently have. Thats a loss of privacy to X that does not currently exist.\r\n\r\nCDNs are delegates of the origin and are **not considered** part of the threat model. A rogue CDN (similar to a compromised server) can do **way** more damage than read out fingerprintable information.\r\n\r\n\r\n> Setting aside the UA aspect, and dealing only with viewport height/width, DPR, ECT and DeviceMemory, etc: can we agree that CH is strictly a harm for privacy?\r\n\r\nWe certainly **can not** agree on that! (and repeating that multiple times will not suddenly make it true)\r\n\r\nWe went through great lengths to make sure the current mechanism does not allow passive fingerprinting, and its use can be treated by UAs similarly to the equivalent JS APIs. Even if we just discuss the viewport-width, DPR, ECT and DeviceMemory, the fact that the information is communicated in a convenient and standard way does not mean that it's easier to exploit it compared to the JS APIs. OTOH, it makes it easier to never keep it in or scrub it from server/CDN logs (e.g. compared to the same information hidden as URL parameter conventions).\r\n\r\n\r\n\r\n\r\n> If we don't agree to the above, i would greatly appreciate it if you could clarify by way of the following: what is a scenario where a) the server / website wants to get access to finger-printable values, and b) the client doesn't want to yield them, that CH helps improve privacy? (keeping in mind that a site that currently gets them through JS, will ask for the in CH, and if they don't get them, continue to ask for the in JS).\r\n> \r\n> If I could better understand a case that fit the above scenario, it might help me much better understand where ya'll are coming from, and where I may be misunderstanding things :)\r\n\r\nIn your scenario above, how do Client Hints make things worse? If the information is exposed through JS, it is exposed. Making it available through another channel doesn't add any new fingerprintable data that attackers can abuse.",
          "createdAt": "2019-02-24T07:31:08Z",
          "updatedAt": "2019-02-24T07:31:08Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> Unfortunately, I will not be able to join ya'll in Prague this year\r\n\r\nKeep in mind, there is remote participation. ",
          "createdAt": "2019-02-25T06:45:48Z",
          "updatedAt": "2019-02-25T06:45:48Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "@mnot I would be very happy to participate in this conversation remotely when its happening in Prague. Any information you could link to / share about how to participate would be greatly appreciated. I am new to the mysterious world of IETF :)",
          "createdAt": "2019-02-25T23:39:59Z",
          "updatedAt": "2019-02-25T23:39:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@snyderp welcome :)\r\n\r\nGeneral resources listed here:\r\n  https://www.ietf.org/about/participate/\r\n\r\nMeeting details here:\r\n  https://www.ietf.org/how/meetings/104/\r\n\r\nBest thing to do is to register for remote participation (free), and watch the agenda (linked from the meeting details above) for links to the audio and video feeds (should be added when the agenda is final). Jabber is also a primary communication channel during the meeting; httpbis@jabber.ietf.org.",
          "createdAt": "2019-02-25T23:47:45Z",
          "updatedAt": "2019-02-25T23:47:45Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "> CDNs are delegates of the origin and are **not considered** part of the threat model. A rogue CDN (similar to a compromised server) can do **way** more damage than read out fingerprintable information.\r\n\r\nThis is addressing the concern by defining it away.  If they're not part of the threat model, then they certainly aught to be. They're distinct parties, with potentially distinct (if any) commitments to the visitor, etc.\r\n\r\nTo say a CDN could do something worse is unrelated; sure they could.  But that is unrelated to whether it is a good idea to provide them with the data they need to easily finger print users!  The relevant framework here is an honest-and-curious vs malicious distinction.\r\n\r\n> We went through great lengths to make sure the current mechanism does not allow passive fingerprinting, and its use can be treated by UAs similarly to the equivalent JS APIs. \r\n\r\nJust to lower the temperature in the room: I appreciate and don't mean to denigrate how much effort you've put into this.  I'm sure its a lot of work, and I'm sincerely grateful folks like you are working hard to find ways to improve the web.  :) But it doesn't change the privacy harm in CH as it stands\u2026\r\n\r\n> Even if we just discuss the viewport-width, DPR, ECT and DeviceMemory, the fact that the information is communicated in a convenient and standard way does not mean that it's easier to exploit it compared to the JS APIs. OTOH, it makes it easier to never keep it in or scrub it from server/CDN logs (e.g. compared to the same information hidden as URL parameter conventions).\r\n\r\nMore examples:\r\n1) User disables JS as a tracking counter measure (e.g. no script).  A browser implementing CH will end up still leaking FP values\r\n2) User has no-op'ed the JS api's in question to reduce tracking (e.g. privacy badger).  A browser implementing CH will end up still leaking FP values\r\n3) User blocks execution of just JS resources to avoid leaking the above vales.  A browser implementing CH will end up still leaking those FP values on non-JS resource fetches\r\netc.\r\n4) User finds it okay to share the FP fields to the origin (and conceivably, even the 3p), but doesn't want to give CDN's and similar convenient access to all of the above.  They might doubly want to reduce the chance that the data sticks around for a long time in a log). A browser implementing CH ends up advertising these FP values to anyone between the client and the server.\r\n\r\nI understand and take your point that there are cases where a CDN or similar could guess at _some_ of these values from _some_ domains\u00a0buy guessing at URLs, but again, there is a quantity-to-the-point-of-quality difference between CDNs using some manually curated set of per-domain-per-application-version regexs, and providing that data in a structured header field.\r\n\r\n> In your scenario above, how do Client Hints make things worse? If the information is exposed through JS, it is exposed. Making it available through another channel doesn't add any new fingerprintable data that attackers can abuse.\r\n\r\nThey make it worse by increasing the attack surface the client needs to defend against.  I hope the above examples help explain.  Also, making the same data in multiple places (and a different set of parties), making it much easier for middle parties to log and preserve the FP values, and relying on browsers to deploy additional countermeasure / standards-deviations to avoid further privacy harm are all examples of additional privacy risk / loss in the standard.\r\n\r\nBut happy to have reached a point where we're at least not arguing that CH somehow _reduces_ FP surface: (e.g. https://github.com/httpwg/http-extensions/issues/767#issuecomment-463351465) \ud83d\ude00",
          "createdAt": "2019-02-26T00:20:27Z",
          "updatedAt": "2019-02-26T00:56:29Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "sorry to spam the thread but this has grown to three related, but distinctl concerns:\r\n\r\n1) FP values winding up in places where they're likely to be long term persisted (e.g. CDN logs and similar)\r\n2) A general growth in the number of parties who will have access to FP values, who didn't before\r\n3) That (whether?) its more of a privacy leak to provide middle-parties access in FP values in HTTP Headers vs. possibly extracting from URLs\r\n\r\nI'm happy to keep them all in this thread, but if folks would like me to spread out to different issues, i'm happy to do so too",
          "createdAt": "2019-02-26T00:45:01Z",
          "updatedAt": "2019-02-26T00:45:01Z"
        },
        {
          "author": "yadij",
          "authorAssociation": "NONE",
          "body": "yoavweiss :\r\n> CDNs are delegates of the origin and are not considered part of the threat model. A rogue CDN (similar to a compromised server) can do way more damage than read out fingerprintable information.\r\n\r\nsnyderp: \r\n> This is addressing the concern by defining it away. If they're not part of the threat model, then they certainly aught to be. They're distinct parties, with potentially distinct (if any) commitments to the visitor, etc.\r\n\r\nI think what Yoav should have said is that CDN are considered part of the origin. So there is no _separate_ model. All privacy and security aspects for \"origin\" also apply to CDN.\r\n\r\nYou keep stating that CH expands the exposure. But look at the exposure scopes in the threat matrix I list below.\r\n\r\n\r\nsnyderp :\r\n> But happy to have reached a point where we're at least not arguing that CH somehow reduces FP surface: (e.g. #767 (comment)) grinning\r\n\r\nThat was a statement by me. AFAIK yoav has never had that position.\r\nFTR my position remains that CH (alone) has better privacy than the status quo (JS hacks). Consider these two scenarios:\r\n\r\n scenario 1: a request arrives for some random URL. This URL is stored, logged, and passed around. The response to this request has a response lacking cacheability headers. For performance vague responses *are* cached. Due to the permutability of query-string values there may be N copies of this URL+object stored in M caches around the world - for potentially 68 year long timespans.\r\n => even with HTTPS protection the FP data can be retrieved from any of these intermediary data sources long after the transaction is over.\r\n\r\n scenario 2: a request arrives with C-H header details. The URL is clean - so no danger from logging and passing that around within the intermediary system. The request C-H headers (being request headers) are not cached with the response (if they are used by Vary/Key etc it is in the form of a crypto hash).\r\n => the clients FP data is only ever in memory during the transaction active period, is never seen by most of the intermediary system components, and cannot be recovered from the long-term storage.\r\n\r\nSo tell me again how scenario #1 is better for privacy?\r\n\r\nsynderp : \r\n>  In the best case (user agent declines the server's request for the headers, site falls back to JS based value extraction)\r\n\r\nThat is actually a case near worst-case.\r\n\r\nThe exposure matrix is a 2x3 [ [JS, CH], [send, fallback, omit] ]. So these:\r\n\r\nJS-only (the status quo):\r\n - FP exposure to all HTTP agents along the path\r\n - FP exposure to all log processors\r\n - FP exposure to all filesystem agents\r\n - FP exposure to other networking services on intermediary host\r\n - FP exposure to any services the above leak URL and/or cache data to\r\n - expected persistent FP exposure to all the above for up to 68 years\r\n\r\nCH-only\r\n - FP data only by request.\r\n - conclusion: less FP data, therefore less exposure than status quo.\r\n - FP exposure to all HTTP agents along the path\r\n - conclusion: less agent types, therefore less exposure than status quo.\r\n\r\nCH with JS fallback\r\n - client is forwarned of FP actions so can proactively close off JS APIs\r\n - bias toward CH-only exposure, with risks of status quo amounts of FP exposure.\r\n - conclusion: less or equal FP exposure to status quo.\r\n\r\nJS with CH fallback\r\n - bias towards status quo FP exposure.\r\n - conclusion: equal FP exposure to status quo.\r\n\r\nBoth CH and JS data\r\n  - CH exposure is a sub-set of JS exposure.\r\n  - conclusion: equal FP exposure to status quo.\r\n\r\nNeither\r\n - no FP exposure within scope of the model.\r\n\r\n\r\nOne may argue that agents without JS support are being added to the exposure set. However I counter that the FP data is already visible to such agents in the form of URL values. The presence of FP data in URLs is already where the worst types of leaks are occuring with the JS-only approach. Simply closing off those major avenues of exposure is the reduction in surface I referred to earlier and still believe is offered by CH.",
          "createdAt": "2019-02-26T05:12:31Z",
          "updatedAt": "2019-02-26T05:12:31Z"
        },
        {
          "author": "inian",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> 1. User disables JS as a tracking counter measure (e.g. no script).  A browser implementing CH will end up still leaking FP values\r\n> 2. User has no-op'ed the JS api's in question to reduce tracking (e.g. privacy badger).  A browser implementing CH will end up still leaking FP values\r\n> 3. User blocks execution of just JS resources to avoid leaking the above vales.  A browser implementing CH will end up still leaking those FP values on non-JS resource fetches\r\n>    etc.\r\n\r\nSimilar to how the user can block scripts from running in his browser, he could block the CH headers from being sent as well (and it is not significantly harder to do so). These privacy protecting extensions like noscript, privacy badger, etc. could be updated to remove Client Hints from non-origin requests. If the user is willing to trade off performance for privacy, he has the choice to do so that way. Privacy focused extensions (or browsers) would have a safe way to block this than trying to strip off query parameters off a URL for example. \r\n\r\nI also agree that CDNs in front of the origin shouldn't be considered as part of the threat model here. A malicious CDN could do a lot more than logging privacy sensitive values. ",
          "createdAt": "2019-02-26T20:51:48Z",
          "updatedAt": "2019-02-26T20:51:48Z"
        },
        {
          "author": "tomlowenthal",
          "authorAssociation": "NONE",
          "body": "The argument that CH is a no-op seems pretty tenuous. CH takes a collection of things which *can* be requested by JS and *can* be put in a URI and puts all of them together in webserver logs. That's a worse privacy outcome. Suggesting that privacy-protecting browsers/extensions might block sending CH in the same way that they block other fingerprintable attributes just seems to admit that CH adds another vector for all the same badness we already have.\r\n\r\nThe proposal seems to add yet another fingerprinting vector which is maybe only roughly as bad as all the others and can be blocked in the same way. Some people seem to be saying that's not a big deal. I think that's a bad idea and it shouldn't happen.\r\n\r\nThe web platform ossifies privacy-harming functionality. In practice, it's very\u00a0difficult for user-agents to defang established fingerprinting techniques. Adding more because they're only roughly as bad as existing ones (NB: I actually think CH is worse, because it's passive and likely to end up in logs) is the wrong direction. We should eliminate existing ways to track people, not add more new ones.",
          "createdAt": "2019-02-26T23:09:45Z",
          "updatedAt": "2019-02-26T23:09:45Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> CH takes a collection of things which _can_ be requested by JS and _can_ be put in a URI and puts all of them together in webserver logs.\r\n\r\nCan you expand upon this? They aren't logged by default in any implementation I'm aware of; one would have to go out of their way to do so in all Web servers, proxies and CDNs that I've ever used.\r\n\r\nIt's true that servers can go out of their way to log (and then misuse) this information. They can also do so if it's encoded into the URI, added to proprietary request headers, pinged to a server in a  request body by active content, and so on. \r\n\r\nSo I'm having a hard time believing that CH makes things more \"likely to end up in logs\". If a server, proxy or CDN is *accidentally* logging this information, they've got much bigger issues with handling sensitive information than just those introduced by CH. If a server is *intentionally* logging this information, the slight convenience afforded by CH (as opposed to current methods) doesn't seem like it's going to move the needle for them; if they want this information, they're going to get it anyway.\r\n\r\nTo me, the more interesting difference is that in CH, the wire form is standardised. That cuts both ways; having a standard form makes it _slightly_ more easy for a generic server to provide a facility to log / otherwise mangle the information; however, it also makes it easier to identify sensitive information for purposes of research / analysis / blocking / etc. ",
          "createdAt": "2019-02-26T23:54:32Z",
          "updatedAt": "2019-02-26T23:54:32Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "Folks the argument that \"middle parties / CDNs can do worse things, so no harm in giving them FP values too\" is way off base.  Again, an honest-but-curious vs malicious distinction.  Saying \"X party could do worse\" doesn't justify making it easier to do other things easily!\r\n\r\nAmong many other reasons, its possible to detect when CDNs misbehave now (at least in the content injecting ways discussed above).  The proposal imagines enabling CDNs to trivially conduct a _new_ type of misbehavior, in a way that cannot be detected\r\n\r\n> It's true that servers can go out of their way to log (and then misuse) this information. They can also do so if it's encoded into the URI, added to proprietary request headers, pinged to a server in a request body by active content, and so on.\r\n\r\nI don't think this is correct.  There are a million bespoke ways this information could be encoded in a URL, some easy to pragmatically extract (e.g. query params), some not (e.g. packed into custom formatted blobs).  In the status quo, an observer would need to come up with patterns to cover every conceivable way of packing these values into a URL string, and keep it updated every time an application changes patterns, etc.  In a CH world, the values are always nicely formatted, in a consistent place, trivial to extract.  This is what I mean by a quantity-to-the-point-of-quality problem.  CH makes whats currently a difficult, constantly changing, not-generally-solveable problem into something trivial, exactly the kind of thing that could be trivially automated, aggregated and sold / shared / leaked.\r\n\r\nTo put it a different way, given a set of 1m requests in a log, would you rather be the person in charge of coding up a system for extracting viewport-width, DPR, ECT, DeviceMemory, etc values from those logs in a pre, or a post, CH world. :)\r\n\r\n> however, it also makes it easier to identify sensitive information for purposes of research / analysis / blocking / etc.\r\n\r\nGiven the amount of literature documenting how often these end points are already abused, I don't think this counts as a \"win\".  We already know people abuse this stuff!  There is no win in making it **easier to count** the abuse; the win is in making it **harder to conduct** the abuse.",
          "createdAt": "2019-02-27T00:07:27Z",
          "updatedAt": "2019-02-27T00:07:27Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@snyderp the argument you seem to be making can be generalised to \"Let's not standardise any semantics for potentially sensitive data, because if there's a bad actor involved in handling that data, it makes their life easier.\"\r\n\r\nDoes that capture it?\r\n\r\n\r\n",
          "createdAt": "2019-02-27T00:13:20Z",
          "updatedAt": "2019-02-27T00:13:20Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "My argument is stronger than \"lets give them a difficult time\" :) \r\n\r\nThe argument is that CH turns a problem that could be \"solved\" for **some cases** with a great deal of manual effort, fragile rule generation, and ongoing maintenance (since URL -> FP value extraction rules would constantly be changing and need to be updated), into something that can be \"solved\" in **all cases** with `echo $_SERVER[\"<whatever>\"];`\r\n",
          "createdAt": "2019-02-27T00:27:58Z",
          "updatedAt": "2019-02-27T00:27:58Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think the disconnect here may be in the relationship between CDNs and other \"third parties\" (e.g., contractors, hosting providers, data centres) and the origin (i.e., the responsible party). IME all of these relationships are highly coordinated and governed by a contract. \r\n\r\nSince they're coordinated, working together effect this sort of extraction currently is fairly trivial; CH doesn't significantly lower the bar. If the \"third party\" does this sort of thing without the consent of the origin, it's breaking the contract, which they have a strong incentive not to do.\r\n\r\nYou seem to consider the contractual constraint there as inadequate. Is that closer?  ",
          "createdAt": "2019-02-27T00:36:29Z",
          "updatedAt": "2019-02-27T00:36:29Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "1) To the degree there is a contractual constraint[1], its not going to be known to the client; it would be irresponsible for the browser to assume \"the origin has made the middle party(s) promise to protect my privacy\". \r\n\r\nMore importantly though, if the state of web privacy demonstrates anything, it is that there will quickly become parties that take advantage of (and monetize) any new FP attack surface.  The list of FP techniques that initially seemed like \"no one would actually do that\", but then became widely deployed is long long long\u2026 (really long!). Adding FP values in CH headers will have the same outcome\r\n\r\n2) I think you're overstating the degree to which the origin ~= the hosting provider ~= CDN.  In some situations they may make sense to collapse into \"one party\".  But thats not the case here; they have access to distinct amounts of information, and CH unambiguously expands the number of parties that have access to privacy-harmful information.\r\n\r\nCurrently, there is no simple way for CDNs / middle parties to gain access to these FP values in a predictable, easy, consistent manner.  CH would create a way for the middle parties to have predictable, easy, consistent access to FP values.\r\n\r\nSaying \"they're both 1p so there is privacy loss\" seems like papering over the plain truth of the situation.\r\n\r\n3) if there is a survey of the promises CDNs / middle parties / the like make about _client_ privacy, I would be extremely interested in it.  It doesn't change the fact that sending FP values in CH headers is harmful to web privacy, but it would be extremely interesting to read either way.  If you know of such a document, I'd be grateful for a link.",
          "createdAt": "2019-03-04T22:21:55Z",
          "updatedAt": "2019-03-04T22:21:55Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> if the state of web privacy demonstrates anything, it is that there will quickly become parties that take advantage of (and monetize) any new FP attack surface\r\n\r\nThat could be true, but Client Hints does not increase the fingerprinting attack surface\r\n\r\n> Currently, there is no simple way for CDNs / middle parties to gain access to these FP values in a predictable, easy, consistent manner\r\n\r\nThey can easily inject scripts that would send them those values in a predictable, easy, consistent manner. There are examples of CDNs injecting scripts as a premium service for analytics or content optimization purposes. Do you have any evidence of well-known CDNs injecting scripts today in order to fingerprint their customers' users without the customer's consent and active participation?\r\n\r\n\r\n> It doesn't change the fact that sending FP values in CH headers is harmful to web privacy\r\n\r\nYou keep making that unsubstantiated claim without any material evidence to back it up, after which you ask for evidence to the contrary. That's not how it [typically works](https://en.wikipedia.org/wiki/Burden_of_proof_(philosophy)).",
          "createdAt": "2019-03-11T11:00:17Z",
          "updatedAt": "2019-03-11T11:22:32Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "> That could be true, but Client Hints does not increase the fingerprinting attack surface\r\n\r\nThe claim is (still) that CH makes it easier for middle parties to fingerprint users\r\n\r\nI claim this because, in the present, middle-parties can only fingerprint users in one of two ways:\r\n\r\n1) trying to extract parameters from URLs (error prone, difficult and not possible with a general solution), or\r\n2) an active attack / traffic tampering (injecting JS, which clients can try to defend against)\r\n\r\nThe CH proposal would provide these values to middle parties in a way that makes finger printing easier and more common.  With CH, middle parties could fingerprint users trivially (no need to guess at FP parameters from URLs, etc), passively (e.g. honest but curious attack scenario), and with a common solution (e.g. reading from the header).\r\n\r\nIt seems we keep talking past each other.  Maybe this could be more productive if we could narrow the conversation.  Do you disagree with 1 or 2 above, or the conclusion I draw from them?\r\n\r\n> You keep making that unsubstantiated claim without any material evidence to back it up, after which you ask for evidence to the contrary. That's not how it typically works.\r\n\r\nSurely it's the person proposing the change that could potentially harm the privacy of billions of people on the web who has the burden of proof!  Not the person saying \"this seems risky, lets make sure\u2026\"",
          "createdAt": "2019-03-11T19:28:48Z",
          "updatedAt": "2019-03-11T19:28:48Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> I claim this because, in the present, middle-parties can only fingerprint users\r\n\r\nI think we need to establish consensus about the threat model for what you're calling \"middle-parties\" before we can mitigate concerns raised about them. AFAICT this is a very new argument. ",
          "createdAt": "2019-03-12T04:48:45Z",
          "updatedAt": "2019-03-12T04:48:45Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "I worry that formalism will obscure the facts (which is that a class of party distinct from the origin will gain access to a new category of privacy sensitive information), but I'm happy to take a stab at it here if you think it will be helpful for the conversation (even if it may need several revisions to get right and tight).\r\n\r\nHere is a first stab:\r\n\r\nMiddle parties are HTTPS terminators, like CDNs, outsourced reverse proxies, etc.  They _may_ have commitments to the origin, they _do not_ have commitments to the client (including regarding privacy).  While they _may_ resort to malicious attacks (traffic tampering, etc) the primary concern is the honest-but-curious scenario, where they maximize the utility of the data they can gain w/o breaking protocol (i.e. they squeeze every $ out of every data point they can see, but don't modify traffic, inject JS, etc).\r\n\r\nI hope this helps @mnot .  CH is privacy harmful because it increases the amount of fingerprinting middle parties can do, by taking something they can only occasionally do now (extracting FP parameters from URLs, by trying a variety of faulty, imperfect, non-generalizeable pattern matching strategies) and changing it into something they can do trivially (reading HTTP header values).",
          "createdAt": "2019-03-12T18:39:22Z",
          "updatedAt": "2019-03-12T18:39:22Z"
        },
        {
          "author": "diracdeltas",
          "authorAssociation": "NONE",
          "body": "> Middle parties are HTTPS terminators, like CDNs, outsourced reverse proxies, etc\r\n\r\nLabeling TLS-terminating CDNs as a distinct security party from the server-which-is-behind-the-CDN seems problematic to me.\r\n\r\n1. Clients have no way of distinguishing whether they are talking to a TLS-terminating CDN or a non-CDN'ed site, so this essentially proposes a security boundary which cannot be enforced by clients. This means that any information which should not be revealed to these \"middle parties\" must be denied for all parties.\r\n2. There is nothing in any browser's UX that I know of which indicates to the user whether they are talking to a TLS-terminating CDN versus the site's server directly. Even if (1) were possible, this seems like a tricky concept to communicate to users.\r\n3. Cookies are sent as a header and are usually more of a privacy/security risk than the client-hints header. Does this mean we should deprecate cookies in favor of JS-accessible state storage mechanisms like localStorage?\r\n\r\nRe: the claim that headers are more likely to be logged, I too would like to see some data for this. It seems that if this is a concern, we should be equally or more concerned that CDNs are logging cookies (which are also sent as headers).\r\n\r\nThe most convincing argument I see for not implementing CH at this time is that it adds complexity and another vector which must be blocked when the client blocks data that CH would otherwise send. (For instance, if a user blocks scripts or installs an extension to block certain fingerprinting vectors, the browser must make sure the data is correspondingly blocked in CH.)\r\n",
          "createdAt": "2019-04-13T02:38:21Z",
          "updatedAt": "2019-04-13T02:38:21Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Recapping discussion from IETF 105..\r\n\r\n- The group does not consider the CDN as adversarial threat model\r\n- The CDN can, sometimes, be part of accidental threat model (misconfiguration, etc)\r\n- We should indicate in security considerations that client hints might carry sensitive information and that they should be treated with care \u2014 WIP #776 PR is aiming to capture this.\r\n\r\nSparse but relevant [minutes from the meeting](https://github.com/httpwg/wg-materials/blob/gh-pages/ietf105/minutes.md#10-min---client-hints---yoav-weiss).\r\n\r\n",
          "createdAt": "2019-07-25T18:52:59Z",
          "updatedAt": "2019-07-25T18:52:59Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given the discussion at IETF 105, can we close this?",
          "createdAt": "2019-11-19T10:16:53Z",
          "updatedAt": "2019-11-19T10:16:53Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "I believe so, I've not heard any followup or rebuttals since our discussions at 105. I'll close this out, if anyone disagrees with the outcome please feel free to reopen.",
          "createdAt": "2019-11-19T15:51:57Z",
          "updatedAt": "2019-11-19T15:51:57Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "I opened this issue, but was not at IETF.  Could you kindly summarize the conclusion, and why the issue is being closed?  Thanks!",
          "createdAt": "2019-11-19T19:18:11Z",
          "updatedAt": "2019-11-19T19:18:11Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/httpwg/http-extensions/issues/767#issuecomment-515170040 provides a summary",
          "createdAt": "2019-11-19T21:32:40Z",
          "updatedAt": "2019-11-19T21:32:40Z"
        }
      ]
    },
    {
      "number": 768,
      "id": "MDU6SXNzdWU0MDk1MzMzMTM=",
      "title": "Data motivating CH?",
      "url": "https://github.com/httpwg/http-extensions/issues/768",
      "state": "CLOSED",
      "author": "pes10k",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "From PING:\r\n\r\nRelated but distinct from https://github.com/httpwg/http-extensions/issues/767, PING is interested in what data has been gathered / exists to motivate this change.  Given that the spec increases the risk of privacy-loss (there is a subsection of the spec for this purpose), we're interested in what data exists to show that this risk would be counter balanced by benefit to:\r\n1) A significant portion of web users,\r\n2) On a significant portion of web sites\r\n\r\nDoes any such data exist?  Any relevant information would be extremely useful as we continue considering the proposal.",
      "createdAt": "2019-02-12T22:38:42Z",
      "updatedAt": "2019-02-22T18:34:20Z",
      "closedAt": "2019-02-12T23:05:38Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "HI, this isn't an issue with the spec; please engage with the authors or the WG mailing list directly.",
          "createdAt": "2019-02-12T23:05:38Z",
          "updatedAt": "2019-02-12T23:05:38Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "PING as been asked to consider the CH proposal, and was told GH issues was the best place to do.\r\n\r\nIf that is not correct, please kindly point us to where the best place would be to follow up.  ietf-http-wg@w3.org ? ",
          "createdAt": "2019-02-12T23:17:35Z",
          "updatedAt": "2019-02-12T23:17:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes, that's fine. ",
          "createdAt": "2019-02-12T23:35:45Z",
          "updatedAt": "2019-02-12T23:35:45Z"
        },
        {
          "author": "colinbendell",
          "authorAssociation": "NONE",
          "body": "@snyderp I published data here: https://cloudinary.com/blog/client_hints_and_responsive_images_what_changed_in_chrome_67",
          "createdAt": "2019-02-21T20:27:50Z",
          "updatedAt": "2019-02-21T20:27:50Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "Hi @colinbendell \r\n\r\nThanks for the link!  After reading through the document though, it wasn't clear to me, which of these improvements would you have *not* been able to make through a combination of `<picture>` and CSS media queries?  Does CH make it more convenient, or is there something unique about CH that enables these optimizations (and if so, do you have a sense of what % of the improvement could have been captured with `<picture>` + `CSS` alone)?\r\n\r\nThanks much for any thoughts you could share!",
          "createdAt": "2019-02-21T20:39:44Z",
          "updatedAt": "2019-02-21T20:39:44Z"
        },
        {
          "author": "colinbendell",
          "authorAssociation": "NONE",
          "body": "I'll reply on the ietf-http-wg@w3.org thread and move it out of this closed issue",
          "createdAt": "2019-02-22T18:34:19Z",
          "updatedAt": "2019-02-22T18:34:19Z"
        }
      ]
    },
    {
      "number": 769,
      "id": "MDU6SXNzdWU0MTAwNDQ3MTk=",
      "title": "Clarify SameSite behavior for non-HTTP API",
      "url": "https://github.com/httpwg/http-extensions/issues/769",
      "state": "OPEN",
      "author": "ericlaw1979",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis",
        "samesite"
      ],
      "body": "In Firefox and Safari, |document.cookie| matches the |Cookie| header. \r\nIn Chrome and Edge, samesite=strict cookies are omitted from the |Cookie| header but included in the |document.cookies| collection following a cross-origin navigation.\r\n\r\nTest: https://debugtheweb.com/test/cookie/samesite/\r\nChrome Issue Tracker: https://crbug.com/925311 ",
      "createdAt": "2019-02-13T23:03:11Z",
      "updatedAt": "2020-07-20T17:17:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tbroyer",
          "authorAssociation": "NONE",
          "body": "Related: https://bugzilla.mozilla.org/show_bug.cgi?id=1530995 (contrary to the test and Chrome issue linked above, the cookie here is set in the response after the navigation; it's still related to how to build a cookie-string for non-HTTP API and whether SameSite cookies should be returned or not)",
          "createdAt": "2019-03-01T13:36:21Z",
          "updatedAt": "2019-03-01T13:36:21Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "See also https://github.com/whatwg/html/issues/804 and #1073.",
          "createdAt": "2020-07-20T17:17:00Z",
          "updatedAt": "2020-07-20T17:17:00Z"
        }
      ]
    },
    {
      "number": 771,
      "id": "MDU6SXNzdWU0MTEwMTg0NTQ=",
      "title": "Clarify \"append\" in CDN-loop",
      "url": "https://github.com/httpwg/http-extensions/issues/771",
      "state": "CLOSED",
      "author": "zwoop",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It may be obvious, but I think clarifying that when a conforming CDN \"adds\" to the header, it must be an append. E.g.\r\n\r\n```\r\nAs with all HTTP header fields defined using the \"#\" rule, the CDN-\r\nLoop header field can be **appended** to by comma-separating values, or by\r\ncreating a new header field with the desired value.\r\n```\r\n\r\n(emphasis mine, s/added/appended/. it certainly wouldn't hurt to have such a clarification IMO :).",
      "createdAt": "2019-02-16T03:03:35Z",
      "updatedAt": "2019-05-02T05:19:50Z",
      "closedAt": "2019-05-02T05:19:50Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OBE",
          "createdAt": "2019-05-02T05:19:50Z",
          "updatedAt": "2019-05-02T05:19:50Z"
        }
      ]
    },
    {
      "number": 773,
      "id": "MDU6SXNzdWU0MTQyMDMxMzM=",
      "title": "Correct behaviour for a POST-redirect-GET when using SameSite=Lax",
      "url": "https://github.com/httpwg/http-extensions/issues/773",
      "state": "OPEN",
      "author": "pmhsfelix",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis",
        "samesite"
      ],
      "body": "In the context of <https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-02>, \r\nI would like to clarity what is the intended behaviour for the `GET` request in the following scenario, when using a cookie with `SameSite=Lax`:\r\n- `POST` to `https://example.com/path-1` triggered by a cross-site document.\r\n- Response to the `POST` is a redirect status code to `https://example.com/path-2`.\r\n- `GET` to `https://example.com/path-2`.\r\n\r\nWhen using `SameSite=Lax` it is rather clear that the first request (`POST`) will not contain the cookie, since it is using a non-safe method.\r\nHowever, the behaviour for the `GET` is not completely clear because:\r\n- It is a safe method.\r\n- However, it was triggered by a non-safe cross-site request.\r\n\r\nI've tested it with two different browsers and obtained two distinct behaviours:\r\n- Safari (macOS Mojave) - the cookie is not sent on the `GET` request.\r\n- Firefox (`65.0.1`) - the cookie is sent on the `GET` request.",
      "createdAt": "2019-02-25T16:52:46Z",
      "updatedAt": "2019-12-27T10:18:58Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 774,
      "id": "MDU6SXNzdWU0MTQ4OTc4MTI=",
      "title": "Appropriate use of well-known URIs",
      "url": "https://github.com/httpwg/http-extensions/issues/774",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "From Ben Kaduk during LC review of 5785bis:\r\n\r\n> Is it also advisable to limit the content under the well-known URI to a discovery document, and move writable resources to a different origin?\r\n",
      "createdAt": "2019-02-27T01:15:37Z",
      "updatedAt": "2019-08-30T06:55:25Z",
      "closedAt": "2019-08-30T06:55:25Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Based upon the discussion around well-known URIs, I think we don't have \"best\" practices here yet.",
          "createdAt": "2019-08-30T06:55:25Z",
          "updatedAt": "2019-08-30T06:55:25Z"
        }
      ]
    },
    {
      "number": 778,
      "id": "MDU6SXNzdWU0MjA4MjE2Nzc=",
      "title": "Cache header name",
      "url": "https://github.com/httpwg/http-extensions/issues/778",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "cache-header"
      ],
      "body": "One proposal at #777 ",
      "createdAt": "2019-03-14T04:01:42Z",
      "updatedAt": "2019-11-04T04:32:34Z",
      "closedAt": "2019-11-04T04:32:34Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Montreal, IETF 105: Do Cache-Status!",
          "createdAt": "2019-07-22T20:30:14Z",
          "updatedAt": "2019-07-22T20:30:14Z"
        }
      ]
    },
    {
      "number": 779,
      "id": "MDU6SXNzdWU0MjA4MjgxMTk=",
      "title": "Should Accept algorithm ignore parameters?",
      "url": "https://github.com/httpwg/http-extensions/issues/779",
      "state": "OPEN",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "",
      "createdAt": "2019-03-14T04:35:59Z",
      "updatedAt": "2019-03-14T04:35:59Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 781,
      "id": "MDU6SXNzdWU0MjY0MTgwNjQ=",
      "title": "empty lists and empty field values",
      "url": "https://github.com/httpwg/http-extensions/issues/781",
      "state": "CLOSED",
      "author": "royfielding",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "The SH syntax does not directly allow empty field values, such as defined for Accept, although this might be allowed by field definitions like\r\n\r\n    MyField = [ sh-list ]\r\n\r\nLikewise, the list types do not allow for empty lists.\r\n\r\n    sh-list     = list-member *( OWS \",\" OWS list-member )\r\n    list-member = sh-item\r\n\r\nI think this is a very odd choice for a generic syntax because the empty set is often given semantic meaning in generic communication. It's hard to do math without zero.\r\n\r\nIf this is intended, the rationale should be explained in the spec, and there should be some discussion with examples about defining fields as an optional value.",
      "createdAt": "2019-03-28T10:36:09Z",
      "updatedAt": "2019-07-04T08:55:11Z",
      "closedAt": "2019-07-04T08:48:07Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, even if empty lists may be problematic top-level, the situation is different when they are nested...",
          "createdAt": "2019-03-28T13:36:32Z",
          "updatedAt": "2019-03-28T13:36:32Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ietf104 - interest in the room in supporting empty (perhaps null?) syntax",
          "createdAt": "2019-03-28T13:37:26Z",
          "updatedAt": "2019-03-28T13:37:26Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "I agree this is something important. It may be used to mean \"I know I must pass the info but I don't know the info\", which is different from \"I don't care about the protocol\" or passing a dummy value just to fill the hole.",
          "createdAt": "2019-03-28T18:00:11Z",
          "updatedAt": "2019-03-28T18:00:11Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In the original base material of header definitions, empty values were generally just not sent at all.\r\n\r\nHaving a specific Null value may or not make sense, not sure.",
          "createdAt": "2019-04-03T13:19:05Z",
          "updatedAt": "2019-04-03T13:19:05Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "On Wed, Apr 03, 2019 at 06:19:09AM -0700, Poul-Henning Kamp wrote:\n> In the original base material of header definitions, empty values were generally just not sent at all.\n> \n> Having a specific Null value may or not make sense, not sure.\n\nI personally like the distinction between \"known to be empty\" and\n\"not presented either because I don't know or because it's empty\".\nSome semantics might explicitly require the presence of some fields\nwhich we would enforce by the protocol. This doesn't mean they can't\nbe empty, they must be present, for example, to make sure they weren't\ndropped in the middle. For example, \"Connection: foo\" gets rid of the\nfield, not just the value.\n\nJust my two cents,\nWilly\n",
          "createdAt": "2019-04-03T19:59:38Z",
          "updatedAt": "2019-04-03T19:59:38Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do we have any RFC'ed headers where there is a difference between a non-present and an empty header ?",
          "createdAt": "2019-04-05T08:29:13Z",
          "updatedAt": "2019-04-05T08:29:13Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "On Fri, Apr 05, 2019 at 01:29:16AM -0700, Poul-Henning Kamp wrote:\n> Do we have any RFC'ed headers where there is a difference between a\n> non-present and an empty header ?\n\nThere's an accept-something if I remember well. Also I've been using\n\"Host:\" in many occasions with HTTP/1.1 requests when I didn't know\nthe host name and this tends to work where no Host field fails ;-)\n\nWilly\n",
          "createdAt": "2019-04-05T08:33:10Z",
          "updatedAt": "2019-04-05T08:33:10Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not against a '?N' null token (along the lines of true/false), but I have a hard time thinking of a use for it.",
          "createdAt": "2019-04-05T08:35:09Z",
          "updatedAt": "2019-04-05T08:35:09Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://greenbytes.de/tech/webdav/rfc7231.html#rfc.section.5.3.4.p.6",
          "createdAt": "2019-04-05T08:36:26Z",
          "updatedAt": "2019-04-05T08:36:26Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Wouldn't an empty list be equivalent to an empty value, thus we don't need a new syntax?",
          "createdAt": "2019-04-05T08:37:08Z",
          "updatedAt": "2019-04-05T08:37:08Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Putting an empty list where for instance an integer is expected, just to say that there will be none, sounds counter-intuitive to me.",
          "createdAt": "2019-04-05T10:10:58Z",
          "updatedAt": "2019-04-05T10:10:58Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "On Fri, Apr 05, 2019 at 01:37:11AM -0700, Julian Reschke wrote:\n> Wouldn't an empty list be equivalent to an empty value, thus we don't need a\n> new syntax?\n\nIndeed, probably.\n",
          "createdAt": "2019-04-06T05:39:55Z",
          "updatedAt": "2019-04-06T05:39:55Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "On Fri, Apr 05, 2019 at 03:11:00AM -0700, Poul-Henning Kamp wrote:\n> Putting an empty list where for instance an integer is expected, just to say\n> that there will be none, sounds counter-intuitive to me.\n\nAgreed in general. My point was that sometimes specs use \"MUST send\" when\nthe sender doesn't know, resulting in stupid values appearing. That's\nexactly what led a number of agents to place a content-length with stupid\nvalues (0 or huge ones) with the CONNECT method a long time ago.\n\nAn empty value where an integer is needed by the application is more of\nan application-level error than a protocol-level one in my opinion : it's\nup to the application to decide how to recover from this missing piece of\ninformation (is it really needed to process the request or not). For me\nit can mean \"don't care\", \"don't know\" or \"not representable\". After all\nfloats support \"NaN\" for the same reason :-)\n\nWilly\n",
          "createdAt": "2019-04-06T05:45:40Z",
          "updatedAt": "2019-04-06T05:45:40Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If there is a \"MUST send\" requirement, there must also be something available in the same spec that can be sent ?",
          "createdAt": "2019-04-08T19:39:02Z",
          "updatedAt": "2019-04-08T19:39:02Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "There is not, and never has been, an interop problem with sending empty field values. They are a list value of zero items or a string item of zero length. Accept and Host, respectively.",
          "createdAt": "2019-04-08T20:52:56Z",
          "updatedAt": "2019-04-08T20:52:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@royfielding how do you know that?",
          "createdAt": "2019-04-08T23:24:44Z",
          "updatedAt": "2019-04-08T23:24:44Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "Because if a recipient drops an empty Host field the request will be rejected with 400. There have been no reports of such breakage in 25 years. It isn\u2019t even a likely scenario given how message fields are parsed and reproduced.",
          "createdAt": "2019-04-09T00:05:34Z",
          "updatedAt": "2019-04-09T00:05:34Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "If a recipient *doesn't* drop an empty host header, the request will still be rejected with 400, surely?\r\n\r\nRegardless, I'd note that many headers address this situation with a reserved value like `none`. Is there value in standardising on one such value for future headers? I'm not convinced, but I'd note that we also have many headers that use `*` to denote \"all\"; it seems to me that if we're going to do null, we should do that too (but again, I'm not convinced this is adding value).",
          "createdAt": "2019-04-09T00:16:39Z",
          "updatedAt": "2019-04-09T00:16:39Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "On Mon, Apr 08, 2019 at 05:16:41PM -0700, Mark Nottingham wrote:\n> If a recipient *doesn't* drop an empty host header, the request will still be\n> rejected with 400, surely?\n\nIt depends on the header field that was empty ;-)  I've used the empty Host\nheader field quite a bit (even in health check requests). My observation has\nbeen that while HTTP/1.1 without Host naturally causes a 400, HTTP/1.1 with\nempty Host is often processed similar to HTTP/1.0 without Host or as 1.1\nwith an unknown Host.\n\n> Regardless, I'd note that many headers address this situation with a reserved\n> value like `none`. Is there value in standardising on one such value for\n> future headers? I'm not convinced, but I'd note that we also have many\n> headers that use `*` to denote \"all\"; it seems to me that if we're going to\n> do null, we should do that too (but again, I'm not convinced this is adding\n> value).\n\nI'd say \"why not\", but it's useful to consider lists and the iterative\nprocessing that can happen, removing one item at a time. Having to place\na specific value to denote emptiness would require specific processing\n(i.e. check for emptiness after removing any item just for the sake of\nreplacing it with the special value).\n\nBy the way, speaking about lists makes me think we may complicate interop\nwhen a header field appears multiple times. For example if we have this\nin a request :\n\n     List: a,b,c,d\n     Foo: bar\n     List: e,f,g,h\n\nIt's not unreasonable to think that some simplified implementations may\nreplace the first occurrence of List with \"none\" after processing it,\nleading to this :\n\n     List: none\n     Foo: bar\n     List: e,f,g,h\n\nOr possibly this :\n\n     List: none\n     Foo: bar\n     List: none\n\nWhich may be processed as \"List: none,e,f,g,h\" or \"List: none,none\"\nrespectively.\n\nJust my two cents,\nWilly\n",
          "createdAt": "2019-04-09T02:28:30Z",
          "updatedAt": "2019-04-09T02:28:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Willy, I think that would be clearly broken, and we should be able to catch it with tests.\r\n\r\nI think we're talking about all of the container types here (dict, list, list of lists, parameterised lists), correct?\r\n\r\nJulian, you gave `Accept-Encoding` as an example. Given that the behaviour recommended is exactly the same as if the header was missing, that's not very compelling.\r\n\r\nBesides the potential stripping issue (I have heard of implementations that strip empty headers, but don't have details on hand), some header libraries may not make a distinction between missing and empty headers. \r\n\r\nOverall, I don't see a lot of value in accommodating empty headers directly, and I don't think we should be promoting it as a practice.\r\n",
          "createdAt": "2019-04-10T08:03:36Z",
          "updatedAt": "2019-04-10T08:03:36Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree, I'm not convinced either.\r\n\r\nI see the potential, but Gettys rule #3 applies:\r\n\r\n   \"The only thing worse than generalizing from one example is generalizing from no examples at all.\"\r\n\r\n(May actually be from Phil Karlton originally, sources differ.)\r\n",
          "createdAt": "2019-04-10T08:35:36Z",
          "updatedAt": "2019-04-10T08:35:36Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Julian, you gave Accept-Encoding as an example. Given that the behaviour recommended is exactly the same as if the header was missing, that's not very compelling.\r\n\r\nHm, no.\r\n\r\n\"A request without an Accept-Encoding header field implies that the user agent has no preferences regarding content-codings.\"\r\n\r\nvs.\r\n\r\n\"An Accept-Encoding header field with a combined field-value that is empty implies that the user agent does not want any content-coding in response.\"\r\n",
          "createdAt": "2019-04-10T08:37:59Z",
          "updatedAt": "2019-04-10T08:37:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes, but in the real world, the outcome is always the same.",
          "createdAt": "2019-04-10T11:51:46Z",
          "updatedAt": "2019-04-10T11:51:46Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "> If a recipient _doesn't_ drop an empty host header, the request will still be rejected with 400, surely?\r\n\r\nNo. HTTP/1.1 introduced an IESG requirement that Host must always be sent and recipients must always reject with 400 if Host is not received. When I pointed out that not all URIs have a host, the response was that clients must send an empty Host field in that situation. It is a MUST requirement in Semantics section 5.4: `If the authority component is missing or undefined for the target URI, then a client MUST send a Host header field with an empty field-value.`\r\n\r\nThis is ingrained in HTTP semantics and commonly used by non-browser HTTP implementations.\r\n\r\n> Regardless, I'd note that many headers address this situation with a reserved value like `none`. Is there value in standardising on one such value for future headers? I'm not convinced, but I'd note that we also have many headers that use `*` to denote \"all\"; it seems to me that if we're going to do null, we should do that too (but again, I'm not convinced this is adding value).\r\n\r\nThere is only one example of an HTTP header field using \"none\" and that is Accept-Ranges. It isn't a good example for anything.\r\n\r\nTo be clear, it would be a bug for an HTTP message processor to drop a received header field just because the value is empty. Nothing about SH will change that. What we are discussing is whether SH is capable of representing an empty list or an empty header field, both of which it is currently incapable of doing.",
          "createdAt": "2019-04-10T17:36:17Z",
          "updatedAt": "2019-04-10T17:36:17Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If that spec specifically says \"empty field-value\", a SH \"empty\" token will not be usable for Host: anyway, and we're back in the \"generalizing from no example at all\" again.",
          "createdAt": "2019-04-11T15:53:13Z",
          "updatedAt": "2019-04-11T15:53:13Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "On Thu, Apr 11, 2019 at 03:53:15PM +0000, Poul-Henning Kamp wrote:\n> If that spec specifically says \"empty field-value\", a SH \"empty\" token will\n> not be usable for Host: anyway, and we're back in the \"generalizing from no\n> example at all\" again.\n\nAfter having thought a bit more about this, I now think that we don't\nneed empty list elements in the end because lists are not strongly\nordered, they're not arrays with a position so an empty element in a\nlist brings no value. I'd further say that removing an element from a\nlist must result in removing the list once the last one was removed as\nit is a set. So I think I'm fine with not dealing with empty lists.\n\nThis then leaves us only with the empty header field alone, likely where\na string or a token are expected. I don't see a reason not to support an\nempty string just like any other string.\n\nA header field is not just a value, it's a name+value combination. With\na void value the name still serves as a boolean (present or not) and\nthis is exactly how it's used when the field is made mandatory to\ndistinguish between agents generations or as a signal to detect support\nfor something.\n\nWe've all filled administrative forms where the requested information\nwas irrelevant but mandatory in the form and just left it void so that\nthe person in charge deals with the particular case (on paper) or\nfilled with whatever was accepted (on web forms) hoping it would just\nbe ignored since irrelevant. For me the Accept and Host fields are\nexactly in this category.\n\nMy concern is to be certain that a valid HTTP request can be transmitted\nover SH. And ironically, the only mandatory HTTP header (\"Host\") is also\nthe one requiring the support for an empty value due to its mandatory\nnature.\n\nWilly\n",
          "createdAt": "2019-04-11T16:12:46Z",
          "updatedAt": "2019-04-11T16:12:46Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have lost count of the number of packages I have received from USA where part of the address is \"Denmark does not have states\" :-)",
          "createdAt": "2019-04-12T20:46:27Z",
          "updatedAt": "2019-04-12T20:46:27Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Again, the purpose of SH is not to allow all possible HTTP header to be represented in the data model -- it's to solidify the 80% case and promote best (and interoperable) practice. Representing a boolean as an empty header field is *not* good practice.",
          "createdAt": "2019-04-15T06:25:35Z",
          "updatedAt": "2019-04-15T06:25:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "See PR above.",
          "createdAt": "2019-07-02T04:23:40Z",
          "updatedAt": "2019-07-02T04:23:40Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I've put in the changes for the list-based header fields.\r\n\r\nIt's less clear to me that it's desirable to default a missing or empty item to an empty string (strings and tokens) 0 (integers and floats), False (boolean) or a 0-length binary array (binary data); to me, those are all going to be application-specific defaults that are better specified explicitly. I'm happy to adjust the spec to make that more clear, if folks feel it already isn't.",
          "createdAt": "2019-07-04T08:55:11Z",
          "updatedAt": "2019-07-04T08:55:11Z"
        }
      ]
    },
    {
      "number": 782,
      "id": "MDU6SXNzdWU0MjY0MjI0NTI=",
      "title": "define a URI reference type",
      "url": "https://github.com/httpwg/http-extensions/issues/782",
      "state": "CLOSED",
      "author": "royfielding",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "SH does not have a common type for URI references, which is odd given how common it is to distinguish references from other forms of string. The expected syntax would be the same as the Link header field:\r\n\r\n     sh-item      += sh-reference\r\n     sh-reference  = \"<\" URI-reference \">\"\r\n\r\nor something like that.",
      "createdAt": "2019-03-28T10:45:43Z",
      "updatedAt": "2019-07-29T21:00:11Z",
      "closedAt": "2019-07-29T21:00:11Z",
      "comments": [
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The reason this was not in my original work, was that it was based on existing headers where (at least at the time) URIs were in a header of their own.\r\n\r\nWhere we are now, having a URI type probably makes sense.",
          "createdAt": "2019-04-03T13:16:57Z",
          "updatedAt": "2019-04-03T13:16:57Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "On Wed, Apr 03, 2019 at 06:17:00AM -0700, Poul-Henning Kamp wrote:\n> Where we are now, having a URI type probably makes sense.\n\n+1, at least because it could allow better normalization.\n\nWilly\n",
          "createdAt": "2019-04-03T19:55:28Z",
          "updatedAt": "2019-04-03T19:55:28Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "My inclination is to make this a strict URI reference, not a \"sloppy\" URL. Thoughts? @annevk?",
          "createdAt": "2019-04-04T08:54:16Z",
          "updatedAt": "2019-04-04T08:54:16Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I don't think browsers would implement a second URL parser for this, if that's what you're asking.",
          "createdAt": "2019-04-04T09:07:14Z",
          "updatedAt": "2019-04-04T09:07:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Even if we define the step-by-step algorithm, like the other types?",
          "createdAt": "2019-04-04T09:08:00Z",
          "updatedAt": "2019-04-04T09:08:00Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "Personally, I don't see any reason to limit URI reference other than to say that non-URI octets must be utf-8. That is something we could not say before, but I have no problem saying it for SH.",
          "createdAt": "2019-04-04T09:13:34Z",
          "updatedAt": "2019-04-04T09:13:34Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Are we confident that UTF-8 would survive all hops?\r\n\r\nIf we're going to loosen it up, we should refer to a specific algorithm, so that it's interoperable. The obvious (and probably only workable) candidate is the [whatwg one](https://url.spec.whatwg.org/#url-parsing), but I need to dig into how workable that would be here.\r\n\r\nIf we use it, we also have to figure out how to reference it; while browsers can keep up with changes over time it's not clear that other libraries will.",
          "createdAt": "2019-04-04T09:17:48Z",
          "updatedAt": "2019-04-04T09:17:48Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "URI References is a draft I have already been working on -- I just put it aside for httpbis v5.",
          "createdAt": "2019-04-04T09:19:47Z",
          "updatedAt": "2019-04-04T09:19:47Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'm reluctant to take a dependency on that at such a late stage; maybe we should add a URL type after shipping SHv1.",
          "createdAt": "2019-04-04T09:20:34Z",
          "updatedAt": "2019-04-04T09:20:34Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "It's just a string for SH.  My draft would update RFC3986, orthogonal to SH.\r\n\r\nAll you have to define is the delimiters and refer to it as a URI reference, which is defined by RFC3986. The SH algorithm is a string with angle bracket delimiters, unconstrained by the syntax of URI, which is the same thing 3986 says. All non-URI characters inside that string are handled by the reference algorithm, not the SH algorithm.",
          "createdAt": "2019-04-04T09:29:28Z",
          "updatedAt": "2019-04-04T09:29:28Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "So it's a UTF-8 string with a different type. Since it's unclear what the base URL is, it cannot be used for \"follow your nose\", right? What potential benefits does it give?",
          "createdAt": "2019-04-04T09:47:39Z",
          "updatedAt": "2019-04-04T09:47:39Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "By default, the base URI would be the same as for all other header fields (the request target). A given field might define some other base, but that would be rare. I would not expect a parser to resolve the reference until it needs to (i.e., evoking the semantics).",
          "createdAt": "2019-04-04T09:56:23Z",
          "updatedAt": "2019-04-04T09:56:23Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "If it's \"just a string for SH\", it seems like we're not adding much value over... strings. The whole point of SH is to make sure that things are parsed the same way.",
          "createdAt": "2019-04-04T19:51:31Z",
          "updatedAt": "2019-04-04T19:51:31Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would not take a signal that browsers won't do anything special as a blocker. Others may do something special.",
          "createdAt": "2019-04-05T07:10:50Z",
          "updatedAt": "2019-04-05T07:10:50Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If it's \"just a string for SH\", it seems like we're not adding much value over... strings. The whole point of SH is to make sure that things are parsed the same way.\r\n\r\nI can see the point of having a SH-type for UR[IL]'s which can cabin and track future developments in that space, but we need to stick a firm SH definition on it.\r\n\r\nThe SH definition can and should be loose with respect to whatever normative references think a UR[IL] might currently look like, because it just has to reliably pluck the UR[IL] out of the SH stream, it does not have to interpret the UR[IL] or explain its semantics.\r\n\r\nI don't think it is SH's job to SHALL 3986 for normative semantics of the data transferred, but a SHOULD or MUST makes sense.\r\n\r\nI am however firmly NO on non-ASCII\r\n\r\nStrawman:\r\n\r\n    sh-urichar = %21-%3C / %3E-%7E\r\n \r\n    sh-uri = \"<\" 1*(sh-urichar) \">\"\r\n\r\nThat way, SH does not get in the way of anything 3986 or successors might want to do.\r\n\r\nIf we wanted to we could do:\r\n\r\n    sh-urichar = %21-%3C / %3E-%7E\r\n \r\n    sh-uri-strict = \"<\" 1*(sh-urichar) \">\"\r\n    \r\n    sh-uri-loose = \"<\" \"<\" 1*(sh-urichar) \">\" \">\"\r\n\r\nwhere sh-uri-strict is SHALL 3986 and sh-uri-loose is for non-3986 URIs\r\n\r\n",
          "createdAt": "2019-04-05T08:27:32Z",
          "updatedAt": "2019-04-05T08:27:32Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't think it is SH's job to SHALL 3986 for normative semantics of the data transferred, but a SHOULD or MUST makes sense.\r\n\r\nMUST == SHALL\r\n\r\n> I am however firmly NO on non-ASCII\r\n\r\nI also don't see why to allow it here but not in strings...",
          "createdAt": "2019-04-05T08:39:06Z",
          "updatedAt": "2019-04-05T08:39:06Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'm now -1 on adding this; I don't think we're going to get something useful out of this without a lot more work, and SH is almost done. Nothing stops this being defined later.",
          "createdAt": "2019-04-05T08:44:18Z",
          "updatedAt": "2019-04-05T08:44:18Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "works for me.",
          "createdAt": "2019-04-05T10:12:01Z",
          "updatedAt": "2019-04-05T10:12:01Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the ability to apply this to the Link header field is pretty compelling.",
          "createdAt": "2019-04-05T10:13:58Z",
          "updatedAt": "2019-04-05T10:13:58Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It doesn't really make any real-world difference in context of headers like Link where the only content is the URI.\r\n\r\nWhere it would make a difference would be headers that have URI(s) and other data in a single header.",
          "createdAt": "2019-04-05T10:27:05Z",
          "updatedAt": "2019-04-05T10:27:05Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think you are confusing \"Link\" (which has other content) with \"Location\".",
          "createdAt": "2019-04-05T10:34:58Z",
          "updatedAt": "2019-04-05T10:34:58Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think not having a URI type would be more consistent to our previous conclusion to not have the Date type (#685).",
          "createdAt": "2019-07-22T21:08:18Z",
          "updatedAt": "2019-07-22T21:08:18Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Consensus in the room in Montreal was to not include a specific URI type (to close this issue).",
          "createdAt": "2019-07-22T21:21:36Z",
          "updatedAt": "2019-07-22T21:21:36Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "works for me.",
          "createdAt": "2019-07-29T20:12:50Z",
          "updatedAt": "2019-07-29T20:12:50Z"
        }
      ]
    },
    {
      "number": 783,
      "id": "MDU6SXNzdWU0MjY0ODgwOTI=",
      "title": "Variant-Key needs justification",
      "url": "https://github.com/httpwg/http-extensions/issues/783",
      "state": "CLOSED",
      "author": "royfielding",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "As mentioned in Prague, I don't see why the origin server is sending duplicate metadata in the Variant-Key field when the data should already be present in content metadata fields. This is true for all of the examples in the spec, but perhaps you have other examples in mind for which that would not be the case?\r\n\r\nI know it is simpler for caches to not have to look at every field, but they can determine this from the metadata during the post-store non-critical path. In general, I don't think we should send redundant data on the wire unless absolutely necessary. It also runs the risk of reality distortion if the key (mistakenly) contradicts the metadata.",
      "createdAt": "2019-03-28T13:20:17Z",
      "updatedAt": "2019-09-01T06:11:25Z",
      "closedAt": "2019-09-01T06:11:25Z",
      "comments": [
        {
          "author": "wimleers",
          "authorAssociation": "NONE",
          "body": "I _think_ @mnot chose this approach to signal that a single response variant can satisfy multiple possible requests. i.e. this bit in the text:\r\n\r\n> If the response can be used to satisfy more than one request, they can be listed in additional members. For example:\r\n> ```\r\n> Variants: Accept-Encoding;gzip;br, Accept-Language;en ;fr\r\n> Variant-Key: gzip;fr, \"identity\";fr\r\n> ```\r\n> indicates that this response can be used for requests whose Accept-Encoding algorithm selects \u201cgzip\u201d or \u201cidentity\u201d, as long as the Accept-Language algorithm selects \u201cfr\u201d \u2013 **perhaps because there is no gzip-compressed French representation.**\r\n\r\n(Emphasis mine.)\r\n\r\nBut I also struggle to see how widely useful this would be. The emphasized sentence in the quote is not a particularly widespread use case, and hence not very convincing.\r\n\r\nI also agree with the reality distortion risk :)\r\n\r\nPerhaps @mnot has concrete use cases in mind for less common request/response headers?",
          "createdAt": "2019-04-06T09:14:02Z",
          "updatedAt": "2019-04-06T09:14:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes; I've seen cases where this (having multiple possible cache keys) quite a lot.\r\n\r\nAlso, for header compression, the Variants information is less likely to change from representation to representation, and so it compresses better when it's separated out. See [this](https://www.mnot.net/blog/2018/11/27/header_compression).",
          "createdAt": "2019-08-30T09:04:33Z",
          "updatedAt": "2019-08-30T09:04:33Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1.  Envision this as a Karnaugh map minimization.  The Variants header tells you what all the possible inputs are, but the Variant-Key header enables you to do the minimization step, circling multiple outputs and marking them as a single outcome.\r\n\r\nA more convincing case for me, though probably not something we want to explicitly encourage, is this:\r\n\r\n    Variants:  Sec-CH-Model;\"Chrome 77\";\"Chrome 76\";\"Chrome 75\";\"Firefox 68\";\"Firefox 67\"\r\n    Variant-Key:  \"Chrome 77\", \"Firefox 68\"\r\n\r\nThat is, \"I would have served this content to the most recent versions of Firefox or Chrome, but would have served different content to an older browser.\"  Without this, resources would be separately cached for each possible value of Sec-CH-UA.",
          "createdAt": "2019-08-30T14:21:30Z",
          "updatedAt": "2019-08-30T14:45:19Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "See also the cookie example I've roughed into the current editor's draft.",
          "createdAt": "2019-08-31T00:52:35Z",
          "updatedAt": "2019-08-31T00:52:35Z"
        }
      ]
    },
    {
      "number": 784,
      "id": "MDU6SXNzdWU0Mjg3NDQxOTg=",
      "title": "Boolean type character choice",
      "url": "https://github.com/httpwg/http-extensions/issues/784",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "This is going to sound like a bikeshed comment, but it's probably worth thinking about:\r\n\r\nThe current syntax uses `?T` and `?F`.  In sitting through a presentation today, I realized that, from a distance, these two strings are hard to distinguish if the text is small enough.  Looking at the QPACK table, I observe that existing header fields often use `1` to mean \"true\".\r\n\r\nI propose that the syntax be changed to `?0` and `?1`.",
      "createdAt": "2019-04-03T12:39:52Z",
      "updatedAt": "2019-04-10T07:37:00Z",
      "closedAt": "2019-04-10T07:37:00Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Some feedback on this suggestion:\r\n> Mike West   I suspect that `Sec-Fetch-User` is going to be the first boolean header hitting the wire. So. Hammer it out quickly, please (@mnot).\r\n> Mike West   Ideally shipping in Chrome 75, which branches on the 18th. ",
          "createdAt": "2019-04-03T12:49:35Z",
          "updatedAt": "2019-04-03T12:49:35Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No opinion.",
          "createdAt": "2019-04-03T13:14:23Z",
          "updatedAt": "2019-04-03T13:14:23Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think the benefits aren't significant enough to change, given that it's already in use by some. Practically speaking, if you project HTTP headers that small, you're going to have lots of other problems too.",
          "createdAt": "2019-04-03T13:50:15Z",
          "updatedAt": "2019-04-03T13:50:15Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "On Wed, Apr 03, 2019 at 05:39:55AM -0700, Martin Thomson wrote:\n> I propose that the syntax be changed to `?0` and `?1`.\n\nI'm used to 0 and 1 as well in general and I didn't first get this\n?T/?F to be honest :-)\n\nWilly\n\n",
          "createdAt": "2019-04-03T19:52:23Z",
          "updatedAt": "2019-04-03T19:52:23Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The non-english interpretation (of lack thereof) is persuasive here. @mikewest @jyasskin will changing this now cause any significant pain? Anyone else?",
          "createdAt": "2019-04-04T08:52:47Z",
          "updatedAt": "2019-04-04T08:52:47Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Signed Exchanges don't have any Boolean fields, and they're versioned anyway so we could change the parsing.",
          "createdAt": "2019-04-04T13:59:33Z",
          "updatedAt": "2019-04-04T13:59:33Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I'm happy for `Sec-Fetch-User` to serialize however you'd like. Pick something, tell me what it is, and I'll do it. Assuming it'll be `?1`, I filed https://bugs.chromium.org/p/chromium/issues/detail?id=949894 and put up https://chromium-review.googlesource.com/c/chromium/src/+/1554484.",
          "createdAt": "2019-04-05T07:08:52Z",
          "updatedAt": "2019-04-05T07:08:52Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Still no opinion :-)",
          "createdAt": "2019-04-05T08:35:57Z",
          "updatedAt": "2019-04-05T08:35:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Let's do `0` / `1`",
          "createdAt": "2019-04-05T08:44:50Z",
          "updatedAt": "2019-04-05T08:44:50Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "With the `?` prefix, though (`?0`/`?1`), right?",
          "createdAt": "2019-04-05T08:46:22Z",
          "updatedAt": "2019-04-05T08:46:22Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "?1",
          "createdAt": "2019-04-05T08:47:37Z",
          "updatedAt": "2019-04-05T08:47:37Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "(Maybe we can use :+1: and :-1: instead?)",
          "createdAt": "2019-04-05T08:49:32Z",
          "updatedAt": "2019-04-05T08:49:32Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "(That was a joke, just in case it wasn't clear. `?1` is just as great as `?T`, and I'll aim to land https://chromium-review.googlesource.com/c/chromium/src/+/1554484 to lock that into Chrome's implementation shortly.)",
          "createdAt": "2019-04-05T09:30:00Z",
          "updatedAt": "2019-04-05T09:30:00Z"
        },
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "The root cause here seems to be interplay between the similar visual appearance of the Greek digamma (`\u03dc`) and tau (`\u03a4`) which became a problem during the introduction of the West Saxon _triewe_ and _false_ to mean opposing values of truthiness (both introduced in the Old English revision, ca. AD 1200). \r\n\r\nRather than work around this legacy problem with the use of numerals, I would recommend reverting to the last character notation that didn't exhibit the problem -- Phoenician could be fine, though we might have to go as far back as Ugaritic.",
          "createdAt": "2019-04-05T10:01:02Z",
          "updatedAt": "2019-04-05T10:01:02Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "@arturjanc: I am not changing Chrome to support Ugaritic. Or Phoenician. :)",
          "createdAt": "2019-04-05T12:35:39Z",
          "updatedAt": "2019-04-05T12:35:39Z"
        }
      ]
    },
    {
      "number": 785,
      "id": "MDU6SXNzdWU0Mjg3NDY5NTA=",
      "title": "Trailing '*' in binary",
      "url": "https://github.com/httpwg/http-extensions/issues/785",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "The syntax requires a '*' at the end, but this doesn't seem to be necessary.",
      "createdAt": "2019-04-03T12:45:46Z",
      "updatedAt": "2019-04-10T07:28:34Z",
      "closedAt": "2019-04-10T07:28:34Z",
      "comments": [
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That is a left-over detail from a much earlier version which supported recursive structures.\r\n\r\nI like the symmetry of having \"quoted\" types (string, binary, possibly URI) being bracketed in both ends, but I am not religious about it.",
          "createdAt": "2019-04-03T13:14:03Z",
          "updatedAt": "2019-04-03T13:14:03Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "On Wed, Apr 03, 2019 at 06:14:06AM -0700, Poul-Henning Kamp wrote:\n> That is a left-over detail from a much earlier version which supported recursive structures.\n> \n> I like the symmetry of having \"quoted\" types (string, binary, possibly URI) being bracketed in both ends, but I am not religious about it.\n\nI like bracketed strings as well as long as they use a different opening\nand closing character, when it's the same it always gets painful once this\nhas to be embedded somewhere else.\n\nWith that said I'm not convinced that leaving only the heading star would\nsignificantly improve readability, reliability, or anything.\n\nWilly\n",
          "createdAt": "2019-04-03T19:54:28Z",
          "updatedAt": "2019-04-03T19:54:28Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For \"inscrutiable\" data like base64, the trailing asterix does make it easier to see that truncation did not happen.",
          "createdAt": "2019-04-03T22:28:25Z",
          "updatedAt": "2019-04-03T22:28:25Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "On Wed, Apr 03, 2019 at 03:28:28PM -0700, Poul-Henning Kamp wrote:\n> For \"inscrutiable\" data like base64, the trailing asterix does make it easier to see that truncation did not happen.\nGood point!\n\nWilly\n",
          "createdAt": "2019-04-04T03:02:11Z",
          "updatedAt": "2019-04-04T03:02:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson do you find that convincing?\r\n\r\nThis is close to bike shedding, but I like it better balanced.",
          "createdAt": "2019-04-04T08:55:25Z",
          "updatedAt": "2019-04-04T08:55:25Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I really don't care, but will observe that truncation is unlikely in h2. And = is also good for one in three values.  The notion of aesthetics is bizarre, but everyone has different views on that.",
          "createdAt": "2019-04-05T07:07:53Z",
          "updatedAt": "2019-04-05T07:07:53Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "On Fri, Apr 05, 2019 at 12:07:56AM -0700, Martin Thomson wrote:\n> I really don't care, but will observe that truncation is unlikely in h2. And\n> = is also good for one in three values.  The notion of aesthetics is bizarre,\n> but everyone has different views on that.\n\nWell, to fuel the discussion, I'd say that truncation may happen at the\napplication layer when retrieving the value before decoding it, but it's\njust the same for any other header field or URI or whatever so we don't\nsignificantly improve the situation with this.\n\nAlso some other types are prefixed with a \"?\" and we don't postfix the\nvalue with this character.\n\nWhile initially my intuition made me prefer the star on each side,\nprobably due to aesthetic reasons influencing me, now as a developer\nI'm thinking that having to add special processing in my parsers to\nstop on '*' or '\\0' is probably more code for little value, and that\nthere will unlikely be some specific code to deal with the rare error\nwhere the value is missing the trailing '*', which also means that we\nmay see such occurrences appear in field.\n\nSo in the end I think I'm more in favor of dropping the trailing star\nto limit implementation divergence.\n\nWilly\n",
          "createdAt": "2019-04-06T05:38:10Z",
          "updatedAt": "2019-04-06T05:38:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We can test for missing `*` to assure consistent implementation (and IIRC we already do).\r\n\r\nI'm going to close this as a bike shed; if someone violently disagrees, I guess we can reopen, but I'm not hearing that yet.",
          "createdAt": "2019-04-10T07:28:34Z",
          "updatedAt": "2019-04-10T07:28:34Z"
        }
      ]
    },
    {
      "number": 786,
      "id": "MDU6SXNzdWU0MjkxMjMyMjE=",
      "title": "Active vs. passive fingerprinting",
      "url": "https://github.com/httpwg/http-extensions/issues/786",
      "state": "CLOSED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "At IETF 104's HTTPWG meeting, @ekr raised concerns about the categorization of Client Hints as an active fingerprinting vector, claiming that they are in-fact passive, because (IIUC) they can be persisted beyond the point where the information was requested, and persisted for future requests on current and future sessions to the same host.\r\n\r\nMy response to that was that this is something origins already do with cookies today, and that Client Hints access can be monitored by browsers in similar ways to other active fingerprinting vectors. On top of that, Client Hints opt-in persistence is purged when the user deletes their cookies, and support is disabled when JS is disabled.\r\n\r\nTalking to @martinthomson, it seems like there's another concern around the fact that the hints change when the values does. That seems similar to me to various change events around the exposed values (which do exist for most if not all Client Hints features). Browsers can track CH value changes in similar ways to active fingerprinting vector change events, and treat registration as if the origin accessed the equivalent API and subscribed to receive future events. Similarly, browsers can also mitigate that change reporting in similar ways (e.g. omit the hints or lie about them in some cases).\r\n\r\n@martinthomson & @ekr - Does the above properly captures the concerns you raised? If so, do the mitigations make sense and properly address them?\r\n\r\nIf they do, I'm happy to modify the security & privacy consideration sections to reflect the above",
      "createdAt": "2019-04-04T07:28:32Z",
      "updatedAt": "2019-12-04T22:24:16Z",
      "closedAt": "2019-12-04T22:24:16Z",
      "comments": [
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "I believe there is a good deal of overlap between this issue and the concerns raised in https://github.com/httpwg/http-extensions/issues/786",
          "createdAt": "2019-04-08T16:41:34Z",
          "updatedAt": "2019-04-08T16:41:34Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I believe there is a good deal of overlap between this issue and the concerns raised in #786\r\n\r\n#786 is this issue. I'm guessing you meant something different :)",
          "createdAt": "2019-04-08T17:54:30Z",
          "updatedAt": "2019-04-08T17:54:30Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "Derp you are exactly right, apologies! \r\n\r\nHere is the one I meant: https://github.com/httpwg/http-extensions/issues/767",
          "createdAt": "2019-04-08T17:57:26Z",
          "updatedAt": "2019-04-08T17:57:26Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe those issues are rather different. The threat model here is persistence of the hints in the browser, where for #767 is seems like the threat model is persistence on the server side. As they are rather different, mitigations for either can be fairly different as well.",
          "createdAt": "2019-04-08T18:03:52Z",
          "updatedAt": "2019-04-08T18:03:52Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "I see, point taken. I meant mostly in terms of the discussion of whether or not CH is an increase in FP surface or not.  But I'm happy to deal with that discussion in both issues if thats preferred.\r\n\r\nHowever, I'd like to reiterate my concern / position that its not sufficient to deal with concerns like these in non-normative security & privacy consideration sections; that to be an appropriate addition to the web, the normative portions of the document should be negative or zero regarding fingerprinting surface / privacy risk. ",
          "createdAt": "2019-04-08T19:52:51Z",
          "updatedAt": "2019-04-08T19:52:51Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson and/or @ekr - does the above description match the concerns you raised during the WG meeting and after it? If so, do the mitigations I mentioned address those concerns? If not, why not?",
          "createdAt": "2019-05-17T15:01:30Z",
          "updatedAt": "2019-05-17T15:01:30Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "> At IETF 104's HTTPWG meeting, @ekr raised concerns about the\n> categorization of Client Hints as an active fingerprinting vector,\n> claiming that they are in-fact passive, because (IIUC) they can be\n> persisted beyond the point where the information was requested, and\n> persisted for future requests on current and future sessions to the\n> same host.\n\nThis seems approximately right. Take your location. With the JS\nAPI, then the client knows whenever the server gets the location,\nbut with the hint, then the client does not. So, in this respect,\nit's passive, not active.\n\n\n> My response to that was that this is something origins already do with\n> cookies today, and that Client Hints access can be monitored by\n> browsers in similar ways to other active fingerprinting vectors. On\n> top of that, Client Hints opt-in persistence is purged when the user\n> deletes their cookies, and support is disabled when JS is disabled.\n>\n> Talking to @martinthomson, it seems like there's another concern\n> around the fact that the hints change when the values does. That seems\n> similar to me to various change events around the exposed values\n> (which do exist for most if not all Client Hints features).\n\nRight. I think this is the most worrying case.\n\n\n> Browsers\n> can track CH value changes in similar ways to active fingerprinting\n> vector change events, and treat registration as if the origin accessed\n> the equivalent API and subscribed to receive future events.\n\nI don't quite understand this point. The key thing from my perspective\nis that when the only way to get access to a property value is to\nmake an active request, then the browser knows each time it is accessed,\nand has an opportunity to monitor for abuse. But when you can instead\nget access to it by subscribing (which is what CH is), and this is\nthe preferred modality, then it's not really possible to monitor for\nabusively high request levels.\n\nFor example, consider the case of PeerConnection. As we know, this has\nhigh fingerprinting potential (due to IP disclosure) and so sites\nroutinely creating PCs for no reason is a marker of abuse. Of course\nthere are sites which have legitimate uses of PC, but they might\n*also* be fingerprinting you. At present, we can distinguish these\nby looking to see when they create PCs, but if we were to replace\nPC by a hypothetical \"host IP address\" Client Hint, then it would\nnot be possible to distinguish sites which are both legitimate\nPC users and fingerprinters from sites which are legitimate PC\nusers and not fingerprinters.\n\nHow does the browser \"treat registration as if...\" usefully?\n\n\n> Similarly,\n> browsers can also mitigate that change reporting in similar ways\n> (e.g. omit the hints or lie about them in some cases).\n\nI don't really see how this is going to work. The hints become\nproblematic if you omit them or lie.\n\nOn Fri, May 17, 2019 at 8:01 AM Yoav Weiss <notifications@github.com> wrote:\n\n> @martinthomson <https://github.com/martinthomson> and/or @ekr\n> <https://github.com/ekr> - does the above description match the concerns\n> you raised during the WG meeting and after it? If so, do the mitigations I\n> mentioned address those concerns? If not, why not?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/httpwg/http-extensions/issues/786?email_source=notifications&email_token=AAIPLIJDLC4RT2ECIZIDW7TPV3CFBA5CNFSM4HDQOBUKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODVVAA7I#issuecomment-493486205>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIMFPOBZ7EAMONJOTVDPV3CFBANCNFSM4HDQOBUA>\n> .\n>\n",
          "createdAt": "2019-05-27T22:04:08Z",
          "updatedAt": "2019-05-27T22:04:08Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  > At IETF 104's HTTPWG meeting, @ekr raised concerns about the categorization of Client Hints as an active fingerprinting vector, claiming that they are in-fact passive, because (IIUC) they can be persisted beyond the point where the information was requested, and persisted for future requests on current and future sessions to the same host.\r\n\r\n> This seems approximately right. Take your location. With the JS API, then the client knows whenever the server gets the location, but with the hint, then the client does not. So, in this respect, it's passive, not active.\r\n\r\nI'm not sure I get why. Can't the client consider every time the hint is sent to the server that the server got the info?\r\n\r\n(location CH is not currently a thing, but we can have the same discussion for e.g. network info, which is).\r\n\r\n\r\n\r\n> > Browsers can track CH value changes in similar ways to active fingerprinting vector change events, and treat registration as if the origin accessed the equivalent API and subscribed to receive future events.\r\n\r\n> I don't quite understand this point. The key thing from my perspective is that when the only way to get access to a property value is to make an active request, then the browser knows each time it is accessed, and has an opportunity to monitor for abuse. But when you can instead get access to it by subscribing (which is what CH is), and this is the preferred modality, then it's not really possible to monitor for abusively high request levels.\r\n\r\nI agree that Client Hints is equivalent to subscribing to an active fingerprinting vector. E.g. the `Viewport` CH is very similar in that way to [MediaQueryList](https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList). JS code doesn't have to actively poll for MQ changes, but can get notified for them. I'm assuming that if developers have registered for that info, each time they'd get notified for it would be considered an \"active request\" for that information, and would be monitored for abuse. Similarly, browsers could track every time a CH value change is sent to the server and consider it an \"active request\" for that information for abuse tracking purposes. Does that make sense?\r\n\r\n\r\n\r\n> I don't really see how this is going to work. The hints become problematic if you omit them or lie.\r\n\r\nIn what way? The hints should be built as a progressive enhancement, and browsers which would omit or lie about them can make sure that adopting sites actually treat them like that.\r\n\r\n> For example, consider the case of PeerConnection. As we know, this has high fingerprinting potential (due to IP disclosure) and so sites routinely creating PCs for no reason is a marker of abuse. Of course there are sites which have legitimate uses of PC, but they might *also* be fingerprinting you. At present, we can distinguish these by looking to see when they create PCs, but if we were to replace PC by a hypothetical \"host IP address\" Client Hint, then it would not be possible to distinguish sites which are both legitimate PC users and fingerprinters from sites which are legitimate PC users and not fingerprinters. How does the browser \"treat registration as if...\" usefully?\r\n\r\nI don't really understand this example, but maybe it requires more knowledge about how PC is used for fingerprinting. Is there fingerprinting \"value\" in revealing the user's IP more than once? How do browsers distinguish legitimate from abusive usage today?",
          "createdAt": "2019-05-29T05:04:13Z",
          "updatedAt": "2019-05-29T11:17:50Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "On Tue, May 28, 2019 at 10:04 PM Yoav Weiss <notifications@github.com>\nwrote:\n\n> At IETF 104's HTTPWG meeting, @ekr <https://github.com/ekr> raised\n> concerns about the categorization of Client Hints as an active\n> fingerprinting vector, claiming that they are in-fact passive, because\n> (IIUC) they can be persisted beyond the point where the information was\n> requested, and persisted for future requests on current and future sessions\n> to the same host.\n>\n> This seems approximately right. Take your location. With the JS API, then\n> the client knows whenever the server gets the location, but with the hint,\n> then the client does not. So, in this respect, it's passive, not active.\n>\n> I'm not sure I get why. Can't the client consider every time the hint is\n> sent to the server that the server got the info?\n>\n> (location CH is not currently a thing, but we can have the same discussion\n> for e.g. network info, which is).\n>\n> Browsers can track CH value changes in similar ways to active\n> fingerprinting vector change events, and treat registration as if the\n> origin accessed the equivalent API and subscribed to receive future events.\n>\n> I don't quite understand this point. The key thing from my perspective is\n> that when the only way to get access to a property value is to make an\n> active request, then the browser knows each time it is accessed, and has an\n> opportunity to monitor for abuse. But when you can instead get access to it\n> by subscribing (which is what CH is), and this is the preferred modality,\n> then it's not really possible to monitor for abusively high request levels.\n>\n> I agree that Client Hints is equivalent to subscribing to an active\n> fingerprinting vector. E.g. the Viewport CH is very similar in that way\n> to [MediaQueryList](\n> https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList). JS code\n> doesn't have to actively poll for MQ changes, but can get notified for\n> them. I'm assuming that if developers have registered for that info, each\n> time they'd get notified for it would be considered an \"active request\" for\n> that information, and would be monitored for abuse. Similarly, browsers\n> could track every time a CH value change is sent to the server and consider\n> it an \"active request\" for that information for abuse tracking purposes.\n> Does that make sense?\n>\nNo, because if this is the default way in which people get this information\nthen you can't distinguish between abuse and non-abuse.\n\nAgain, the abuse monitoring is about looking ad the number of times and the\ncontext in which the site asks for the info, but in this case abuse and\nnon-abuse will look identical.\n\n\nI don't really see how this is going to work. The hints become problematic\n> if you omit them or lie.\n>\n> In what way? The hints should be built as a progressive enhancement, and\n> browsers which would omit or lie about them can make sure that adopting\n> sites actually treat them like that.\n>\nI'm not following. The point of the hint is lost if you lie, and so there's\nan incentive not to.\n\n\n> For example, consider the case of PeerConnection. As we know, this has\n> high fingerprinting potential (due to IP disclosure) and so sites routinely\n> creating PCs for no reason is a marker of abuse. Of course there are sites\n> which have legitimate uses of PC, but they might *also* be fingerprinting\n> you. At present, we can distinguish these by looking to see when they\n> create PCs, but if we were to replace PC by a hypothetical \"host IP\n> address\" Client Hint, then it would not be possible to distinguish sites\n> which are both legitimate PC users and fingerprinters from sites which are\n> legitimate PC users and not fingerprinters. How does the browser \"treat\n> registration as if...\" usefully?\n>\n> I don't really understand this example, but maybe it requires more\n> knowledge about how PC is used for fingerprinting. Is there fingerprinting\n> \"value\" in revealing the user's IP more than once? How do browsers\n> distinguish legitimate from abusive usage today?\n>\nWe typically do it via crawling and looking for what looks like abuse. See,\nfor instance,\nhttp://randomwalker.info/publications/OpenWPM_1_million_site_tracking_measurement.pdf\n",
          "createdAt": "2019-05-29T12:38:11Z",
          "updatedAt": "2019-05-29T12:38:11Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Hey folks! I'm skimming through this thread with https://github.com/WICG/ua-client-hints/ in mind, as it's something I'd like Chrome to continue pushing forward (also https://github.com/WICG/lang-client-hint/, but that turns out to be a bit more difficult given its usage).\r\n\r\nIn the UA use-case, browsers are broadcasting the value as an HTTP header on every request, which I think we would all agree enables completely passive fingerprinting. The CH infrastructure gives us a path towards requiring sites to affirmatively ask for details above and beyond the brand/version (either via CH or via the JS API), which would make usage visible to mechanisms like OpenWPM and browsers themselves. That seems like a strict improvement over the status quo. Would y'all disagree?\r\n\r\n@ekr: With regard to more traditional hints, I think you're correct to state that forcing information requests through JS APIs currently gives you more insight into the ways in which that information is used by a given application. I think you're also correct to say that CH removes the necessity to ask for a given bit of information on an ongoing basis. This means that fundamentally dual-use APIs will be more difficult to categorize if the work can be pushed to an opaque backend server.\r\n\r\nThat said, it seems likely that this is what we'll end up with in the not-so-distant future, as there are certainly incentives to reduce the number of times information is gathered in a world where it's well-known that those requests feed into a behavioral model for a given page. I talked with @yoavweiss about a model which would require a page to more persistently opt-in. Would a model in which `Accept-CH-Lifetime` would be dropped if the next navigation didn't include the relevant `Accept-CH` header, be interesting? That would give you more or less the same page-level detail about data being explicitly requested.",
          "createdAt": "2019-06-06T13:57:13Z",
          "updatedAt": "2019-06-06T13:57:13Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> abuse and non-abuse will look identical\r\n\r\nCan you clarify what you consider abusable values and if any of the current hints fall into that category? (i.e. viewport width, DPR, image width, network RTT, BW, and effective type, data saving preference, UA string information or Accept Language information)\r\nIf not, is this a concern about potential future values?\r\n\r\nI'm trying to understand if the concern is exposing bits in a larger fingerprinting map, or something more directly abusable (e.g. the theoretical local IP address case you raised before).\r\n\r\n \r\n\r\n> We typically do it via crawling and looking for what looks like abuse\r\n\r\nIs that at runtime in the browser, or something done ahead of time? (the use of \"crawling\" here confused me, so trying to clarify)",
          "createdAt": "2019-06-18T15:49:40Z",
          "updatedAt": "2019-06-18T15:49:40Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was [discussed](https://github.com/httpwg/wg-materials/blob/gh-pages/ietf105/minutes.md#10-min---client-hints---yoav-weiss) at the IETF 105 HTTPWG meeting, and I believe we have a path to resolution here. (although the minutes don't really capture the subtleties)\r\n\r\n@martinthomson - I believe you wanted we'd add some language around the criteria for features that might be able to use client hints, to make sure we capture the range of possible information exposure (from \"clamping down User-Agent string\" on one hand of the spectrum, and geolocation headers on the other). I'll take a stab at doing that and send to you for review.",
          "createdAt": "2019-07-25T16:10:16Z",
          "updatedAt": "2019-07-25T16:10:16Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by #879 ",
          "createdAt": "2019-12-04T22:24:16Z",
          "updatedAt": "2019-12-04T22:24:16Z"
        }
      ]
    },
    {
      "number": 787,
      "id": "MDU6SXNzdWU0MzA3MTk4MTQ=",
      "title": "Headers vs. Query Strings",
      "url": "https://github.com/httpwg/http-extensions/issues/787",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Some guidance about when to use URI components like query strings vs. minting new headers would be good.\r\n\r\nProbably by adding text to 4.4. HTTP URLs and linking between that and 4.7. HTTP Header Fields.",
      "createdAt": "2019-04-09T01:01:21Z",
      "updatedAt": "2019-08-30T07:20:39Z",
      "closedAt": "2019-08-30T07:20:39Z",
      "comments": []
    },
    {
      "number": 788,
      "id": "MDU6SXNzdWU0MzA5MTkyMDA=",
      "title": "Consider adding `None` to the list of values for the `SameSite` attribute.",
      "url": "https://github.com/httpwg/http-extensions/issues/788",
      "state": "CLOSED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "Giving developers an explicit keyword that asserts non-`SameSite`ness  seems like it's both helpful from an explanatory perspective, and could open paths towards tightening cookie behavior in the future. Perhaps something like `SameSite=None` to represent the status quo default behavior. That is, the following two `Set-Cookie` header values would produce the same cookie today:\r\n\r\n```\r\nname=value\r\n```\r\n\r\n```\r\nname=value; SameSite=None\r\n```",
      "createdAt": "2019-04-09T11:39:23Z",
      "updatedAt": "2019-04-30T06:57:47Z",
      "closedAt": "2019-04-30T06:57:47Z",
      "comments": []
    },
    {
      "number": 790,
      "id": "MDU6SXNzdWU0MzY5MjcwNTE=",
      "title": "Structured headers: serializing token vs string",
      "url": "https://github.com/httpwg/http-extensions/issues/790",
      "state": "CLOSED",
      "author": "evert",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Hi everyone!\r\n\r\nDraft-10 contains the following excerpt:\r\n\r\n>    3.  If input_item is a string, return the result of applying\r\n>        Serialising a String (Section 4.1.8) to input_item.\r\n> \r\n>    4.  If input_item is a token, return the result of Serialising a\r\n>        Token (Section 4.1.9) to input_item.\r\n\r\nI am currently writing a [javascript implementation](https://github.com/evert/structured-headers), where there is no real native 'token' type (I suspect that this is true for most languages).\r\n\r\nI'm curious, as an implementer, what should I do with that sentence? I have a few options:\r\n\r\n1. Treat any string that can be represented as a token by serializing it as a token, but anything else as a string.\r\n2. Treat everything as a string and ignore the token\r\n3. Expose a sort of wrapper that marks certain strings as tokens.\r\n\r\nEven though I feel that 1 is the nicest user experience, I worry that this will cause issues for future use-cases of structured headers that explicitly demand certain members to be serialized as either a token or string.\r\n\r\nCan you give a recommendation on what I should do?",
      "createdAt": "2019-04-24T22:03:43Z",
      "updatedAt": "2019-07-03T03:54:38Z",
      "closedAt": "2019-07-03T03:54:38Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "We discussed this in #505; I think it's cycled back around to where your generic API needs a piece of metadata alongside stringy data to say whether to use token or string.\r\n\r\nWhether that metadata is in the form of a second parameter, or a wrapper class, or some other signal... /shrug\r\n\r\nIn my [naive pure-Ruby implementation](https://github.com/phluid61/http-structured-headers) I created wrapper classes, so either a `Symbol` or an instance of my custom `Identifier` (needs to be renamed) class will be encoded as a token.  I don't know how well that works in the real world.",
          "createdAt": "2019-04-28T21:06:48Z",
          "updatedAt": "2019-04-28T21:06:48Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "What @phluid61 said. Perhaps it's worth adding some implementation considerations along these lines?",
          "createdAt": "2019-05-02T05:19:30Z",
          "updatedAt": "2019-05-02T05:19:30Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One of the things I have a bit of a hard time with here... is that I find it difficult to make a real case for why anyone would want the flexibility to choose either a string or token in cases where either may be used.\r\n\r\nI can understand in some cases wanting to be able to restrict the character set to a few safe characters, and I can understand that in some cases you would want everything that 'string' affords, but the second case, I'm not sure if I see the benefit of users to have to make an explicit choice.\r\n\r\nIn other words, how open would you be to altering the specification a bit to allow any string to be encoded as a token if the character set allows it?\r\n\r\nThat way we can basically treat strings and tokens as identical when either may appear, and force tokens where only tokens are allowed.",
          "createdAt": "2019-05-04T03:29:09Z",
          "updatedAt": "2019-05-04T03:29:09Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> One of the things I have a bit of a hard time with here... is that I find it difficult to make a real case for why anyone would want the flexibility to choose either a string or token in cases where either may be used.\r\n\r\nStrings and tokens are fundamentally different things, the similarity of their serialisation notwithstanding. A string is a string; character data; unconstrained.  A token is a symbolic identifier; a member of a set; atomic.  So it shouldn't ever be the case that \"either may be used.\"\r\n\r\nWhen someone is writing a spec and has to choose between the two: If communicating, say, a filename, then use a string.  If communicating an identifier that represents which encoding to use, then use a token.\r\n\r\n> That way we can basically treat strings and tokens as identical when either may appear, and force tokens where only tokens are allowed.\r\n\r\nI don't understand.  Either tokens are just strings that don't need quotes to be serialised, in which case there'd never be a time when they are allowed but other strings/binaries aren't; or they are different things, so really oughtn't to be de/serialised ambiguously.",
          "createdAt": "2019-05-04T12:45:19Z",
          "updatedAt": "2019-05-04T12:45:19Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You are describing the motivation behind the current state of the spec. My question is, can this be changed?\r\n\r\nSpecifically it would be helpful to use the token serialization for strings when possible.\r\n\r\nI'm trying to understand what we'd lose if we did. Many existing HTTP headers have this property already.\r\n\r\nWhether a string is a member of a set, atomic, identifier or whatever meaning you want to project on a specific string, it still is just sent over the wire as a string and that narrower meaning depending on context can still be enforced.\r\n\r\nSimilarly, your header can define certain strings to always be formatred as, say, an email address. The structured header spec can remain unaware of these details and just help with transport.\r\n\r\nBut maybe I'm missing something crucial",
          "createdAt": "2019-05-04T13:41:52Z",
          "updatedAt": "2019-05-04T14:02:02Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "bq. I don't understand. Either tokens are just strings that don't need quotes to be serialised, in which case there'd never be a time when they are allowed but other strings/binaries aren't;  (...)\r\n\r\nIn current header fields, this is usally the case (everywhere we currently say \"token / quoted-string\" right now). Why change that?",
          "createdAt": "2019-05-04T14:08:14Z",
          "updatedAt": "2019-05-04T14:08:14Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "The only places I know if where we do that, it's in a \"x=y\" parameter or extension point, where the _y_ could be either a string or a token\\*. *Not* because there's no difference between a string and a token.\r\n\r\nWe achieve that in SH by replacing `token / quoted-string` with `sh-item`\r\n\r\n\\* **Edit**: because some values of _x_ accept a string, and some _x_ accept a token.",
          "createdAt": "2019-05-05T00:10:16Z",
          "updatedAt": "2019-05-05T00:11:51Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "While there are cases like parameters where tokens and quoted strings are equivalent, there are other places where it matters; we re-introduced tokens (nee identifiers) to allow for some WHATWG-defined headers to be potentially ported to SH, and they have situations where a token needs to be a token (i.e., unquoted).\r\n\r\n",
          "createdAt": "2019-05-10T06:41:08Z",
          "updatedAt": "2019-05-10T06:41:08Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW: I think in general we should allow token where quote-string is allowed (as simplified syntax), but not the other way around.",
          "createdAt": "2019-05-10T06:45:33Z",
          "updatedAt": "2019-05-10T06:45:33Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah I agree with @reschke, so @mnot's use case should still be fine.",
          "createdAt": "2019-05-10T12:25:23Z",
          "updatedAt": "2019-05-10T12:25:23Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "If string and token are, as I believe, different _types_, then this part RFC 7231 is a legacy Bad Thing:tm:, and since Structured Headers is a clean break of sorts, we are under no obligation to persist it:\r\n\r\n```\r\n   A parameter value that matches the token production can be\r\n   transmitted either as a token or within a quoted-string.  The quoted\r\n   and unquoted values are equivalent.  For example, the following\r\n   examples are all equivalent, but the first is preferred for\r\n   consistency:\r\n\r\n     text/html;charset=utf-8\r\n     text/html;charset=UTF-8\r\n     Text/HTML;Charset=\"utf-8\"\r\n     text/html; charset=\"utf-8\"\r\n```\r\n\r\nIf string and token really are the same thing, then it's hard to justify any syntactic location that allows `sh-token` but not `sh-string`.  In terms of implementation, you'd still have to feed that \"encode as token\" metadata into the serialiser, or force every serialiser to never put quotes around strings that contain only `sh-token`-compatible characters.\r\n\r\n\\<glib>\r\nExtrapolating _ad absurdum_ we might as well remove token completely, from everywhere. `content-type: \"text/html\"; \"charset\"=\"utf-8\"`\r\n\r\n... I mean, it works for JSON.\r\n\\</glib>",
          "createdAt": "2019-05-11T07:55:29Z",
          "updatedAt": "2019-05-11T07:55:29Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'm inclined to close this with no action.",
          "createdAt": "2019-07-01T03:00:51Z",
          "updatedAt": "2019-07-01T03:00:51Z"
        }
      ]
    },
    {
      "number": 791,
      "id": "MDU6SXNzdWU0MzY5MjgwNjM=",
      "title": "Structured headers: serialise / serialize",
      "url": "https://github.com/httpwg/http-extensions/issues/791",
      "state": "CLOSED",
      "author": "evert",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "The structured headers draft heavily uses the spelling 'serialise'.\r\n\r\nI have no stake in this. I was raised in the Netherlands, learned UK-English and now live in Canada. I enjoy the subtle differences and cultural expression.\r\n\r\nThere is one instance in the draft though that specifically suggest calling a function 'serialise':\r\n\r\nhttps://tools.ietf.org/html/draft-ietf-httpbis-header-structure-10#section-3.9\r\n\r\n> A generic implementation should expose the top-level parse\r\n   (Section 4.2) and serialise (Section 4.1) functions.\r\n\r\nThis I am less comfortable with. Many (if not most) popular programming languages will use 'serialize' in their spelling. I feel that it would be slightly better to stick to this.\r\n\r\nI might also just rename my `serialise` function to `stringify` because it's more consistent with typical Javascript api's such as `JSON.stringify`.",
      "createdAt": "2019-04-24T22:07:22Z",
      "updatedAt": "2019-05-03T06:55:20Z",
      "closedAt": "2019-05-03T06:55:19Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Usually I let the RFC Editor sort this out, but that's a good point. Will adjust.",
          "createdAt": "2019-04-25T23:46:45Z",
          "updatedAt": "2019-04-25T23:46:45Z"
        }
      ]
    },
    {
      "number": 794,
      "id": "MDU6SXNzdWU0Mzc3ODQwMDc=",
      "title": "Structured headers: merge List and Parameterized List",
      "url": "https://github.com/httpwg/http-extensions/issues/794",
      "state": "CLOSED",
      "author": "evert",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I wanted to bring this up as a suggestion, I hope it's not too late in the development in the draft.\r\n\r\nI intended to use the structured headers format for a draft I'm working on: [Prefer-Push](https://tools.ietf.org/html/draft-pot-prefer-push-00).\r\n\r\nThe specific format I'm using right now is a list:\r\n\r\n    Prefer-Push: rel1, rel2, \"rel3\"\r\n\r\nIt occurred to me that it might be a good idea to keep a door open to future extensions. If I tell folks from Day 1 that the value _must_ be parsed as a parameterized list, it allows this to be extended further down the line despite that there's no parameters defined right now.\r\n\r\nThis led me to wonder... well, is this even a good idea? It seems reasonable to try and keep things open for future extension.\r\n\r\nThis led me to my second thought: is there ever a point to *not* parse lists as if they were parameterized lists. The implication is that any of these headers can always be more easily extended.",
      "createdAt": "2019-04-26T18:01:36Z",
      "updatedAt": "2019-04-29T19:17:13Z",
      "closedAt": "2019-04-29T19:17:13Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, if the quotation marks actually matter, `rel1, rel2, \"rel3\"` isn't a valid parameterised list, because the primary identifier of each list element has to be a token. (In the same vein you can't parameterise a list of numbers, or certain URL references)\r\n\r\nIf you're asking why that's the case, uhm... I think it grew out of #443.",
          "createdAt": "2019-04-28T21:21:12Z",
          "updatedAt": "2019-04-28T21:21:12Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see, that makes sense.\r\n\r\nI guess really my question then becomes, why not define a more broader syntax and leave it up to specific headers to to specify what subset they require, but I think that ship may have sailed.",
          "createdAt": "2019-04-29T19:17:13Z",
          "updatedAt": "2019-04-29T19:17:13Z"
        }
      ]
    },
    {
      "number": 797,
      "id": "MDU6SXNzdWU0Mzk0NDAxODk=",
      "title": "Parameterised Identifier -> Parameterised Item?",
      "url": "https://github.com/httpwg/http-extensions/issues/797",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "in [Signed Exchanges](https://tools.ietf.org/html/draft-yasskin-http-origin-signed-responses-05#section-3.1.2), @jyasskin asks about having Parameterised Lists whose parameterised identifiers are things other than Tokens. \r\n\r\nBecause of the way SH is put together, I think this would be a fairly easy change, in terms of the spec and implementations; it would require a few more tests.\r\n\r\nThe only downside I can think of immediately is that specs would need to constrain the type of the parameterised identifier themselves, and specify error handling (if it weren't the default \"blow up\").\r\n\r\nThoughts?\r\n\r\nI also wonder if we should come up with a better name than \"parameterised identifier\", especially since we've ditched \"identifier\" elsewhere. _member name_? _member id_? _primary identifier_?",
      "createdAt": "2019-05-02T06:15:34Z",
      "updatedAt": "2019-07-05T04:47:14Z",
      "closedAt": "2019-07-04T07:50:37Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "That works, since splitting lists from parameterised lists.  Are you thinking `primary-id = sh-item`, or just adding a few types?\r\n\r\nIt also changes my thinking a tiny bit on #782 , although not much.\r\n\r\n> I also wonder if we should come up with a better name than \"parameterised identifier\", especially since we've ditched \"identifier\" elsewhere. _member name_? _member id_? _primary identifier_?\r\n\r\nI like \"parameterised element\" but that introduces a new word. \"parameterised item\" is a nice shade, if any item is allowed there, but \"primary identifier\" works too. :art: :paintbrush:",
          "createdAt": "2019-05-02T07:56:08Z",
          "updatedAt": "2019-05-02T07:56:08Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The downside here is that it would be very hard to represent in JSON -- e.g., in the [test suite](https://github.com/httpwg/structured-header-tests). At least some programming languages support hashes/dictionaries/objects with arbitrary key types (e.g., Python, JavaScript, Ruby), but I'm not sure how widespread that is -- especially if folks represent the different between `token` and `string` with an object for `token`.\r\n\r\n@jyasskin is this a nice-to-have or something that's a blocker?",
          "createdAt": "2019-07-03T03:45:30Z",
          "updatedAt": "2019-07-03T03:45:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "(Fwiw I do think we should call this a Parameterised Token)",
          "createdAt": "2019-07-03T07:28:44Z",
          "updatedAt": "2019-07-03T07:28:44Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> The downside here is that it would be very hard to represent in JSON -- e.g., in the [test suite](https://github.com/httpwg/structured-header-tests).\r\n\r\nAt this point do we just have to accept that the SH data model is essentially a subset of the JavaScript model?  Numbers are bounded by JavaScript's limitations, object keys have to be stringy, nobody likes 'token' because it isn't a native JS type...\r\n\r\nI don't mind if that's the case, but it would be good to just say it outright somewhere.  It would also give us a solid position to start from when considering other proposals.\r\n\r\n> At least some programming languages support hashes/dictionaries/objects with arbitrary key types (e.g., Python, JavaScript, Ruby), but I'm not sure how widespread that is -- especially if folks represent the different between `token` and `string` with an object for `token`.\r\n\r\nHmm, C++ and Go could be have issues mixing key types within a single map, and Perl is definitely not going to like non-string keys.",
          "createdAt": "2019-07-03T07:37:14Z",
          "updatedAt": "2019-07-03T07:37:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It doesn't have to be -- it's just easier for me to write tests this way :)",
          "createdAt": "2019-07-03T07:49:12Z",
          "updatedAt": "2019-07-03T07:49:12Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was a nice-to-have for me. I\u2019d worked around it by putting an unused string as the identifier. It looks like that workaround is no longer necessary? \ud83d\ude03",
          "createdAt": "2019-07-05T04:47:13Z",
          "updatedAt": "2019-07-05T04:47:13Z"
        }
      ]
    },
    {
      "number": 799,
      "id": "MDU6SXNzdWU0Mzk2OTQzMzA=",
      "title": "Update abstract to reflect the current document scope",
      "url": "https://github.com/httpwg/http-extensions/issues/799",
      "state": "CLOSED",
      "author": "royfielding",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "The current (draft 10) abstract says\r\n\r\n> This document describes a set of data types and algorithms associated with them that are intended to make it easier and safer to define and handle HTTP header fields. It is intended for use by new specifications of HTTP header fields as well as revisions of existing header field specifications when doing so does not cause interoperability issues.\r\n\r\nwhereas the editors are currently working on something more like\r\n\r\n   - This document describes a set of data types and associated algorithms for easier definition and processing of HTTP header fields that are known to have values limited to those types. It is intended for use by specifications of new HTTP header fields that wish to use a common syntax that is more limited than traditional HTTP/1.x field values.",
      "createdAt": "2019-05-02T17:05:23Z",
      "updatedAt": "2019-07-01T03:06:08Z",
      "closedAt": "2019-07-01T03:06:08Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I like the current first sentence and the new second one.\r\n\r\n> This document describes a set of data types and associated algorithms associated with them that are intended to make it easier and safer to define and handle HTTP header fields. It is intended for use by specifications of new HTTP header fields that wish to use a common syntax that is more restrictive than traditional HTTP/1.x field values.\r\n\r\n\"Easy and safe\" implies \"restricted\"; no need to say 'limited' twice in as many sentences. (Sounds a bit.. judgmental.) And it fits the mental model I've built up.",
          "createdAt": "2019-05-02T23:37:01Z",
          "updatedAt": "2019-05-02T23:37:01Z"
        }
      ]
    },
    {
      "number": 801,
      "id": "MDU6SXNzdWU0Mzk2OTkzMjA=",
      "title": "Add a subsection on limitations",
      "url": "https://github.com/httpwg/http-extensions/issues/801",
      "state": "CLOSED",
      "author": "royfielding",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "If the proposed syntax is intended to exclude many existing field values defined by HTTP in practice, then the document should clearly state that up front and as an essential design criteria (e.g., a new section 1.1 on field value limitations) before strict processing.\r\n\r\nThe reader shouldn't have to figure out from the ABNF that this syntax is incapable of handling empty field values, links with parameters, empty lists, or heterogeneous lists. It should also make some mention of motivations, such as avoiding the hell of Cookie syntax and failures in handling Set-Cookie in list form.",
      "createdAt": "2019-05-02T17:18:47Z",
      "updatedAt": "2019-08-09T06:57:19Z",
      "closedAt": "2019-08-09T06:57:19Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The document already clearly states that it's not to be used for existing values. \r\n\r\nIf you have a proposal for text here I'm happy to look at it, but I don't really know where you're going with this.\r\n\r\n",
          "createdAt": "2019-07-01T04:29:29Z",
          "updatedAt": "2019-07-01T04:29:29Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "As per discussion in Montreal, closing.",
          "createdAt": "2019-08-09T06:57:19Z",
          "updatedAt": "2019-08-09T06:57:19Z"
        }
      ]
    },
    {
      "number": 802,
      "id": "MDU6SXNzdWU0Mzk3MjIxMDI=",
      "title": "Standardize node identifiers (Cache, Proxy-Status).",
      "url": "https://github.com/httpwg/http-extensions/issues/802",
      "state": "CLOSED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "cache-header",
        "proxy-status"
      ],
      "body": "We should standardize on the format and naming of node identifiers, since right now they are in different format in each draft.\r\n\r\nFrom [draft-ietf-httpbis-cache-header](https://tools.ietf.org/html/draft-ietf-httpbis-cache-header):\r\n```\r\no  \"node\" - a string identifying for the cache node.  MAY be a\r\n   hostname, IP address, or alias.\r\n```\r\n\r\nFrom [draft-ietf-httpbis-proxy-status](https://httpwg.org/http-extensions/draft-ietf-httpbis-proxy-status.html):\r\n```\r\n* proxy - a sh-token identifying the HTTP intermediary generating this response.\r\n```\r\n\r\nFrom [RFC7239 (Forwarded HTTP Extension)](https://tools.ietf.org/html/rfc7239):\r\n```\r\no  \"by\" identifies the user-agent facing interface of the proxy.\r\n```\r\n```\r\nThe node identifier is one of the following:\r\n\r\no  The client's IP address, with an optional port number\r\n\r\no  A token indicating that the IP address of the client is not known\r\n   to the proxy server\r\n\r\no  A generated token, allowing for tracing and debugging, while\r\n   allowing the internal structure or sensitive information to be\r\n   hidden\r\n\r\nThe node identifier is defined by the ABNF syntax as:\r\n\r\n    node     = nodename [ \":\" node-port ]\r\n    nodename = IPv4address / \"[\" IPv6address \"]\" /\r\n                \"unknown\" / obfnode\r\n\r\n    IPv4address = <Defined in [RFC3986], Section 3.2.2>\r\n    IPv6address = <Defined in [RFC3986], Section 3.2.2>\r\n    obfnode = \"_\" 1*( ALPHA / DIGIT / \".\" / \"_\" / \"-\")\r\n\r\n    node-port     = port / obfport\r\n    port          = 1*5DIGIT\r\n    obfport       = \"_\" 1*(ALPHA / DIGIT / \".\" / \"_\" / \"-\")\r\n\r\n    DIGIT = <Defined in [RFC5234], Section 3.4>\r\n    ALPHA = <Defined in [RFC5234], Section B.1>\r\n```\r\n\r\ncc @mnot",
      "createdAt": "2019-05-02T18:16:53Z",
      "updatedAt": "2019-07-03T04:12:13Z",
      "closedAt": "2019-07-03T04:11:59Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "My .02 - For CDNs, at least, this is much closer to a HTTP product token than a hostname or IP address. Also, I think the 7239 format is too exacting to get wide adoption; some people are just going to want to stick an alias in there with out the leading and trailing underscores. \r\n\r\nThat said, I'm fine with aligning the definitions in the two documents and adding guidance, although we still may want to give them different terms, since a cache can occur in servers, clients and proxies, whereas a proxy is just a proxy.",
          "createdAt": "2019-07-01T04:48:51Z",
          "updatedAt": "2019-07-01T04:48:51Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed that 7239 might not be the best choice. I don't have strong preference between formats suggested in `Cache` and `Proxy-Status` drafts, I just want them to be consistent.\r\n\r\n> That said, I'm fine with aligning the definitions in the two documents and adding guidance, although we still may want to give them different terms, since a cache can occur in servers, clients and proxies, whereas a proxy is just a proxy.\r\n\r\nCould we use `node` for all those cases?",
          "createdAt": "2019-07-02T10:59:53Z",
          "updatedAt": "2019-07-02T10:59:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "PTAL; if that doesn't seem right please reopen.",
          "createdAt": "2019-07-03T04:12:12Z",
          "updatedAt": "2019-07-03T04:12:12Z"
        }
      ]
    },
    {
      "number": 807,
      "id": "MDU6SXNzdWU0Mzk4NTE1NTg=",
      "title": "Proxy-Status: add Proxy Internal Response.",
      "url": "https://github.com/httpwg/http-extensions/issues/807",
      "state": "CLOSED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "proxy-status"
      ],
      "body": "This is proposal to add `Proxy Internal Response` type that could be used to indicate that the response was generated by the intermediary (since we don't have any type that could be used in such case).\r\n\r\n* Name: proxy_internal_response\r\n* Description: The intermediary generated the response locally, without attempting to connect to the next hop (e.g. in response to a request to a debug endpoint terminated at the intermediary).\r\n* Extra Parameters: None.\r\n* Recommended HTTP status code:\r\n\r\nPR: #806 \r\n\r\ncc @mnot ",
      "createdAt": "2019-05-03T01:34:21Z",
      "updatedAt": "2019-07-03T04:20:22Z",
      "closedAt": "2019-07-03T04:20:22Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We already have `proxy_internal_error`; maybe adjust that one to suit?",
          "createdAt": "2019-07-01T07:49:32Z",
          "updatedAt": "2019-07-01T07:49:32Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Erm, those 2 have quite different purpose:\r\n\r\n`proxy_internal_error` is `Proxy-Status` equivalent of `500 Internal Server Error`, i.e. something is terribly broken and proxy couldn't handle the received request.\r\n\r\n`proxy_internal_response` is supposed to indicate successful response generated by the proxy itself (e.g. in response to a request to a special debug URL like https://www.cloudflare.com/cdn-cgi/trace).\r\n\r\ncc @alyssawilk",
          "createdAt": "2019-07-02T11:19:20Z",
          "updatedAt": "2019-07-02T11:19:20Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Got it. Merging, but we might want to look at the entire set and make sure we have enough context / prose around all of them (including this one) to make sure people understand the appropriate uses of them.",
          "createdAt": "2019-07-03T04:19:35Z",
          "updatedAt": "2019-07-03T04:19:35Z"
        }
      ]
    },
    {
      "number": 808,
      "id": "MDU6SXNzdWU0Mzk4NTQwNzc=",
      "title": "Proxy-Status: detailed types for HTTP request errors.",
      "url": "https://github.com/httpwg/http-extensions/issues/808",
      "state": "CLOSED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "proxy-status"
      ],
      "body": "Currently, `Proxy-Status` draft defines only a single catch-all `http_request_error` error type for all issues with HTTP requests, and piggy-backs on the `4xx` status codes (`400`, `403`, `405`, `406`, `408`, `411`, `413`, `414`, `415`, `416`, `417`, `429`) for the exact reason as to why the request failed.\r\n\r\nThis is a bit inconsistent with the detailed error types it defines for issues with HTTP responses (`http_response_incomplete`, `http_protocol_error`, `http_response_header_block_size`, `http_response_header_size`, `http_response_body_size`, `http_response_transfer_coding`, `http_response_content_coding`, `http_response_timeout`).\r\n\r\nBut more importantly, it means that the `Proxy-Status` header isn't self-contained and it forces recipients to look in 2 places (`Proxy-Status` header and status code) to get the reason of the failure, and to take any action (log the error, etc.).\r\n\r\nWhile duplicating the information between `4xx` status codes and `Proxy-Status` type isn't ideal, the self-contained header seems to be worth it, IMHO.\r\n\r\nCurrent draft:\r\n```\r\nHTTP/1.1 411 Length Required\r\nProxy-Status: http_request_error\r\n```\r\n\r\nThis proposal:\r\n```\r\nHTTP/1.1 411 Length Required\r\nProxy-Status: http_request_length_required\r\n```\r\n\r\nThoughts?\r\n\r\ncc @alyssawilk @mnot",
      "createdAt": "2019-05-03T01:51:02Z",
      "updatedAt": "2019-11-28T04:57:38Z",
      "closedAt": "2019-11-28T04:57:38Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Besides the bloat issues in the spec (we'll manage ;), I'm concerned here that we're creating a lot of corner cases due to misalignment; if the response status code and the proxy-status type are misaligned, what will happen? In particular, if some software isn't aware of proxy-status, it will act on the status code, whereas other software on the same path that is aware of it will act differently. ",
          "createdAt": "2019-07-01T04:55:51Z",
          "updatedAt": "2019-07-01T04:55:51Z"
        },
        {
          "author": "alyssawilk",
          "authorAssociation": "NONE",
          "body": "Just weighing in here, if we don't split out these as their own status codes, I suspect folks will end up shoving the redundant information into the details section.  If the goal of proxy status is to have consistent standardized error diagnoses across various proxies I think it's worth the bloat because otherwise the information will be not be delivered and/or communicated consistently",
          "createdAt": "2019-07-01T12:42:32Z",
          "updatedAt": "2019-07-01T12:42:32Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Alyssa do you mean s/status codes/error types/?",
          "createdAt": "2019-07-02T04:20:49Z",
          "updatedAt": "2019-07-02T04:20:49Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Isn't misalignment an issue already, since it can happen for response errors as well (even more so, since we use only a few 5xx response codes)? e.g. `http_response_body_size` vs `502 Bad Gateway`.",
          "createdAt": "2019-07-02T12:30:57Z",
          "updatedAt": "2019-07-02T12:30:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "What if we just had a parameter `status_code` whose value was the status code in question?",
          "createdAt": "2019-07-04T07:46:00Z",
          "updatedAt": "2019-07-04T07:46:00Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`status_code` param would make the headers self-contained, yes, but if we want to have an easy-to-extend registry of valid status types, then we probably shouldn't piggy-back on the harder-to-extend(?) list of existing HTTP status codes. It also doesn't address the inconsistency problem.",
          "createdAt": "2019-07-19T10:48:02Z",
          "updatedAt": "2019-07-19T10:48:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@PiotrSikora I've just committed a start at this; it doesn't include all of the status codes (right now, only 4xx; I think we'd need to include at least 2xx and 3xx, and possibly 5xx and 1xx too).\r\n\r\nPTAL. I know I was OK with this when we talked on Friday, but going through this has made me question that; it's really a lot of duplicated information, and it requires a lookup table to find the right type (along with the errors that might happen there). I think we might get some pushback from the group as a result.\r\n\r\nI'm happy to go to them to see what they think, but if we choose to go with at `status_code` approach, I think what we'd do is to say \"use this if there's a specific status code that covers your situation; if not, create a new type that does.\"\r\n\r\nTell me what you think.",
          "createdAt": "2019-10-23T06:19:11Z",
          "updatedAt": "2019-10-23T06:19:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@PiotrSikora ping",
          "createdAt": "2019-10-30T01:39:14Z",
          "updatedAt": "2019-10-30T01:39:14Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A couple of considerations (that's my first time reading proxy-status, so be forgiving :).\r\n\r\n- as the status message (eg. \"bad_request\") may change in time (see https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#status.422) I won't use it;\r\n- a reasonable way could be to use `status_code` only when the status is generated `on origin's behalf`",
          "createdAt": "2019-10-30T07:27:38Z",
          "updatedAt": "2019-10-30T07:52:35Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In Singapore, discussed not enumerating all cases as new errors. Discussion landed on only transmitting the error code as the value.",
          "createdAt": "2019-11-21T06:25:48Z",
          "updatedAt": "2019-11-21T06:25:48Z"
        }
      ]
    },
    {
      "number": 809,
      "id": "MDU6SXNzdWU0NDA0ODcxOTg=",
      "title": "[feature] Push messaging from server to client",
      "url": "https://github.com/httpwg/http-extensions/issues/809",
      "state": "CLOSED",
      "author": "wzr1337",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi all,\r\n\r\nbased on the work we did on https://www.w3.org/Submission/viwi-protocol/ I want to request adding new functionality which can be implemented with two new VERBS and two new headers.\r\n\r\n**Use Case:**\r\nClients want to subscribe to `urls`, as topics with all the filtering, paging information etc. being expressed in the `url`. This would allow services to push information into clients whenever it is considered necessary.\r\n\r\n**Implementation:**\r\nAs subscriptions are a \"convenience\" method compared to polling via `GET`, I propose two new HTTP Verbs\r\n\r\n* SUB for subscription to `url`\r\n* UNSUB for un-subscribing from `url`\r\n\r\nTo control the frequency of updates, we would need additional headers:\r\n\r\n* subscription-interval: <timeStepInMs> \r\n* subscription-updatelimit: <timeStepInMs>\r\n\r\n_Periodic_\r\nThe optional interval attribute specifies the update frequency in milliseconds for periodic updates, while the optional updatelimit attribute specifies the maximum update rate in milliseconds for \u2018on change\u2019 notification. If interval is set, updatelimit is always overruled.\r\n\r\n_On change_\r\nIf interval is not set, the notification interval is defined \u2018on change\u2019 and can be limited by specifying an updatelimit. If an \u2018on change\u2019 occours before updatelimit elapsed, an event will be sent as soon as updatelimit elapsed. If there are multiple changes before the next possible update, only the last one know state is sent after updatelimit elapsed.\r\n\r\n**Summary**\r\nAs this is very close to a regular GET, it would be easy and we could also standardise that per each client-server relation, there would just be a single UDP/IP channel for notifications used and held up. We could also specify that this is a \"simplex\" connection regarding payload data. as clients would use other HTTP verbs to send data. Each data sent from the server to the client would be exactly the same as a GET response. Very straight forward from my perspective and a valuable extension of the standard for all things \"realtime\". \r\n\r\nAll the Headers we replicate in WebSockets today.. puuuffff gone ;) we can just plain HTTP headers... \r\n\r\nThe viwi/RSI spec would than be just rewrote to hold the interface design rules etc. the entire WebSocket parts would be obsolete.\r\n\r\nAlso It would than not be relevant anymore wether we transmit JSON (text) or binary content.. \r\n\r\nThink of it as a GET with multiple responses.. same formats, payloads, everything.. just not req/res but req/res/res/res/res... including all status codes etc.\r\n\r\nRe-Auth would also just be another SUB request with a new Token.. super easy ;)\r\n\r\nThere are a couple of solutions discussed and implemented. As described in the spec I reference to, WebSockets are used, replicating some of the HTTP headers and a topic. \r\n\r\nWith this proposal, I want to reduce friction. - \u00a5 Why setup two sockets, if you can handle it via one?\r\n\r\nThe socket you use for HTTP GET, PUT, POST etc. would have to kept open but could then be used to push information in the other direction.\r\n\r\nThink of a multi-repsonse GET request. Super convenient to work with from developers point of view on both ends of the connection. No extra protocol needed, no extra syntax to learn. Just multiple responses to the same GET request, either on an `on change` or a periodic basis, limited to a certain rate by either the client or the server.\r\n\r\n**Use-case 1 - chat messages**\r\n```\r\nSUB /messages/\r\n```\r\n\r\ninitial response\r\n```\r\n290 OK\r\n```\r\n\r\n1st data response\r\n```\r\n200 OK\r\n[\r\n  \"foo\",\r\n  \"bar\"\r\n]\r\n```\r\n\r\n2nd data response (100ms later)\r\n```\r\n200 OK\r\n[\r\n  \"foo\",\r\n  \"bar\",\r\n  \"boo\"\r\n]\r\n```\r\n\r\netc.",
      "createdAt": "2019-05-05T20:31:27Z",
      "updatedAt": "2019-05-06T18:13:02Z",
      "closedAt": "2019-05-06T18:13:02Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed on https://github.com/quicwg/base-drafts/issues/2664, this is more appropriate as an e-mail to the HTTPbis mailing list, not a GitHub issue.  The [Contributing guidelines](https://github.com/httpwg/http-extensions/blob/master/CONTRIBUTING.md) have good suggestions about where to direct work, specifically:\r\n\r\n> Before filing a new issue, please consider a few things:\r\n> - Issues should be just that; issues with our deliverables, **not proposals**, questions or support requests.\r\n> - Please review the issues list to make sure that you aren't filing a duplicate.\r\n> - If you're not sure how to phrase your issue, please ask on the mailing list.\r\n> \r\n> Issues can also be raised on the [Working Group mailing list](https://lists.w3.org/Archives/Public/ietf-http-wg/) by clearly marking them as such (e.g., in the Subject: line).",
          "createdAt": "2019-05-06T18:13:02Z",
          "updatedAt": "2019-05-06T18:13:02Z"
        }
      ]
    },
    {
      "number": 810,
      "id": "MDU6SXNzdWU0NDI5NzQ4OTA=",
      "title": "[SH] inline encoding metadata in Byte Sequence?",
      "url": "https://github.com/httpwg/http-extensions/issues/810",
      "state": "CLOSED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "String currently says:\r\n\r\n> When it is necessary for a field value to convey non-ASCII string content, a byte sequence SHOULD be specified, along with a character encoding (preferably UTF-8).\r\n\r\nIt could be useful to allow us to explicitly say, inline, whether or not a byte sequence encodes utf-8 data.  I'm thinking something like:\r\n\r\n    sh-binary = \"*\" [ bin-charset ] *(base64) \"*\"\r\n    bin-charset = \"$\" [ charset ] \"$\"\r\n\r\nAnd copy-paste the relevant bits from [RFC 7231, section 3.1.1.2](https://tools.ietf.org/html/rfc7231#section-3.1.1.2).\r\n\r\ne.g.\r\n\r\n```\r\n*$us-ascii$SW4gQS5ELjIxMDEgd2FyIHdhcyBiZWdpbm5pbmc=*\r\n*$UTF-8$RXN0LWNlIHF1ZSB0dSBwYXJsZXMgZnJhbsOnYWlzPw==*\r\n*$$U1hNZ2RFaHBVeUJDYVU1aFVua2dSR0ZVWVQ4PQ==*\r\n*WW91J2xsIGhhdmUgdG8gZ3Vlc3M=*\r\n```\r\n\r\nIs it worthwhile?",
      "createdAt": "2019-05-11T09:42:44Z",
      "updatedAt": "2019-05-15T23:14:44Z",
      "closedAt": "2019-05-15T23:14:44Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "This seems too much like RFC5987 encoding, which didn't work out so well. Header fields defining binary content can specify an encoding for their payload statically; making this flexible *and* visible to software that doesn't understand the header field semantics doesn't add much (any?) value.",
          "createdAt": "2019-05-15T09:31:02Z",
          "updatedAt": "2019-05-15T09:31:02Z"
        }
      ]
    },
    {
      "number": 814,
      "id": "MDU6SXNzdWU0NTE4ODc2NDc=",
      "title": "Cookies: mismatch between specification and test",
      "url": "https://github.com/httpwg/http-extensions/issues/814",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis",
        "samesite"
      ],
      "body": "As far as @bakulf and I can tell, https://github.com/web-platform-tests/wpt/blob/master/cookies/samesite/form-get-blank.html attempts to set SameSite cookies cross-site, in particular line `create_test(CROSS_SITE_ORIGIN, CROSS_SITE_ORIGIN, SameSiteStatus.LAX, \"Cross-site top-level form GETs are laxly same-site\");`.\r\n\r\nThis seems counter to step 14 of https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-5.4.\r\n\r\nYet Chrome passes this test.\r\n\r\ncc @mikewest ",
      "createdAt": "2019-06-04T09:21:53Z",
      "updatedAt": "2020-04-07T11:53:56Z",
      "closedAt": "2020-04-07T11:53:56Z",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "The editor's draft is more up to date: https://httpwg.org/http-extensions/draft-ietf-httpbis-rfc6265bis.html#storage-model. https://github.com/httpwg/http-extensions/issues/594 and https://github.com/httpwg/http-extensions/pull/800 capture the conversation around that change. In a nutshell, no one matched the spec. Chrome tried to, and immediately broke some OAuth endpoints.",
          "createdAt": "2019-06-04T09:37:41Z",
          "updatedAt": "2019-06-04T09:37:41Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Should have closed this earlier; closing it now. Both the spec and the tests are, I think, the behavior we want here.",
          "createdAt": "2020-04-07T11:53:56Z",
          "updatedAt": "2020-04-07T11:53:56Z"
        }
      ]
    },
    {
      "number": 815,
      "id": "MDU6SXNzdWU0NTkyNzYzOTk=",
      "title": "bcp56bis refers to PATCH method",
      "url": "https://github.com/httpwg/http-extensions/issues/815",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## I expect\r\n\r\nThis bcp56bis to refer to methods properly defined in  httpbis-semantics\r\n\r\nhttps://github.com/httpwg/http-extensions/blame/master/draft-ietf-httpbis-bcp56bis.md#L420\r\n\r\n## Instead\r\n\r\n `PATCH`  is still entangled with entity, entity-header & co\r\n\r\n\r\n## Note\r\n\r\n- is that an issue?\r\n- should we introduce PATCH in httpbis-semantics ?\r\n- should we add an httpbis-patch ?",
      "createdAt": "2019-06-21T16:23:45Z",
      "updatedAt": "2019-06-25T06:01:37Z",
      "closedAt": "2019-06-25T06:01:37Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is not an issue for bcp56bis.\r\n\r\nIt might be a work item for http-core. Personally I would recommend keeping it a separate document.",
          "createdAt": "2019-06-25T05:00:42Z",
          "updatedAt": "2019-06-25T05:00:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Agreed.",
          "createdAt": "2019-06-25T06:01:37Z",
          "updatedAt": "2019-06-25T06:01:37Z"
        }
      ]
    },
    {
      "number": 816,
      "id": "MDU6SXNzdWU0NjAyNTgwMDA=",
      "title": "Structured Headers: Lists as dictionary values.",
      "url": "https://github.com/httpwg/http-extensions/issues/816",
      "state": "CLOSED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "_I kinda expect that this is a dupe, as I know there's been conversation on this topic (https://github.com/httpwg/http-extensions/issues/476 is close, for example). But I didn't find anything specifically on point, so I'm erring on the side of another issue._\r\n\r\nThe discussion of substructures in https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-10#appendix-B.2 is somewhat unsatisfying, as it seems there are a number of cases in which a little support for additional structure would be helpful. In particular, allowing the values of dictionary members to be lists would open up a syntax for a few of the policy headers I'm somewhat responsible for that seems difficult to replicate otherwise.\r\n\r\nEven the example in that section:\r\n\r\n> ```\r\n> Example-Thing: name=\"Widget\", cost=89.2, descriptions=\"foo bar\"\r\n> Example-Description: foo; url=\"https://example.net\"; context=123,\r\n>                      bar; url=\"https://example.org\"; context=456\r\n> ```\r\n\r\nimplicitly treats the `descriptions` member as a space-separated list which requires parsing logic above and beyond what structured headers themselves offer. It seems like a very common pattern, and one which would be hard to layer in after the fact in a v2 if we decide that syntax really would be nice.\r\n\r\nI am 100% sure that y'all considered a syntax like:\r\n\r\n```\r\nExample-Dictionary-Header: ..., memberName=[thing1, thing2, thing3]\r\n```\r\n\r\n(which, of course, could also be used for [lists of lists](https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-10#section-3.3)). I'm not sure why you rejected it. The discussion in #476 seemed to be about the narrow value of allowing parsing without context. I happen to believe that that's actually valuable, but I also think there's both semantic and aesthetic value in explicitly demarcating lists as a primitive that can exist basically anywhere `sh-item` exists in the current spec.\r\n\r\nI'm happy to send a PR and add tests to https://github.com/httpwg/structured-header-tests/ if you'd accept them, conceptually. :)",
      "createdAt": "2019-06-25T07:28:34Z",
      "updatedAt": "2019-07-04T07:49:54Z",
      "closedAt": "2019-07-04T07:49:54Z",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Examples. Yes. I should have added examples. Off the top of my head, in no particular order:\r\n\r\n* [Trusted Types](https://github.com/WICG/trusted-types) will end up with something like the `Trusted-Types` header defined in https://wicg.github.io/trusted-types/dist/spec/#trusted-types-http-header, which has a number of potential configuration options (making a dictionary appealing as an alternative to the JSON bits suggested today), but those options themselves often require lists (the policy names, for example).\r\n\r\n* [CSP](https://github.com/w3c/webappsec-csp/) is ~entirely named lists of values.\r\n\r\n* [Reporting API](https://w3c.github.io/reporting/) is more nested than structured headers can trivially handle, but assuming we can restructure it appropriately, it's going to require named lists of endpoints.\r\n\r\n* [Feature Policy](https://w3c.github.io/webappsec-feature-policy/) is similar to CSP in that it's a set of named lists. They're thinking about adding more complexity, but even what they have today is difficult to support via SH.\r\n\r\nIf more examples would be helpful, I'll spend a little more time digging.",
          "createdAt": "2019-06-25T07:36:59Z",
          "updatedAt": "2019-06-25T07:36:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I _think_ it should be possible to do the same thing as we did in List of Lists with `inner-list`; it might even be best to refactor both List and Dictionary to allow `inner-list | item` as their payload. Would that work for you?",
          "createdAt": "2019-07-01T04:25:08Z",
          "updatedAt": "2019-07-01T04:25:08Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I can accept anything that provides the technical capability, so reusing\r\n`inner-list` is certainly an option that I do think that would work from\r\nthe grammar\u2018s perspective. If that\u2019s acceptable to y\u2018all, I\u2019m happy to send\r\na patch.\r\n\r\nThat said, it seems like it might be marginally confusing, as it creates\r\nonly a one-character distinction between dictionaries and parameterized\r\nlists (`label;param1;param2;param3` vs `key=list1;list2;list3`). It\r\nsomewhat doubles-down on the notion that a header is unparseable _a\r\npriori_, and that you need to bring in knowledge of the expected types.\r\n\r\nI would prefer a serialization that\u2018s comprehensible without that extra\r\ninformation (e.g. `key=[list1,list2,list3]`), but that\u2019s a distinct\r\ndiscussion. :)",
          "createdAt": "2019-07-01T06:02:21Z",
          "updatedAt": "2019-07-01T07:15:36Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "(Speaking of parameterized lists, a new syntax would allow us to use lists\r\nas a parameterized ist\u2018s parameter\u2018s value, while reusing `inner-list`\r\nwould be ambiguous.)",
          "createdAt": "2019-07-01T06:08:36Z",
          "updatedAt": "2019-07-01T07:02:23Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Doesn't this bring us back to a discussion from way back (which I'm *pretty* sure I haven't just imagined) that involved assuming all items were lists-of-items?  Without a new sigil, do we assume all dictionary member values are lists?  Or that all single-element lists are scalar items?\r\n\r\nI'm starting to wonder if it's time to reconsider abandoning the familiar `,` and `;` infix list notation for HTTP/1 serialisation, and maybe look at something more C-inspired?  (With just enough poison pills to make sure it doesn't work in a JSON parser, of course)",
          "createdAt": "2019-07-01T08:34:23Z",
          "updatedAt": "2019-07-01T08:34:23Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "No, it leaves us where we are -- you need to understand the \"master\" type of a header field to know how to get it into the correct data structure.\r\n\r\n",
          "createdAt": "2019-07-01T08:46:59Z",
          "updatedAt": "2019-07-01T08:46:59Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Dictionary-with-items vs dictionary-with-lists as top-level types?",
          "createdAt": "2019-07-01T08:57:04Z",
          "updatedAt": "2019-07-01T08:57:04Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I'm poking at the parsing and serialization algorithms, and discovering that I really don't like the magical nature of the result. \"If the dictionary's `this_key` value is a list, ... Otherwise fail parsing.\" is going to make it very hard to write a generic parser, which seemed to me to be part of the point of moving to structured headers in the first place. This, of course, isn't a problem introduced by this change, but a somewhat fundamental assumption in the design. Since y'all have closed out https://github.com/httpwg/http-extensions/issues/476#issuecomment-376775762, is there any point in bringing it up again? If so, would you prefer it there or on the list?\r\n\r\nI'll finish this patch just so y'all can see what it looks like, but I do wonder about the strategy.",
          "createdAt": "2019-07-01T09:23:54Z",
          "updatedAt": "2019-07-01T09:23:54Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> assuming all items were lists-of-items\r\n\r\nParameterized lists' syntax seems to make this difficult, as `key;value1=value2;value3` might be reasonably interpreted as `key(value1=value2, value3)` or `key(value1=[value2, value3])`",
          "createdAt": "2019-07-01T09:45:05Z",
          "updatedAt": "2019-07-01T09:45:05Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> > assuming all items were lists-of-items\r\n> \r\n> Parameterized lists' syntax seems to make this difficult, as `key;value1=value2;value3` might be reasonably interpreted as `key(value1=value2, value3)` or `key(value1=[value2, value3])`\r\n\r\nI'm confused.\r\n\r\nLet me rephrase, in point form:\r\n\r\n* In the current draft, when parsing a dictionary, I know that `x=y` means `{\"x\": y}`\r\n* If a dictionary item value could be a list, and there's no sigil, I have to assume that it means `{\"x\": [y]}`\r\n* However if the dictionary data type still allows for scalar item values, do I then have to back-track and say: if the dictionary item value is a list with exactly one member, replace the list with its member item?\r\n\r\nOr are you saying that I have to pass in even more metadata to say, \"if you see a dictionary item key 'foo', parse its value as a list\"?  Because that's horrible.",
          "createdAt": "2019-07-01T10:08:07Z",
          "updatedAt": "2019-07-01T10:08:07Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "(I regret my use of the word \"item\")",
          "createdAt": "2019-07-01T10:13:04Z",
          "updatedAt": "2019-07-01T10:13:04Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> Or are you saying that I have to pass in even more metadata to say, \"if you see a dictionary item key 'foo', parse its value as a list\"? Because that's horrible.\r\n\r\nThat's what the PR I put up says, and I think it's in-line with the general strategy this draft takes. As I suggested above, I think it will be hard to write a generic parser if that's the result we end up with.\r\n\r\nThat said, the approach you suggest would be simpler: if we just assume that every dictionary member's value is a list, then `x=y` parses unambiguously as `{\"x\": [\"y\"]}`, and `x=y;z` as `{\"x\": [\"y\", \"z\"]}`. That would make it impossible to have a scalar dictionary value, but perhaps that's a reasonable tradeoff, as it gives consumers a clear contract?\r\n\r\nI worry about backtracking in the case where a given member's value is expected to be a list, but we turn it into a scalar if it happens to have a single item. That seems confusing for consumers.\r\n\r\nMaking that type information explicit in the serialization would be a way of avoiding that confusion. I'd be in favor of that.",
          "createdAt": "2019-07-01T10:23:06Z",
          "updatedAt": "2019-07-01T10:23:06Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Or are you saying that I have to pass in even more metadata to say, \"if you see a dictionary item key 'foo', parse its value as a list\"? Because that's horrible.\r\n> \r\n> That's what the PR I put up says, and I think it's in-line with the general strategy this draft takes.\r\n\r\nOnly for top-level types (see #476), which was why I asked if Mark was suggesting we create dictionary-of-scalars and dictionary-of-lists types.  It's #443 all over again, again.",
          "createdAt": "2019-07-01T11:03:10Z",
          "updatedAt": "2019-07-01T11:03:10Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> Only for top-level types (see #476), which was why I asked if Mark was suggesting we create dictionary-of-scalars and dictionary-of-lists types. It's #443 all over again, again.\r\n\r\nI see.\r\n\r\nI think splitting dictionary's behavior into scalar-only or list-only is a little strange, as I fully expect headers (like some of those above) to treat dictionaries as containing both, depending on the key. I'd like it to be the case that that's possible. I agree with you that it's not (without a side-channel of metadata) unless we have distinct syntax. That sounds fine to me, FWIW (and it would sound even better to me if the top-level type was also identifiable. :) ).\r\n\r\nI suggested a somewhat obvious `label=[thing1, thing2, thing3]` syntax above. That seems to be both quite legible for humans, and quite parseable for machines.",
          "createdAt": "2019-07-01T11:54:40Z",
          "updatedAt": "2019-07-01T11:54:40Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Kind of related, I think it would be beneficial to allow having a dictionary that contains both scalar and compound values. Like `a=1, c=d=1;e=2` where `c` is a compound value consisting of a dictionary with two keys: _d_ and _e_.\r\n\r\nI'd assume that lists are expected provide extensibility. Consider Cache-Control. The parameters (i.e., dictionary members) are added as time goes. In the future, we might want to have introduce a parameter that takes compound value as an argument.\r\n\r\nHowever, IIRC, that's forbidden by the current specification.",
          "createdAt": "2019-07-01T12:38:52Z",
          "updatedAt": "2019-07-01T12:39:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I was thinking that we could just have Dictionary and List (getting rid of List of Lists), and for each of them allow members to be items or inner-lists.\r\n\r\nSyntactically, all that we'd need to do is to specify that if there's a single-item list, it's serialised as having a trailing `;` -- e.g.,\r\n\r\n~~~\r\nFoo-Dict-Header: a=b, c=d;e, f=g;, h=i\r\n~~~\r\n\r\nwhich maps to something like:\r\n\r\n~~~\r\n{\r\n  'a': 'b',\r\n  'c': [ 'd', 'e' ],\r\n  'f': [ 'g' ],\r\n  'h': 'i'\r\n}\r\n~~~\r\n\r\nOf course there's other ways to denote this, but this seems the most minimal / natural way to do it. The only thing I suspect is going to be awkward is swapping out the type of an item to an array when a `;` is encountered; it will require either scanning forward or changing types dynamically (but implementations will still be able to optimise as they please).\r\n\r\nThoughts?",
          "createdAt": "2019-07-02T05:02:46Z",
          "updatedAt": "2019-07-02T05:02:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot My +1 goes to the approach you propose.\r\n\r\nBecause that's exactly the generalised syntax for the header field strings that we have now. In my view, Structured Headers is designed as a generalization of header field notations that exist today.",
          "createdAt": "2019-07-02T05:29:59Z",
          "updatedAt": "2019-07-02T05:29:59Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot are you operating in knowledge of the schema for 'f', or not?  It seems like this is attempting to split the difference somehow and not understanding the framework into which this fits is problematic.\r\n\r\nThe draft seems to want to say that types are explicit in the syntax.  That's cool, but is that really necessary here?  If you always have lists as the value of dictionary members, you don't need to answer this question (or have a trailing ';').  You only need to allow for that in the processing of certain fields where only a single (or no) value is permitted.\r\n\r\nThat is, `Foo-Dict-Header: a=b, c=d;e` is all you need and that maps to `{ 'a': ['b'], 'c': ['d', 'e'] }`.  If processing 'a' assumes a single value, you start by checking the length of the value and rejecting it if `a.isPresent() && a.len() != 1`.",
          "createdAt": "2019-07-02T05:56:23Z",
          "updatedAt": "2019-07-02T05:56:23Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson I'm not, beyond the top-level type.\r\n\r\nI see what you're saying about making everything a list. One of my goals is to make specs using SH as error-proof as possible, and so I was planning on saying something like _unless a specification using SH explicitly allows an array as a value, assume an array is an error condition_ or similar.\r\n\r\nThat would avoid the necessity of them each and always having to say \"If there is more than one _x_, error...\" -- and inevitably missing one instance.\r\n\r\nThat said, I don't dispute that we could make the data model work that way and omit the trailing `;` -- but we'd have to get the prose right for consuming specs. Some examples would probably help.\r\n\r\n ",
          "createdAt": "2019-07-02T06:16:08Z",
          "updatedAt": "2019-07-02T06:16:08Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe if the API requires an explicit opt-in to get a list, and generates an error if that opt-in isn't present and >1 options appear, then you might get what you want.",
          "createdAt": "2019-07-02T06:51:08Z",
          "updatedAt": "2019-07-02T06:51:08Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We don't specify the API for parsers at that level, but we could put something like that in implementation advice...",
          "createdAt": "2019-07-02T07:16:09Z",
          "updatedAt": "2019-07-02T07:16:09Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> I was thinking that we could just have Dictionary and List (getting rid of List of Lists), and for each of them allow members to be items or inner-lists.\r\n> \r\n> [...]\r\n> \r\n> Of course there's other ways to denote this, but this seems the most minimal / natural way to do it. The only thing I suspect is going to be awkward is swapping out the type of an item to an array when a `;` is encountered; it will require either scanning forward or changing types dynamically (but implementations will still be able to optimise as they please).\r\n> \r\n> Thoughts?\r\n\r\nThree:\r\n\r\n1. I think a trailing `;` looks like a serialisation error.\r\n2. How long before someone files a bug somewhere that `x=a;b;` \"doesn't work but should\"? Or `y,`?\r\n3. Does this and #817 mean we should make `z=;` valid?\r\n\r\nRegarding the discussion about implementation guidance and APIs and such; how is array-vs-item (or array-of-one-vs-array-of-many) any different from string-vs-integer?",
          "createdAt": "2019-07-02T14:31:26Z",
          "updatedAt": "2019-07-02T14:31:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@phluid61 \r\n\r\n1. I don't disagree. It's less ugly than anything else I could think of. However, @martinthomson's approach avoids all of that.\r\n2. We could write the algorithms to account for that. But if they're using a serialiser, they won't hit that, and if they're not, the parsers *should* at least behave in a consistent way.\r\n3. No; #817 is about top-level lists, not these.",
          "createdAt": "2019-07-03T01:39:08Z",
          "updatedAt": "2019-07-03T01:39:08Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson thinking a bit more, I think a proposal along the lines you're discussing would be:\r\n\r\n1. All dictionary parameter values are lists.\r\n2. List and list of lists would still be separate types (otherwise, everything would be a list of lists).\r\n\r\nI have to say I'm not crazy about either of these; the former for reasons explained (I suspect we could come up with something, but it's going to be awkward), and the latter because then we'll have two different ways to handle inner lists.\r\n\r\nWe could also come up with a Dictionary of Lists type, but that would not fit well with the common use case, which is that some dictionary items will be singular types, others will be lists.\r\n\r\nTo me, the thing we should optimise for here is the data model -- it's going to persist longer than the serialisation, if we do this right.\r\n\r\nSo IME we're back at the start -- we need some sigil in the serialisation that indicates whether a dictionary (and list?) item is an array. \r\n\r\nI proposed using the presence of `;` (with a trailing `;` if the array has only one member). That's not the only way to do it, of course, but it does seem \"natural\" in headers (with the exception of a one member array, which I personally think is acceptable). \r\n\r\nAre there other suggestions? I'd like to ship a new draft by the deadline (Monday), so unless we can resolve this quickly, I'm inclined to ship `;` with a note asking for feedback.",
          "createdAt": "2019-07-03T01:49:42Z",
          "updatedAt": "2019-07-03T01:49:42Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For me, I'd be comfortable with lists in all these places.  An accessor function for a single value could generate an error if the cardinality is wrong.  That's not at all difficult to implement.  It also avoids problems: where `x=a;` is presented as two values, one being the empty string; and `x=a` is still the predominant form for a list of one item, which you risk invalidating as a valid client of this doc by requiring decoration.\r\n\r\nI agree that the data model is most important here, but the question is whether the canonical model that we operate from is list of \"things\" or list of lists (and dict of \"things\" or dict of lists).  List of lists is a more limited model, from which you can get to the stricter forms as needed.  The question is whether you need that explicitly signaled on the wire, or whether it is sufficient for a generic processor to be ignorant of certain distinctions of type.\r\n\r\nPart of the goal of this doc is to extend the role of the generic processor somewhat.  But I don't think that this completely rules out contextual handling of data, and nor could it ever.  So you have to pick where to draw the line.",
          "createdAt": "2019-07-03T04:47:18Z",
          "updatedAt": "2019-07-03T04:48:44Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "See PR #824 for a roughed-in proposal.",
          "createdAt": "2019-07-03T06:00:45Z",
          "updatedAt": "2019-07-03T06:00:45Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson yes, but as I said above, specs would still need to be written very precisely to avoid error, e.g., \r\n\r\n> Use the single value accessor (defined in {{}}) to retrieve a value from the \"foo\" member. If it is not an integer, fail parsing; otherwise...\r\n\r\nI think that's going to trip up spec authors; they'll forget it and then we'll be in the Wild West. Compare:\r\n\r\n> If the \"foo\" member is not an integer, fail parsing; otherwise...\r\n\r\nSimples.\r\n\r\nAlso, with the \"everything is a list\" approach, it implies that _all_ list items are arrays, which is tedious in the common case.",
          "createdAt": "2019-07-03T07:03:35Z",
          "updatedAt": "2019-07-03T07:03:35Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "@mnot: The `;` (and trailing `;`) proposal is fine if that's what y'all want to run with. I'm happy to see that we're going to be able to support the use case, and I can live with whatever syntax y'all can agree upon.\r\n\r\nThat said, it really is less legible (at least to humans (who matter!)) than the `[...]` syntax suggested several times in this thread. That really does seem to me to be the most obvious and unambiguous annotation (and I'd note that we're _all_ using that syntax in prose to explain to each other what we mean by various other proposals). `x=[y]` is, IMO, significantly more clear as a list value than `x=y;`.\r\n\r\nCan you help me understand why you're ignoring it? :)",
          "createdAt": "2019-07-03T07:28:53Z",
          "updatedAt": "2019-07-03T07:28:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@mikewest there are two reasons; one is that we want this to look as much like \"traditional\" HTTP headers as possible (semicolons are often used for substructure in list-based headers). The other is that we don't want this to look like JSON or another existing format; if it does, people might think that the same conventions apply, or that they can use an existing parser.\r\n",
          "createdAt": "2019-07-03T07:31:40Z",
          "updatedAt": "2019-07-03T07:31:40Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW, I'm all on board with \"not JSON\", but I keep feeling the nostalgia factor is causing us grief.  There is a third way: make up a whole new syntax.  It could work, as long as everyone hates it equally.",
          "createdAt": "2019-07-03T07:41:14Z",
          "updatedAt": "2019-07-03T07:41:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@phluid61 I hear you, but I also want to ship this. We're very close, if we can get get these last few issues closed.",
          "createdAt": "2019-07-03T07:54:20Z",
          "updatedAt": "2019-07-03T07:54:20Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "@mnot: Thanks! As someone who ends up minting a lot of headers, I don't think I buy either of those reasons (and, honestly, would have preferred JSON in the first place!). Trailing semicolons are wacky, and I still think that some kind of bracketing (`[...]`, `{...}`, `<...>`, `(...)`, `\u00ab...\u00bb`, ...) syntax is significantly more comprehensible. Still, as long as the functionality is in place, I will use whatever spelling y'all land on.",
          "createdAt": "2019-07-03T07:59:53Z",
          "updatedAt": "2019-07-03T07:59:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK, so let's walk down that path a bit and see where it takes us.\r\n\r\nIf we do this, we need brackets, and we also need delimiters between the items. Those can't be any already used delimiter, so I think that leaves us with `;` and whitespace.\r\n\r\nThat gives us a few permutations to consider (first one being just semicolons, as in the PR):\r\n\r\n~~~\r\nTest-Header: a=b, c=d;e, f=g;, h=i\r\nTest-Header: a=b, c=(d;e), f=(g), h=i\r\nTest-Header: a=b, c=(d e), f=(g), h=i\r\n~~~\r\n\r\nPreferences? Remember that these are all single-character tokens, but IRL they'll be integers, floats, binary, quote-delimited strings, etc.\r\n\r\nI've chosen parens here because `[...]` looks like JSON arrays (see above), `<...>` I'd like to reserve for links down the road, and `\u00ab...\u00bb` isn't ASCII. Thoughts about that?",
          "createdAt": "2019-07-03T08:13:54Z",
          "updatedAt": "2019-07-03T08:14:11Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> OK, so let's walk down that path a bit and see where it takes us.\r\n> \r\n> If we do this, we need brackets, and we also need delimiters between the items. Those can't be any already used delimiter, so I think that leaves us with `;` and whitespace.\r\n\r\nWhy not?  With paren-matching and a stack-based algorithm (which we have), it could also be COMMA.\r\n\r\n> That gives us a few permutations to consider (first one being just semicolons, as in the PR):\r\n> \r\n> ```\r\n> Test-Header: a=b, c=d;e, f=g;, h=i\r\n> Test-Header: a=b, c=(d;e), f=(g), h=i\r\n> Test-Header: a=b, c=(d e), f=(g), h=i\r\n> ```\r\n\r\n```\r\nTest-Header: a=b, c=(d,e), f=(g), h=i\r\n```\r\n\r\nAlso the non-dictionary list counterparts:\r\n\r\n```\r\nTest-Hodor: a, b;c, d;, e\r\nTest-Hodor: a, (b;c), (d), e\r\nTest-Hodor: a, (b c), (d), e\r\nTest-Hodor: a, (b,c), (d), e\r\n```\r\n\r\n> Preferences? Remember that these are all single-character tokens, but IRL they'll be integers, floats, binary, quote-delimited strings, etc.\r\n\r\nI think I like parens and semicolons best.  It gives us a more straight-forward streaming parser (identify by first character), a little bit of truncation detection, a deliberate and visual separator, and resistance against the weird \"auto-concatenation with commas\" issue that currently only (potentially) affects strings.\r\n\r\nI still have a question about empty inner-lists.  `()` is even easier to generate and expect to be valid than a lonely `;` -- should they be allowed in the data model?  If not: the parsing algorithm would have another edge-case to detect.\r\n\r\n> I've chosen parens here because `[...]` looks like JSON arrays (see above), `<...>` I'd like to reserve for links down the road, and `\u00ab...\u00bb` isn't ASCII. Thoughts about that?\r\n\r\n:+1:",
          "createdAt": "2019-07-03T08:40:42Z",
          "updatedAt": "2019-07-03T08:40:42Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Thanks for taking another look at this!\r\n\r\n> Why not? With paren-matching and a stack-based algorithm (which we have), it could also be COMMA.\r\n\r\nOr `|`. Or `/`. Or `:`. ASCII is full of options. And just imagine the possibilities extended ASCII could bring! :)\r\n\r\nI agree with both of you, though, that parens and semicolons seem like a reasonable choice.\r\n\r\n> I still have a question about empty inner-lists. \r\n\r\n`()` as an explicit signal of an empty list makes a good deal of sense to me.\r\n\r\n> Also the non-dictionary list counterparts:\r\n\r\nAnd, for completeness, parameterized lists?\r\n\r\n```\r\nTest-Header: a;b=(c;d);e, f;g=(h);i=(j;k)\r\n```",
          "createdAt": "2019-07-03T08:52:20Z",
          "updatedAt": "2019-07-03T09:11:14Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "```\r\nTest-Header: a;b=(c;d);e, f;g=(h);i=(j,k)\r\n                                      ^ ?\r\n```\r\n\r\n",
          "createdAt": "2019-07-03T09:09:52Z",
          "updatedAt": "2019-07-03T09:09:52Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Good eye! That was a typo. :( I've corrected it.",
          "createdAt": "2019-07-03T09:11:17Z",
          "updatedAt": "2019-07-03T09:11:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "If we think we want to use this for parameterised lists too, we should make the internal delimiter WSP, to avoid visual confusion. \r\n\r\nConsider:\r\n\r\n~~~\r\nTest-ParamList: abc; d=e; f=(g;h;i;j); k; l=(m;n); o, pqr; s=t\r\n~~~\r\n\r\nvs.\r\n\r\n~~~\r\nTest-ParamList: abc; d=e; f=(g h i j); k; l=(m n); o, pqr; s=t\r\n~~~\r\n",
          "createdAt": "2019-07-03T09:43:23Z",
          "updatedAt": "2019-07-03T09:43:23Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I kind of like the above, in that the original example \"foo bar\" just becomes (foo bar)...",
          "createdAt": "2019-07-03T09:44:15Z",
          "updatedAt": "2019-07-03T09:44:15Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I think I prefer explicit separation via a visible delimiter. But that's only a preference, and I'm happy to defer to yours.",
          "createdAt": "2019-07-03T10:09:07Z",
          "updatedAt": "2019-07-03T10:09:07Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Whitespace is the most visible delimiter :) \r\n\r\nI've updated the PR; PTAL. I have't yet implemented or written tests for this, so it may need some adjustments, but I'd like to get this general approach agreed to first.",
          "createdAt": "2019-07-04T02:54:45Z",
          "updatedAt": "2019-07-04T02:54:45Z"
        }
      ]
    },
    {
      "number": 819,
      "id": "MDU6SXNzdWU0NjI1MTMyNDY=",
      "title": "tls_unexpected_peer_certificate details",
      "url": "https://github.com/httpwg/http-extensions/issues/819",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "proxy-status"
      ],
      "body": "This field uses `details` for a specific purpose, but that's already in the generic parameters. Suggest `cert_id` or similar. \r\n\r\n/cc @PiotrSikora ",
      "createdAt": "2019-07-01T05:12:55Z",
      "updatedAt": "2019-07-20T14:34:05Z",
      "closedAt": "2019-07-20T14:33:09Z",
      "comments": [
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks like `tls_unexpected_peer_identity` has the same issue. Should we use `cert_id` for both?\r\n\r\nNote that the identifier is context-based, since if proxy configured SHA256-based validation, then `cert_id` would be `SHA256(peer_certificate)`, if it configured SPKI-based validation, then `cert_id` would be `SPKI(peer_certificate)`, etc.\r\n\r\nWe could also use `sha256` and `spki` instead of `cert_id` (and `identity` for  `tls_unexpected_peer_identity`), but that doesn't seem very future-proof.\r\n\r\nWhat do you think?",
          "createdAt": "2019-07-02T12:48:02Z",
          "updatedAt": "2019-07-02T12:48:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hmm, that's awkward. Maybe two fields? E.g.,\r\n  * `validation_type`: [`sha256`, `spki`... ]\r\n  * `cert_id`: ...\r\n\r\nIs there a registry we can refer to, maybe?",
          "createdAt": "2019-07-03T04:23:00Z",
          "updatedAt": "2019-07-03T04:23:00Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm afraid that there isn't any registry that we can refer to, at least none that I know of.\r\n\r\n`validation_type` (opaque type) and `cert_id` (opaque value) seem a bit awkward. Wouldn't it be easier to just have `sha256` and `spki` params?\r\n\r\nAlso, in Envoy, we actually configure list of acceptable `sha256` and `spki` values, and matching against any of them works, so we should probably emit both of them anyway.\r\n\r\nI could envision merging `tls_unexpected_peer_certificate` and `tls_unexpected_peer_identity` into a single status type `tls_unexpected_peer_certificate` that lists all 3 params, e.g.\r\n`tls_unexpected_peer_certificate; sha256=xxxx; spki=aaaa; identity=backend.local`\r\n\r\nSee #864.\r\n\r\nWhat do you think?",
          "createdAt": "2019-07-19T10:28:53Z",
          "updatedAt": "2019-07-19T10:28:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Better than what we had :)",
          "createdAt": "2019-07-20T14:34:05Z",
          "updatedAt": "2019-07-20T14:34:05Z"
        }
      ]
    },
    {
      "number": 821,
      "id": "MDU6SXNzdWU0NjI1NjQ0NDQ=",
      "title": "Considering http_response_status",
      "url": "https://github.com/httpwg/http-extensions/issues/821",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "proxy-status"
      ],
      "body": "All proxy status types share a property; they indicate that the response was generated by a proxy, rather than the origin. This is useful; it allows a recipient to know not only that, but where it _was_ generated (by inspecting `proxy`).\r\n\r\nHowever, there is one exception -- `http_response_status` is explicitly decorating a response that's been forwarded by the origin. \r\n\r\nBesides the _one-of-these-things-is-not-like-the-others_ factor, I suspect this is going to trip some folks up, because they'll log or otherwise act on the presence of the header field with an understanding of \"this response was generated by a proxy, not by the origin.\" Since it's a debugging tool, that's especially concerning.\r\n\r\nI think this could be addressed by moving those use cases into a new header field (still defined by this document; e.g., `Proxy-Info`), but I'm open to other approaches.\r\n\r\n@PiotrSikora I know you had use cases around this, so would be very interested in your take.\r\n",
      "createdAt": "2019-07-01T07:47:53Z",
      "updatedAt": "2020-03-17T06:14:45Z",
      "closedAt": "2020-03-17T06:14:45Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "(also cc @alyssawilk)",
          "createdAt": "2019-07-02T04:19:49Z",
          "updatedAt": "2019-07-02T04:19:49Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This status type has two major use cases:\r\n\r\n1) It explicitly states that the status code and response body were generated by the next hop and not by the proxy.\r\ne.g. Can you tell whether this response was generated by the proxy (which may or may not support `Proxy-Status`) or by the backend?\r\n```\r\nHTTP/1.1 503 Service Unavailable\r\nDate: Tue, 02 Jul 2019 11:33:08 GMT\r\nServer: someproxy\r\n```\r\nCompare with:\r\n```\r\nHTTP/1.1 503 Service Unavailable\r\nDate: Tue, 02 Jul 2019 11:33:08 GMT\r\nProxy-Status: http_response_status; proxy=foocdn\r\nServer: someproxy\r\n```\r\n\r\n2) It acts as a `traceroute` for proxies.\r\n```\r\nHTTP/1.1 502 Bad Gateway\r\nDate: Tue, 02 Jul 2019 11:33:08 GMT\r\nProxy-Status: http_response_status; proxy=foocdn,\r\n              http_response_status; proxy=example.com,\r\n              tls_rejected_proxy_certificate; proxy=lb-us-west\r\nServer: someproxy\r\n```\r\n\r\nNotably, in both of those use cases, this status type gets more useful the less familiar you are with the proxy chain that you're dealing with. i.e. it doesn't provide too much benefit if you consider `Proxy-Status` only as an \"edge\" header to be emitted by CDNs, but once you consider that origins can emit those as well, and that you can see the route that the request took outside of your product/organization, it becomes really useful.\r\n\r\n> Besides the one-of-these-things-is-not-like-the-others factor, I suspect this is going to trip some folks up, because they'll log or otherwise act on the presence of the header field with an understanding of \"this response was generated by a proxy, not by the origin.\" Since it's a debugging tool, that's especially concerning.\r\n\r\nWell, that really depends on how we're going to present this feature :), and how is it going to be implemented in the open-source proxies and major CDNs.\r\n\r\nIf they are going to append `Proxy-Status` at each hop (`traceroute` / reverse `Forwarded`), then I don't think anybody is going to be confused by this \"special\" type. On the other hand, if `Proxy-Status` is going to be used primarily as an \"error indicator\", then yes, we might want to migrate this status type and `proxy_internal_response` (#807) elsewhere.\r\n\r\nPerhaps we should mandate one or the other?\r\n\r\ncc @ghedo, since he expressed interest in deploying this at Cloudflare.\r\n\r\nOn a separate note, it isn't obvious (to me) what happened from just looking at the status type name, perhaps `http_response_forwarded` would be a bit more descriptive? What do you think?",
          "createdAt": "2019-07-02T12:23:12Z",
          "updatedAt": "2019-07-02T12:23:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I agree this is an interesting and important use case -- I just want to talk about how we're expressing it in the protocol.\r\n\r\nMy preference would be to keep `Proxy-Status` confined to responses that are generated by the proxy, to make it crystal clear when that is happening. To serve this use case, I'm thinking we could use a different header, something like `Proxy-Info`; e.g.,\r\n\r\n~~~\r\nProxy-Info: node=\"fooProxy\", nextHop=\"barOrigin\", latency=525\r\n~~~\r\n\r\nNote that this lets us migrate some of the generic parameters over, because they don't apply to just error responses.\r\n\r\nThat would make your example above:\r\n\r\n~~~\r\nProxy-Info: node=\"foocdn\",\r\n            node=\"example.com\",\r\n            node=\"lb-us-west\"\r\nProxy-Status: tls_rejected_proxy_certificate; node=\"lb-us-west\"\r\n~~~\r\n\r\nWDYT? To me this is better, because it's really clear that the status is generated by a proxy. After all, the most common case is going to be normal, non-error operation, which means that we avoid a lot of repeating `http_response_status` to scan through; i.e., it'll look like:\r\n\r\n~~~\r\nProxy-Info: node=\"foocdn\",\r\n            node=\"example.com\",\r\n            node=\"lb-us-west\"\r\n~~~",
          "createdAt": "2019-07-03T04:32:56Z",
          "updatedAt": "2019-07-03T04:32:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@PiotrSikora please see #843 for a rough idea of what this would look like; still needs a fair amount of cleanup and obviously we'd want to think about more information types, but you can get the idea.",
          "createdAt": "2019-07-05T01:43:45Z",
          "updatedAt": "2019-07-05T01:43:45Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At some point we're going to need a map to explain how all these intermediation header fields contribute: Cache-Status, Via, Proxy-Status (or Proxy-Error), Proxy-Info, CDN-Loop, et al all provide value independently, but navigating all of this is hard.",
          "createdAt": "2019-07-22T20:31:46Z",
          "updatedAt": "2019-07-22T20:31:46Z"
        },
        {
          "author": "alyssawilk",
          "authorAssociation": "NONE",
          "body": "From a user-perspective where the desire is to know where the response came from, I'd prefer as few sources of truth as possible.  Splitting into proxy-status and proxy-info seems like a step back in that regard as compared to the traceroute style trace in Piotr's example.  \r\n\r\nAdditionally, I think there's also a range of generated responses from responses fully generated by a proxy to responses fully proxied from another source, where one might for example, get instructions and partial headers and/or data from a side-car and synthesize a response from that.  In a world with user-defined headers and body transformations and lua/wasm filters operating on responses I'm not sure it's going to be easy to divide things into two buckets of \"internally generated response\" and \"not\" ",
          "createdAt": "2019-07-22T20:59:39Z",
          "updatedAt": "2019-07-22T20:59:39Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@PiotrSikora PTAL - https://httpwg.org/http-extensions/draft-ietf-httpbis-proxy-status.html\r\n\r\nIf we like this direction, I think the next step is to define some more parameters for other aspects that intermediaries might want to talk about...",
          "createdAt": "2019-11-28T04:59:43Z",
          "updatedAt": "2019-11-28T04:59:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@PiotrSikora ping? I'm inclined to publish this as-is for discussion in Vancouver...",
          "createdAt": "2020-02-25T04:03:33Z",
          "updatedAt": "2020-02-25T04:03:33Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Submission deadline is tomorrow, so I'm going to go ahead and submit, but not close this so we can continue discussion.",
          "createdAt": "2020-03-02T02:29:07Z",
          "updatedAt": "2020-03-02T02:29:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW the deadline is 2020-03-**09**, so one more week ",
          "createdAt": "2020-03-02T14:02:57Z",
          "updatedAt": "2020-03-02T14:02:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing, we can always open more!",
          "createdAt": "2020-03-17T06:14:45Z",
          "updatedAt": "2020-03-17T06:14:45Z"
        }
      ]
    },
    {
      "number": 822,
      "id": "MDU6SXNzdWU0NjMwODE3ODM=",
      "title": "Add draft-ietf-httpbis-digest-headers.md to the repo",
      "url": "https://github.com/httpwg/http-extensions/issues/822",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ioggstream"
      ],
      "labels": [],
      "body": "## Task\r\n\r\nAdd draft-ietf-httpbis-digest-headers.md as it has been adopted by the http workgroup.",
      "createdAt": "2019-07-02T08:04:14Z",
      "updatedAt": "2019-07-03T07:53:10Z",
      "closedAt": "2019-07-03T07:53:10Z",
      "comments": []
    },
    {
      "number": 825,
      "id": "MDU6SXNzdWU0NjM2MTc3MjI=",
      "title": "Digest Headers: add post-00 sections",
      "url": "https://github.com/httpwg/http-extensions/issues/825",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nthe draft after the -00  to contain the following section\r\n\r\n```\r\n# Changes\r\n\r\n_RFC Editor: Please remove this section before publication._\r\n\r\n\r\n## Since draft-ietf-httpbis-digest-headers-00\r\n\r\n```",
      "createdAt": "2019-07-03T08:33:36Z",
      "updatedAt": "2019-09-06T10:23:47Z",
      "closedAt": "2019-09-06T10:23:47Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ioggstream I think we can close this.",
          "createdAt": "2019-09-05T13:35:38Z",
          "updatedAt": "2019-09-05T13:35:38Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I still need to complete the PR :)",
          "createdAt": "2019-09-05T13:38:08Z",
          "updatedAt": "2019-09-05T13:38:08Z"
        }
      ]
    },
    {
      "number": 827,
      "id": "MDU6SXNzdWU0NjM2MjUyMDk=",
      "title": "Digest headers: typo in reference",
      "url": "https://github.com/httpwg/http-extensions/issues/827",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nreferences to FIPS180-3\r\n\r\n## Instead\r\n\r\nI have a reference to FIPS-180-3",
      "createdAt": "2019-07-03T08:49:17Z",
      "updatedAt": "2019-07-03T10:41:04Z",
      "closedAt": "2019-07-03T10:41:04Z",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "fixed in #829 ",
          "createdAt": "2019-07-03T10:41:04Z",
          "updatedAt": "2019-07-03T10:41:04Z"
        }
      ]
    },
    {
      "number": 828,
      "id": "MDU6SXNzdWU0NjM2MjU3NzU=",
      "title": "Digest Headers: what about the other algorithms?",
      "url": "https://github.com/httpwg/http-extensions/issues/828",
      "state": "CLOSED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "ADLER32 and CRC32c are in the registry, but not mentioned in the text (although they are covered by this blanket statement)\r\n\r\n> ## Changes compared to RFC5843\r\n>\r\n> [...]\r\n>\r\n> The status for all other algorithms have been updated to \"standard\".\r\n\r\nIs it ok to gloss them this way?",
      "createdAt": "2019-07-03T08:50:24Z",
      "updatedAt": "2019-10-22T08:20:43Z",
      "closedAt": "2019-10-22T08:20:43Z",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@phluid61 thanks for your question! I really appreciate some guidance here!\r\n\r\nWhat should we put there instead of `standard`?\r\n\r\nHere's the rationale for the current choice:\r\n\r\n- I wasn't able to find the RFCs registering CRC32c and ADLER32 in the IANA table;\r\n- RFC5843 doesn't mention them;\r\n- eg. for Adler32, [RFC3309 has no iana considerations](https://tools.ietf.org/html/rfc3309#section-4)\r\n\r\nThis draft:\r\n\r\n- does not remove those adler32 and crc32c from https://www.iana.org/assignments/http-dig-alg/http-dig-alg.xhtml\r\n- just updates their status to `standard`\r\n\r\nThanks for your time!",
          "createdAt": "2019-07-03T09:09:37Z",
          "updatedAt": "2019-07-03T09:09:37Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm pretty sure those RFCs predate standardised registration, so it's definitely going to be a mess.\r\n\r\nI think you could mark ADLER32 as 'obsoleted' (see: https://tools.ietf.org/html/rfc4460#section-2.38 ) I think the references in the registry are still the most relevant.\r\n\r\nCRC32c is 'standard', as far as I can see.",
          "createdAt": "2019-07-03T09:39:37Z",
          "updatedAt": "2019-07-03T09:39:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "WDYT of adding a subsection to section 9 - \"Obsolete ADLER32 Digest Algorithm\" that cites Stream Control Transmission Protocol (SCTP) Checksum Change https://tools.ietf.org/html/rfc3309 ",
          "createdAt": "2019-07-03T09:56:45Z",
          "updatedAt": "2019-07-03T09:56:45Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok for me. Do you agree to leave this to `-01` ?",
          "createdAt": "2019-07-03T11:13:41Z",
          "updatedAt": "2019-07-03T11:13:41Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Please keep -00 as close to the draft we adopted as possible.",
          "createdAt": "2019-07-03T23:34:24Z",
          "updatedAt": "2019-07-03T23:34:24Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seems that ADLER32 is still used by various projects, like dcache.org, for a weak form of validation.\r\n\r\n@paulmillar is mentioned in the IANA table too :) Can you share your view on the subject?\r\n",
          "createdAt": "2019-07-25T09:54:30Z",
          "updatedAt": "2019-07-25T09:54:30Z"
        },
        {
          "author": "manger",
          "authorAssociation": "NONE",
          "body": "ADLER32 and CRC32c are well-defined, standardised, algorithms. But there is no spec specifically registering them for use in the HTTP Digest header. My judgement at the time (as the designated expert for that IANA table of HTTP Digest Algs) was that it was sufficient for the _algorithms_ to have specs, without demanding an extra spec just to added them to the table.\r\n\r\nADLER32 was added (despite its limitations for short messages described in RFC3309 \"SCTP Checksum Change\") as it was widely used in FTP, which HTTP was replacing in many situations.\r\n\r\nAs for the new \"Status\" column ...\r\nThe status of the algorithm is probably more useful than the status of a registration spec, though that would require a separate judgement call.\r\n\r\nADLER32 is deprecated in SCTP, but presumably still widely used in ZLIB. So for the HTTP Digest table ... uhmm ... \"obsolete\" or \"standard\" (or \"informational\"?) is probably fine.\r\n\r\nI suggest adding ADLER32 and CRC32c to draft-ietf-httpbis-digest-headers. That tidies up the registration.",
          "createdAt": "2019-08-01T02:39:34Z",
          "updatedAt": "2019-08-01T02:39:34Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @manger.\r\n\r\nI thought to two possibilities:\r\n\r\n- add CRC32c and ADLER32 in the digest-algorithms (eg like they were never added);\r\n- update the CRC32c and ADLER32 in the IANA considerations with a full definition of all the fields,\r\n  so that *this spec* becomes a complete reference for the addition of those algorithms.\r\n\r\n@reschke  who can provide some guidance on that? ",
          "createdAt": "2019-08-01T08:21:23Z",
          "updatedAt": "2019-08-01T08:21:44Z"
        },
        {
          "author": "paulmillar",
          "authorAssociation": "NONE",
          "body": "@ioggstream From a quick read through the document, it seems this document assumes the reason for requesting a checksum is to verify the image has not been modified by a potentially hostile agent.  For this use-case, using a non-crypto hash (e.g., ALDER32) or a crypto hash that has been broken (such as MD5) is (very likely) a bad choice.\r\n\r\nHowever, there are potentially other use-cases for requesting a hash.  One such example is when a file has been transferred and (soon after) the user/client wishes to verify the integrity of the transfer against accidental (i.e. non-malicious) corruption.  In such cases, a non-cryptographically strong algorithm may be acceptable.\r\n\r\nThe other (related) scenario is where the only known-good value for a file's hash was calculated using an algorithm that is either not intended to be crypto-strong (e.g., ADLER32), or using an algorithm that has been compromised (e.g., MD5).  Under these circumstances, the client may wish to know the remote content's hash using such algorithms, as it provides at least some measure of protection.\r\n\r\nMy suggestion would be something along the lines of ...\r\n\r\n> Servers MAY support non-cryptographically secure hash algorithms.  Clients\r\n> MUST ignore any hash values calculated using algorithms that do not\r\n> meet the clients requirements.\r\n\r\nThe onus is on the client to decide which algorithms are appropriate for their use-case.  This isn't dictated by the document (and will likely change over time, anyway, as more hash algorithms are broken).",
          "createdAt": "2019-08-06T10:08:55Z",
          "updatedAt": "2019-08-06T10:08:55Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@paulmillar   thanks for your feedback!\r\n\r\nWhat do you think of this PR? https://github.com/httpwg/http-extensions/pull/877\r\n\r\n> verify the integrity of the transfer against accidental (i.e. non-malicious) corruption.\r\n> In such cases, a non-cryptographically strong algorithm may be acceptable.\r\n\r\nAs the number of messages grow, chance or purpose may not change that much :)\r\nI agree that we can warn about that and push people to use the best\r\ncrypto algorithm for their use case (which may be CRC32c).\r\n\r\n> ... or using an algorithm that has been compromised (e.g., MD5).\r\n\r\nWe decided not to support broken crypto algorithms. If you don't need\r\ncrypto quality you can go CRC32c.\r\n\r\n> The onus is on the client to decide \r\n\r\nWhile the receiver (either client or server) may even ignore `Digest`, we should foster interoperability around secure choices which, as you correctly said, may change in time.\r\n\r\n\r\n",
          "createdAt": "2019-08-09T10:49:39Z",
          "updatedAt": "2019-08-09T10:49:39Z"
        },
        {
          "author": "paulmillar",
          "authorAssociation": "NONE",
          "body": "Hi @ioggstream\r\n\r\n> What do you think of this PR? #877\r\n\r\nI've commented on the PR directly, but (in summary) the PR looks OK as-is, but I wondered if it would be helpful to split the behaviour of the agent generating the insecure hash from the behaviour of the recipient.  (see PR for a concrete suggestion).\r\n\r\n> We decided not to support broken crypto algorithms. If you don't need\r\n> crypto quality you can go CRC32c.\r\n\r\nThere's an additional consideration: number of bits.  ADLER32 and CRC32 are both 32-bit algorithms.  When dealing with large volumes of data there's an increased risk of non-malicious corruption that (by chance) a 32-bit algorithm fails to detect.  There is some interest in using MD5 not for its (broken) cryptographic behaviour, but simply because a hash has 128-bits.",
          "createdAt": "2019-08-13T12:23:08Z",
          "updatedAt": "2019-08-13T12:23:08Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I've commented on the PR directly\r\n\r\nThanks!\r\n\r\n> There is some interest in using MD5 not for its (broken) cryptographic behaviour, but simply because a hash has 128-bits.\r\n\r\nWe deeply discussed MD5 in #867 Feel free to add your comments there - though the decision was taken we are still in draft.",
          "createdAt": "2019-08-19T12:33:58Z",
          "updatedAt": "2019-08-19T12:33:58Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@phluid61 @LPardue  Addressed via\r\n\r\n- [x] #891 Update CRC32C in iana table\r\n- [x] #877 Obsolete Adler32 but don't forbit\r\n\r\nCan we close?",
          "createdAt": "2019-10-09T08:54:09Z",
          "updatedAt": "2019-10-09T08:54:09Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@phluid61 great!",
          "createdAt": "2019-10-22T08:20:43Z",
          "updatedAt": "2019-10-22T08:20:43Z"
        }
      ]
    },
    {
      "number": 831,
      "id": "MDU6SXNzdWU0NjM2NDAzODQ=",
      "title": "Digest: unused references",
      "url": "https://github.com/httpwg/http-extensions/issues/831",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ioggstream"
      ],
      "labels": [
        "digest-headers"
      ],
      "body": "- [x] Warning: no \\<xref> in \\<rfc> targets \\<reference anchor='RFC7233'>\r\n- [x] Warning: no \\<xref> in \\<rfc> targets \\<reference anchor='FIPS180-4'>\r\n- [x] Warning: no \\<xref> in \\<rfc> targets \\<reference anchor='RFC2818'>\r\n- [x] Warning: no \\<xref> in \\<rfc> targets \\<reference anchor='RFC5788'>\r\n- [x] Warning: no \\<xref> in \\<rfc> targets \\<reference anchor='RFC6962'>\r\n",
      "createdAt": "2019-07-03T09:20:06Z",
      "updatedAt": "2019-07-03T10:22:36Z",
      "closedAt": "2019-07-03T10:22:35Z",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed in #833 ",
          "createdAt": "2019-07-03T10:22:35Z",
          "updatedAt": "2019-07-03T10:22:35Z"
        }
      ]
    },
    {
      "number": 832,
      "id": "MDU6SXNzdWU0NjM2NTczNTY=",
      "title": "Digest: update references for SHA algorithms.",
      "url": "https://github.com/httpwg/http-extensions/issues/832",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## Question\r\n\r\nShould we update the FIPS180 reference to the latest one?\r\n\r\n## Context\r\n\r\nNIST updated the document defining SHA-* algoritms.\r\n\r\nThe latest reference is\r\n\r\n```\r\n  FIPS180-4:\r\n    title: NIST FIPS 180-4, Secure Hash Standard\r\n    author:\r\n      name: NIST\r\n      ins: National Institute of Standards and Technology, U.S. Department of Commerce\r\n    date: 2015-08\r\n    target: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\r\n```\r\n\r\ndigest-headers references preserve the ones cited in RFC3230 and subsequent.",
      "createdAt": "2019-07-03T09:53:59Z",
      "updatedAt": "2019-09-05T15:49:55Z",
      "closedAt": "2019-09-05T15:49:55Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cross-posting from elsewhere, I said\r\n\r\n> Note that references to FIPS180-1 are due to historical reference, e.g. an algorithm that was removed from later drafts.\r\n\r\nI think we probably want to use FIPS180-4 for SHA-256 and SHA-512, and FIPS180-1 for SHA-1.",
          "createdAt": "2019-07-03T10:04:53Z",
          "updatedAt": "2019-07-03T10:04:53Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is also [RFC 6234](https://tools.ietf.org/html/rfc6234).",
          "createdAt": "2019-07-04T01:40:11Z",
          "updatedAt": "2019-07-04T01:40:11Z"
        }
      ]
    },
    {
      "number": 834,
      "id": "MDU6SXNzdWU0NjM2NzE1MjM=",
      "title": "Digest: add -latest to docname",
      "url": "https://github.com/httpwg/http-extensions/issues/834",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ioggstream"
      ],
      "labels": [
        "digest-headers"
      ],
      "body": "- [x] WARNING: The Internet-Draft name 'draft-ietf-httpbis-digest-headers' should end with a two-digit sequence number or 'latest'. (at line 20)\r\n\r\n",
      "createdAt": "2019-07-03T10:24:56Z",
      "updatedAt": "2019-07-03T10:38:55Z",
      "closedAt": "2019-07-03T10:38:55Z",
      "comments": []
    },
    {
      "number": 836,
      "id": "MDU6SXNzdWU0NjM2ODAyNjk=",
      "title": "Digest:  abstract should not contain citations.",
      "url": "https://github.com/httpwg/http-extensions/issues/836",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nAbstract should not contain citations. See https://tools.ietf.org/html/rfc7322#section-4.3\r\n\r\n## Instead\r\n\r\nWARNING: xref not allowed inside t (inside <abstract>) (at line 48)\r\nWARNING: xref not allowed inside t (inside <abstract>) (at line 49)\r\n",
      "createdAt": "2019-07-03T10:45:12Z",
      "updatedAt": "2019-07-03T10:54:48Z",
      "closedAt": "2019-07-03T10:54:48Z",
      "comments": []
    },
    {
      "number": 839,
      "id": "MDU6SXNzdWU0NjQwNjQ1NTg=",
      "title": "Parameterised Lists -> Lists",
      "url": "https://github.com/httpwg/http-extensions/issues/839",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Discussion on #816 and #797 makes me wonder whether it would be good to refactor Parameterised Lists to be just Lists -- i.e.:\r\n\r\n* All List items would be allowed to have parameters; a \"bare\" list would just have no parameters\r\n* By necessity, List items would still be able to be any item type (or an inner-list, if #816 goes forward), meaning that #797 would be implemented\r\n* The top-level permissible types would be collapsed down to just `Dictionary` `List` and `Item`.\r\n\r\nThe obvious benefit here is simplification. Another benefit would be future-proofing headers that might need to elaborate on their list items in the future; they can just add new parameters as necessary.\r\n\r\nThe downsides I can see:\r\n* As per discussion in #797, it's no longer simple to map lists to a simple programming language data type, nor to simple JSON. However, I think I could adjust the JSON in the test suite to give us the expressiveness we need here, and I think the wrapper object here is pretty self-explanatory.\r\n* It would require current specs using Parameterised List to re-specify using List. Not a big deal, I think, but worth checking with folks like @mikewest.\r\n* A header that wants any list item to fail parsing if it contains parameters will have to say so explicitly -- but as per above, I think that's the right default.\r\n\r\nWhat do folks think -- worth it?",
      "createdAt": "2019-07-04T05:11:35Z",
      "updatedAt": "2019-07-08T02:26:15Z",
      "closedAt": "2019-07-08T02:26:15Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@phluid61 @bsdphk @kazuho would also like your thoughts.",
          "createdAt": "2019-07-04T05:12:07Z",
          "updatedAt": "2019-07-04T05:12:07Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I ran into an issue recently where I wanted to define a new header as a List. I ended up choosing Parameterized List instead. Even though I didn't have any parameters yet, this seemed like a better way to future-proof it.\r\n\r\nI'm a proponent of this.",
          "createdAt": "2019-07-04T06:06:17Z",
          "updatedAt": "2019-07-04T06:06:17Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "It's graceful and DRY, but the javascript people probably won't like it. I'm also in a museum in Darwin, a thousand miles from my computer, so I'm not digging very deep right now.\r\n\r\nWithin a list, is there a difference between an item, and a parameterised item with no parameters? And if so, how are they distinguished in the serialisation? ",
          "createdAt": "2019-07-04T06:18:30Z",
          "updatedAt": "2019-07-04T06:18:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I don't think so -- I think it's just \"list items can have parameters.\"\r\n\r\n@annevk any thoughts?\r\n\r\nEnjoy the North -- hopefully it's warmer than Melbourne :)",
          "createdAt": "2019-07-04T06:34:25Z",
          "updatedAt": "2019-07-04T06:34:25Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My +1 goes to adopting this too. It's simpler, and more future-proof.\r\n\r\nRegarding similarity to JSON, it's my understanding that sh-param already requires a not-so-straightforward mapping. Because a JSON object does not have a concept of \"a value associated with attributes.\"\r\n\r\nI think there are at least two ways to map an parameterized item to JSON. One is to use an array, like `[\"value\", {\"param1\": 123, \"param2\": 456}]`. The other is to use a special attribute to represent the public value of the parameterlized item, like `{\"_\": \"value\", \"param1\": 123, \"param2\": 456}`. We can use the latter if we need to have distinction between a list and a parameterlized item.",
          "createdAt": "2019-07-04T06:37:36Z",
          "updatedAt": "2019-07-04T06:38:08Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I'm having trouble wrapping my head around the proposal. I think that it means that headers can be more expressive and complex, which sounds great to me! Would you mind putting up an example of what this change would enable?",
          "createdAt": "2019-07-04T06:41:05Z",
          "updatedAt": "2019-07-04T06:41:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I don't think there's any change in the serialisation -- it's just getting rid of the distinction between `List` and `Parameterised List`, so that in headers you define, you just specify `List` for both use cases.",
          "createdAt": "2019-07-04T06:43:15Z",
          "updatedAt": "2019-07-04T06:43:15Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> I don't think there's any change in the serialisation\r\n\r\nThen I really don't understand the proposal. :) Going back to the original issue:\r\n\r\n> All List items would be allowed to have parameters; a \"bare\" list would just have no parameters\r\n\r\nI think this means that `list_item1;a=b;c;d=e, list_item2;f=g` would be a valid representation of a list with two items, each of which had parameters.\r\n\r\n> By necessity, List items would still be able to be any item type (or an inner-list, if #816 goes forward), meaning that #797 would be implemented\r\n\r\nI think this means that `*[binary goes here]*;a=b;c;d=e, 18.2345432;f=g` and `*[binary goes here]*;a=b;c;d=e, (list_item2 list_item3);f=g` would both also be valid.\r\n\r\nIs that about right?",
          "createdAt": "2019-07-04T06:55:22Z",
          "updatedAt": "2019-07-04T06:55:22Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> I think this means that `list_item1;a=b;c;d=e, list_item2;f=g` would be a valid representation of a list with two items, each of which had parameters.\r\n\r\nYes.\r\n\r\n> I think this means that `*[binary goes here]*;a=b;c;d=e, 18.2345432;f=g` and `*[binary goes here]*;a=b;c;d=e, (list_item2 list_item3);f=g` would both also be valid.\r\n\r\nYes. I'm saying that the serialisation doesn't change because _this_ issue is depending on #816 and #797 to do the work for it; if they get in, it seems like a natural cleanup / consolidation to me.\r\n",
          "createdAt": "2019-07-04T06:57:38Z",
          "updatedAt": "2019-07-04T06:58:03Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Got it. :+1: More expressiveness is good.\r\n\r\n> (list_item2 list_item3);f=g\r\n\r\nWhat about `(list1_item1;a=b;c=d list1_item2;e=f);g=h;i=j, (list2_item1;a=b;c=d list2_item2;e=f)`?\r\n\r\nI assume parameter name (and dictionary item names) wouldn't change? That is, `list_item1;(param1 param2)=whatever` would still be invalid?",
          "createdAt": "2019-07-04T07:04:36Z",
          "updatedAt": "2019-07-04T07:04:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "No to both of those, at least as I see it currently (I could be convinced, but it seems pretty complex).",
          "createdAt": "2019-07-04T07:09:32Z",
          "updatedAt": "2019-07-04T07:09:32Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Allowing parameterized inner-list items would address the example in https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-10#appendix-B.2. I think it could then be rewritten as:\r\n\r\n```\r\nExample-Thing:\r\n    name=\"widget\",\r\n    cost=89.2,\r\n    descriptions=(foo;url=\"https://example.net\";context=123\r\n                  bar;url=\"https://example.org\";context=456)\r\n```\r\n",
          "createdAt": "2019-07-04T07:12:16Z",
          "updatedAt": "2019-07-04T07:12:16Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'm not against it, but let's see if we can declare victory on this step first :)",
          "createdAt": "2019-07-04T07:15:51Z",
          "updatedAt": "2019-07-04T07:15:51Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Victory it is! I am defining a header whose value is probably(?) a parameterized list _literally right now_, and will happily change it to a list if/when this lands.",
          "createdAt": "2019-07-04T07:20:16Z",
          "updatedAt": "2019-07-04T07:20:16Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK. I might land the PRs for those two issues and do this, then submit a new draft after @bsdphk has a chance to look over it. I'll try to update the test suite and my implementation before submission to flush out any bugs, but it might have to wait until after (deadline is Monday).",
          "createdAt": "2019-07-04T07:48:33Z",
          "updatedAt": "2019-07-04T07:48:33Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I think this is fine. We haven't really started looking into JavaScript types for these things yet and that still seems a little early to do as well. And even then we could offer convenience methods that return a lossy array (without parameters) if that turns out to be a common use case.\r\n\r\n(And it's indeed very likely you want to go from items to more expressive items, I've come across this a few times in the last couple months alone.)",
          "createdAt": "2019-07-04T07:53:08Z",
          "updatedAt": "2019-07-04T07:53:45Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "See PR #841 for a first pass at this.",
          "createdAt": "2019-07-04T08:25:12Z",
          "updatedAt": "2019-07-04T08:25:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Also @evert wanted to make sure you saw this, as it's an API change. Thoughts?",
          "createdAt": "2019-07-05T00:43:04Z",
          "updatedAt": "2019-07-05T00:43:04Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Seems like only positive feedback, so I'm going to merge, take another look in situ, and then perhaps get a new draft out. Thanks.",
          "createdAt": "2019-07-07T23:17:47Z",
          "updatedAt": "2019-07-07T23:17:47Z"
        }
      ]
    },
    {
      "number": 840,
      "id": "MDU6SXNzdWU0NjQwOTM5ODM=",
      "title": "Talk about freshness",
      "url": "https://github.com/httpwg/http-extensions/issues/840",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Some people find it surprising that a cache can return a stale response (e.g., when disconnected from the origin server). It would be good to talk about:\r\n\r\n* [ ] Advice to clients regarding examining the freshness of returned responses\r\n* [ ] Advice to servers about setting appropriate cache-control for corner cases (e.g., `must-revalidate`)\r\n* [ ] Advice to spec authors when they're writing requirements for both\r\n\r\n",
      "createdAt": "2019-07-04T06:51:11Z",
      "updatedAt": "2019-08-30T06:54:34Z",
      "closedAt": "2019-08-30T06:54:34Z",
      "comments": [
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "This has come up in a proposed errata for RFC 8555, https://www.rfc-editor.org/errata_search.php?rfc=8555&eid=5771",
          "createdAt": "2019-07-04T16:23:58Z",
          "updatedAt": "2019-07-04T16:23:58Z"
        }
      ]
    },
    {
      "number": 842,
      "id": "MDU6SXNzdWU0NjQxNTA2NTc=",
      "title": "Dictionary of a dictionary",
      "url": "https://github.com/httpwg/http-extensions/issues/842",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Now that we are generalizing how the types are used, I think it might be a good idea to allow a dictionary value to be a mapping (i.e., a list of parameters).\r\n\r\nThis would be a generalization. At the moment, top level elements can contain scalars, lists, or dictionaries. However, it is at the moment impossible to use a dictionary at the second level even though scalars and lists are permitted.\r\n\r\nIn terms of use-case, the proposed change would allow for example something like a cache-control directive to take a mapping as an argument (see https://github.com/httpwg/http-extensions/pull/824#discussion_r300230506).\r\n\r\nLogic-wise, I assume that the added complexity would not be significant, as we can reuse the definition for the parameters of a parameterised list.",
      "createdAt": "2019-07-04T09:01:37Z",
      "updatedAt": "2019-08-19T08:55:04Z",
      "closedAt": "2019-08-19T08:55:04Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@kazuho are you just asking for parameters on dictionary values, in a manner that's equivalent to list values?",
          "createdAt": "2019-07-09T04:09:57Z",
          "updatedAt": "2019-07-09T04:09:57Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot Sorry for the belated response.\r\n\r\nYes. I'd be fine with member-value being exactly list-member.",
          "createdAt": "2019-07-10T12:52:44Z",
          "updatedAt": "2019-07-10T12:52:44Z"
        }
      ]
    },
    {
      "number": 844,
      "id": "MDU6SXNzdWU0NjUxNzk1OTU=",
      "title": "* in parameter names",
      "url": "https://github.com/httpwg/http-extensions/issues/844",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "RFC5987 encoding uses `*` in parameter names. Should we allow this? Would require modifying `key`.",
      "createdAt": "2019-07-08T10:30:57Z",
      "updatedAt": "2019-08-13T05:18:37Z",
      "closedAt": "2019-08-13T05:18:37Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "RFC 8187.\r\n\r\nThat said, good catch. But also opens the can of worms about non-ASCII.",
          "createdAt": "2019-07-08T10:49:10Z",
          "updatedAt": "2019-07-08T10:49:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@bsdphk nudged me into remembering it. I agree WRT the can-of-ASCII-worms, but in this case, our current design has the effect that it's not possible to port a 8187-encoded header into SH without performing some pretty nasty tricks (because we'd need a _different_ sigil to indicate the encoded parameter, and we really don't have any available).\r\n\r\nThat may be a perfectly fine outcome; it could be that we don't want to port `Content-Disposition` (others?) into SH. \r\n\r\nThe charm of the current design that it's easy to represent in common programming languages, e.g., as a property of an object. Not sure how important that really is, though.",
          "createdAt": "2019-07-09T04:01:08Z",
          "updatedAt": "2019-07-09T04:01:08Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is there a path toward including Unicode directly?  I mean, there's not even a shadow of a hope of just putting Unicode between quotes and calling it a day when it comes to existing header fields, I assume.  But what would it take to get there?  Sadly, I don't think that a new serialization is what gets you there, at least not directly, but it does suggest that there are possibilities.",
          "createdAt": "2019-07-09T04:06:27Z",
          "updatedAt": "2019-07-09T04:06:27Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The path to unicode is -- for the current, textual serialisation -- to encode it somehow into ASCII. 8187 is one way to do that, but it's important to remember that it's *just* for parameter values that use a special convention, and have a fallback parameter value that's pure ASCII. \r\n\r\nI.e., it's a very specific model, not a general approach to unicode in headers. If we accommodate `*` in keys, we could say that it's reserved for this use, and have an alternative encoding of the value in a new serialisation.",
          "createdAt": "2019-07-09T04:09:06Z",
          "updatedAt": "2019-07-09T04:09:06Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's not a path, that's a hack.  Reserving `*` for that hack might be reasonable, but I'm looking at the bigger problem space.\r\n\r\nIf you accept that header field values are sequences of bytes (not ASCII), then you do have some leeway.  The problem being that I suspect that the reason we have the hack is that we don't have 8-bit clean paths through everywhere.  But if there is some incentive associated with making these 8-bit clean for some other purpose (like alternative serialization), then there is hope for that.  Once there, the semantics of `Header: \"\ud83d\uddb2\ud83d\udd25\"` are ours to define.\r\n\r\nToo optimistic?",
          "createdAt": "2019-07-09T04:15:30Z",
          "updatedAt": "2019-07-09T04:15:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think so. But really this is #537.",
          "createdAt": "2019-07-09T04:20:22Z",
          "updatedAt": "2019-07-09T04:20:22Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, then I'll add my support to Roy's comments there, acknowledging that that might be a little optimistic.",
          "createdAt": "2019-07-09T04:31:01Z",
          "updatedAt": "2019-07-09T04:31:01Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"Link\", too, not only \"Content-Disposition\".\r\n\r\nIf we don't get non-ASCII in strings, reserving \"*\" for RFC 8187 encoding might be the next best approach. Another thing would be to allow \"\\uxxxx\" escapes in string values (just saying...).\r\n\r\nNot having something will cause people to invent new stuff, which seems to be a bad outcome.",
          "createdAt": "2019-07-09T05:35:26Z",
          "updatedAt": "2019-07-09T05:36:15Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If UTF-8 is definitely out of scope, I also hope that `*` can be reserved for RFC 8187 encoding. At least it keeps a door open to merging these formats one day.\r\n\r\nThat said I really would *love* RFC8187 encoding in structured headers. I realize that this topic has been beaten to death already though.",
          "createdAt": "2019-07-09T22:14:22Z",
          "updatedAt": "2019-07-09T22:14:22Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Does it conflict in serialisation with binary data? I can't keep track of where we're up to.",
          "createdAt": "2019-07-29T03:01:35Z",
          "updatedAt": "2019-07-29T03:01:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "No.",
          "createdAt": "2019-07-29T15:44:27Z",
          "updatedAt": "2019-07-29T15:44:27Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "My sense after discussion in Montreal is that specifying the use of 8187 in SH is too much complexity for the benefit. However, it seems like we can allow `*` in key names without too much trouble, enabling those use cases if folks want to specify how to do it.",
          "createdAt": "2019-08-13T05:14:38Z",
          "updatedAt": "2019-08-13T05:14:38Z"
        }
      ]
    },
    {
      "number": 845,
      "id": "MDU6SXNzdWU0NjUxODA3NTA=",
      "title": "Clarify why ABNF doesn't allow empty sh-dict and sh-list.",
      "url": "https://github.com/httpwg/http-extensions/issues/845",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "",
      "createdAt": "2019-07-08T10:33:43Z",
      "updatedAt": "2019-08-19T08:58:37Z",
      "closedAt": "2019-08-19T08:58:37Z",
      "comments": []
    },
    {
      "number": 848,
      "id": "MDU6SXNzdWU0NjUyMjYzMDA=",
      "title": "Serializing sh-float is hard",
      "url": "https://github.com/httpwg/http-extensions/issues/848",
      "state": "CLOSED",
      "author": "bsdphk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "The current definition of sh-float is surprisingly hard to serialize correctly, the best C-code I could come up with is:\r\n\r\n        int\r\n        serialize_sh_float(char buf[18], double d)\r\n        {\r\n                int p = 0, l, dig;\r\n\r\n                buf[0] = '*';\r\n                buf[1] = '\\0';\r\n                if (isnan(d))\r\n                        return (-1);\r\n                if (fabs(d) >= 99999999999999.95)\r\n                        return (-1);\r\n\r\n                if (d < 0) {\r\n                        buf[p++] = '-';\r\n                        d = -d;\r\n                        l = 18;\r\n                } else {\r\n                        l = 17;\r\n                }\r\n                dig = trunc(log10(d));\r\n                p += snprintf(buf + p, l - p, \"%.*f\", 15-dig, d);\r\n                while (buf[p-2] == '0') {\r\n                        buf[p-1] = '\\0';\r\n                        p--;\r\n                }\r\n                return (p);\r\n        }\r\n\r\nAnd that is horrible in severale levels.\r\n\r\nIf we insist instead that sh-float can have maximum six digits after the decimal point, people can rely on the default \"6 decimals\" behaviour of \"%f\" formatters, and use the simpler:\r\n\r\n        int\r\n        serialize_sh_float(char buf[18], double d)\r\n        {\r\n                int p = 0, l, dig;\r\n\r\n                if (isnan(d))\r\n                        return (-1);\r\n                if (fabs(d) >= 99999999999999.95)\r\n                        return (-1);\r\n\r\n                if (d < 0) {\r\n                        buf[p++] = '-';\r\n                        d = -d;\r\n                }\r\n                p += snprintf(buf + p, 18 - p, \"%-16f\", d);\r\n                while (buf[p-1] == ' ')\r\n                        p -= 1;\r\n                buf[p] = '\\0';\r\n                return (p);\r\n        }\r\n",
      "createdAt": "2019-07-08T12:19:52Z",
      "updatedAt": "2019-08-20T01:24:27Z",
      "closedAt": "2019-08-20T01:24:27Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "+1 from me, our primary focus should be on data types that will have good interop. That level of precision isn't necessary for any current use of HTTP headers I'm aware of, off the top of my head.",
          "createdAt": "2019-07-09T03:50:27Z",
          "updatedAt": "2019-07-09T03:50:27Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Proposal:\r\n\r\n1. Call these **decimal**.\r\n2. Allow a maximum of 9 digits on the left of the decimal place and 6 after.  This matches the definition for int and allows storing this in the same sized slot with a `*1e6` or `/1e6` conversion factor.",
          "createdAt": "2019-07-22T21:00:59Z",
          "updatedAt": "2019-07-22T21:00:59Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ABNF gets much simpler.\r\n```\r\nsh-decimal = [\"-\"] 1*9DIGIT \".\" 1*6DIGIT\r\n```",
          "createdAt": "2019-07-22T21:03:32Z",
          "updatedAt": "2019-07-22T21:03:32Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson That would probably curtail the range too much.\r\n\r\nI think it is desirable to be able to move posix time_t timestamps in these.",
          "createdAt": "2019-07-24T11:49:03Z",
          "updatedAt": "2019-07-24T11:49:03Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If this really is an integer with fixed point semantics, why do we need it at all?",
          "createdAt": "2019-07-24T12:11:30Z",
          "updatedAt": "2019-07-24T12:11:30Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> If this really is an integer with fixed point semantics, why do we need it at all?\r\n\r\nBecause it's easier than making people specify \"divide the number by a million to get its real value\"?\r\n\r\nThat said, I agree that 9 digits to the left of the point is probably not enough, so a floating point representation is more useful.\r\n\r\nThis is the ABNF equivalent of @bsdphk's C code, yeah?:\r\n\r\n```\r\nsh-float    = [\"-\"] (\r\n           1*9DIGIT \".\" 1*6DIGIT /\r\n            10DIGIT \".\" 1*5DIGIT /\r\n            11DIGIT \".\" 1*4DIGIT /\r\n            12DIGIT \".\" 1*3DIGIT /\r\n            13DIGIT \".\" 1*2DIGIT /\r\n            14DIGIT \".\" 1DIGIT )\r\n```\r\n\r\nThat easily gets us a current 32-bit time_t plus microseconds, and a whole range of other values besides.",
          "createdAt": "2019-07-26T07:33:41Z",
          "updatedAt": "2019-07-26T07:33:41Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why do the arguments about size of integers not also apply here?  `time_t` is 64-bit on my system, which doesn't fit in the sh-integer definition either.",
          "createdAt": "2019-07-29T02:19:10Z",
          "updatedAt": "2019-07-29T02:19:10Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "The current time is `1564367600`ish. You don't need to prefix it with 30 bits worth of zeroes.",
          "createdAt": "2019-07-29T02:33:59Z",
          "updatedAt": "2019-07-29T02:33:59Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I've read the IETF105 minutes, and thought about the fixed-point discussion.  All the uses for \"decimal number with fractional part\" I can think of\\* would reasonably served by at least 10 digits to the left\\*\\* and at least 3 to the right of the point.  So I would support any fixed- or floating-point representation that supports that range of values.\r\n\r\n\\* that's all that matters, right?\r\n\r\n\\*\\* a ten-decimal-digit time_t gives us until November 20, 2286",
          "createdAt": "2019-07-30T08:09:40Z",
          "updatedAt": "2019-07-30T08:09:40Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Using the max-six-decimal definition, and allowing 15 digits with no period or decimals, this C-code will do the job:\r\n\r\n        static char *\r\n        sh_float(double d)\r\n        {\r\n                static char buf[40];\r\n                int n;\r\n\r\n                if (fabs(d) < 1000000000) {\r\n                        n = snprintf(buf, sizeof(buf), \"%f\", d);\r\n                        while (buf[--n] == '0')\r\n                                buf[n] = '\\0';\r\n                        if (buf[n] == '.')\r\n                                buf[n] = '\\0';\r\n                } else {\r\n                        n = snprintf(buf, sizeof(buf), \"%.15g\", d);\r\n                }\r\n                return (buf);\r\n        }\r\n",
          "createdAt": "2019-08-03T00:53:30Z",
          "updatedAt": "2019-08-03T00:53:30Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, wrong button.",
          "createdAt": "2019-08-03T00:53:54Z",
          "updatedAt": "2019-08-03T00:53:54Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If I take #893, then I can *almost* represent that in a JS float in the most horrific way imaginable:\r\n\r\n```js\r\nlet dot = s.indexOf(\".\");\r\nif (dot > 0) {\r\n  m = s.length - dot - 1;\r\n  s = s.slice(0, dot) + s.slice(dot+1);\r\n} else if (dot == 0) {\r\n  throw \"bad\";\r\n}\r\nconst stored = parseInt(s) + m * Math.pow(10, 15);\r\n```\r\n\r\nBut that doesn't quite fit.  69999999999999999 doesn't fit into a double.  If you want to remember the number of additional decimal places so that you don't lose any precision on those trailing decimal places (things like 0.3 are surprisingly tricky to re-encode), you are left with supplementary values.  Can someone make a better case for any more than 10^10 values here?  I couldn't see a good one.  You can fit a 32-bit value in that.\r\n\r\nIf you really think that time_t is valuable, which I'm totally not convinced of, then fewer steps might be acceptable.  I can pack this:\r\n```\r\nsh-float    = [\"-\"] (1*9DIGIT \".\" 1*6DIGIT / 12DIGIT \".\" 1*3DIGIT)\r\n```\r\n",
          "createdAt": "2019-08-19T06:13:18Z",
          "updatedAt": "2019-08-19T06:13:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "PR updated. Any further comments, or ready to merge?",
          "createdAt": "2019-08-19T08:34:29Z",
          "updatedAt": "2019-08-19T08:34:29Z"
        }
      ]
    },
    {
      "number": 849,
      "id": "MDU6SXNzdWU0NjU4MTEyMDk=",
      "title": "Example of a Digest of empty representation",
      "url": "https://github.com/httpwg/http-extensions/issues/849",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nThe spec to show an  example of the `Digest` of an empty representation.\r\n\r\nTo favor interoperability we could propose to use a simple checksum of the resulting payload body (which iiuc may be empty or not).\r\n\r\n## empty representations and content-encoding\r\n\r\niiuc, an empty representation could eg. have a non-empty payload body due to Content-Encoding,\r\nso we couldn't just skip the validation in case of an empty representation\r\n\r\n```\r\nIn [119]: sha256(compress(b'')).hexdigest()                                                                                                                                                                                                  \r\nOut[119]: '7a53d5f4237c606ddaba52a2d4a3e40200eea48f5992172c6751209decae8d5a'\r\n\r\nIn [120]: sha256(b'').hexdigest()                                                                                                                                                                                                            \r\nOut[120]: 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\r\n\r\n```\r\n\r\n## empty representation and integrity\r\n\r\nI may want to ensure with Digest that the resource representation is as expected (eg. 'No Content')\r\nso a digest of an empty representation cannot be skipped.\r\n\r\n## empty representation and confidentiality\r\n\r\nAn empty representation may be masked by an encrypted content-coding. In this case we should not disclose informations, so a MICE-like choice that supports only one content coding may not fit this use-case.\r\n\r\n## MICE example\r\nSee https://github.com/martinthomson/http-mice/issues/3\r\n\r\nConsideration:\r\n\r\n- MICE defines both a content-coding and a digest-algorithm, so they are not required to convey content-encoding informations (there's only one content-encoding);\r\n- I'm not sure how MICE's tight coupling b/w digest and content-coding could work with multiple \r\n  content codings.\r\n \r\n@LPardue @martinthomson \r\n",
      "createdAt": "2019-07-09T14:22:56Z",
      "updatedAt": "2019-11-25T10:59:45Z",
      "closedAt": "2019-11-25T10:39:26Z",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed in Singapore:\r\n\r\n- a digest-algorithm is free to define the value associated to an empty representation;\r\n- for the existing algorithms it should not be treated as a special case.\r\n\r\nhttps://github.com/httpwg/wg-materials/blob/gh-pages/ietf106/minutes.md#issue-849--digest-of-empty-representations",
          "createdAt": "2019-11-25T10:39:26Z",
          "updatedAt": "2019-11-25T10:59:45Z"
        }
      ]
    },
    {
      "number": 850,
      "id": "MDU6SXNzdWU0NjU4MTY1NDQ=",
      "title": "Clarify digest-algorithm syntax with parameters (or drop parameters).",
      "url": "https://github.com/httpwg/http-extensions/issues/850",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nThis spec either:\r\n\r\n* to provide an RFC3230 compatible example of digest-algorithm with parameters;\r\n* explicitly drop parameters because they are not widely used and augment the attack surface;\r\n\r\nRFC3230 stated that:\r\n\r\n```\r\n   For some algorithms, one or more parameters may be\r\n   supplied.\r\n\r\n      digest-algorithm = token\r\n\r\n   The BNF for \"parameter\" is as is used in RFC 2616 [4].  All digest-\r\n   algorithm values are case-insensitive.\r\n```\r\n\r\nbut:\r\n\r\n- provided no example of parameterized algorithms\r\n\r\nIn this draft we *preserved that sentence* but:\r\n\r\n- still did not provide an example of parameterized algorithm;\r\n- still did not update the reference to BNF to the latest http spec.\r\n\r\nIn #1213 there's a possible fix to support parameters, like the following\r\n\r\n```\r\nDigest: myhash=dcRDgR2GM35DluAV13PzgnG6+pvQwPywfFvAu1UeFrs=; param1=40\r\n\r\n```\r\n\r\n## Notes\r\n\r\nUse cases are parametrizable digest-algorithms like mi-sha256.\r\n\r\nAnother solution could be to *deprecate* field parameters in digest: parameters could still be adopted serializing them in the digest-value, and leaving the specification/serialization to the definition of the digest-algorithm. eg:\r\n```\r\nDigest: myhash=40/dcRDgR2GM35DluAV13PzgnG6+pvQwPywfFvAu1UeFrs\r\n```",
      "createdAt": "2019-07-09T14:32:36Z",
      "updatedAt": "2020-10-17T12:02:41Z",
      "closedAt": "2020-10-17T12:02:41Z",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue @reschke I don't know of any parameter in the wild, but removing that will deviate from RFC 3230.\r\n\r\nIf we want to remove parameters, we should explicit:\r\n\r\n- that we will deprecate that feature (eg. because parameters can make things less secure);\r\n- that parameters are forbidden;\r\n- that if you want to use a parameterized algorithm you should encode their values in the digest-value and take care of the security considerations inside the definition of your digest-algorithm;\r\n\r\n`bikeshed=bs:8|offset:2|8E9q0okq`\r\n\r\n\r\n",
          "createdAt": "2020-07-05T19:56:46Z",
          "updatedAt": "2020-08-17T09:45:01Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, deviating would fine in this case. One point in revising specs is to remove unused stuff.",
          "createdAt": "2020-07-05T20:12:28Z",
          "updatedAt": "2020-07-05T20:12:28Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke I agree. My question is whether it's better to:\r\n\r\n- leave digest-algorithm implementors to define a way to pass parameters via the serialization\r\n- standardize the way parameters are passed.\r\n\r\nGuidance on that is welcome.",
          "createdAt": "2020-07-06T12:15:03Z",
          "updatedAt": "2020-07-06T12:15:03Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot removal of Digest parameters would be a case where our update work deviates a bit further from what we might have initially had in mind. As Julian points out its fine to do so, however I want to make this more visibile before we take a decision.",
          "createdAt": "2020-08-13T13:15:47Z",
          "updatedAt": "2020-08-13T13:15:47Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I want to make this more visibile before we take a decision\r\n\r\n@LPardue I tweeted on that https://twitter.com/ioggstream/status/1295292991335268352 :) \r\n\r\nTo me leaving the parameter definition to the algorithm specification is fine, eg https://github.com/httpwg/http-extensions/issues/850#issuecomment-653931895 ",
          "createdAt": "2020-08-17T09:57:51Z",
          "updatedAt": "2020-08-17T09:57:51Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll send an email to the HTTP WG list too.",
          "createdAt": "2020-08-18T09:11:42Z",
          "updatedAt": "2020-08-18T09:11:42Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 for removing parameters.",
          "createdAt": "2020-08-18T10:00:07Z",
          "updatedAt": "2020-08-18T10:00:07Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+0 on removing parameters, but I want to strongly suggest that any examples of encoded parameters are expressed in terms of Structured Fields, even if the entire header is not compliant.\r\n\r\nie:\r\n\r\n    bikeshed=:SD8E9q0okq:\r\n\r\nwhere the parameters are encoded in the first two base64 encoded bytes.\r\n     \r\n",
          "createdAt": "2020-08-18T10:11:03Z",
          "updatedAt": "2020-08-18T10:11:03Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mailing list thread: https://lists.w3.org/Archives/Public/ietf-http-wg/2020JulSep/0092.html\r\n\r\n",
          "createdAt": "2020-08-26T13:00:07Z",
          "updatedAt": "2020-08-26T13:00:07Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke @mnot brief recap after discussion.\r\n\r\nWe propose to deprecate parameters because:\r\n\r\n* we were not able to find any implementation;\r\n* if they are used as an input parameter for validating the checksum, an attacker can use them to steer the validation process;\r\n\r\nThe proposal:\r\n- deprecate parameters (a receiver MUST ignore a checksum containing parameters)\r\n- suggests that digest-algorithms wishing parameterization, can encode parameters inside the checksum\r\n\r\nOT: I agree that making digest a SF would have resolved the issue with just some advice of not using parameters as input values when defining new digest-algorithms",
          "createdAt": "2020-10-07T20:15:06Z",
          "updatedAt": "2020-10-07T20:15:06Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue @reschke As parameters are now obsoleted, we have to decide whether to provide instructions for the transition.\r\nThe actual draft just deprecated parameters and does not allow their presence. If you think the current behavior is fine, imho we could merge #1259 and cutoff -04\r\n\r\n## Current behavior\r\n\r\nThe presence of a parameter in any representation-data-digest will invalidate the syntax of the whole Digest value.\r\n\r\n\r\n## Hyp 1\r\n\r\nadd the parameter definition to the ABNF and explicit that they SHOULD|MUST be ignored, while the checksum should be processed\r\n\r\n## Hyp 2\r\n\r\nadd the parameter definition to the ABNF and explicit that if a representation-data-digest contains parameter only this checksum should be ignored\r\n\r\n\r\n",
          "createdAt": "2020-10-16T22:23:10Z",
          "updatedAt": "2020-10-16T22:23:10Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we have no evidence of parameters in use, why would we need to consider a transition? Don't make things more complicated than they need to be.",
          "createdAt": "2020-10-17T04:17:18Z",
          "updatedAt": "2020-10-17T04:17:18Z"
        }
      ]
    },
    {
      "number": 851,
      "id": "MDU6SXNzdWU0NjU4MjgyMDk=",
      "title": "Using Digest in signatures",
      "url": "https://github.com/httpwg/http-extensions/issues/851",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nTo better detail the usage of `Digest` in signatures, including:\r\n\r\n- [x] you need a transport-layer integrity mechanism for the whole message;\r\n- [x] what should be included in signature for integrity (representation metadata affecting digest-algorithms)\r\n- [ ] issues with signing partial representations (eg. Range-Request, PATCH, ..)\r\n- [x] using strong crypto algorithms\r\n\r\nThis should be done:\r\n\r\n- [x] respecting the dependency model is that a signature doesn't need to include a digest but it can;\r\n- [x] don't explain too much of signature risks inverting the dependency;\r\n- [x] add useful guidance that is relevant to Digest and expected usages but without also defining the expected usages completely.\r\n\r\n## Questions\r\n\r\n- consider signing `Content-Length` too ([it's a representation-metadata in http-core](https://tools.ietf.org/html/draft-ietf-httpbis-semantics-04#section-6.2)), though it would eliminate the ability to do things like chunked transfer-encoding, which is quite common. @dlongley\r\n\r\n## Previous discussions\r\n\r\nWhat we have today is probably sufficient but we're open to compelling reasons on what would be really helpful to define in this document.\r\n\r\nThe followings may be out-of-scope:\r\n\r\n  - [length-extension attack on the signature](https://en.wikipedia.org/wiki/Length_extension_attack): Digest should not be subject to length extension attacks because **it doesn't provide a proof of origin**;\r\n  - which other signature data unrelated to `Digest` (eg. timestamp, method & co)\r\n",
      "createdAt": "2019-07-09T14:53:27Z",
      "updatedAt": "2020-08-17T11:41:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What does it take to close this issue?\r\n\r\nSince we opened it, the HTTP WG has adopted a signautes draft. Does that move the needle on any questions we have?  Can we spin out anything or makr them as won't do?",
          "createdAt": "2020-08-13T13:18:26Z",
          "updatedAt": "2020-08-13T13:18:26Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"Usage in signatures\" covers the goals enough.\r\n\r\nhttps://github.com/httpwg/http-extensions/blame/master/draft-ietf-httpbis-digest-headers.md#L1012\r\n\r\n- we provide considerations but won't specify what other headers should be signed (eg. content-length);\r\n- as https://github.com/httpwg/http-extensions/blob/master/draft-ietf-httpbis-message-signatures.md should be independent from Digest, the best we can do is to write a BCP on Digest and Signatures.\r\n\r\nThis is the repository placeholder https://github.com/ioggstream/draft-polli-digest-signatures (still not edited).\r\n\r\n@richanna @jyasskin @jricher  WDYT? \r\n@LPardue feel free to close if you agree.\r\n",
          "createdAt": "2020-08-17T11:41:13Z",
          "updatedAt": "2020-08-17T11:41:13Z"
        }
      ]
    },
    {
      "number": 852,
      "id": "MDU6SXNzdWU0NjYyMDk0MDE=",
      "title": "Create a threat model for `Digest` header.",
      "url": "https://github.com/httpwg/http-extensions/issues/852",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I wish\r\n\r\nA threat model for `Digest`.\r\n\r\n## Questions\r\n\r\n- is this useful/required?\r\n- should this go into Security Considerations or in another document?",
      "createdAt": "2019-07-10T09:44:07Z",
      "updatedAt": "2020-09-07T15:41:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "# Security issues for HTTP Digest\r\n\r\n## Actors\r\n\r\n- User\r\n- User-Agent: see RFC7230\r\n- Intermediaries that do not do TLS termination\r\n- Intermediaries that do TLS termination.\r\n\r\n- Application: the application actually running the service\r\n\r\n## Attacker capabilities\r\n\r\n1. Intermediaries can alter HTTP messages\r\n\r\n2. Intermediaries that do transport-layer termination can alter HTTP messages\r\n\r\n3. The application can erroneously or purposedly alter the message\r\n\r\n4. User can forge messages with the same checksum values\r\n\r\n## Attacker non-capabilities\r\n\r\n# Attacks and mitigations\r\n\r\n## Alteration of HTTP message headers\r\n\r\n### The attack\r\n\r\nAn intermediary can alter an HTTP header by chance or purpose.\r\n\r\n### Proposed mitigation\r\n\r\n[x] Use an end-to-end transport-layer security mechanism.\r\n\r\n\r\n## Alteration of HTTP representation-metadata headers\r\n\r\n### The attack\r\n\r\nA TLS-terminator intermediary can alter representation-metadata by chance or purpose.\r\n\r\n### Proposed mitigation\r\n \r\n - [x] Use a signature mechanism that covers both `Digest` and the representation-metadata.\r\n\r\n## Send a Digest header with a different payload\r\n\r\n### The attack\r\n\r\nA TLS-terminator intermediary can replace the representation-data with another\r\none having the same digest-algorithm.\r\n\r\nA malicious User can forge two messages with:\r\n\r\n  - different representation-data\r\n  - same Digest header values\r\n  \r\nsend an HTTP message with the first representation-data\r\nthen pretend he sent the one with the second representation-data.\r\n\r\nA malicious Server could implement a similar behavior.\r\n\r\n### Proposed mitigation\r\n\r\n[x] Use a digest-algorithm that is not subject to collision (eg. sha-256),\r\nor refuse to use digest-algorithms subject to collision.\r\n\r\n## Server resource exhaustion for calculating Digest on huge representation-data\r\n\r\n### The attack\r\n\r\nA User could exhaust server resources by chance or purpose via:\r\n\r\n1- sending a huge representation\r\n2- digest calculation of the complete representation\r\n3- forcing the server to evaluate the digest of the included representation\r\n\r\n### Proposed mitigation\r\n\r\n  - [x] To consume huge representation-data, you may consider\r\n         mechanisms sending progressive integrity checksums in the payload body\r\n         and just use `Digest` to provide the last checksum value.\r\n\r\n## Server resource exhaustion for calculating Digest on partial representations\r\n\r\n### The attack\r\n\r\nA malicious User could exhaust server resources via:\r\n\r\n1- reconstruction of the complete representation\r\n2- digest calculation of the complete representation\r\n3- forcing the server to evaluate many different digest-algorithms for a given representation\r\n\r\n### Proposed mitigation\r\n\r\nIf you are exposed to this kind of attack because \r\nreconstructing complete representations of your \r\nobjects is computationally intensive, avoid using\r\n[ ] Digest with mechanisms like Range-Requests and PATCH.\r\n\r\nIf you support multiple digest-algorithms:\r\n\r\n - [ ] limit the supported digest-algorithms to the\r\n  ones you really care for;\r\n - [ ] establish a policy for validating only the digest\r\n  using the stronger digest-algorithm.\r\n\r\n## Confidence in recipient's Digest validation \r\n\r\n### The attack\r\n\r\nThe recipient may skip Digest header validation by chance or purpose\r\nand still be compliant to the specification: as explained in {#digest-header} \r\nthe recipient MAY ignore any or all the received representation-data-digests.\r\n\r\nThis is because Digest was originally conceived in RFC3230 as a tool \r\nfor the recipient to validate the received representation, but not\r\nfor the sender to receive an integrity proof of the communication. \r\n\r\n- [ ] You should not rely on the recipient having correctly verified the Digest value\r\nof the selected representation.\r\n\r\n### Proposed mitigation\r\n\r\nIf you want the recipient to validate the `Digest`:\r\n\r\n- [ ] agree on `Digest` processing with your peer, like it is\r\n  done in [MICE](https://github.com/martinthomson/http-mice/blob/master/draft-thomson-http-mice.md)",
          "createdAt": "2019-07-24T08:50:16Z",
          "updatedAt": "2020-09-07T15:41:21Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let's see if we can incorporate some of this into the security considerations.",
          "createdAt": "2020-08-13T13:19:47Z",
          "updatedAt": "2020-08-13T13:19:47Z"
        }
      ]
    },
    {
      "number": 853,
      "id": "MDU6SXNzdWU0NjYyMTQwNTQ=",
      "title": "Investigate the use of Digest with PATCH",
      "url": "https://github.com/httpwg/http-extensions/issues/853",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## About PATCH\r\n\r\n1- `PATCH` is not in http 723x\r\n2- `PATCH` media type should be something like https://tools.ietf.org/html/rfc7396 because \r\nservers SHOULD NOT assume PATCH semantics for generic\r\n   media types that don't define them, such as \"application/xml\" or\r\n   \"application/json\".  Doing so will cause interoperability issues,\r\n   because the semantics of PATCH become specific to that resource,\r\n   rather than general.\r\n3- it's difficult to use patch + checksums, like @LPardue said\r\n\r\n## As of now we\r\n\r\n1- warn people about PATCH+Digest\r\n2- don't forbid PATCH+Digest\r\n\r\n## Notes\r\n\r\n-  it could be useful to validate the PATCH request body before applying it to the resource\r\n- guidance of the usage of Digest+PATCH is welcome to confirm  if the current expression of Digest support that use.",
      "createdAt": "2019-07-10T09:53:46Z",
      "updatedAt": "2019-11-02T18:32:22Z",
      "closedAt": "2019-11-02T18:32:22Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> it's difficult to use patch + checksums\r\n\r\ncare to elaborate?",
          "createdAt": "2019-07-10T10:36:59Z",
          "updatedAt": "2019-07-10T10:36:59Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can't find my original comment. IIRC I felt there was potential for confusion with what a digest header field on a PATCH request actually meant. Is is A) the digest of the PATCH body or B) the intended digest of the resource after being patched or C) something else.\r\n\r\nIf the intention is B, there is the danger that other requests (i.e. other PATCHes) could modify the representation such that the digest would not match the client's anticipation. ",
          "createdAt": "2019-07-10T10:53:17Z",
          "updatedAt": "2019-07-10T10:53:17Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems fairly clear to me that any Digest header field refers to the included representation.\r\n\r\nNow, that doesn't mean that there isn't value in signaling what you expect the digest of the updated resource representation to be after the PATCH is applied.  That however, is follow-on work and probably requires a new header field (say Patched-Digest).",
          "createdAt": "2019-07-10T11:52:52Z",
          "updatedAt": "2019-07-10T11:52:52Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue the original comment is in the FAQ https://github.com/httpwg/http-extensions/blob/master/draft-ietf-httpbis-digest-headers.md#faq\r\n\r\n> a 200 OK response to a PATCH request would contain the digest of the patched item, and the etag of the new object. This behavior - tighly coupled to the application logic - gives the client low probability of guessing the actual outcome of this operation (eg. concurrent changes, ...)\r\n\r\n@martinthomson the behavior inherited from RFC 3230  with `Range-Requests` and other partial representations is to send the [digest of a complete representation](https://httpwg.org/http-extensions/draft-ietf-httpbis-digest-headers#representation-digest). See:\r\n\r\n- https://github.com/httpwg/http-extensions/blob/master/draft-ietf-httpbis-digest-headers.md#representation-data-is-partially-contained-in-the-payload-ie-range-request\r\n\r\niiuc sending a checksum of a partial representation re-opens the door to the issues \r\nthat lead to the `Content-MD5` deprecation.\r\n\r\n",
          "createdAt": "2019-07-10T12:44:36Z",
          "updatedAt": "2019-07-10T13:01:50Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We need to be clear whether we talk about request or response header fields.",
          "createdAt": "2019-07-10T13:04:05Z",
          "updatedAt": "2019-07-10T13:04:05Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So this kind of came to a standstill. Trying to pick it up, assertions I make are:\r\n\r\n- A request or response can include the Digest header field.\r\n- Such a header refers to the whole representation, even if partial representation is transferred in the message.\r\n- It is not possible to PATCH with a message body that includes part of a patch (because there is no specified way for clients to send partial content).\r\n\r\nWe currently have the following text in the FAQ appendix\r\n\r\n```\r\nHow to use Digest with PATCH method?\r\n\r\nThe PATCH verb brings some complexities (eg. about representation metadata header fields, patch document format, \u2026),\r\n\r\n    PATCH entity-headers apply to the patch document and MUST NOT be applied to the target resource, see [RFC5789], Section 2.\r\n    servers shouldn\u2019t assume PATCH semantics for generic media types like \u201capplication/json\u201d but should instead use a proper content-type, eg [RFC7396]\r\n    a 200 OK response to a PATCH request would contain the digest of the patched item, and the etag of the new object. This behavior - tighly coupled to the application logic - gives the client low probability of guessing the actual outcome of this operation (eg. concurrent changes, \u2026)\r\n```\r\n\r\nThis seems both overly discussive but light on useful information. Therefore I suggest that we scrap the current text in the appendix and possibly add some guidance under a broader \"applicability of digest to request payloads\" section.\r\n\r\n",
          "createdAt": "2019-09-05T14:03:26Z",
          "updatedAt": "2019-09-05T14:03:49Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "### requests\r\n\r\nimho  request Digest, disrespectful of the payload body, should reflect\r\nthe reassembled resource representation, similarly to range-requests.\r\n\r\n### response\r\n\r\nPATCH does not have a well defined semantic like PUT\r\n\r\n> A successful PUT of a given\r\n>   representation would suggest that a subsequent GET on that same\r\n>   target resource will result in an equivalent representation being\r\n>   sent in a 200 (OK) response\r\n\r\nIf it had, I'd suggest that PATCH should return the Digest of the selected representation of the resource independently of the payload body and response status code (eg. 204)\r\n\r\n### problems\r\n\r\nStill, the fact that PATCH's representation metadata are tied to the PATCH and not to the resource,\r\nmake it impossible for the client to select the representation ",
          "createdAt": "2019-09-05T15:46:04Z",
          "updatedAt": "2019-09-05T15:47:54Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No.\r\n\r\nA Digest needs to refer to the payload of the message. If it appears in a request, than it's for the payload of the request.\r\n\r\n\r\n",
          "createdAt": "2019-09-05T16:47:13Z",
          "updatedAt": "2019-09-05T16:47:13Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If it appears in a request, than it's for the payload of the request.\r\n\r\nMy understanding is that's not what RFC3230 says, see the `instance` definition in https://tools.ietf.org/html/rfc3230#section-3.\r\n\r\nWe aim at obsoleting RFC3230 without modifying the semantic: in that sense, I see `PATCH` as an \"instance manipulation\" of the target resource.\r\n\r\n",
          "createdAt": "2019-09-05T17:05:13Z",
          "updatedAt": "2019-09-05T17:07:55Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, can you translate the following text from RFC 3230:\r\n\r\n~~~\r\n   The instance described by a message might be fully contained in the\r\n   message-body, partially-contained in the message-body, or not at all\r\n   contained in the message-body.  The instance is specified by the\r\n   Request-URI and any cache-validator contained in the message.\r\n~~~\r\n\r\ninto something I can understand? What, for instance, refers the Digest request header field in PUT or POST to?",
          "createdAt": "2019-09-05T17:14:45Z",
          "updatedAt": "2019-09-05T17:14:45Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> fully ... partially... not at all contained in the message body\r\n\r\nsee [resource representation](https://httpwg.org/http-extensions/draft-ietf-httpbis-digest-headers.html#resource-representation)\r\n\r\nSee you use [digest to convey the representation-data-digest of the selected representation](https://httpwg.org/http-extensions/draft-ietf-httpbis-digest-headers.html#goals)\r\n\r\n## PUT\r\n\r\n>   PUT, DELETE  a representation of the status of the action;\r\n\r\nso digest is well defined\r\n\r\n### PUT with complete representation\r\n\r\nSee [this example](https://httpwg.org/http-extensions/draft-ietf-httpbis-digest-headers.html#digest-in-both-request-and-response-returned-value-depends-on-representation-metadata)\r\n\r\nyou send a complete representation, and retrieve a complete representation of the resource\r\n\r\n\r\n### PUT without complete representation\r\n\r\nIf PUT returns 204 it may  return a Digest header, provided that the response contains all the required representation metadata.\r\n\r\nSee #926 \r\n\r\n## POST\r\n\r\n>    POST  a representation of the status of, or results obtained from,\r\n      the action;\r\n\r\nWe are not providing examples containing the `result of the action` and we're currently\r\nlimiting to exchanges reflecting the `status of the resource`.\r\n \r\nWe could clarify that in the case of `result of the action`, Digest value applies to the representation-data.",
          "createdAt": "2019-09-06T08:21:33Z",
          "updatedAt": "2019-09-06T11:05:57Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, but you were arguing for compatiblity with the old spec. To get there, I'd like to understand what it actually defines for PUT/POST/PATCH.\r\n\r\nMy theory is that it really does not define that, so we are free to define things properly.",
          "createdAt": "2019-09-06T08:37:05Z",
          "updatedAt": "2019-09-06T08:37:05Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The old spec does not define behaviors for PUT/POST/PATCH.\r\n\r\nI think we should retain the fact that Digest should be independent from \"instance manipulations\" https://tools.ietf.org/html/rfc3230#section-1\r\n\r\nI see PATCHing as an \"instance manipulation\" because we are not conveying the full representation in the request: do you think that's reasonable?\r\n\r\nI will open:\r\n\r\n- a new issue for POST, which is interesting (thanks for pointing it out!)\r\n- a PR for PUT + 204 with an example (your precious feedback is welcome there!!!!)",
          "createdAt": "2019-09-06T08:52:10Z",
          "updatedAt": "2019-09-06T08:52:10Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">I see PATCHing as an \"instance manipulation\" because we are not conveying the full representation in the request: do you think that's reasonable?\r\n\r\nNote. We shouldn't mix up completely separate things:\r\n\r\n- partial responses (206)\r\n- content encoding\r\n- payloads that are used to *modify* the target resource (POST, PATCH...)\r\n\r\nThe latter is at a different layer of abstraction.\r\n\r\nAs @martinthomson said, the Digest header field always should refer to the payload being transmitted (both directions).",
          "createdAt": "2019-09-06T09:03:42Z",
          "updatedAt": "2019-09-06T09:03:42Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> payloads that are used to modify the target resource (POST, PATCH...)\r\n> The latter is at a different layer of abstraction.\r\n\r\n@reschke thousand thanks for your clarification: I tried to address them in #923.",
          "createdAt": "2019-09-06T10:46:14Z",
          "updatedAt": "2019-09-26T10:14:04Z"
        }
      ]
    },
    {
      "number": 854,
      "id": "MDU6SXNzdWU0NjYyMTUwNzI=",
      "title": "Digest should use http-core or rfc 723x?",
      "url": "https://github.com/httpwg/http-extensions/issues/854",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers",
        "editorial"
      ],
      "body": "## Task\r\n\r\nShould we base on 723x or [http-core](https://github.com/httpwg/http-core) ?\r\nAre there changes in http-core that modify or improve Digest definition (eg. terminology, ...)?\r\n\r\n",
      "createdAt": "2019-07-10T09:55:57Z",
      "updatedAt": "2020-04-15T14:30:37Z",
      "closedAt": "2020-04-15T14:30:37Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Depends on publication timing.\r\n\r\nI don't expect -core to change anything that would effect this spec.",
          "createdAt": "2019-07-10T09:57:21Z",
          "updatedAt": "2019-07-10T09:57:21Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "digest references moved to http-core. #1140 ",
          "createdAt": "2020-04-15T14:30:37Z",
          "updatedAt": "2020-04-15T14:30:37Z"
        }
      ]
    },
    {
      "number": 855,
      "id": "MDU6SXNzdWU0NjYyMTU5NTI=",
      "title": "Shall we use sh-binary serialization for `id-sha` digest-algoritms?",
      "url": "https://github.com/httpwg/http-extensions/issues/855",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## Hypothesis\r\nConsidering that:\r\n\r\n1- every digest-algorithm define his own serialization method (eg. you don't need to use just b64)\r\n\r\n2- Structured headers allow to [serialize byte-sequences](https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#binary) like the following:\r\n\r\n```\r\nsh-binary = \"*\" *(base64) \"*\"\r\nbase64    = ALPHA / DIGIT / \"+\" / \"/\" / \"=\"\r\n``` \r\n\r\n3- the newly defined digest-algorithms `id-sha-256` and `id-sha-512` do not have a \r\n    predefined encoding format, so that we can chose which one to use.\r\n\r\nWe could:\r\n\r\n- use for `id-sha-256|512` the `sh-binary` serialization\r\n\r\n## Notes\r\n\r\nPro:\r\n- compatibility with structured headers\r\n\r\nCons:\r\n- syntax will be different from the (previous) sha-xxx",
      "createdAt": "2019-07-10T09:57:44Z",
      "updatedAt": "2020-10-18T13:14:10Z",
      "closedAt": "2019-07-24T16:21:18Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that it would be best to consider digests as octet sequences.  You can encode all sorts of stuff into one of those.",
          "createdAt": "2019-07-10T11:53:35Z",
          "updatedAt": "2019-07-10T11:53:35Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure that answers @ioggstream original question as intended. If we rephrase the question to be:\r\n\r\nSpec says \"The encoded digest output uses the encoding format defined for the specific digest-algorithm.\". Presently, SHA based algorithms encode using base64 and Unixsum uses ASCII decimal-digit string. `id-sha-256` and `id-sha-512` are new digest-algorithms added in this update but presently have no defined encoding format; should they also be base64 encoded or something else?\r\n\r\n@martinthomson are you suggesting that the encoding format be octects?",
          "createdAt": "2019-07-10T12:45:45Z",
          "updatedAt": "2019-07-10T12:45:45Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, in that every digest algorithm produce a single output that is a sequence of octets and that the new SH be used to encode that.  I know that this doesn't fit with existing code, but you could carve out exceptions for legacy identifiers (and then discourage their use).",
          "createdAt": "2019-07-10T13:29:37Z",
          "updatedAt": "2019-07-10T13:29:37Z"
        },
        {
          "author": "dlongley",
          "authorAssociation": "NONE",
          "body": "It would be great to consider [Multibase](https://tools.ietf.org/html/draft-multiformats-multibase-01) (see also: https://github.com/multiformats/multibase, https://tools.ietf.org/html/draft-multiformats-multihash-00) to solve this problem for current and future algorithms.",
          "createdAt": "2019-07-10T14:08:11Z",
          "updatedAt": "2019-07-10T14:09:28Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My inner pragmatist leans toward simply using base64 encoded for id-sha-256|512. This is partly driven by the possibility of endpoints generating digests `id-sha-256` and `sha-256` with associated `content-encoding: identity`. Having different encoding formats for effectively the same thing seems weird.",
          "createdAt": "2019-07-10T14:27:46Z",
          "updatedAt": "2019-07-10T14:27:46Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@dlongley I will propose a PR to multibase so that it will add an algorithm to the iana digest-algorithm table \r\n\r\nIn this way as soon as multihash becomes an RFC multihash will be supported for digest.\r\n\r\nJust give me some days to write it (I'm at europython until Sunday)",
          "createdAt": "2019-07-10T14:31:53Z",
          "updatedAt": "2019-07-10T14:31:53Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Extensibility options are interesting, thanks for sharing @dlongley.  The way digest algorithm currently works for encoding is clunky with each algorithm defining their base-encoding format but it sort of skirts the issue that Multibase appears to solve.\r\n\r\nI think the extensibility story is more interesting where a future multihash digest algorithm specifies the multibase encoding. That gives people a choice of using a more flexible tool in future, or falling back to the explicit clunkiness we have today.\r\n",
          "createdAt": "2019-07-10T14:38:58Z",
          "updatedAt": "2019-07-10T14:38:58Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Having different encoding formats for effectively the same thing seems weird.\r\n\r\nLucas is definitely right. I'm closing this, while we should write something in the algorithm-agility section.\r\n\r\n",
          "createdAt": "2019-07-24T16:21:18Z",
          "updatedAt": "2020-10-18T13:14:10Z"
        }
      ]
    },
    {
      "number": 867,
      "id": "MDU6SXNzdWU0NzEyOTIzNjg=",
      "title": "Should the obsolescence of MD5 be stronger?",
      "url": "https://github.com/httpwg/http-extensions/issues/867",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "While it is great that SHA-1 and MD5 are being obsoleted, there are cases in which MD5 is a MUST NOT (and SHA-1 is on track to that, but not there yet). For example, IPsec marks it a MUST NOT: https://tools.ietf.org/html/rfc8221#section-6.\r\n\r\nIf the state of things is such that we can't reasonably say MUST NOT, can we have text that gives indication of the future of this algorithm's usage?",
      "createdAt": "2019-07-22T20:00:04Z",
      "updatedAt": "2019-07-26T14:57:00Z",
      "closedAt": "2019-07-26T14:57:00Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ioggstream from your experience in actual digest usage would strong obsolescence \r\ncause issues?",
          "createdAt": "2019-07-22T21:15:21Z",
          "updatedAt": "2019-07-22T21:15:21Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The original discussion was something like:\r\n\r\n- MUST NOT in signatures;\r\n- NOT RECOMMENDED on the rest, so we retain backward compatibility.\r\n  It's fine to me to MUST NOT, providing a suitable way to report it in the iana table.\r\n\r\n",
          "createdAt": "2019-07-22T21:19:38Z",
          "updatedAt": "2019-07-22T21:19:38Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As another datapoint, RFC 8221 also says:\r\n\r\n> It is expected that deprecation of an algorithm be performed\r\n   gradually.  This provides time for various implementations to update\r\n   their implemented algorithms while remaining interoperable.  Unless\r\n   there are strong security reasons, an algorithm is expected to be\r\n   downgraded from MUST to MUST- or SHOULD, instead of MUST NOT (see\r\n   Section 2).  Similarly, an algorithm that has not been mentioned as\r\n   mandatory-to-implement is expected to be introduced with a SHOULD\r\n   instead of a MUST.\r\n\r\nI don't believe our intention is to make the Digest header document something that is continually updated. There a gradual approach may not be suited to our goals.",
          "createdAt": "2019-07-22T21:23:39Z",
          "updatedAt": "2019-07-22T21:23:39Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If there's consensus on `MUST NOT`, I'd go for it. \r\nWe could use RFC8221 as a reference.",
          "createdAt": "2019-07-24T15:18:15Z",
          "updatedAt": "2019-07-24T15:18:15Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, at IETF 105 \"[Deprecating MD5 and SHA-1 signature hashes in TLS 1.2](https://datatracker.ietf.org/doc/draft-lvelvindron-tls-md5-sha1-deprecate/)\" was adopted by the TLS working group. \r\n\r\nGiven the general community direction, I think a stronger MUST NOT is acceptable.",
          "createdAt": "2019-07-24T15:28:29Z",
          "updatedAt": "2019-07-24T15:28:29Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok. Here is for completeness the original thread https://github.com/ioggstream/draft-polli-resource-digests-http/issues/16",
          "createdAt": "2019-07-24T15:59:31Z",
          "updatedAt": "2019-07-24T15:59:31Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do we want to \"MUST NOT\" even sha-1 ?",
          "createdAt": "2019-07-24T15:59:55Z",
          "updatedAt": "2019-07-24T15:59:55Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Preliminary patch here. #875  @tfpauly does this address your comment?",
          "createdAt": "2019-07-24T16:11:32Z",
          "updatedAt": "2019-07-24T16:12:20Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ioggstream Yes, that looks great! \r\n\r\nTo your other question, my impression is that deprecating SHA-1 is probably less advisable at this point, but if someone has further information, I'd love to hear it.",
          "createdAt": "2019-07-24T19:08:06Z",
          "updatedAt": "2019-07-24T19:08:06Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed via #875 ",
          "createdAt": "2019-07-26T14:57:00Z",
          "updatedAt": "2019-07-26T14:57:00Z"
        }
      ]
    },
    {
      "number": 868,
      "id": "MDU6SXNzdWU0NzEyOTM1ODM=",
      "title": "Relationship to SRI",
      "url": "https://github.com/httpwg/http-extensions/issues/868",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "It would be awesome if this could relate directly to [SRI](https://w3c.github.io/webappsec-subresource-integrity/).  Ideally, if SRI uses the same hash function, the value in the `Digest` header field is the same.",
      "createdAt": "2019-07-22T20:01:56Z",
      "updatedAt": "2020-01-18T15:57:57Z",
      "closedAt": "2020-01-18T15:57:57Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1, seems sensible to address this explicitly and help out implementers.",
          "createdAt": "2019-07-22T21:07:47Z",
          "updatedAt": "2019-07-22T21:07:47Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson what do you think of the following?\r\nWe could define a new `digest-algorithm` named `sri`, which inherits the `sri` serialization,\r\neg.\r\n\r\n```\r\n<script src=\"https://example.com/example-framework.js\"\r\n        integrity=\"sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC\"\r\n        crossorigin=\"anonymous\"></script>\r\n```\r\n\r\ncould have it's related\r\n\r\n```\r\nGET /example-framework.js\r\n\r\nHTTP/1.1 200 OK\r\nDigest: sri=sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC\r\n\r\n...whatever.js...\r\n\r\n```\r\n",
          "createdAt": "2019-07-23T13:09:04Z",
          "updatedAt": "2019-07-23T13:09:04Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think that would be a great outcome.  The idea is to have the oq... be generated the same way.\r\n\r\n(For my benefit, because SRI and the whole \"representation data\" doesn't explicitly range requests or content codings, what is the state of play there?)",
          "createdAt": "2019-07-29T02:08:33Z",
          "updatedAt": "2019-07-29T02:08:33Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson can you make an example of the expected request/response?\r\n\r\nAbout encoding, probably in Sri case we should use an id-sha-384 to.cover the actual unencoded representation.\r\n\r\n",
          "createdAt": "2019-07-30T11:28:48Z",
          "updatedAt": "2019-07-30T11:28:48Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From the SRI spec Section 3.4.5, Example 8 is a bit worrisome https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\r\n\r\n```\r\nThis algorithm allows the user agent to accept multiple, valid strong hash functions. \r\nFor example, a developer might write a script element such as:\r\n\r\n<script src=\"https://example.com/example-framework.js\"\r\n        integrity=\"sha384-Li9vy3DqF8tnTXuiaAJuML3ky+er10rcgNR/VqsVpcw+ThHmYcwiB1pbOxEbzJr7\r\n                   sha384-+/M6kredJcxdsqkczBUjMLvqyHb1K/JThDXWsBVxMEeZHEaMKEOEct339VItX1zB\"\r\n        crossorigin=\"anonymous\"></script>\r\n\r\nwhich would allow the user agent to accept two different content payloads, \r\none of which matches the first SHA384 hash value and the other matches the second SHA384 hash value.\r\n````\r\n\r\nSRI hashes are always calculated on the identity encoding, so AFAICT this example demonstrates an ability to hash two different representations and serve them. The Digest header doesn't quite work the same way.",
          "createdAt": "2019-07-30T12:42:53Z",
          "updatedAt": "2019-07-30T12:42:53Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding SRI and range requests, there is an open issue / feature request: https://github.com/w3c/webappsec-subresource-integrity/issues/57",
          "createdAt": "2019-07-30T12:43:40Z",
          "updatedAt": "2019-07-30T12:43:40Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I took some time to read https://w3c.github.io/webappsec-subresource-integrity/ \r\nand think about this.\r\n\r\n## My position:\r\n\r\n- our goal for this spec is to \"fix\" the inconsistencies related to representation manipulations and content-encoding;\r\n- I'd avoid to entangle Digest to a complex spec like SRI.\r\n\r\nThis could be done:\r\n\r\n- in a non-normative appendix;\r\n- in another spec;\r\n\r\n\r\n## SRI Complexities\r\n\r\n### [algorithm agility](https://w3c.github.io/webappsec-subresource-integrity/#agility) \r\n\r\n>  the user agent will choose the strongest hash function in the list, \r\n>  via the https://w3c.github.io/webappsec-subresource-integrity/#getprioritizedhashfunction\r\n\r\nThis would be a breaking change in `Digest`, though we could suggest that `the receiver SHOULD use the strongest digest-algorithm`.\r\n\r\n\r\n### [Multiple payloads](https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist)\r\n\r\nThe example posted by @LPardue will not be supported by Digest but:\r\n\r\n- iiuc when the resource will be fetched, only one `Digest` value will be used\r\n\r\n### SRI digest \r\n\r\n> digest https://w3c.github.io/webappsec-subresource-integrity/#digest\r\n\r\nThis seems incidentally compatible with the `digest-algorithm` encoding defined for `id-sha-256` and `id-sha-512`. The only missing digest-algorithm respect to SRI is `id-sha-384`.\r\n\r\nBeware that this incidentality is not guaranteed to persist in future SRI implementation. At maximum we could state in an appendix or faq that `id-sha-*` is compatible with `sha*` from [REC-SRI-20160623](https://www.w3.org/TR/2016/REC-SRI-20160623/)\r\n\r\n",
          "createdAt": "2019-08-09T10:28:42Z",
          "updatedAt": "2019-08-09T10:28:42Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ioggstream said:\r\n\r\n> This seems incidentally compatible with the digest-algorithm encoding defined for id-sha-256 and id-sha-512. The only missing digest-algorithm respect to SRI is id-sha-384.\r\n\r\n> Beware that this incidentality is not guaranteed to persist in future SRI implementation. At maximum we could state in an appendix or faq that id-sha-* is compatible with sha* from REC-SRI-20160623\r\n\r\nI don't think we can attempt to draw any lines between SRI and identity encoding due to [SRI Section 3.3](https://www.w3.org/TR/2016/REC-SRI-20160623/#apply-algorithm-to-response)\r\n\r\n> 3.3 Response verification algorithms\r\n> 3.3.1 Apply algorithm to response\r\n\r\n>    Let result be the result of applying algorithm to the representation data without any content-codings applied, except when the user agent intends to consume the content with content-encodings applied. In the latter case, let result be the result of applying algorithm to the representation data.",
          "createdAt": "2019-09-05T14:56:47Z",
          "updatedAt": "2019-09-05T14:56:47Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So up-levelling a bit here. \r\n\r\nBoth Digest and SRI have what appears to be a similar goal but different implmentation characteristics. So perhaps it could help to capture this e.g. how does an implementer pick one, or how does it rationalise things if it chooses to use both. To @ioggstream point about where to do this, I think this it is probably best suited as a section in each document; however, they should acknowledge that neither requires the other.\r\n\r\nSRI\r\n> This specification defines a mechanism by which user agents may verify that a fetched resource has been delivered without unexpected manipulation.\r\n\r\nDigest\r\n> This document defines the Digest and Want-Digest header fields for HTTP, thus allowing client and server to negotiate an integrity checksum of the exchanged resource representation data.\r\n\r\nBy my reading SRI is more concerned with the integrity of resources delivered from a third party.  It allows the first-party to set client integrity expectations of a separately transferred resource; the expected digest is sent in one message (inside the message payload) and independently the resource is received in a different message. In effect, a client that reads SRI sets expectations on itself, with possibly some belief that the first party is more trustworthy than the third party. But of course, SRI can be used to load from first or third party.\r\n\r\nIn contrast, Digest is coupled to the message related to its representation. The sender informs the receiver of its integrity expectations i.e. \"As best I can tell, this representation should have this hash\". By combining Digest with Signature this can sort of be turned into \"The signature party thinks the representation should have this hash\".\r\n\r\nBecause SRI is carried in message payload, Digest can be used to protect the integrity of the integrity-check.\r\n\r\nI think the correct way to square the circle of relationship between the two is to say that endpoints that implement these features should apply their requirements. And that when both SRI and Digest are supported, it makes sense to check Digest first. Why? Because digest can protect the transfer of a representation over multiple ranges, different paths and different content-encodings. Only after an endpoint has assurance that the composed representation has integrity within it's own self-defined terms should it then apply the integrity expectations set by a separate SRI party.\r\n\r\nThis means that Digest checks could pass but SRI could fail. I think that's fine. \r\n\r\n\r\n",
          "createdAt": "2019-09-05T14:57:03Z",
          "updatedAt": "2019-09-05T14:57:03Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson reopening for clarity, as this was accidentally closed via the #971 PR\r\n\r\nFeel free to close it #971 fixes for you.",
          "createdAt": "2019-11-04T12:36:01Z",
          "updatedAt": "2019-11-04T12:36:24Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm closing this due to inactivity and the fact that PR has landed that addresses the initial issue. If there are changes or additions to the current document, lets open new more specific issues.",
          "createdAt": "2020-01-18T15:57:57Z",
          "updatedAt": "2020-01-18T15:57:57Z"
        }
      ]
    },
    {
      "number": 869,
      "id": "MDU6SXNzdWU0NzEzMjY2NzM=",
      "title": "Disentangle the DNS Check argument",
      "url": "https://github.com/httpwg/http-extensions/issues/869",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "Add text noting the DNS check / not-check guidance in RFCs 7540 and 8336, respectively.  Explicitly side-step the issue by saying that if you would do a DNS lookup for a hostname in the primary cert, you MUST do the DNS check for a hostname in a secondary cert as well; if you would omit the DNS lookup for a hostname in the primary cert, you MAY omit the DNS check for a hostname in the secondary cert as well.",
      "createdAt": "2019-07-22T20:52:20Z",
      "updatedAt": "2020-04-14T19:08:06Z",
      "closedAt": "2020-04-14T19:08:06Z",
      "comments": []
    },
    {
      "number": 870,
      "id": "MDU6SXNzdWU0NzEzMzExMDc=",
      "title": "Privacy considerations for client-requested server certificates",
      "url": "https://github.com/httpwg/http-extensions/issues/870",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "If a malicious server claims support for a variety of common hostnames for which it doesn't actually possess certificates, browser clients with a long-lived connection to the attacker will probe for certificates when the user attempts to access those sites.  This allows the server to monitor user behavior during the lifetime of the connection, even without valid certificates.\r\n\r\nOne obvious strategy is to probe everything \"interesting\" ASAP after the ORIGIN frame, but that obviously leaks what the client considers interesting, which is its own privacy leak.\r\n\r\nNote that a DNS lookup of claimed hostnames prior to requesting the cert prevents this attack.  Should probably recommend that clients which omit the DNS lookup never solicit secondary server certificates, but probably don't need to mandate anything.",
      "createdAt": "2019-07-22T20:59:08Z",
      "updatedAt": "2020-04-14T19:09:06Z",
      "closedAt": "2020-04-14T19:09:06Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In addition to monitoring user behavior, depending on client behavior (do you race two connections? fallback on error?), the malicious server could also deny access to other hostname or degrade performance.",
          "createdAt": "2019-07-22T21:07:11Z",
          "updatedAt": "2019-07-22T21:07:11Z"
        }
      ]
    },
    {
      "number": 871,
      "id": "MDU6SXNzdWU0NzEzNTA4OTU=",
      "title": "Enable Client Hints on first navigation request through HTTPSSVC",
      "url": "https://github.com/httpwg/http-extensions/issues/871",
      "state": "CLOSED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Client Hints adoption have suffered from their absence in the very-first navigational requests, which prevents origins from adapting navigational (e.g. HTML) responses. the HTTPSSVC proposal gives us an opportunity to push the server opt-in earlier, and make sure the opt-in is available by the time the very first request to the origin is sent.",
      "createdAt": "2019-07-22T21:41:32Z",
      "updatedAt": "2020-01-07T10:18:35Z",
      "closedAt": "2020-01-07T10:18:35Z",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While the first navigation case is still important, I was [convinced](https://github.com/httpwg/http-extensions/pull/866#issuecomment-515068660) that HTTPSSVC may not be the right path forward. Closing.",
          "createdAt": "2020-01-07T10:18:35Z",
          "updatedAt": "2020-01-07T10:18:35Z"
        }
      ]
    },
    {
      "number": 872,
      "id": "MDU6SXNzdWU0NzE2NjY1ODQ=",
      "title": "Use cases for Digest",
      "url": "https://github.com/httpwg/http-extensions/issues/872",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nMore descriptive Digest use-cases.\r\n\r\n## Note\r\n\r\nDigest is used:\r\n\r\n- [x] Digest is usually combined with some mechanism to protect HTTP metadata. \r\nThis allows for L7 protections that transcend transport. See [draft-ietf-httpbis-digest-headers.md#L129](https://github.com/httpwg/http-extensions/blame/master/draft-ietf-httpbis-digest-headers.md#L129)\r\n\r\n- [x] you could compose a resource from partial content \r\n   retrieved from different sources and validate \r\n  the resource's integrity before passing it to\r\n  application for processing. See [draft-ietf-httpbis-digest-headers.md#L686](https://github.com/httpwg/http-extensions/blame/master/draft-ietf-httpbis-digest-headers.md#L686)\r\n\r\n- [ ] in web payments APIs, including EU PSD2 directive via [http-signatures](https://tools.ietf.org/html/draft-cavage-http-signatures-11)\r\n- [x] in MICE content-coding;\r\n- [ ] in [webpackage](https://github.com/WICG/webpackage) (via MICE)\r\n\r\n## Questions\r\n\r\n- We can highlight more the concept of \"Digest as a Signature building block\" in the use-cases\r\n- Should we reference other I-D like http-signatures (now under http-extension), MICE and webpackage in the spec\r\n  to clarify use cases?\r\n\r\n@jyasskin @royfielding issue reopened here from https://github.com/ioggstream/draft-polli-resource-digests-http/issues/15",
      "createdAt": "2019-07-23T12:25:15Z",
      "updatedAt": "2020-08-17T11:20:04Z",
      "closedAt": "2020-08-17T11:20:04Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We've made progress on this. My fear is that mention of other WIP specs like packaging and could tie us up. Therefore, I suggest spinning out the two remaining use cases into separate issues and asking the WG for feedback if we should work on them.",
          "createdAt": "2020-08-13T13:22:56Z",
          "updatedAt": "2020-08-13T13:22:56Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "imho the current setup is fine and we can close this issue without further actions.\r\nThe current reference to MICE algorithm is informative and is related to Trailers.",
          "createdAt": "2020-08-17T11:20:04Z",
          "updatedAt": "2020-08-17T11:20:04Z"
        }
      ]
    },
    {
      "number": 874,
      "id": "MDU6SXNzdWU0NzIzMTYyMjI=",
      "title": "Request `Digest` validation",
      "url": "https://github.com/httpwg/http-extensions/issues/874",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## Considering that\r\n\r\n- Digest specs allows the receiver to skip digest validation\r\n\r\n## We could\r\n\r\n- Provide some method to mandate digest validation. Clearly the receiver may cheat :P \r\n\r\nA discussion on the subject happened here:\r\n\r\nhttps://github.com/fcrepo/fcrepo-specification/issues/373#issuecomment-391833541",
      "createdAt": "2019-07-24T14:28:32Z",
      "updatedAt": "2019-07-26T14:57:52Z",
      "closedAt": "2019-07-26T14:57:51Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for sharing. I only skimmed the thread but my initial opinion is that we want to define this as out of scope for the Digest refactor, but ensure that we don't prevent other from supporting their use case with some other proposal in a separate doc.",
          "createdAt": "2019-07-24T14:38:16Z",
          "updatedAt": "2019-07-24T14:38:16Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree.",
          "createdAt": "2019-07-26T14:57:51Z",
          "updatedAt": "2019-07-26T14:57:51Z"
        }
      ]
    },
    {
      "number": 880,
      "id": "MDU6SXNzdWU0NzQ0NDkwNTQ=",
      "title": "Examples for id-sha-256 and id-sha-512",
      "url": "https://github.com/httpwg/http-extensions/issues/880",
      "state": "CLOSED",
      "author": "manger",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "draft-ietf-httpbis-digest-headers includes examples of sha-256 in the Digest header value, but no examples of the two new algorithms it introduces: id-sha-256 and id-sha-512.\r\n\r\nExamples would be extremely useful to illustrate the difference between sha-256 and id-sha-256.",
      "createdAt": "2019-07-30T08:35:12Z",
      "updatedAt": "2019-08-09T09:33:22Z",
      "closedAt": "2019-08-09T09:33:22Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That sounds reasonable to me.",
          "createdAt": "2019-07-30T10:28:48Z",
          "updatedAt": "2019-07-30T10:28:48Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@manger WDYT? #883 ",
          "createdAt": "2019-07-31T11:37:09Z",
          "updatedAt": "2019-07-31T11:37:09Z"
        }
      ]
    },
    {
      "number": 881,
      "id": "MDU6SXNzdWU0NzQ1MDYyMTQ=",
      "title": "Digest headers example 7.1.4 is wrong",
      "url": "https://github.com/httpwg/http-extensions/issues/881",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "I think the digest for the response is incorrect because the encoding is br but the digest is the same as other examples with identity encoding.\r\n\r\n```\r\nResponse:\r\n\r\n  Content-Type: application/json\r\n  Content-Encoding: br\r\n  Digest: sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=\r\n\r\n  iwiAeyJoZWxsbyI6ICJ3b3JsZCJ9Aw==\r\n```",
      "createdAt": "2019-07-30T10:33:44Z",
      "updatedAt": "2019-07-31T13:07:42Z",
      "closedAt": "2019-07-31T11:10:32Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for fixing this. In future could we wait on peer review of the PR before merging it? I appreciate that in this case the change was small but longer term I'd like to avoid missing changes and getting issues closed when I might not be paying as close attention.",
          "createdAt": "2019-07-31T12:05:24Z",
          "updatedAt": "2019-07-31T12:05:24Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure, you're right!",
          "createdAt": "2019-07-31T13:07:42Z",
          "updatedAt": "2019-07-31T13:07:42Z"
        }
      ]
    },
    {
      "number": 884,
      "id": "MDU6SXNzdWU0NzUyMzk2Mzg=",
      "title": "Mention effects of transfer coding and HTTP trailers",
      "url": "https://github.com/httpwg/http-extensions/issues/884",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## Suggestion\r\n\r\nMention `digest` usage with `Transfer-Encoding` and trailers\r\n\r\n * [x] use with transfer coding should not affect `digest` because transfer coding is not a property of the representation;\r\n * [ ] use with multiple transfer codings (eg with intermediaries?) should not affect `digest` too; (see above)\r\n * [x] caveats with transfer codings, trailers #884  and signatures (this may be addressed in digest+signatures BCP);\r\n\r\n\r\n## Considerations\r\n\r\n- [x] sending `digest` in HTTP trailers may help the sender in dinamically calculating `digest-value`\r\n  while streaming content; #1157 \r\n- this only work if it's the Origin-Server to apply the `Transfer-Coding`;\r\n- [x] this may not work for all  `digest-algorithms`, eg. see [mi-sha256 in MICE I-D](https://github.com/martinthomson/http-mice/blob/master/draft-thomson-http-mice.md) for a counter-example); @martinthomson @jyasskin  #1157 \r\n- a clarification on using `Digest` with `Transfer-Encoding` should be added before adding this;\r\n- [x] Digest in trailer MUST NOT be discarded #1157\r\n\r\n## Notes\r\n\r\n- Suggested in https://lists.w3.org/Archives/Public/ietf-http-wg/2019JulSep/0087.html\r\n- being transfer coding a representation manipulation assimilated in this spec to range-requests  co, we provided the following examples #884 \r\n\r\n",
      "createdAt": "2019-07-31T16:22:04Z",
      "updatedAt": "2020-08-18T09:08:45Z",
      "closedAt": "2020-08-18T09:08:45Z",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "### Example: http/2 trailers\r\n\r\nTransfer-Encoding is not a property of the representation, so `digest` value is not affected.\r\nThe following example uses http/2: is that useful? Should we only use HTTP/1.1?\r\n\r\n```\r\nRequest:\r\n\r\n :method = GET\r\n :scheme = https\r\n :path = /resource\r\n CONTINUATION\r\n te: trailers\r\n want-digest: sha-256\r\n\r\nResponse:\r\n\r\n  :status =200\r\n  CONTINUATION\r\n  trailer: digest\r\n  DATA\r\n  {\"hello\": \"world\"}\r\n  HEADERS\r\n  digest: sha-256=fafafa...\r\n\r\n```\r\n\r\n\r\n### Example with transfer-Encoding\r\n\r\nAn Origin Server sends the digest in the HTTP trailer, so it can calculate `digest-value` \r\nwhile streaming content and thus mitigate resource consumption. See https://tools.ietf.org/html/rfc7230#section-4.4\r\n\r\n```\r\nRequest:\r\n\r\nGET /resource HTTP/1.1 \r\n\r\nResponse:\r\n\r\nHTTP/1.1 200 OK\r\nTransfer-Encoding: chunked\r\nContent-Type: text/plain\r\nTrailer: digest\r\n\r\n4\\r\\n\r\nWiki\\r\\n\r\n5\\r\\n\r\npedia\\r\\n\r\n0\\r\\n\r\ndigest: sha-256=04s4ot1HbgRcKZ6O5dZGaDRFbZe9WSpxdGtCOmoF84Y=\r\n```\r\n",
          "createdAt": "2019-07-31T16:35:38Z",
          "updatedAt": "2019-07-31T16:53:57Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "When thinking about sending the digest in trailers, look at which use cases from #872 can actually take advantage of that.",
          "createdAt": "2019-07-31T18:42:22Z",
          "updatedAt": "2019-07-31T18:42:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What work is remaining to close out this issue?",
          "createdAt": "2020-08-13T13:24:41Z",
          "updatedAt": "2020-08-13T13:24:41Z"
        }
      ]
    },
    {
      "number": 885,
      "id": "MDU6SXNzdWU0NzU0NDgxMjM=",
      "title": "Define id- as a prefix for any Digest alg, not just id-sha-256 and id-sha-512",
      "url": "https://github.com/httpwg/http-extensions/issues/885",
      "state": "OPEN",
      "author": "manger",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "draft-ietf-httpbis-digest-headers introduces id-sha-256 as a separate algorithm to sha-256 for the Digest HTTP header to allow an integrity check that doesn't depend on the content-encoding.\r\n\r\nThe desire to apply integrity to the content-encoded representation, or the decoded representation, is independent of the choice of integrity algorithm.\r\n\r\nHow about defining \"id-\" as a prefix that can be applied to any integrity algorithm to indicate the choice of representation? That avoids the need to duplicate sha-256 and sha-512 entries (and others) in the table of Digest algorithms.",
      "createdAt": "2019-08-01T03:12:56Z",
      "updatedAt": "2020-10-18T18:45:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See also https://www.iana.org/assignments/hash-function-text-names/hash-function-text-names.xhtml",
          "createdAt": "2019-08-01T03:14:43Z",
          "updatedAt": "2019-08-01T03:14:43Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@manger \r\n\r\n> How about defining \"id-\" as a prefix that can be applied to any integrity algorithm\r\nThat was the original idea, though it come with some complexities, eg registering all possible\r\nvalues to the IANA table.\r\n\r\n@martinthomson can we provide a new, short, separate, I-D defining the `id-` prefix for digest-algoritms? The same I-D could be used to add other hash functions (eg, sha-384) to the IANA table.\r\n\r\nI can provide it in a brief time if there's agreement on that.\r\n\r\nSee https://github.com/martinthomson/http-mice/issues/17 that's somewhat related.",
          "createdAt": "2019-08-01T08:05:23Z",
          "updatedAt": "2019-08-01T08:08:59Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let's add it in a FAQ and close this",
          "createdAt": "2020-04-30T11:24:59Z",
          "updatedAt": "2020-04-30T11:24:59Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue should we file a new I-D for that and close this issue? Should we reserve the `id-` word for algorithms?",
          "createdAt": "2020-08-17T11:17:23Z",
          "updatedAt": "2020-08-17T11:17:23Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There's two things at play in my mind:\r\n\r\n1) I think I originally misread @manger's point. I'm coming to a position that thinks it is more logically pure to do it the way he has suggested.\r\n2) We use `id-sha-{256|512}` as a device to help explain some of the thornier parts of using digest.\r\n\r\nPoint 2 is important not to lose IMO.\r\n\r\nMy suggested course of action is to keep this issue open for the time being, @ioggstream to lead on putting together an independent Internet-Draft that describes \"id- prefix for digest algorithms\", and @ioggstream to lead on a WIP PR to replace the definition of `id-sha-` algorithms in digest with cross references to the new I-D. This would give us a good picture of the impact of change, which we can then take to the WG for feedback. Subject to that, we can then resolve this issue with the new text or close with no action.\r\n\r\n\r\n",
          "createdAt": "2020-08-18T10:06:42Z",
          "updatedAt": "2020-08-18T10:06:42Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll accept your suggestion to check the impacts. \r\n\r\nIn general:\r\n\r\n1- ok to a new I-D \"id- prefix for digest algorithms\"\r\n2- I will retain `id-sha` in Digest without references to other I-D\r\n3- we could reserve the `id-` prefix for Digest algorithms in this I-D so we can close this issue\r\n\r\n",
          "createdAt": "2020-08-18T11:45:24Z",
          "updatedAt": "2020-08-18T11:45:24Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"id-\" prefix for digest-algorithms:\r\n\r\n- https://datatracker.ietf.org/doc/draft-polli-id-digest-algorithms/\r\n- https://github.com/ioggstream/draft-polli-id-digest-algorithms \r\n\r\nIMHO id-sha-256 and id-sha-512 are one selling point for this I-D, as they give the opportunity to implementors to avoid the fallacies of their current implementations (that is, they always send the sha-256 of the unencoded body even when Content-Encoding != null) \r\n\r\n@LPardue @manger can we close now?",
          "createdAt": "2020-09-08T14:24:01Z",
          "updatedAt": "2020-09-08T16:11:25Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for doing the work and sorry for the delay. I suspect that given how concise the I-D turned out being, we could incorporate some of that text back into digest without much impact. \r\n\r\nWe should ask the WG whether they think the ability to have `id-` prefix would be useful, or if we can just continue with the draft as is.",
          "createdAt": "2020-10-18T18:04:59Z",
          "updatedAt": "2020-10-18T18:04:59Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Both solutions are good. The only issue I see is for checksum algorithms starting with `id-` :)\r\n",
          "createdAt": "2020-10-18T18:45:04Z",
          "updatedAt": "2020-10-18T18:45:04Z"
        }
      ]
    },
    {
      "number": 886,
      "id": "MDU6SXNzdWU0NzU1NTk2MjI=",
      "title": "Change digest-headers title.",
      "url": "https://github.com/httpwg/http-extensions/issues/886",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers",
        "editorial"
      ],
      "body": "## Question\r\n\r\nWe can consider to change the `title: Resource Digests for HTTP` to the more\r\ndirect `title: Digest Headers`.\r\n",
      "createdAt": "2019-08-01T08:57:24Z",
      "updatedAt": "2019-08-18T08:46:24Z",
      "closedAt": "2019-08-18T08:46:24Z",
      "comments": []
    },
    {
      "number": 889,
      "id": "MDU6SXNzdWU0Nzg3MTQ2MTI=",
      "title": "SameSite cookies: Cross-site top-level navigation followed by redirect back to the first party",
      "url": "https://github.com/httpwg/http-extensions/issues/889",
      "state": "OPEN",
      "author": "chlily1",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis",
        "samesite"
      ],
      "body": "(Notation: => is a navigation, -> is a redirect, \"A\" is the first party site which has SameSite cookies set on it.)\r\n\r\nCurrently, top-level A=>B->A results in sending both Strict and Lax cookies on the redirect back to A, as reflected in this WPT testcase: https://github.com/web-platform-tests/wpt/blob/master/cookies/samesite/form-get-blank.html#L58\r\n\r\nThis should ideally send Lax (but not Strict) cookies, because the analogous top-level navigation scenario A=>B=>A would result in sending only Lax but not Strict cookies to A on the last navigation.",
      "createdAt": "2019-08-08T22:26:16Z",
      "updatedAt": "2020-07-27T15:14:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kiding",
          "authorAssociation": "NONE",
          "body": "I'd like to weigh in on resolving this issue since the browser implementations have diverged. \r\n\r\nFollowing the A=>B->A example, the Chrome/Chromium test cases (implemented by @chlily1, exported to web-platform-tests) assume both A's are \"strictly same-site.\" (See [`wpt@2379191`](https://github.com/web-platform-tests/wpt/blob/2379191282384315dfa83973551badbc997ce683/cookies/samesite/form-get-blank.https.html#L58))\r\n\r\nOn the Safari/WebKit side, the test cases assume both A's are _not strict_. (See [`webkit@d615092`](https://github.com/WebKit/webkit/blob/d61509279f6864b7c81e2219f87c3d1130549c32/LayoutTests/http/tests/cookies/same-site/fetch-after-top-level-cross-origin-redirect-expected.txt#L7)) This behavior (which I personally prefer) is consistent with the A=>B=>A scenario. Firefox/Gecko behaves like WebKit. (See [`gecko-dev@15cc802`](https://github.com/mozilla/gecko-dev/blob/15cc8023f7861e4bb56cd43f179d5c45937d7c19/dom/security/test/general/test_same_site_cookies_redirect.html#L38-L43)) There even is a 2-year-old [bug 1456408](https://bugzilla.mozilla.org/show_bug.cgi?id=1456408) that's basically the same as this issue.\r\n\r\nFYI, A simple demo page to test with is available at https://brass-tremendous-marmoset.glitch.me.",
          "createdAt": "2020-07-27T15:14:38Z",
          "updatedAt": "2020-07-27T15:14:38Z"
        }
      ]
    },
    {
      "number": 894,
      "id": "MDU6SXNzdWU0ODIzMjU3MjU=",
      "title": "Question: distinction between sending and receiving weak digests",
      "url": "https://github.com/httpwg/http-extensions/issues/894",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## Question\r\n\r\nFrom @paulmillar\r\n\r\nPerhaps there is a useful distinction between generating a digest and accepting a digest; e.g., an agent MAY support generating a weak digest but SHOULD NOT accept a weak digest.\r\n\r\n",
      "createdAt": "2019-08-19T13:52:34Z",
      "updatedAt": "2019-11-25T11:30:32Z",
      "closedAt": "2019-11-25T11:30:32Z",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  Perhaps there is a useful distinction between generating a digest and accepting a digest\r\n\r\nI think that some real-life use-cases for that could be useful to get a better insight of the problem.\r\n\r\nMy understanding is that - while the spec allows the receiver to ignore the `digest` - the general use case expect that the recipient  validates it.\r\n\r\n> an agent MAY support generating a weak digest but SHOULD NOT accept a weak digest.\r\n\r\nThis introduces an asymmetry between sender and recipient. To be \"liberal in what you send\" exposes  the sender to the following behaviors:\r\n\r\n* if the recipient is a server:\r\n\r\n1- ignore validation or\r\n2- reply with eg. a `400` + `Want-Digest`\r\n\r\n* if the recipient is a client that does not send a `Want-Digest`:\r\n\r\n1- you will never know, maybe the client will re-issue the request\r\n\r\n\r\nDoes this sound reasonable to you? Thanks for your time, as this discussion is interesting.\r\n",
          "createdAt": "2019-08-19T13:52:59Z",
          "updatedAt": "2019-08-19T13:52:59Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "openjdk is discontinuing md5. I'd say that we can close this and suggest implementors using only secure algorithms.\r\n\r\nhttps://github.com/openjdk/jdk/commit/b171594072659cd9914c0f211156f4af3e2b0550#diff-7de55d11c146a664ea77257279945551",
          "createdAt": "2019-11-25T11:30:32Z",
          "updatedAt": "2019-11-25T11:30:32Z"
        }
      ]
    },
    {
      "number": 895,
      "id": "MDU6SXNzdWU0ODMyNjkwMTY=",
      "title": "End of input in parsing parameterised members",
      "url": "https://github.com/httpwg/http-extensions/issues/895",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "In Parsing a Parameterized Member from Text, there is an \"in a loop\" construct, rather than \"while input_string is not empty\", as is elsewhere. Can it be changed to the latter construct? Does end of input need to be considered more carefully?\r\n\r\nInside, there is:\r\n\r\n~~~\r\n   2. If the first character of input_string is not \";\", exit the loop.\r\n   3. Consume a \";\" character from the beginning of input_string.\r\n~~~\r\n\r\nThis implies that if input_string is empty, but it would be good to make that explicit.\r\n\r\nAlso, check elsewhere for similar omissions.",
      "createdAt": "2019-08-21T08:18:46Z",
      "updatedAt": "2019-08-26T03:05:19Z",
      "closedAt": "2019-08-26T03:05:12Z",
      "comments": []
    },
    {
      "number": 896,
      "id": "MDU6SXNzdWU0ODMyNjk2MDE=",
      "title": "Serialisation of Floats",
      "url": "https://github.com/httpwg/http-extensions/issues/896",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "... is currently unrealistic; it rejects values that have too much precision, which is going to be difficult to handle in many implementations. ",
      "createdAt": "2019-08-21T08:19:52Z",
      "updatedAt": "2019-08-26T05:46:29Z",
      "closedAt": "2019-08-26T05:46:29Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "So, what do?\r\n\r\n1. leave it; accept that sh-float is not the same as double-precision 64-bit binary format IEEE 754\r\n2. make it a lot closer to '', and come up with a different serialisation\r\n3. drop floats (for now)\r\n\r\nOption 1 will cause pain for the rest of forever, because I know that nobody cares about that sort of thing, they'll just want to `sprintf(\"%f\")` their `double`.\r\n\r\nOption 2 interests me (hex with a dot? explicit exponent and significand parts? something else?) but probably nobody else.  I'm sure people would love to see numbers like `-0xC.90FEp-2` in their HTTP headers.  Let alone having to convert them to/from JS numbers.\r\n\r\nOption 3 feels bad, but maybe it's easier?  Are any of the known/impending uses of SH going to notice the absence?",
          "createdAt": "2019-08-21T11:10:03Z",
          "updatedAt": "2019-08-21T11:10:03Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Perhaps there's a 1.b: an algorithm for converting a double to an sh-float (or phrased another way: an algorithm for serialising a double) that includes a consistent, reliable rounding strategy.",
          "createdAt": "2019-08-22T22:15:04Z",
          "updatedAt": "2019-08-22T22:15:04Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think we just need to remove the \"fail serialisation\" step for the fractional component, and then enforce it in the actual serialisation.",
          "createdAt": "2019-08-26T02:00:50Z",
          "updatedAt": "2019-08-26T02:00:50Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "(and truncate, not round)",
          "createdAt": "2019-08-26T02:01:01Z",
          "updatedAt": "2019-08-26T02:01:01Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": ":thinking: . o O ( round-towards-zero or round-towards-negative-infinity..? )",
          "createdAt": "2019-08-26T02:56:52Z",
          "updatedAt": "2019-08-26T02:56:52Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "\"If the fractional component has more than six digits of precision, truncate it after the first six digits.\"",
          "createdAt": "2019-08-26T03:13:36Z",
          "updatedAt": "2019-08-26T03:13:36Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Kinda weird if `0.1234567` becomes `0.123456` and is ok, but `1234567890.1234567` becomes `1234567890.123456` and isn't.",
          "createdAt": "2019-08-26T03:40:42Z",
          "updatedAt": "2019-08-26T03:40:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Why is that weird? It sounds like you're experiencing regret about the current approach to limiting floats...",
          "createdAt": "2019-08-26T03:49:46Z",
          "updatedAt": "2019-08-26T03:49:46Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not a blocker. It just feels weird that it truncates at 6 digits whether or not that's the appropriate number.  So some numbers with >6 digits of precision will truncate fine, but others won't.",
          "createdAt": "2019-08-26T03:55:13Z",
          "updatedAt": "2019-08-26T03:55:13Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "PTAL",
          "createdAt": "2019-08-26T04:56:36Z",
          "updatedAt": "2019-08-26T04:56:36Z"
        }
      ]
    },
    {
      "number": 897,
      "id": "MDU6SXNzdWU0ODMyNzAwNjI=",
      "title": "References to ABNF / abstract limits",
      "url": "https://github.com/httpwg/http-extensions/issues/897",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "In parsing and serialisation algorithms, there are some indirect references to the limits defined in the abstract model; it would be good to make these explicit.",
      "createdAt": "2019-08-21T08:20:49Z",
      "updatedAt": "2019-08-26T02:19:28Z",
      "closedAt": "2019-08-26T02:19:28Z",
      "comments": []
    },
    {
      "number": 898,
      "id": "MDU6SXNzdWU0ODMyNzA0MTQ=",
      "title": "'member' in serialising a dictionary",
      "url": "https://github.com/httpwg/http-extensions/issues/898",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "... is fuzzy. Needs more precision.\r\n",
      "createdAt": "2019-08-21T08:21:31Z",
      "updatedAt": "2019-08-26T01:55:09Z",
      "closedAt": "2019-08-26T01:55:09Z",
      "comments": []
    },
    {
      "number": 899,
      "id": "MDU6SXNzdWU0ODMyNzA3OTI=",
      "title": "Refactor inner list parsing",
      "url": "https://github.com/httpwg/http-extensions/issues/899",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "There's a discontinuity between how lists and dictionaries parse and serialise inner lists; refactor?",
      "createdAt": "2019-08-21T08:22:16Z",
      "updatedAt": "2019-08-26T03:03:39Z",
      "closedAt": "2019-08-26T03:03:39Z",
      "comments": []
    },
    {
      "number": 900,
      "id": "MDU6SXNzdWU0ODMzNDQ3OTY=",
      "title": "Review",
      "url": "https://github.com/httpwg/http-extensions/issues/900",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "- [x] implementer notes\r\n- [x] Defining new structured headers\r\n- [x] intentionally strict processing\r\n- [x] introduction\r\n- [x] text about splitting / joining header fields and their effects",
      "createdAt": "2019-08-21T10:45:29Z",
      "updatedAt": "2019-08-26T03:27:21Z",
      "closedAt": "2019-08-26T03:27:21Z",
      "comments": []
    },
    {
      "number": 901,
      "id": "MDU6SXNzdWU0ODM1NjAwNTI=",
      "title": "Multiple SameSite attributes in cookie-attribute-list",
      "url": "https://github.com/httpwg/http-extensions/issues/901",
      "state": "CLOSED",
      "author": "chlily1",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis",
        "samesite"
      ],
      "body": "The [spec](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-5.4) (step 13) doesn't say what to do when there are multiple attributes in the cookie-attribute-list with an attribute-name of SameSite. For other attributes it says to take the value of the last attribute with that name, so presumably SameSite should do the same.",
      "createdAt": "2019-08-21T17:46:57Z",
      "updatedAt": "2020-01-20T13:35:25Z",
      "closedAt": "2020-01-20T13:35:25Z",
      "comments": []
    },
    {
      "number": 902,
      "id": "MDU6SXNzdWU0ODM3NTM1MjY=",
      "title": "[SH] consume-then-prepend vs peek-then-consume when parsing",
      "url": "https://github.com/httpwg/http-extensions/issues/902",
      "state": "CLOSED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "Some parsing algorithms (e.g. Parsing an Inner List) say something like\r\n\r\n~~~\r\n       2.  If the first character of input_string is \")\":\r\n           1.  Consume the first character of input_string.\r\n~~~\r\n\r\nwhereas others (e.g. Parsing a Key from Text) say:\r\n\r\n~~~\r\n       1.  Let char be the result of removing the first character of\r\n           input_string.\r\n       2.  If char is not one of lcalpha, DIGIT, \"*\", \"_\", or \"-\":\r\n           1.  Prepend char to input_string.\r\n~~~\r\n\r\nI think the algorithms as a whole would be more consumable if there was consistent approach (peek-unshift or unshift-shift).",
      "createdAt": "2019-08-22T03:45:21Z",
      "updatedAt": "2019-08-26T01:40:42Z",
      "closedAt": "2019-08-26T01:40:42Z",
      "comments": []
    },
    {
      "number": 903,
      "id": "MDU6SXNzdWU0ODM3NTc1OTg=",
      "title": "[SH] [trivial] unnecessary 'else'",
      "url": "https://github.com/httpwg/http-extensions/issues/903",
      "state": "CLOSED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "In **4.2.6. Parsing a String from Text**, in step 4.2 there is:\r\n\r\n~~~\r\n       2.  If char is a backslash (\"\\\"):\r\n\r\n           1.  If input_string is now empty, fail parsing.\r\n\r\n           2.  Else:\r\n~~~\r\n\r\nThat `Else` isn't necessary, and isn't present in similar constructs in other algorithms.  Everything nested under it can be outdented to the same level as the `If input_string...`",
      "createdAt": "2019-08-22T04:04:46Z",
      "updatedAt": "2019-08-26T01:41:52Z",
      "closedAt": "2019-08-26T01:41:52Z",
      "comments": []
    },
    {
      "number": 904,
      "id": "MDU6SXNzdWU0ODQzMDkxMDM=",
      "title": "[SH] Serialising an Inner List adds extra space",
      "url": "https://github.com/httpwg/http-extensions/issues/904",
      "state": "CLOSED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "In Serialising an Inner List: `3.  If inner_list is not empty, append a single WS to output.`\r\n\r\nHowever it never removes elements from inner_list, so *technically* every member (including the last member) should have a space after.",
      "createdAt": "2019-08-23T03:17:54Z",
      "updatedAt": "2019-08-30T07:41:38Z",
      "closedAt": "2019-08-30T07:41:38Z",
      "comments": []
    },
    {
      "number": 905,
      "id": "MDU6SXNzdWU0ODUyMzM4MDI=",
      "title": "Editorial: in structured headers rename \"Strings\" to \"ASCII Strings\"",
      "url": "https://github.com/httpwg/http-extensions/issues/905",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "This makes it more immediately apparent that this is far more limited than strings of modern programming languages and you likely want to use a (UTF-8) Byte Sequence for representing those.",
      "createdAt": "2019-08-26T13:21:13Z",
      "updatedAt": "2019-09-10T09:16:17Z",
      "closedAt": "2019-09-10T09:16:17Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We already use the phrase \"ASCII string\" to indicate the type of many of the algorithms, so I'm afraid that this will cause some confusion.\r\n\r\nDo you have an alternative suggestion? Or, would it be sufficient to emphasise their nature in their definition?",
          "createdAt": "2019-08-30T07:33:55Z",
          "updatedAt": "2019-08-30T07:33:55Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "You also use \"string\" for a number of things that are not \"String\". And similar for \"float\" and \"integer\", so that's not particularly persuasive.",
          "createdAt": "2019-08-30T07:54:46Z",
          "updatedAt": "2019-08-30T07:55:06Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not even ASCII. Quite a few of the 128 ASCII characters can't be sent in an sh-string. ",
          "createdAt": "2019-09-01T12:34:58Z",
          "updatedAt": "2019-09-01T12:34:58Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Yes.",
          "createdAt": "2019-09-04T06:02:25Z",
          "updatedAt": "2019-09-04T06:02:25Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'm not inclined to change this; we already subset integers and floats, but we don't call them e.g., \"integers up to 15 digits.\"\r\n\r\n",
          "createdAt": "2019-09-04T09:25:50Z",
          "updatedAt": "2019-09-04T09:25:50Z"
        }
      ]
    },
    {
      "number": 907,
      "id": "MDU6SXNzdWU0ODYyMDcxMjk=",
      "title": "[SH] Allow parameterized inner-list values.",
      "url": "https://github.com/httpwg/http-extensions/issues/907",
      "state": "CLOSED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "As discussed around https://github.com/httpwg/http-extensions/issues/839#issuecomment-508367966, it would be lovely if we could address the use case raised in https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#structured-headers-dont-fit-my-data by allowing list items themselves to contain parameters. This would allow the example in the specification:\r\n\r\n```\r\nExample-Thing: name=\"Widget\", cost=89.2, descriptions=(foo bar)\r\nExample-Description: foo; url=\"https://example.net\"; context=123,\r\n                     bar; url=\"https://example.org\"; context=456\r\n```\r\n\r\nto be written as:\r\n\r\n```\r\nExample-Thing:\r\n    name=\"Widget\",\r\n    cost=89.2,\r\n    descriptions=(foo;url=\"https://example.net\";context=123\r\n                  bar;url=\"https://example.org\";context=456)\r\n```",
      "createdAt": "2019-08-28T07:31:41Z",
      "updatedAt": "2019-10-25T04:35:43Z",
      "closedAt": "2019-10-25T04:35:43Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hm. We put parameters on (item or inner-list), where maybe we should have just put them on item; I suspect your use case is more common than the one that's currently enabled.\r\n\r\nWould you be against making that change (i.e., moving parameters \"inside\" the list, as opposed to enabling them both on the list as a whole and individual items)?\r\n",
          "createdAt": "2019-08-30T04:53:07Z",
          "updatedAt": "2019-08-30T04:53:07Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> Would you be against making that change (i.e., moving parameters \"inside\" the list, as opposed to enabling them both on the list as a whole and individual items)?\r\n\r\nThat sounds fine to me. I, personally, don't yet have a use for parameterizing the `inner-list` itself, but I would quite appreciate being able to add parameters to the items an `inner-list` contains.",
          "createdAt": "2019-08-30T05:45:53Z",
          "updatedAt": "2019-08-30T05:45:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@bsdphk @phluid61 any concern about trying the above change?",
          "createdAt": "2019-08-30T10:20:26Z",
          "updatedAt": "2019-08-30T10:20:26Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we keep this up, I can dust of my original proposal which had recursion :-)\r\n\r\nAs long as we can pick it apart consistently, I'm fine.",
          "createdAt": "2019-09-03T21:02:29Z",
          "updatedAt": "2019-09-03T21:02:29Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> If we keep this up, I can dust of my original proposal which had recursion :-)\r\n\r\nI'm fine with recursion, FWIW. More complexity === better. ;)",
          "createdAt": "2019-09-05T04:45:20Z",
          "updatedAt": "2019-09-05T04:45:20Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "So to summarise, I think the proposal is:\r\n\r\n* Allow parameters on Item\r\n* Allow parameters on inner-list\r\n\r\nThis removes the need to make parameters specific to Dictionaries and lists, and effectively allows parameters \"everywhere\". This is probably a very good story for extensibility, if we document it right.\r\n\r\nThe only downside that I see is that implementations will no longer map \"simple\" types (e.g., integers, strings) to their analogies in-language; it'll all need to be objects, to accommodate parameters.\r\n\r\nI think that's acceptable -- especially given the token/string schism -- but wanted to make sure everyone understood this. \r\n\r\nFor the test suite, it means that the JSON representation of an item will probably be something like:\r\n\r\n~~~ json\r\n{\r\n  \"value\": 12335,\r\n  \"parameters\": {\r\n    \"foo\": 456.78\r\n}\r\n~~~\r\n\r\nand with an inner-list:\r\n\r\n~~~ json\r\n{\r\n  \"value\": [\r\n    {\r\n      \"value\": \"a\",\r\n      \"parameters\": {\r\n        \"foo\": true\r\n      }\r\n    },\r\n    {\r\n      \"value\": \"b\"\r\n    }\r\n  ],\r\n  \"parameters\": {\r\n    \"foo\": \"bar\"\r\n  }\r\n}\r\n~~~\r\n\r\nThis is _verbose_, but fairly straightforward. And of course APIs can make this a lot easier with various methods (e.g., `getParameters` and the like).\r\n\r\nWhat do people think? This is not a small change, so I'm likely to do it in an isolated draft version. There aren't *that* many implementations yet, so if we're going to do this, now is the time.",
          "createdAt": "2019-10-02T03:21:08Z",
          "updatedAt": "2019-10-02T14:21:03Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Except that 'serializing an item' is used by param values. But that can be unpicked.",
          "createdAt": "2019-10-02T06:07:01Z",
          "updatedAt": "2019-10-02T06:07:01Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "SGTM.",
          "createdAt": "2019-10-02T06:51:31Z",
          "updatedAt": "2019-10-02T06:51:31Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm quite happy with that proposal -- it solves the use case that we've had with reporting, where both inner and outer list items may require parameters.\r\n\r\nEven if reporting ends up not needing to use both levels of parameters at the same time, I'm fairly certain that parameters on either inner or outer list items will be used separately by different headers, and it should make both parsing and serialization more straightforward to describe and implement if both are allowed in the same structure.",
          "createdAt": "2019-10-02T14:59:16Z",
          "updatedAt": "2019-10-02T14:59:16Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "no opinion.",
          "createdAt": "2019-10-03T09:03:43Z",
          "updatedAt": "2019-10-03T09:03:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I've created a PR #954; would very much appreciate a close review from multiple people, as it's fairly intrusive. Having said that, I think I like it.\r\n\r\nThe diff is useful, but you can also see the HTML here:\r\n  https://httpwg.org/http-extensions/mnot-907/draft-ietf-httpbis-header-structure.html\r\n\r\nI haven't yet updated the tests or my implementation.",
          "createdAt": "2019-10-09T23:20:02Z",
          "updatedAt": "2019-10-09T23:20:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "(BTW, as I did this I noticed a number of small-ish stylistic issues in the spec; I'll address those separately)",
          "createdAt": "2019-10-09T23:21:33Z",
          "updatedAt": "2019-10-09T23:21:33Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "At a first (quick) read-through it looks pretty good. I'll have to find time to mash it into code to see if I notice any issues.\r\n\r\nHigh level question: the combined ABNF for dictionary says:\r\n\r\n```\r\ndict-member    = member-name \"=\" member-value *parameter\r\nmember-value   = sh-item / inner-list\r\nsh-item        = bare-item *parameter\r\ninner-list     = \"(\" OWS [ sh-item *( SP sh-item ) OWS ] \")\" *parameter\r\n```\r\n\r\nObviously it's easy to remove `*parameter` from `dict-member`, but does that change the semantics?  Does anyone currently use it as ((key,value),params) rather than (key,(value,params)) ?",
          "createdAt": "2019-10-09T23:42:42Z",
          "updatedAt": "2019-10-09T23:42:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Ah, good catch; that `*parameter` shouldn't be there.\r\n\r\nI don't *think* it changes the semantics; keys can't be duplicated, so there shouldn't be any conflicts, and an implementation can choose how it surfaces things.",
          "createdAt": "2019-10-09T23:48:02Z",
          "updatedAt": "2019-10-09T23:48:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Merged; should be out in a new draft in the next day or two. I still need to update my implementation; @phluid61 has a PR for updates to the tests.",
          "createdAt": "2019-10-25T04:35:43Z",
          "updatedAt": "2019-10-25T04:35:43Z"
        }
      ]
    },
    {
      "number": 908,
      "id": "MDU6SXNzdWU0ODYzMjg5MjA=",
      "title": "Additional terminology for structured headers",
      "url": "https://github.com/httpwg/http-extensions/issues/908",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Reviewing https://github.com/whatwg/fetch/pull/925 I realize that it would be really useful if \"structured header\", \"structured header name\" (even if its value space matches that of a \"header name\", it's still a separate field), and \"structured header value\" were defined terms with an ID that could be referenced in normative fashion.",
      "createdAt": "2019-08-28T11:43:46Z",
      "updatedAt": "2019-08-30T07:39:14Z",
      "closedAt": "2019-08-30T07:39:14Z",
      "comments": []
    },
    {
      "number": 909,
      "id": "MDU6SXNzdWU0ODczMjE0NzQ=",
      "title": "Less requirements, more advice",
      "url": "https://github.com/httpwg/http-extensions/issues/909",
      "state": "OPEN",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "A take-away from the BCP190 discussion.",
      "createdAt": "2019-08-30T06:59:31Z",
      "updatedAt": "2019-08-30T06:59:31Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 911,
      "id": "MDU6SXNzdWU0ODczMzk3MzA=",
      "title": "Improve references",
      "url": "https://github.com/httpwg/http-extensions/issues/911",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "## I expect\r\n\r\nThat the following references contain Section\r\n\r\n- [ ] https://github.com/httpwg/http-extensions/blame/master/draft-ietf-httpbis-bcp56bis.md#L187 as this is quite a different approach respect to the widely used OpenAPI one.",
      "createdAt": "2019-08-30T07:47:22Z",
      "updatedAt": "2019-09-05T22:54:28Z",
      "closedAt": "2019-09-05T22:54:27Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mistakenly assumed this was related to Digest headers. What document are you raising this issue against?",
          "createdAt": "2019-09-05T13:33:57Z",
          "updatedAt": "2019-09-05T13:33:57Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue the issue is open on BCP56bis :)",
          "createdAt": "2019-09-05T15:56:18Z",
          "updatedAt": "2019-09-05T15:56:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@ioggstream this is specifically about standard APIs, not single-origin APIs.",
          "createdAt": "2019-09-05T22:54:27Z",
          "updatedAt": "2019-09-05T22:54:27Z"
        }
      ]
    },
    {
      "number": 912,
      "id": "MDU6SXNzdWU0ODczNDkzMDE=",
      "title": "What prohibits a legacy header and structured header of the same name in a single request",
      "url": "https://github.com/httpwg/http-extensions/issues/912",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "If I understand @mnot correctly Structured Headers effectively patches the HTTP protocol. What forbids a request from containing two headers with the same name with different value types?",
      "createdAt": "2019-08-30T08:11:13Z",
      "updatedAt": "2019-09-15T02:22:01Z",
      "closedAt": "2019-08-30T09:37:30Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes, but as I said, a header has to \"opt into\" SH. In HTTP as it stands, there isn't typing on-the-wire, so the parser will take the *whole* value and attempt to parse it; it will either succeed (because the other, manually-inserted value can be parsed), or fail (because it can't).",
          "createdAt": "2019-08-30T09:37:26Z",
          "updatedAt": "2019-08-30T09:37:26Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "This comment is about the data model since APIs (unless this is carefully considered and rejected, but the reasons are not immediately apparent from this draft) might well allow a mixture. So I think you have to actually call this out somehow. (And APIs don't care about whether headers have opted in or not, they don't know and shouldn't.)",
          "createdAt": "2019-08-30T10:17:50Z",
          "updatedAt": "2019-08-30T10:18:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK, so let's talk about a hypothetical HTTP API that wants to incorporate SH. Mixing different types of headers in one message is definitely on the table for the foreseeable future.\r\n\r\nOur API currently exposes a `message` object that has a  `headers` member. `headers` currently has `getHeader` and `setHeader` to manipulate header fields by name.\r\n\r\nTo incorporate SH, our API needs to add some new methods to `headers`; let's say `getDict`, `getList` and `getItem`, along with the corresponding `set*` functions. \r\n\r\nEach one is passed a field name; the `set*` ones are also passed a value to set.\r\n\r\nIn this design, the API itself does *not* need to know the difference between them; it's up to the caller to decide when it's appropriate to call a given function. They can *always* call the \"normal\" functions (`getHeader` and `setHeader`) if they want to work with the strings, but if a header is defined as a SH, they'll be wanting to call the other ones.\r\n\r\nI _think_ you're asking what happens when an API has some append semantics; e.g., `addHeader`. A pathological user might call `setDict` and then `addHeader`, and I agree that there are some choices to be made here. The sane thing to do, I think, would be to specify that `setDict` blows away any existing value.\r\n\r\nIs that what you're talking about, or is it something else?",
          "createdAt": "2019-08-30T10:33:52Z",
          "updatedAt": "2019-08-30T10:33:52Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "At an API-level the problem is with appending, indeed.\r\n\r\nAt a model level, there's nothing that patches https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#message.abstraction really to say that for a given name, there's either a structured header value or a normal value, but you cannot have multiple fields with either. It seems that kind of contraint should be written down somewhere and not be left for particular protocol representations to sort out.",
          "createdAt": "2019-08-30T10:51:13Z",
          "updatedAt": "2019-08-30T10:51:13Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, even if we try to forbid it, it can happen on the wire. The recipient side needs to reliably handle that case... (where \"reliably\" can mean to fail parsing).",
          "createdAt": "2019-08-30T10:54:14Z",
          "updatedAt": "2019-08-30T10:54:14Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "On the wire is unclear as there is no wire representation, right?",
          "createdAt": "2019-08-30T10:57:42Z",
          "updatedAt": "2019-08-30T10:57:42Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can you elaborate? Senders can sent two instances of a header field, one using SH syntax, one using something else. \r\n\r\n",
          "createdAt": "2019-08-30T11:00:35Z",
          "updatedAt": "2019-08-30T11:00:35Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I see, you're talking about representing the value using the normal syntax. That's not really a problem as in that case the fact that it's typed is lost too.",
          "createdAt": "2019-08-30T11:03:40Z",
          "updatedAt": "2019-08-30T11:03:40Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> ...there's either a structured header value or a normal value, ...\r\n\r\nWhat is normal? Every current header essentially has its own data model. What this spec allows is for newly minted headers to share an underlying model.\r\n\r\nYou still have to know the specific header to know whether you can parse it using SH or not. ",
          "createdAt": "2019-09-01T12:29:38Z",
          "updatedAt": "2019-09-01T12:29:38Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I'm talking about arbitrary headers applications can (and do) mint.",
          "createdAt": "2019-09-04T06:02:01Z",
          "updatedAt": "2019-09-04T06:02:01Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Then the recipient either knows to parse it as SH or not.\r\n\r\nThe \"or not\" part is easy, I guess you just want to give people a hook to let them feed things through the SH parsing machine.  At which point things like auto-concatenation can come into effect, depending on how you define your API.\r\n\r\nNot sure how it's a spec issue, though.",
          "createdAt": "2019-09-04T06:24:24Z",
          "updatedAt": "2019-09-04T06:24:24Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "As an extreme example, can you have an SH Set-Cookie and a non-SH Set-Cookie in a single response? What allows/prohibits that? (I hope you're not expecting end points to validate all known headers in existence...)\r\n\r\n(Or in broader terms, what's the data model for requests/responses, and in particular their headers.)\r\n\r\n",
          "createdAt": "2019-09-04T06:48:56Z",
          "updatedAt": "2019-09-04T06:48:56Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> As an extreme example, can you have an SH Set-Cookie and a non-SH Set-Cookie in a single response?\r\n\r\nThat doesn't make sense; Set-Cookie is not an SH header. If someone sends a message with a header field value that isn't valid for that header, then its not valid for that header. I could write a netcat script that says `Set-Cookie: lol$#nerd\"` What do you do about that? \r\n\r\nAnd no, the recipient doesn't have to validate every header in existence, just the ones it acts on.\r\n\r\n> (Or in broader terms, what's the data model for requests/responses, and in particular their headers.) \r\n\r\nThat's a long way from where we are now. All this spec is doing is making it easier for new headers to be DRY. ",
          "createdAt": "2019-09-04T09:49:02Z",
          "updatedAt": "2019-09-04T09:49:02Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "@phluid61 it so happens that `fetch()` doesn't expose `Set-Cookie` headers, but if you did `Cache-Control: lol#nerd\"` it'd expose that as-is and let the application decide how to handle it. So I'm not sure how validity is relevant here.",
          "createdAt": "2019-09-10T09:18:18Z",
          "updatedAt": "2019-09-10T09:18:18Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Are you talking about [the fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)?  I don't think it should be affected by SH at all.  None of the headers that it intrinsically understands are SH headers, and it already treats every other header as a byte sequence, regardless of any underlying data structures.  (`response.headers.get('Date')` doesn't return a Date object.)  That still works.",
          "createdAt": "2019-09-10T13:01:53Z",
          "updatedAt": "2019-09-10T13:01:53Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "A different point of view is that SH headers are arbitrary headers with typed values and it would make a lot of sense for JavaScript to be able to set typed values that make it all the way to the server, provided the connection supports them as well.",
          "createdAt": "2019-09-10T13:22:35Z",
          "updatedAt": "2019-09-10T13:22:35Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure what you mean by \"arbitrary headers\". Every header is by its definition SH or not \u2013 that is arbitrary on the part of the person who specified it\\*; and a header that is defined as SH can be arbitrarily treated as an opaque byte sequence; but a header that is not defined as SH cannot be arbitrarily given SH structure or semantics or anything.\r\n\r\n\\* note: \"specified\" here doesn't have to mean they wrote a spec; it equally applies to me making up `X-Debug-MK` on the fly.\r\n\r\nSo: if you want your API to be able to maintain SH data types all the way through, using JS types as a close analogue, then you either have to know which headers are by their definition able to be represented as such, or punt that entirely to someone who is willing to take on the responsibility (i.e. the application).\r\n\r\nThe former doesn't work. The latter means you have to provide extra knobs and buttons in your API; but that's up to your API, not this spec.",
          "createdAt": "2019-09-10T23:24:53Z",
          "updatedAt": "2019-09-10T23:24:53Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Again though, there's nothing in the model that forces a consistent choice to be made for a single header name and the data model is such that at least for one header name there can be duplicates (Set-Cookie). At least I don't see this spelled out anywhere in sufficient detail.",
          "createdAt": "2019-09-11T15:33:38Z",
          "updatedAt": "2019-09-11T15:33:38Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> Again though, there's nothing in the model that forces a consistent choice to be made for a single header name\r\n\r\nBecause the choice is made in the header's definition/specification.  It doesn't make sense to even discuss it in the model.\r\n\r\n> and the data model is such that at least for one header name there can be duplicates (Set-Cookie).\r\n\r\nNo, there can't, unless you introduce it.  If your API knows about 'Set-Cookie' it knows it's not SH, so it forbids SH-flavoured accesses.  If it doesn't know about 'Set-Cookie' then it creates \u2013 and is responsible for managing \u2013 the risk of letting users do The Wrong Thing:tm:.  You can't abdicate that responsibility; you chose to take it on by building your API that way.\r\n\r\nHere's a thought experiment: Date and Expires share an underlying data model and a serialisation.  Let's say you decide to add support to carry JS `Date` objects end-to-end, using the [HTTP-date format](https://tools.ietf.org/html/rfc7231#section-7.1.1.2) on the wire.  That's a perfectly reasonable choice for you to make, and not much different from adding SH primitives.\r\n\r\nNow in this thought experiment I write this code:\r\n\r\n```js\r\nheaders.append('X-MK-Timestamp', 'Wed, 21 Oct 2015 07:28:00 GMT');\r\nheaders.append('X-MK-Timestamp', new Date());\r\n```\r\n\r\nHow would you resolve that?\r\n\r\n> At least I don't see this spelled out anywhere in sufficient detail.\r\n\r\nI might be wrong, but I'm pretty sure HTTP specs have always intentionally avoided specifying APIs.",
          "createdAt": "2019-09-12T00:00:17Z",
          "updatedAt": "2019-09-12T00:00:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "from [section 2](https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#specify):\r\n\r\n> Likewise, header field definitions can only use Structured Headers for the entire header field value, not a portion thereof.",
          "createdAt": "2019-09-12T00:01:04Z",
          "updatedAt": "2019-09-12T00:01:04Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "@mnot thanks, though that still does not capture `Set-Cookie` I think, which afaict is a special case to the data model as while all other headers have a single combined value, for `Set-Cookie` there's one combined value per declaration. (Which is also why you sorta have to know about that one, but you still don't have to know about its allowed values.)",
          "createdAt": "2019-09-12T07:12:10Z",
          "updatedAt": "2019-09-12T07:14:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "That's captured in [HTTP itself](https://httpwg.org/specs/rfc7230.html#field.order) -- \r\n\r\n> Note: In practice, the \"Set-Cookie\" header field ([RFC6265]) often appears multiple times in a response message and does not use the list syntax, violating the above requirements on multiple header fields with the same name. Since it cannot be combined into a single field-value, recipients ought to handle \"Set-Cookie\" as a special case while processing header fields. (See Appendix A.2.3 of [Kri2001] for details.)",
          "createdAt": "2019-09-12T22:48:17Z",
          "updatedAt": "2019-09-12T22:48:17Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Right, so you could still end up with a `Set-Cookie` header containing a structured value and one that does not, if the API only knows about the `Set-Cookie` data model exception and not how to validate its value. Or more abstractly, there's nothing in the data model that outlaws that. ",
          "createdAt": "2019-09-13T07:28:29Z",
          "updatedAt": "2019-09-13T07:28:29Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "SH says how to combine header fields with the same name (it matches the list restriction in 7230, 3.2.2), and that SH can only be used for the entire field value or none of it. So anything that can't be combined that way can't be SH.\r\n\r\nIf you know enough about`set-cookie` that you know you can't combine fields that way (or at all), that already tells you that you can't use SH for `set-cookie`.\r\n\r\nSo too for any arbitrary header field. If it uses SH, it has to use it everywhere. Whether you do that by flagging a field name on first access and restricting it to a certain access mode from then on, or parsing byte sequence values when modes mix, or ignoring the issue altogether, or whatever, that's up to you.",
          "createdAt": "2019-09-13T23:31:01Z",
          "updatedAt": "2019-09-13T23:31:01Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I don't think your assertion about `Set-Cookie` follows, but I'll bow out at this point as well.",
          "createdAt": "2019-09-14T09:34:20Z",
          "updatedAt": "2019-09-14T09:34:20Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> but I'll bow out at this point as well.\r\n\r\nDon't be like that. I'm not trying to be obtuse, I'm trying to understand what you want the spec to say.\r\n\r\nIt currently says nothing about multiple 'instances' of the same header field.  I believe that's because [RFC 7230, Section 3.2.2](https://httpwg.org/specs/rfc7230.html#rfc.section.3.2.2) says:\r\n\r\n> A sender MUST NOT generate multiple header fields with the same field name in a message unless either the entire field value for that header field is defined as a comma-separated list [i.e., #(values)] or the header field is a well-known exception (as noted below).\r\n\r\nIt's a normative reference, so it applies to SH.  It means that you can generate multiple instances of a SH header field as long as the value is a sh-list or sh-dictionary.\r\n\r\nset-cookie is the one known exception called out in RFC 7230 which has can appear multiple times but can't be combined.  It explicitly calls out that \"it cannot be combined into a single field-value,\" so it violates [this from SH](https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#rfc.section.4.2):\r\n\r\n> When generating input_bytes, parsers MUST combine all instances of the target header field into one comma-separated field-value, as per [RFC7230], Section 3.2.2; this assures that the header is processed correctly.\r\n\r\nSo set-cookie can not be SH.  If an endpoint knows enough about set-cookie to know that it can't get automatically combined, it by default also knows that set-cookie isn't SH.\r\n\r\nWhat would you like it to say further than that?",
          "createdAt": "2019-09-15T02:22:01Z",
          "updatedAt": "2019-09-15T02:22:01Z"
        }
      ]
    },
    {
      "number": 913,
      "id": "MDU6SXNzdWU0ODczNzYyMDY=",
      "title": "Structured Headers and JavaScript",
      "url": "https://github.com/httpwg/http-extensions/issues/913",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "For https://github.com/whatwg/fetch/issues/930 I was trying to think of a natural mapping and I see a potential problem with String and Token. A natural way to do this in JavaScript would be to treat both as a JavaScript string and depending on the content serialize as one or the other. However, this would mean that if something takes a String that could also be represented as a Token, it gets a Token. And unless consumers are always required to support that, there's a problem.\r\n\r\nAn alternative here is that we do something less ergonomic, but that'll likely end up favoring one of these over the other.\r\n\r\n(Depending on the outcome of #907 for the getter side we might need a wrapper Item object of sorts that could indicate whether something is a string or token and you could use the same on the setter side, but passing a string when setting should probably work as well.)",
      "createdAt": "2019-08-30T09:11:37Z",
      "updatedAt": "2019-10-25T04:36:22Z",
      "closedAt": "2019-10-25T04:36:22Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> However, this would mean that if something takes a String that could also be represented as a Token, it gets a Token. And unless consumers are always required to support that, there's a problem.\r\n\r\nI think we should required consumers to support that.",
          "createdAt": "2019-08-30T09:38:09Z",
          "updatedAt": "2019-08-30T09:38:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "This was already discussed; see #790. \r\n\r\nBasically, you'll need to wrap Token with some sort of object to distinguish it from string.\r\n\r\n@reschke this is not ABNF-defined headers, it's new. There are use cases where the difference is semantic.",
          "createdAt": "2019-08-30T09:40:07Z",
          "updatedAt": "2019-08-30T09:40:07Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well. It's still ABNF, but I understand that you're referring to the conventions wrt token/quoted-string.\r\n\r\nWhat I wanted to say is that this is a good convention, and it doesn't seem to be a good idea not to use it here as well.\r\n\r\nIn which cases would there be a semantic difference?",
          "createdAt": "2019-08-30T09:42:05Z",
          "updatedAt": "2019-08-30T09:42:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "How would you feel if we had a term of art that indicated that they were isomorphic?",
          "createdAt": "2019-08-30T10:12:51Z",
          "updatedAt": "2019-08-30T10:12:51Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\"token\" and \"quoted-string\" isomorphic? Sounds good to me.",
          "createdAt": "2019-08-30T10:32:04Z",
          "updatedAt": "2019-08-30T10:32:04Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "To be clear -- do not specify them as isomorphic, but define language that can be referenced easily by specifications that want to make them so.",
          "createdAt": "2019-08-30T10:34:24Z",
          "updatedAt": "2019-08-30T10:34:24Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Could you explain why this can't be the default?",
          "createdAt": "2019-08-30T10:39:32Z",
          "updatedAt": "2019-08-30T10:39:32Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We've talked about this a lot, Julian. E.g., Cache-Control directives, remember that? There are many examples of headers that depend on one for or another, and the intent of SH is to make it possible to back-port some existing headers optimistically.\r\n\r\nAllowing specifications to nominate values as token-or-string is a good compromise position, I think.",
          "createdAt": "2019-08-30T10:57:11Z",
          "updatedAt": "2019-08-30T10:57:11Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Cache-Control has a related issue, and we haven't resolved it yet.\r\n\r\nI'm kind if surprised that backporting for existing field values suddenly is a goal again, though.",
          "createdAt": "2019-08-30T10:58:49Z",
          "updatedAt": "2019-08-30T10:58:49Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "re: isomorphism\r\n\r\nDo you mean like defining an ABNF rule and/or \"virtual\" type that can be either string or token?",
          "createdAt": "2019-09-03T03:07:37Z",
          "updatedAt": "2019-09-03T03:07:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "yep",
          "createdAt": "2019-09-03T03:08:27Z",
          "updatedAt": "2019-09-03T03:08:27Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Feels a bit like \"you shouldn't do this, but we know you will, so here's how\".\r\n\r\nImmature thought: is it time to rethink strings so the hierarchy goes Binary>String>Token, and you can freely transform up, but only down if the subset constraints match? (I know that Binary is a byte sequence, not a string, and :something something: character encoding...)",
          "createdAt": "2019-09-03T03:31:44Z",
          "updatedAt": "2019-09-03T03:31:44Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think there are valid cases for it; indeed, I came across one the other day in an SH-using spec.\r\n\r\nRe: hierarchy -- I'd really rather not rework things to that extent now, unless there are significant benefits.",
          "createdAt": "2019-09-03T04:50:49Z",
          "updatedAt": "2019-09-03T04:50:49Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "How important is it to actually document this pairing here, now?  We aren't providing a schema specification (beyond top-level data types).  Like, we aren't making it easy to say \"a list of all integers\", or \"a list of lists of all strings\", or \"a parameterised item where for any parameter with param-name of `q` the param-value should be a float\"; so do we need to make it easier to say \"string-or-token\" in similar places?\r\n\r\nIs that the only pairing that needs special treatment?  Does nobody care about integer-or-float?\r\n\r\nAlso, which header specs require it? The push so far _seems_ to be driven from implementations.",
          "createdAt": "2019-09-03T05:55:17Z",
          "updatedAt": "2019-09-03T05:55:51Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'm thinking about something that's just a documentation convention, not something that would change a typical SH implementation (unless it specifically wanted to present an abstraction for it). This is more for convenience of spec authors.",
          "createdAt": "2019-09-03T07:16:49Z",
          "updatedAt": "2019-09-03T07:16:49Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Me too, that's why I'm wondering where it's actually come up.",
          "createdAt": "2019-09-03T11:45:57Z",
          "updatedAt": "2019-09-03T11:45:57Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "It came up in how to design the JavaScript API as it'll likely favor one over the other. And I think you're right that this also applies to serializing integers and floats (unless we require BigNum for the former and Number for the latter, but that seems to be unlikely the API that folks want).",
          "createdAt": "2019-09-04T05:53:31Z",
          "updatedAt": "2019-09-04T05:53:31Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "As long as someone is allowed to say \"must be a Token\" in one place, and someone is allowed to say \"must be a String\" in another, there's not really anything that can be done.",
          "createdAt": "2019-09-04T06:38:25Z",
          "updatedAt": "2019-09-04T06:38:25Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Yeah, that'll lead to favoring one type over another or an extremely awkward to use API. Having the types be isomorphic would be much better. For integers and floats it'd also seem better if we ended up with JSON's way of dealing with that.",
          "createdAt": "2019-09-04T06:54:35Z",
          "updatedAt": "2019-09-04T06:54:35Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Or you could use Ruby ;) ",
          "createdAt": "2019-09-04T09:37:55Z",
          "updatedAt": "2019-09-04T09:37:55Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's enough to say that JavaScript doesn't have a native type that corresponds with token, so there's no natural mapping from something like a js string.",
          "createdAt": "2019-09-15T23:15:52Z",
          "updatedAt": "2019-09-15T23:15:52Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "If #907 goes forward (and it looks like it will), I think this will be overcome by events, since that will effectively require implementations to move away from a direct mapping to \"simple\" types in favour of something like objects.",
          "createdAt": "2019-10-07T05:31:21Z",
          "updatedAt": "2019-10-07T05:31:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "#907 did indeed happen, so I think this is OBE.",
          "createdAt": "2019-10-25T04:36:22Z",
          "updatedAt": "2019-10-25T04:36:22Z"
        }
      ]
    },
    {
      "number": 914,
      "id": "MDU6SXNzdWU0ODczOTQwOTU=",
      "title": "bcp56bis and openapi",
      "url": "https://github.com/httpwg/http-extensions/issues/914",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mnot"
      ],
      "labels": [
        "bcp56bis"
      ],
      "body": "One of the central idea around bcp56bis was (from https://github.com/w3ctag/design-reviews/issues/232) this reasonable statement\r\n\r\n> the common practice of using [..] OpenAPI/Swagger to define a bunch\r\n> of fixed paths isn't really suitable for standards use\r\n\r\nReading bcp56bis it was not clear to me whether it applies to protocol editors or to application providers / developers. While the intro states:\r\n\r\n> when such an application has multiple, separate implementations of the server component\r\n\r\nthe use cases cited in `Is HTTP Being Used?` seem broader:\r\n\r\n> when any of the following conditions are true: the transport port in use is 80 or 443 [..]\r\n\r\nThe above statement seems to extend the following citation from  RFC7320:\r\n\r\n> Publishing a standard that constrains an existing URI structure [..]\r\n> is inappropriate [..] and the IETF [..] should not usurp it.\r\n\r\nIMHO while the following sentence would be reasonable eg. for a specification like OIDC\r\n\r\n> For example, specifying that a \"GET to the URL /foo retrieves a bar document\" is bad practice.\r\n> Likewise, specifying \"The widget API is at the path /bar\" violates {{!RFC7320}}.\r\n\r\nI'm not sure that applies when writing eg. the `kubernetes API` or `wordpress API`\r\n\r\n",
      "createdAt": "2019-08-30T09:49:42Z",
      "updatedAt": "2019-10-07T08:10:44Z",
      "closedAt": "2019-10-07T08:10:43Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "From the intro:\r\n\r\n> It is written primarily to guide IETF efforts to define application protocols using HTTP for deployment on the Internet, but might be applicable in other situations.\r\n\r\nHappy to clarify that if necessary.",
          "createdAt": "2019-08-30T10:27:21Z",
          "updatedAt": "2019-08-30T10:27:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing due to lack of activity; feel free to comment if you have suggested clarifications.",
          "createdAt": "2019-10-07T08:10:43Z",
          "updatedAt": "2019-10-07T08:10:43Z"
        }
      ]
    },
    {
      "number": 915,
      "id": "MDU6SXNzdWU0ODc0NTU5MzU=",
      "title": "SH: \"textual header (field)\"",
      "url": "https://github.com/httpwg/http-extensions/issues/915",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "This term is likely confusing, as, in practice, *all* HTTP header field values are textual.\r\n\r\nIt's true that in HTTP/2 and HTTP/3 they may not be transmitted as plain text, but that's just an artefact of the on-the-wire protocol. If that was relevant, would an HTTP/1.1 header field transmitted over TLS still be considered \"textual\"?\r\n\r\nSo minimally there should be a precise definition. On the other hand, it might be simpler just to get rid of them term, and to explain somewhere once that the field value might not be transferred as plain text in  HTTP/1.1, 2, or 3, and maybe that future versions of HTTP might introduce a new binary encoding based on SH.",
      "createdAt": "2019-08-30T12:25:14Z",
      "updatedAt": "2019-10-08T01:35:28Z",
      "closedAt": "2019-10-08T01:35:28Z",
      "comments": []
    },
    {
      "number": 916,
      "id": "MDU6SXNzdWU0ODc0NjA3MTQ=",
      "title": "SH: boolean definition doesn't say what is what",
      "url": "https://github.com/httpwg/http-extensions/issues/916",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "    Boolean values can be conveyed in Structured Headers.\r\n\r\n    The ABNF for a Boolean in textual HTTP headers is:\r\n\r\n    sh-boolean = \"?\" boolean\r\n    boolean    = \"0\" / \"1\"\r\n\r\nEither say \"0\" is false and \"1\" is true, or maybe rephrase the ABNF to:\r\n\r\n    sh-boolean = sh-false / sh-true\r\n    sh-false = \"?0\"\r\n    sh-true = \"?1\"\r\n",
      "createdAt": "2019-08-30T12:36:25Z",
      "updatedAt": "2019-09-02T03:10:00Z",
      "closedAt": "2019-09-02T03:10:00Z",
      "comments": []
    },
    {
      "number": 917,
      "id": "MDU6SXNzdWU0ODc0NjE0NzA=",
      "title": "SH: needs reference for UTF-8",
      "url": "https://github.com/httpwg/http-extensions/issues/917",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "",
      "createdAt": "2019-08-30T12:38:14Z",
      "updatedAt": "2019-09-02T02:55:48Z",
      "closedAt": "2019-09-02T02:55:48Z",
      "comments": []
    },
    {
      "number": 918,
      "id": "MDU6SXNzdWU0ODc0Njc0NjU=",
      "title": "SH: broken link in IEEE reference",
      "url": "https://github.com/httpwg/http-extensions/issues/918",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "<http://grouper.ieee.org/groups/754/> 404s.",
      "createdAt": "2019-08-30T12:51:54Z",
      "updatedAt": "2019-09-06T08:09:05Z",
      "closedAt": "2019-09-06T08:09:05Z",
      "comments": []
    },
    {
      "number": 925,
      "id": "MDU6SXNzdWU0OTAyNjI5MTU=",
      "title": "Add example with PUT + 204",
      "url": "https://github.com/httpwg/http-extensions/issues/925",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nan example digest of PUT  + 204\r\n\r\n## Note \r\n\r\nPUT without complete representation\r\nIf PUT returns 204 it may return a Digest header, provided that the response contains all the required representation metadata.\r\n\r\n```\r\nPUT /books/123 HTTP/1.1\r\nContent-Type: application/json\r\n\r\n{\"id\": \"123\", \"title\": \"Foo\"}\r\n\r\n---\r\n\r\nHTTP/1.1 204 No Content\r\nContent-Type: application/json\r\nDigest: sha256=TtjhvKObwiGt3XI75TExBCKFSkySLPWqQptGn190rMQ=\r\n```",
      "createdAt": "2019-09-06T10:52:50Z",
      "updatedAt": "2019-09-23T16:23:12Z",
      "closedAt": "2019-09-23T16:23:12Z",
      "comments": []
    },
    {
      "number": 927,
      "id": "MDU6SXNzdWU0OTA2MDAzMjU=",
      "title": "digest: unnumbered section (appendix) needs to be last",
      "url": "https://github.com/httpwg/http-extensions/issues/927",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "~~~\r\nWarning: Numbered sections are not permitted after unnumbered sections: found section \"Changes\" without attribute numbered=\"no\"\r\nWarning: Numbered sections are not permitted after unnumbered sections: found section \"Changes\" without attribute numbered=\"no\"\r\n~~~\r\n\r\nEither move \"Changes\" before \"Acknowledgements\", or make it unnumbered.",
      "createdAt": "2019-09-07T06:46:27Z",
      "updatedAt": "2019-09-22T16:15:09Z",
      "closedAt": "2019-09-22T16:15:09Z",
      "comments": []
    },
    {
      "number": 931,
      "id": "MDU6SXNzdWU0OTMxNjA3NDU=",
      "title": "string characters",
      "url": "https://github.com/httpwg/http-extensions/issues/931",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "From kari:\r\n\r\n\r\n\"contains characters outside the range %x00-1f or %x7f \"\r\n\r\nI suppose that you mean\r\n\r\n\r\n\tcontains characters on the range %x00-1f or %x7f\r\n\r\nor\r\n\r\n\tcontains characters outside the range %x20-7e\r\n\r\n",
      "createdAt": "2019-09-13T06:38:26Z",
      "updatedAt": "2019-09-13T06:40:58Z",
      "closedAt": "2019-09-13T06:40:39Z",
      "comments": []
    },
    {
      "number": 933,
      "id": "MDU6SXNzdWU0OTU0Nzc0NDQ=",
      "title": "SameSite attribute is not easily extensible",
      "url": "https://github.com/httpwg/http-extensions/issues/933",
      "state": "OPEN",
      "author": "sbingler",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis",
        "samesite"
      ],
      "body": "If we add a new attribute to SameSite (e.g. previously we added SameSite=None and [draft-west-cookie-samesite-firstparty-01](https://tools.ietf.org/html/draft-west-cookie-samesite-firstparty-01) proposes SameSite=FirstPartyLax and FirstPartyStrict), site owners will need to get the right behavior on both old and new UAs. The current specification (-03) makes this difficult because all unknown values as parsed as \u201cNone\u201d (or \u201cLax\u201d after [draft-west-cookie-incrementalism-00](https://tools.ietf.org/html/draft-west-cookie-incrementalism-00#section-3))\r\n\r\nIf unknown values were instead ignored, older UAs would fallback onto an earlier declaration, while newer ones would get the new behavior.\r\n\r\nFor instance, a site using FirstPartyStrict could fallback to None, to keep cookies accessible in older browsers, with SameSite=None; SameSite=FirstPartyStrict.\r\n\r\nAlternatively, the site may wish to fallback to Strict, preferring the tighter CSRF protection, via SameSite=Strict; SameSite=FirstPartyStrict.\r\n\r\nIf we added, say, a StrictOnOrigin mode which used same-origin instead of same-site, a site might use SameSite=Strict; SameSite=StrictOnOrigin.\r\n\r\nInterestingly, the [draft-02](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-02#section-5.3.7) does this, however [draft-03](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-5.3.7) changed this to unconditionally take the last attribute. Firefox implements -02 while Chrome implements -03 (@chlily1, @martinthomson, @mikewest). Whichever option we choose, we should make sure implementations align.\r\n\r\nBelow are findings comparing how a variety of UAs, along with the above drafts, interpret different combination of SameSite attributes. (@johnwilander, which did you all implement for the new Safari behavior?)\r\n\r\nAll UA results were taken from each UA's dev tools.\r\n\r\n| SameSite Attribute | Draft 02 | Draft 03 | Draft 03 + Inc | Chrome 77 | Firefox 69 | Safari OS X 10.14 |\r\n|-----------------------------------|----------|----------|----------------|-----------|------------|-------------------|\r\n| \" | Unset | Unset | Lax | Unset | Unset | Unset |\r\n| SameSite=garbage | Unset | None | Lax | Unset | Unset | Strict |\r\n| SameSite=garbage; SameSite=None | Unset | None | None | None | Unset | Strict |\r\n| SameSite=garbage; SameSite=Lax | Lax | Lax | Lax | Lax | Lax | Lax |\r\n| SameSite=garbage; SameSite=Strict | Strict | Strict | Strict | Strict | Strict | Strict |\r\n| SameSite=None; SameSite=garbage | Unset | None | Lax | Unset | Unset | Strict |\r\n| SameSite=Lax; SameSite=garbage | Lax | None | Lax | Unset | Lax | Strict |\r\n| SameSite=Strict; SameSite=garbage | Strict | None | Lax | Unset | Strict | Strict |\r\n| SameSite=Lax; SameSite=None | Lax | None | None | None | Unset | Strict |\r\n\r\n",
      "createdAt": "2019-09-18T22:05:39Z",
      "updatedAt": "2020-01-21T17:54:40Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sbingler",
          "authorAssociation": "NONE",
          "body": "For those interested in recreating the results, here is the code used:\r\n```\r\ndocument.cookie = \"no_samesite=1\";\r\ndocument.cookie = \"garbage=1; samesite=garbage\";\r\ndocument.cookie = \"garbage_none=1; samesite=garbage; samesite=none\";\r\ndocument.cookie = \"garbage_lax=1; samesite=garbage; samesite=lax\";\r\ndocument.cookie = \"garbage_strict=1; samesite=garbage; samesite=strict\";\r\ndocument.cookie = \"none_garbage=1; samesite=none; samesite=garbage\";\r\ndocument.cookie = \"lax_garbage=1; samesite=lax; samesite=garbage\";\r\ndocument.cookie = \"strict_garbage=1; samesite=strict; samesite=garbage\";\r\ndocument.cookie = \"lax_none=1; samesite=lax; samesite=none\";\r\n```",
          "createdAt": "2019-09-18T22:15:59Z",
          "updatedAt": "2019-09-18T22:15:59Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "@sbingler, @davidben, @chlily1, and I chatted about this last week.\r\n\r\nMy current opinion is that https://tools.ietf.org/html/draft-west-cookie-samesite-firstparty-01 is misguided, and that extending `SameSite` further is not going to be the right way to make further changes to cookies. I think it's quite reasonable to ensure that implementations land on a consistent story with regard to garbage values for `SameSite`, but I don't think it's important for us to make room for extension to the currently accepted values.\r\n\r\nI feel like there are reasonable arguments for both Chrome's current behavior and Firefox's current behavior. I don't have a strong reason to pick one or the other. Perhaps it's simplest for Chrome to match Firefox's behavior by simply ignoring cookies that assert `SameSite=garbage`? Is that the outcome you'd prefer, @sbingler?",
          "createdAt": "2020-01-20T13:25:31Z",
          "updatedAt": "2020-01-20T13:25:31Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe Firefox's behavior is that it ignores the attribute when `SameSite=garbage` (falling back to a previous one, if any). That's the -02 behavior, rather than the -03 behavior, which unconditionally takes the last one attribute (so no falling back to a previous one) and *then* ignores unrecognized ones.\r\n\r\nI believe Chrome and Safari (as of 10.15) implement the -03 behavior, while Firefox implements the -02 behavior. If we were trying to extend `SameSite`, I think the -02 behavior would be ideal because it gives the developer full control over the fallback chain. That would requiring changing Chrome as well as the macOS/iOS cookie logic again. Failing that, leaving rfc6252bis alone but changing cookie-incrementalism to treat `SameSite=garbage` as `SameSite=None` rather than the default would cover the most likely desired fallback when trying to extend `SameSite`.\r\n\r\nThat said, I agree with you that we probably shouldn't try to extend `SameSite` anymore, so trying to optimize for that is not terribly important.\r\n\r\nWhatever happens, at least one of Chrome+Safari or Firefox should change because they do not behave the same. As things currently stand, it's Firefox that's out of date, since they implement the -02 behavior rather than the -03 behavior.",
          "createdAt": "2020-01-21T17:54:40Z",
          "updatedAt": "2020-01-21T17:54:40Z"
        }
      ]
    },
    {
      "number": 934,
      "id": "MDU6SXNzdWU0OTcxMjQzODk=",
      "title": "Fix artworks formatting",
      "url": "https://github.com/httpwg/http-extensions/issues/934",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ioggstream"
      ],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\n- [x] requests and responses to use different artworks\r\n- [x] artworks not containing trailing/heading carriages\r\n\r\n",
      "createdAt": "2019-09-23T14:13:37Z",
      "updatedAt": "2019-09-23T16:52:53Z",
      "closedAt": "2019-09-23T16:52:53Z",
      "comments": []
    },
    {
      "number": 936,
      "id": "MDU6SXNzdWU0OTc3MTg3MTc=",
      "title": "Explain reference to `cache-validators`",
      "url": "https://github.com/httpwg/http-extensions/issues/936",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nto clarify the following passage\r\n\r\n> The resource is specified by the effective\r\n> Request-URI, and any cache-validator contained in the message.\r\n\r\nfor defining the behavior of digest with caching (eg. when Digest is returned together with\r\nLast-Modified and ETag).\r\n\r\nand to better extend the definition of Digest to POST and PATCH requests.\r\nThis is because [POST is cacheable for rfc 7231 \u00a74.2.3](https://tools.ietf.org/html/rfc7231#section-4.2.3) though only when they include explicit freshness information.\r\n\r\nIf we go on the new http-core definition (which is cleaner) we have that\r\n\r\n> Responses to POST requests are only cacheable when they include\r\n>   explicit freshness information (see Section 4.2.1 of [Caching]) \r\n>   and a\r\n>   Content-Location header field that has the same value as the POST's\r\n>   effective request URI (Section 6.2.5).\r\n \r\neg.\r\n```\r\n>POST /books\r\n\r\n< Content-Location: /books\r\n< Cache-Control: max-age=3600\r\n\r\n```\r\n\r\n## note\r\nAccording to https://tools.ietf.org/html/draft-ietf-httpbis-semantics-04#section-7.3.3\r\n\r\nPOST responses identify returned resources in different ways according to the following:\r\n\r\n### referenced resource target != effective request uri\r\n\r\n* the primary resource is identified by Content-Location\r\n* the enclosed representation matches the primary resource\r\neg. 1\r\n\r\n ```\r\nPOST /books\r\n\r\n{\"title\": \"foo\"}\r\n---\r\nHTTP/1.1 201\r\nContent-Location /books/123\r\n\r\n{\"title\": \"foo\", \"id\": 123}\r\n```\r\n\r\neg. 2\r\n\r\n ```\r\nPOST /books\r\n\r\n{\"title\": \"foo\"}\r\n---\r\nHTTP/1.1 204 No Content\r\nContent-Location /books/123\r\n\r\n```\r\n### representation describe the status of the request\r\n\r\n* primary resource identified by `Location`\r\n* enclosed representation matches the status of the request\r\n  according to the resource's own semantic\r\n\r\neg.\r\n\r\n ```\r\nPOST /books\r\n\r\n{\"title\": \"foo\"}\r\n---\r\nHTTP/1.1 200\r\nLocation /books/123\r\n\r\n{\"status\": \"updated\", \"id\": 123}\r\n```\r\n",
      "createdAt": "2019-09-24T14:17:21Z",
      "updatedAt": "2020-08-26T13:22:30Z",
      "closedAt": "2020-08-26T13:22:30Z",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "re-reading the old RFC my understanding is that validator fields should just be aligned with Digest (that is: digest-value should be aligned with the values of last-modified and etag). While it is trivial, the original editor could have considered that a potential issue.",
          "createdAt": "2020-08-17T12:52:19Z",
          "updatedAt": "2020-08-17T12:52:19Z"
        }
      ]
    },
    {
      "number": 938,
      "id": "MDU6SXNzdWU0OTgyMzI2MzI=",
      "title": "Add code samples for digest headers",
      "url": "https://github.com/httpwg/http-extensions/issues/938",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect \r\n\r\nTo have code samples for digest headers",
      "createdAt": "2019-09-25T11:46:48Z",
      "updatedAt": "2019-09-27T17:20:36Z",
      "closedAt": "2019-09-27T17:20:36Z",
      "comments": []
    },
    {
      "number": 942,
      "id": "MDU6SXNzdWU1MDA3ODkxODg=",
      "title": "Header for considering the request body as part of the cache key",
      "url": "https://github.com/httpwg/http-extensions/issues/942",
      "state": "OPEN",
      "author": "asbjornu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As requested by @reschke in httpwg/http-core#250, I'm creating an issue for the specification of a header that signifies to cache intermediaries that the request body should be a part of the cache key so the response from a `POST` request can be cached safely.\r\n\r\nAs I discussed in the HTTP Workshop in May, `GET` with a body is in use by large vendors such as Elasticsearch (see elastic/elasticsearch#16024) and their interpretation of the spec being that this is \"just fine\" (see https://github.com/elastic/elasticsearch-php/issues/737#issuecomment-378590773). Language is hopefully being added to the spec that makes this not seem \"just fine\" anymore, but I think we also need to provide a solution to the specific problem of not wanting to jam JSON into a URL to be able to use the `GET` keyword. `POST` should therefore be usable with search-like semantics without sacrificing caching.",
      "createdAt": "2019-10-01T09:56:09Z",
      "updatedAt": "2019-10-01T09:56:09Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 943,
      "id": "MDU6SXNzdWU1MDA3OTI3NDM=",
      "title": "SEARCH method",
      "url": "https://github.com/httpwg/http-extensions/issues/943",
      "state": "CLOSED",
      "author": "asbjornu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As requested by @reschke in httpwg/http-core#250, I'm creating an issue for the specification of the `SEARCH` method as an alternative to `POST`, making search requests safe, idempotent and cacheable.\r\n\r\nAs discussed in the HTTP Workshop in May, `GET` requests with a body is in use by large vendors such as Elasticsearch (see elastic/elasticsearch#16024) and their interpretation of the spec being that this is \"just fine\" (see https://github.com/elastic/elasticsearch-php/issues/737#issuecomment-378590773). Language is hopefully being added to the spec that makes this not seem \"just fine\" anymore, but I think we also need to provide a solution to the specific problem of not wanting to jam JSON into a URL to be able to use the `GET` keyword.\r\n\r\nWhile `POST` with the header defined in #942 would help, `POST` is still an unsafe method that poorly reflects the safe, idempotent semantics of search-like operations. I therefore argue that a a `SEARCH` method is needed to have a safe, idempotent method with explicit caching support, in opposition to `POST` which explicitly is **not cacheable**.\r\n\r\nThe [current draft](https://tools.ietf.org/html/draft-snell-search-method-01) for `SEARCH` is written by @jasnell, but I hope he would be willing to hand over the spec to someone else.",
      "createdAt": "2019-10-01T10:02:26Z",
      "updatedAt": "2020-08-11T02:45:36Z",
      "closedAt": "2020-08-11T02:45:36Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure that an issue is the right way to track this, because this would be a substantial new addition to a draft that's not actually supposed to define anything new.  I would think the right venue for this is reviving the draft and/or writing a new one that succeeds it, then taking it to the working group for potential adoption.",
          "createdAt": "2019-10-09T17:45:46Z",
          "updatedAt": "2019-10-09T17:45:46Z"
        },
        {
          "author": "jasnell",
          "authorAssociation": "NONE",
          "body": "Absolutely willing to hand it over! Would love to see this move forward, just don't have any time to move it forward myself.",
          "createdAt": "2019-10-09T17:47:41Z",
          "updatedAt": "2019-10-09T17:47:41Z"
        },
        {
          "author": "asbjornu",
          "authorAssociation": "NONE",
          "body": "@MikeBishop, this issue got a reply from both you and @jasnell, so I'd say its creation is an absolute success so far! \ud83c\udf89 \ud83d\ude04 I agree it needs proper stewardship, though, so now that James has agreed to hand it over, we \"just\" need someone who knows how to write an I-D to take it and to do exactly as you suggest and revive/rewrite the draft.",
          "createdAt": "2019-10-10T09:46:47Z",
          "updatedAt": "2019-10-10T09:46:47Z"
        },
        {
          "author": "mitar",
          "authorAssociation": "NONE",
          "body": "I think `SEARCH` is to specific. What about `FETCH` or `RETRIEVE`?",
          "createdAt": "2020-07-16T00:53:46Z",
          "updatedAt": "2020-07-16T00:53:46Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "See https://github.com/httpwg/admin/issues/2. ",
          "createdAt": "2020-08-11T02:45:36Z",
          "updatedAt": "2020-08-11T02:45:36Z"
        }
      ]
    },
    {
      "number": 945,
      "id": "MDU6SXNzdWU1MDI5NDg4OTU=",
      "title": "EU Cookie Law: Mechanisms enabling user agents to aid in compliance absent",
      "url": "https://github.com/httpwg/http-extensions/issues/945",
      "state": "CLOSED",
      "author": "ttacker",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "A European Union (EU) [directive](https://en.wikipedia.org/wiki/Directive_(European_Union)) requires member states to achieve a result, without dictating specific means. In contrast, EU [regulations](https://en.wikipedia.org/wiki/EPrivacy_Regulation_(European_Union)) are binding law in all member states. Recital 25 of the Preamble and Article 5(3) of the [ePrivacy Directive](https://en.wikipedia.org/wiki/Privacy_and_Electronic_Communications_Directive_2002) (ePD)--often referred to as the EU Cookie Law--regulate the use of cookies. The [ePrivacy Regulation](https://en.wikipedia.org/wiki/EPrivacy_Regulation_(European_Union)) (ePR) is expected to repeal and replace the ePD in 2019, but it's expected the ePR will regulate the use of cookies in substantially the same manner as the ePD.\r\n\r\nTo paraphrase [one summary](https://www.iubenda.com/en/help/5525-cookies-gdpr-requirements), the EU Cookie Law requires the following:\r\n\r\n- Unless an exempt type of cookie, informed consent, based on explicit affirmative action, before storing a cookie on the user's device.\r\n- Conspicuously providing the option for obtaining informed consent.\r\n- A means for withdrawal of consent.\r\n- Ability to prove consent occurred, even if subsequently withdrawn.\r\n- A guarantee, via prior blocking, no tracking performed before consent.\r\n- Informing users of the use of third-party cookies.\r\n- Stating the category and purpose of third-party cookies, even if not listed individually.\r\n- Linking to relevant third-party privacy/cookie policies.\r\n\r\n[RFC 6265](https://www.rfc-editor.org/info/rfc6265) doesn't include mechanisms enabling user agents to aid in compliance with the above requirements, and this has resulted in presentation of inconsistently placed, and inconsistently formatted, cookie banners worldwide. Such inconsistency degrades user experience, works against conspicuousness, and is annoying to the point that some have attempted to create [workarounds](https://cookiesok.com/) to address the lack of desired user agent functionality. Internet Draft (I-D) [draft-ietf-httpbis-rfc6265bis](https://datatracker.ietf.org/doc/draft-ietf-httpbis-rfc6265bis/) proposes to obsolete RFC 6265; however, it also fails to address the issues raised above.\r\n\r\nAttributes, such as the following, could be added to the Set-Cookie Header:\r\n\r\n- Category (Allows grouping for purpose of category consent.)\r\n- Purpose (Provides information to ensure consent is informed.)\r\n- Exempt (Informs user agent not to prompt for consent.)\r\n- Third-Party (Informs user agent to label cookie as third-party.)\r\n- Policy (Allows linking to third-party privacy/cookie policy.)\r\n\r\nEach user agent could then prompt users for consent in a consistent manner across all servers that implement the standard. Consent could be requested individually, for all cookies all at the same time, or selectively (depending on capabilities of the user agent.)\r\n\r\nIf permissible, such attributes may eventually enable user agents to allow users to provide advance consent, via settings, for selected categories of cookies, for selected purposes, on selected domains. A list of allowable categories and purposes may also need to be standardized before anything other than the ability to accept all cookies for selected domains would be feasible.\r\n\r\nDue to the requirement that servers be able to prove consent occurred, user agents would need to be required to provide a response to that effect, and servers would need to be able to reliably assume requested cookies were not stored if no such response is received. Servers would need a mechanism to ensure older user agents don't automatically store the cookies without prompting for consent, as the existing Set-Cookie Header would be used.\r\n\r\nI'm not yet sure what withdrawal of consent might look like.",
      "createdAt": "2019-10-05T10:57:17Z",
      "updatedAt": "2019-10-06T00:27:03Z",
      "closedAt": "2019-10-06T00:27:03Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hi Timothy,\r\n\r\nThanks for writing that up (and welcome to the group). Personally, I agree very much and have been talking to some folks about doing something like this as an extension to cookies. \r\n\r\nHowever, while there is an emerging set of values that are commonly used on sites -- which is great -- they won't be effective unless they're closely tied into the relevant legislation, and that means a fair amount of work, and engagement with all of the relevant parties.\r\n\r\nPrevious experience (e.g., P3P, DNT) has shown that doing so takes a considerable amount of time, and has a non-trivial amount of associated risk. Getting buy-in to this approach from the legislative bodies / regulators beforehand can lend considerable weight (which was lacking in both of those examples), so personally my focus is on educating those folks that this is possible, before actually specifying it.\r\n\r\nBeyond all that, the scope of work for 6265bis was pretty tightly constrained when we started it; we nominated a set of drafts (linked to [here](https://github.com/httpwg/http-extensions#rfc6265bis)) that were to be included, along with various errata and bug fixes. As such, this is out of scope for this draft. \r\n\r\nOn top of that, we've been having trouble meeting those more modest goals, and I'm concerned that adding a significant new feature like this would put the document's delivery at yet more risk.\r\n\r\nSo, I'm closing this issue as out of scope for _this_ draft. That doesn't mean we might not try to tackle it in a different document, under the right conditions. \r\n\r\nThanks for raising it.",
          "createdAt": "2019-10-06T00:27:03Z",
          "updatedAt": "2019-10-06T00:27:03Z"
        }
      ]
    },
    {
      "number": 947,
      "id": "MDU6SXNzdWU1MDQwNTA2OTU=",
      "title": "Variants draft has expired",
      "url": "https://github.com/httpwg/http-extensions/issues/947",
      "state": "CLOSED",
      "author": "clelland",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It looks like the latest draft, https://tools.ietf.org/html/draft-ietf-httpbis-variants-05, has expired (and references an expired draft of Structured Headers itself)\r\n\r\nShould a new version be published at this point?\r\n@mnot ",
      "createdAt": "2019-10-08T13:39:34Z",
      "updatedAt": "2019-10-08T22:27:32Z",
      "closedAt": "2019-10-08T22:27:32Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes, working on both for IETF106.",
          "createdAt": "2019-10-08T22:27:32Z",
          "updatedAt": "2019-10-08T22:27:32Z"
        }
      ]
    },
    {
      "number": 948,
      "id": "MDU6SXNzdWU1MDQ0ODk4NzU=",
      "title": "Digest Headers: artwork line too long",
      "url": "https://github.com/httpwg/http-extensions/issues/948",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers",
        "editorial"
      ],
      "body": "## I expect\r\n\r\nno warnings in builds\r\n\r\n## Instead\r\n\r\nI got\r\n\r\n```\r\n\r\nWARNING: The following anchor names may collide with internally generated anchors in XML2RFCV3 mode because: a-client-requests-an-unsupported-digest-the-server-may-reply-with-an-unsupported-digest (at line 699), a-client-requests-an-unsupported-digest-the-server-may-reply-with-a-400 (at line 723)\r\nWARNING: artwork line too long: '   qvalue = ( \"0\"\u2002 [ \".\"\u2002 0*1DIGIT ] )\u2003/\u2002 ( \"1\"\u2002 [ \".\"\u2002 0*1( \"0\" ) ] )' (70 characters) (at line 421)\r\nWARNING: artwork line too long: '   Digest: id-sha-512=WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm+AbwAgBWnrIiYllu7BNNyealdVLvRwE\\nmTHWXvJwew==' (112 characters) (at line 486)\r\nWARNING: artwork line too long: '   Digest: sha-256=4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=, id-sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=' (120 characters) (at line 486)\r\nWARNING: artwork line too long: 'Digest: sha-256=4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=, id-sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=' (117 characters) (at line 662)\r\nWARNING: artwork line too long: 'Digest: id-sha-512=WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm+AbwAgBWnrIiYllu7BNNyealdVLvRwE\\nmTHWXvJwew==' (109 characters) (at line 713)\r\nWARNING: artwork line too long: '# Out: Identity encoding, sha256 4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=' (77 characters) (at line 1377)\r\nWARNING: artwork line too long: 'print(\"Brotli encoding, sha256\", digest(item, encoding=brotli.compress))' (72 characters) (at line 1377)\r\nWARNING: artwork line too long: '# Out: Brotli encoding, sha256 4REjxQ4yrqUVicfSKYNO/cF9zNj5ANbzgDZt3/h3Qxo=' (75 characters) (at line 1377)\r\nWARNING: artwork line too long: 'print(\"Identity encoding, sha512\", digest(item, algorithm=hashlib.sha512))' (74 characters) (at line 1377)\r\nWARNING: artwork line too long: '# Out: Identity encoding, sha512 b'WZDPaVn/7XgHaAy8pmojAkGWoRx2UFChF41A2svX+TaPm+AbwAgBWnrIiYllu7BNNyealdVLvRwE\\nmTHWXvJwew==\\n'' (128 characters) (at line 1377)\r\n(cat draft-ietf-httpbis-digest-headers.htmltmp;echo) | sed -f lib/addstyle.sed > draft-ietf-httpbis-digest-headers.html\r\n```\r\n\r\n## Notes\r\n\r\ncheck if that's fixable or not.",
      "createdAt": "2019-10-09T08:18:53Z",
      "updatedAt": "2020-03-04T23:44:52Z",
      "closedAt": "2020-03-04T23:44:51Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks like you have figures/examples that are too long.  You'll need to manually line wrap them.",
          "createdAt": "2019-10-11T18:56:40Z",
          "updatedAt": "2019-10-11T18:56:40Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed in #1086 ",
          "createdAt": "2020-03-04T23:44:51Z",
          "updatedAt": "2020-03-04T23:44:51Z"
        }
      ]
    },
    {
      "number": 949,
      "id": "MDU6SXNzdWU1MDQ1MTk2Nzk=",
      "title": "Digest and Caching",
      "url": "https://github.com/httpwg/http-extensions/issues/949",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nTo clarify relations between Digest and Caching.\r\n\r\n- [x] #936 \r\n- [x] #940 \r\n\r\nMoreover address  Digest behavior with:\r\n\r\n- [x]  `If-Modified-Since` and `304` with an empty body: do we have all the relevant metadata to compute and reply with the digest?\r\n- [ ] Intermediary caches",
      "createdAt": "2019-10-09T09:16:01Z",
      "updatedAt": "2020-10-17T11:05:22Z",
      "closedAt": "2020-10-17T11:05:22Z",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot WDYT ^",
          "createdAt": "2019-10-25T15:06:13Z",
          "updatedAt": "2019-10-25T15:06:13Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I need to catch up with this spec -- will comment before Singapore (I hope).",
          "createdAt": "2019-10-28T00:34:00Z",
          "updatedAt": "2019-10-28T00:34:00Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot friendly ping",
          "createdAt": "2020-08-13T13:26:18Z",
          "updatedAt": "2020-08-13T13:26:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Regarding #936, this text is very odd:\r\n\r\n> The resource is specified by the effective request URI and any validator field contained in the message.\r\n\r\nI _think_ [this text](https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#identifying.payload) might help. I.e., you want to say that Digest applies to the selected representation [ref] of the resource corresponding [ref] to the message it occurs within.\r\n\r\n\r\n",
          "createdAt": "2020-08-14T07:27:00Z",
          "updatedAt": "2020-08-14T07:27:00Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke  question: imho if  a server returns  Digest in a \"304 not modified\" response, it must explicit all necessary representation metadata (eg. content-type, content-encoding) used to compute the Digest value. Does it sound reasonable to you? Do we have to state it in the spec?",
          "createdAt": "2020-10-16T20:33:09Z",
          "updatedAt": "2020-10-16T20:33:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "_Please_ avoid re-specifying how other parts of HTTP work -- it only introduces errors.",
          "createdAt": "2020-10-17T00:21:08Z",
          "updatedAt": "2020-10-17T00:21:08Z"
        }
      ]
    },
    {
      "number": 952,
      "id": "MDU6SXNzdWU1MDQ3NTE2ODQ=",
      "title": "Warn about content-location in digest",
      "url": "https://github.com/httpwg/http-extensions/issues/952",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nto mention content-location effects on representations.",
      "createdAt": "2019-10-09T16:11:23Z",
      "updatedAt": "2020-03-01T20:55:54Z",
      "closedAt": "2020-03-01T20:55:54Z",
      "comments": []
    },
    {
      "number": 957,
      "id": "MDU6SXNzdWU1MTAxMTkyMzM=",
      "title": "Not maximum lifetime for server opt-in preferences specified",
      "url": "https://github.com/httpwg/http-extensions/issues/957",
      "state": "CLOSED",
      "author": "amtunlimited",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "The client hint spec does not seem to specify if there's a maximum lifetime for the origin opt-in preferences. There seem to be spec that the data should be cleared when site data, cookies, cache, etc. are cleared, but barring that should there be some sort of reasonable limit?",
      "createdAt": "2019-10-21T16:57:03Z",
      "updatedAt": "2019-12-04T23:29:30Z",
      "closedAt": "2019-12-04T23:29:30Z",
      "comments": [
        {
          "author": "amtunlimited",
          "authorAssociation": "NONE",
          "body": "I'm new to this process; I'm not sure how to add the \"client-hints\" label",
          "createdAt": "2019-10-21T16:57:49Z",
          "updatedAt": "2019-10-21T16:57:49Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson thoughts? You were the one pushing for an implicit lifetime. Do we want to cap it?",
          "createdAt": "2019-11-18T11:04:49Z",
          "updatedAt": "2019-11-18T11:04:49Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that what you should say is that the browser can discard this state, but it should do so only when it drops all other state for the origin (e.g., when clearing cookies).  Modeling this as part of origin-bound state like that is far easier to reason about and more reliable for sites.",
          "createdAt": "2019-11-19T09:52:38Z",
          "updatedAt": "2019-11-19T09:52:38Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We already have \"Implementers SHOULD support Client Hints opt-in mechanisms and MUST clear persisted opt-in preferences when any one of site data, browsing history, browsing cache, or similar, are cleared.\"\r\n\r\nDo we need to also add something around origin-bound state to that?",
          "createdAt": "2019-11-19T10:01:16Z",
          "updatedAt": "2019-11-19T10:01:16Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "As Safari is already capping script-set storage lifetime to 7 days (Brave does w/ cookies, plans to do for all storage too), and some other vendors have hinted at the same, I suggest a max lifetime of 7 days.\r\n\r\nEspecially given the possibility that these values can be tracking vectors (discussed in the fingerprinting conversation).",
          "createdAt": "2019-11-21T16:19:27Z",
          "updatedAt": "2019-11-21T16:19:27Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The text above means that browsers that choose to set max lifetime to storage/cookies will MUST do the same for Client Hints. I don't think we need to bake in the specific max age that some UAs chose into an IETF draft.",
          "createdAt": "2019-11-22T06:11:18Z",
          "updatedAt": "2019-11-22T06:11:18Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "I hear what you're saying, but the purpose of a standard is not to say \"some people will act X and some folks will act Y\", its to bring X and Y as close as possible.  What is the use case for a lifetime of > 7 days?  Like any cache value, its perf utility decreases as life time increases, but the privacy risk stays constant.\r\n\r\nPut differently, what is the concern w/ a maximum value, to at least partially constrain the privacy risk?",
          "createdAt": "2019-11-22T22:23:22Z",
          "updatedAt": "2019-11-22T22:23:22Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds like the restriction you're talking about is of larger scope than Client Hints, and applies the origin storage in general. I suggest you'd try to enforce those specific values e.g. on session cookies, and Client Hints will follow out of that.\r\n\r\nAt the same time, I was under the impressions that when we [removed the explicit lifetime](https://github.com/httpwg/http-extensions/pull/878), we tied the lifetime of Client-Hints persistence to session cookies, but looks like we did not. I'll submit a PR on that front.\r\n",
          "createdAt": "2019-11-28T10:36:40Z",
          "updatedAt": "2019-11-28T10:36:40Z"
        }
      ]
    },
    {
      "number": 958,
      "id": "MDU6SXNzdWU1MTA0OTg5OTE=",
      "title": "Error responses digest is computed on the error message",
      "url": "https://github.com/httpwg/http-extensions/issues/958",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nthe digest of an error response is computed on the error message\r\n\r\n## Note\r\n\r\nthat's because representation metadata of the response - which is required for computing digest - is related to the enclosed representation",
      "createdAt": "2019-10-22T08:18:32Z",
      "updatedAt": "2020-03-04T23:45:30Z",
      "closedAt": "2020-03-04T23:45:30Z",
      "comments": []
    },
    {
      "number": 960,
      "id": "MDU6SXNzdWU1MTEwODYyMTk=",
      "title": "\"destination\" vs. \"next hop\"",
      "url": "https://github.com/httpwg/http-extensions/issues/960",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "proxy-status"
      ],
      "body": "In some places, we talk about an error caused by something related to the destination failing, and sometimes it's about the \"next hop.\" \r\n\r\nWe should think about this, at the least, and probably make it consistent.",
      "createdAt": "2019-10-23T05:39:16Z",
      "updatedAt": "2019-10-25T04:31:15Z",
      "closedAt": "2019-10-25T04:31:15Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think this is better; happy to revisit.",
          "createdAt": "2019-10-25T04:31:15Z",
          "updatedAt": "2019-10-25T04:31:15Z"
        }
      ]
    },
    {
      "number": 961,
      "id": "MDU6SXNzdWU1MTIzMTU0NDc=",
      "title": "SH nits",
      "url": "https://github.com/httpwg/http-extensions/issues/961",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "* [x] inner-list ABNF specifies single SP, but parsing eats OWS\r\n* [x] token doesn't allow +, which is common in media types. Other chars too?\r\n* [x] explicitly talk about parameter extensibility\r\n* [x] revise authoring advice\r\n* [x] check all examples for parseability\r\n* [x] summarise the relationships between the datatypes (e.g., in an intro subsection)\r\n",
      "createdAt": "2019-10-25T05:45:00Z",
      "updatedAt": "2019-11-27T05:46:02Z",
      "closedAt": "2019-11-27T05:46:02Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@phluid61 was it you that pointed out the first bullet above? I remember a conversation about it, but I don't remember where it was. Simple fix is to change to `1*SP`, I think...",
          "createdAt": "2019-10-26T21:20:01Z",
          "updatedAt": "2019-10-26T21:20:01Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep it was me, in a [comment in PR 954](https://github.com/httpwg/http-extensions/pull/954#pullrequestreview-299752981). The algorithm currently accepts `SP OWS`.",
          "createdAt": "2019-10-27T23:27:56Z",
          "updatedAt": "2019-10-27T23:27:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "`SP OWS` sounds most consistent with what's already there. Thanks.",
          "createdAt": "2019-10-28T07:13:30Z",
          "updatedAt": "2019-10-28T07:13:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Since `token` is required to start with `ALPHA`, is there any reason we can't just allow [all RFC7230 `token` characters](https://httpwg.org/specs/rfc7230.html#rule.token.separators) after that? ",
          "createdAt": "2019-10-28T07:26:00Z",
          "updatedAt": "2019-10-28T07:26:00Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "`tchar` doesn't include slash `/` or colon `:`",
          "createdAt": "2019-10-30T03:19:47Z",
          "updatedAt": "2019-10-30T03:20:34Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Good catch.",
          "createdAt": "2019-10-30T03:41:07Z",
          "updatedAt": "2019-10-30T03:41:07Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Having to include separators kinda highlights the fact that we're using sh-token for things that are a bit more structured.",
          "createdAt": "2019-10-30T03:49:51Z",
          "updatedAt": "2019-10-30T03:49:51Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Re: Point 1: it looks like the ABNF allows OWS before the closing ')' on an inner list, but the parsing algorithm only accepts a single SP ([Parsing an inner list](https://github.com/httpwg/http-extensions/blob/master/draft-ietf-httpbis-header-structure.md#parsing-an-inner-list-parse-innerlist), step 3.v)",
          "createdAt": "2019-11-05T18:57:48Z",
          "updatedAt": "2019-11-05T18:57:48Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "You want to add this?\r\n\r\n```\r\ninner-list = \"(\" OWS [ sh-item *( SP OWS sh-item ) [ SP OWS ] ] \")\" *parameter\r\n                                                   ^^^^     ^\r\n```",
          "createdAt": "2019-11-07T04:58:59Z",
          "updatedAt": "2019-11-07T04:58:59Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why at the end and not also at the beginning?",
          "createdAt": "2019-11-07T08:45:12Z",
          "updatedAt": "2019-11-07T08:45:12Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "It's after an sh-item. The algorithm is: OWS, item, space-or-paren, goto 1.\r\n\r\nAt this point it's probably easier and more sensible to just add HTAB to the allowed characters in 3.v, and change the ABNF to\r\n`\"(\" OWS [ sh-item *( RWS sh-item ) OWS ] \")\"`",
          "createdAt": "2019-11-07T11:23:36Z",
          "updatedAt": "2019-11-07T11:23:36Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@phluid61, yes, the issue was that the ABNF looks like\r\n`inner-list    = \"(\" OWS [ sh-item *( SP OWS sh-item ) OWS ] \")\" *parameter`\r\n\r\nbut what is actually parsed by [Parsing an inner list](https://github.com/httpwg/http-extensions/blob/master/draft-ietf-httpbis-header-structure.md#parsing-an-inner-list-parse-innerlist) is\r\n\r\n`inner-list    = \"(\" OWS [ sh-item *( SP OWS sh-item ) [ SP OWS ] ] \")\" *parameter`\r\n\r\nYour ABNF makes sense to me; I'd update the algorithm to match. Requiring OWS to begin with SP seems like a pretty arbitrary restriction.\r\n",
          "createdAt": "2019-11-07T14:33:02Z",
          "updatedAt": "2019-11-07T14:33:02Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Just noticed that the algorithms for token don't account for `:` or `/` \u2013 they only refer to `tchar`",
          "createdAt": "2019-11-12T04:32:52Z",
          "updatedAt": "2019-11-12T04:32:52Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "_yep, I had that queued up... :)_\r\n\r\n- [x] variable names should be consistent about `-` vs `_`\r\n- [x] failing parse or serialisation should always have a usable reason phrase\r\n- [x] 4.2.4 still refers to a range, rather than inlining it. This needs to be consistent.\r\n- [x] token parse and serialise refer to tchar, which isn't all chars allowed",
          "createdAt": "2019-11-12T05:16:10Z",
          "updatedAt": "2019-11-12T09:03:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "- [x] at one point we also talked about renaming `Float` to `Decimal` -- thoughts?",
          "createdAt": "2019-11-12T05:55:07Z",
          "updatedAt": "2019-11-27T05:45:52Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As I advocated for at the meeting, fixed-point decimal is far less likely to run into those issues.  But apparently all that discussion at the meeting can be trumped by the fact that a floating point number has a larger dynamic range.\r\n\r\nSo seconds with nanosecond resolution needs 9 decimal places, but it can't do a large enough span of time to be useful as an absolute measure.  I tend to think that that use case might be worth losing and that even 6 decimal places is a bit of a stretch.  Or, if these are important enough, they can choose not to use SH.",
          "createdAt": "2019-11-12T06:08:26Z",
          "updatedAt": "2019-11-12T06:08:26Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed-point decimal lacks the only advantage that floats have over integers, which is the dynamic range. If your header field doesn't need the dynamic range, use an integer \u2013 change it from 'seconds' to 'microseconds' if that's what's needed.  (Also, can't do nanoseconds; precision starts at nine-point-six.)\r\n\r\nWRT the name, as I mentioned elsewhere it might be valuable giving all the types names that don't map so closely to native types in common languages, to emphasise that SH types are actually different.",
          "createdAt": "2019-11-12T08:20:26Z",
          "updatedAt": "2019-11-12T08:20:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Suggestions for names welcome.",
          "createdAt": "2019-11-12T09:14:03Z",
          "updatedAt": "2019-11-12T09:14:03Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> So seconds with nanosecond resolution needs 9 decimal places,\r\n\r\nDonning my \"Famous Faulty Predictins\" hat, I will argue that there are not enough relevant needs for nano-seconds in HTTP headers to let that influence the design of SH.\r\n\r\nI think caling the type \"Decimal\" instead of \"Float\" is not a bad idea.",
          "createdAt": "2019-11-12T10:52:58Z",
          "updatedAt": "2019-11-12T10:52:58Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Anyone against changing Float to Decimal?",
          "createdAt": "2019-11-13T22:14:37Z",
          "updatedAt": "2019-11-13T22:14:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Decimal now being discussed in #982.",
          "createdAt": "2019-11-27T05:45:47Z",
          "updatedAt": "2019-11-27T05:45:47Z"
        }
      ]
    },
    {
      "number": 962,
      "id": "MDU6SXNzdWU1MTIzNTA4NTg=",
      "title": "Hints aren't free",
      "url": "https://github.com/httpwg/http-extensions/issues/962",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Enabling a client hint adds a number of bytes to every request.  With HPACK, that might eventually be as little as 1 byte, but this isn't free.  The draft should recognize this cost and caution against turning everything into a hint.",
      "createdAt": "2019-10-25T07:27:32Z",
      "updatedAt": "2019-11-19T15:53:47Z",
      "closedAt": "2019-11-19T15:53:47Z",
      "comments": []
    },
    {
      "number": 963,
      "id": "MDU6SXNzdWU1MTIzNTMwNjU=",
      "title": "Specific hints might not be useful on all requests",
      "url": "https://github.com/httpwg/http-extensions/issues/963",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Client hints might be most useful in some types of requests and not others.  Clients might choose to limit which hints are sent with requests based on contextual information.\r\n\r\nFor instance, hints that apply to presentation like DPR are less applicable to resource loads for javascript or json objects.  Though I'm sure that someone can come up with a use case for almost anything in almost any context, the cost (#962), small as it might be, is probably not always justified in the aggregate.  So the draft should probably say that *for a given hint* opting in to clients hints might be either:\r\n\r\n1. constrained by the UA to apply only to similar requests to the one where the hint has been requested, or \r\n\r\n2. only sent for requests made from a specific application context.\r\n\r\nFor (1), this is something that can be applied generically in specifications (like the fetch spec).\r\n\r\nFor (2), the definition of each client hint might provide suggestions.\r\n\r\nThis is probably something that the fetch specification changes need to consider more carefully, but this specification might lay some groundwork for that.",
      "createdAt": "2019-10-25T07:33:18Z",
      "updatedAt": "2019-12-04T15:09:44Z",
      "closedAt": "2019-12-04T15:09:44Z",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> 1. constrained by the UA to apply only to similar requests to the one where the hint has been requested, or\r\n\r\nClient Hint opt-ins are only applicable on top-level navigation responses, (due to privacy and simplicity considerations), so that doesn't seem feasible.\r\n\r\n\r\n\r\n> For (2), the definition of each client hint might provide suggestions.\r\n\r\nThat makes sense, and we can add some text to this draft to indicate that they can. (and as you say, have some Fetch flag that enables features to enable/disable CH for certain request destinations)",
          "createdAt": "2019-11-05T15:59:40Z",
          "updatedAt": "2019-11-05T15:59:40Z"
        },
        {
          "author": "eeeps",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Re: adding destination/context to the opt-in model...\r\n\r\nShould this be something that the...\r\n\r\n1. ...definition of the hint decides (e.g., the DPR hint definition would mandate that it is only sent for fetches whose destination is \"image\" or \"video\")\r\n2. ...UA decides, contextually\r\n3. ...author decides, as a part of their opt-in\r\n\r\n?\r\n\r\nI'd argue for a set of specified defaults (1), which authors can override to meet their edge cases, if need be (3). I'm having a hard time thinking through how the UA would make this decision on its own (2).",
          "createdAt": "2019-11-22T19:53:45Z",
          "updatedAt": "2019-11-22T19:53:45Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@eeeps - I don't think that we need to dive into those details in the IETF draft, but I imagined something along the line of (1). (3) seems to throw complexity on the syntax/user, so I'd love to see concrete use cases before we go that route.\r\n\r\nThis was closed by https://github.com/httpwg/http-extensions/pull/985, but I don't have permissions to actually close it... @igrigorik - can you click the button?",
          "createdAt": "2019-12-04T11:17:27Z",
          "updatedAt": "2019-12-04T11:17:27Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Yep, resolving.",
          "createdAt": "2019-12-04T15:09:44Z",
          "updatedAt": "2019-12-04T15:09:44Z"
        }
      ]
    },
    {
      "number": 967,
      "id": "MDU6SXNzdWU1MTU0NzU1NDU=",
      "title": "\"Digest can be used in requests too. Returned value depends on the representation metadata header fields.\"",
      "url": "https://github.com/httpwg/http-extensions/issues/967",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ioggstream",
        "LPardue"
      ],
      "labels": [
        "digest-headers"
      ],
      "body": "There are two occurences of the fragment\r\n\r\n> Digest can be used in requests too. Returned value depends on the representation metadata header fields.\r\n\r\nThis is not the most helpful of statements, when we say \"returned value\" what exactly are we trying to convey. I think it would help to be a bit more exact.",
      "createdAt": "2019-10-31T14:25:46Z",
      "updatedAt": "2019-11-03T11:02:51Z",
      "closedAt": "2019-11-03T11:02:51Z",
      "comments": []
    },
    {
      "number": 968,
      "id": "MDU6SXNzdWU1MTU0OTE4OTM=",
      "title": "A client requests an unsupported Digest, the server MAY reply with a 400",
      "url": "https://github.com/httpwg/http-extensions/issues/968",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "I think this example demonstrates the under specification of the Want-Digest header. Does it work as \r\n\r\n1. A discovery mechanism that allows the client to probe the server for the set of digests it supports (client and server specifically)\r\n2. A unilateral advertisement of the algorithms supported by the sending endpoint\r\n\r\n\r\n\r\nBut to try and understand if it is 1) or 2) I see nothing in RFC 3230 that prescribes behaviour like this but I may well have missed it. Either way I don't think we should be putting normative text (MAY reply) in the section header. \r\n\r\nSo lets decouple things.\r\n\r\nI'm assuming in this example case that we operate under the model that server is allowed to respond with a 4xx under any circumstance. But specifically in this case the server is unwilling to accept requests with `sha` algorithm.\r\n\r\nThen next it advertises the list of algorithms it can generate? In which case, a header names Want-Digest is not very inutuitive. It seems to act asymmetrically, while we are expending a lot of effort to understand and describe how Digest can be used in Request and Response.",
      "createdAt": "2019-10-31T14:47:06Z",
      "updatedAt": "2020-08-24T14:04:59Z",
      "closedAt": "2020-08-24T14:04:59Z",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't think we should be putting normative text (MAY reply) in the section header.\r\n\r\nagree, will fix it after IETF106.\r\n\r\n> I see nothing in RFC 3230 that prescribes behaviour like this\r\n\r\nit's not a prescribed behavior, as rfc3230 is not very rigid.\r\nimho it's a possibility which we have in rfc3230 that we may use to implement some sort of negotiation. \r\n\r\nthe alternative would be that the server responds with a sha-256 digest \r\nthat the client won't be able to process, as cited in rfc3230#4.3.2\r\n\r\n> A sender MAY send an instance-digest using a digest-algorithm without\r\n   knowing whether the recipient supports the digest-algorithm, or even\r\n   knowing that the recipient will ignore it",
          "createdAt": "2019-10-31T15:39:22Z",
          "updatedAt": "2019-10-31T15:39:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": " > imho it's a possibility which we have in rfc3230 that we may use to implement some sort of negotiation.\r\n\r\nOur job with this draft is to update the status quo. So we need to be really careful not create new modes or capabilities, especially if they end up being somehow incompatible with how people actually use Want-Digest today. So my problem is that this example is quite suggestive of a protocol design aspect but has no useful text. And trying to write up negotiation is likely to hit barriers or just be ignored in extant deployments.  \r\n\r\nI'd be happier with a separate example that shows a 4xx response that includes the digest of the error body (i.e. the returned error page). I'd be happy with a stand alone example that shows a request with Want-Digest and a response that includes no Digest and no Want-Digest  because of the algorithm mismatch. \r\n\r\nGiven the timeframes lets punt this to IETF 106.",
          "createdAt": "2019-10-31T17:55:55Z",
          "updatedAt": "2019-10-31T17:55:55Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This also relates to \r\n\r\n> 6. What changes in `Want-Digest`?\r\n\r\n>   We allow to use the `Want-Digest` in responses to advertise the supported digest-algorithms\r\n   and the inability to accept requests with unsupported digest-algorithms.",
          "createdAt": "2019-10-31T18:42:29Z",
          "updatedAt": "2019-10-31T18:42:29Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The current situation on this thread:\r\n\r\n- we did not add further normative parts on want-digest\r\n\r\n> a stand alone example that shows a request with Want-Digest and a response that includes no Digest and no Want-Digest because of the algorithm mismatch.\r\n\r\n- we have examples showing two legitimate ways of managing unsupported algorithms in a way which is similar to the [Negotiation of Content-MD5](https://tools.ietf.org/html/rfc3230#section-5) proposed in RFC3230. Moreover Digest Negotiation is one of the goal of RFC3230: \r\n   * one ignoring Want-Digest and returning 200 + Digest (WRT the client, this is exactly the same of returning no Digest), \r\n   * one returning the supported Want-Digest algorithms with a 400 error\r\n\r\n\r\n> I'd be happier with a separate example that shows a 4xx response that includes the digest of the error body (i.e. the returned error page). \r\n\r\n- we have another example showing that Digest of error responses refers to the error payload\r\n\r\nAbout what changes in Want-Digest: probably the only thing is the deprecation of contentMD5, because all the examples describe behaviors which are legitimante under RFC3230",
          "createdAt": "2020-08-18T09:02:05Z",
          "updatedAt": "2020-08-18T09:16:06Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> About what changes in Want-Digest: probably the only thing is the deprecation of contentMD5, because all the examples describe behaviors which are legitimante under RFC3230\r\n\r\nIIUC all we need to do is update the example `Want-Digest: SHA-512;q=0.3, sha-256;q=1, md5;q=0` to remove/replace the `md5` algorithm. I don't think we need to explicitly mention this because the example is non-normative, and the deprecation of MD5 is already covered. Or maybe I'm misunderstanding?",
          "createdAt": "2020-08-18T09:16:57Z",
          "updatedAt": "2020-08-18T09:16:57Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just added that `md5;q=0` to express that the sender does not want md5, but un case this creates confusion I replaced it with `unixsum;q=0` in #1249 \r\n",
          "createdAt": "2020-08-18T10:39:16Z",
          "updatedAt": "2020-08-18T11:52:26Z"
        }
      ]
    },
    {
      "number": 970,
      "id": "MDU6SXNzdWU1MTU2MTI4MTM=",
      "title": "the request method should not vary the digest semantic",
      "url": "https://github.com/httpwg/http-extensions/issues/970",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## Uniform digest request semantic\r\n\r\nWhile discussing #923 @reschke made the following consideration\r\n\r\n> I just don't think that it would be a good idea to vary the semantics based on the request method. \r\n\r\nIn this issue we will gather some examples and considerations so that we can state that \r\ndigest in requests is always computed on the request body.",
      "createdAt": "2019-10-31T17:25:47Z",
      "updatedAt": "2020-09-09T10:26:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Does this need fixing, or can we close with no action?",
          "createdAt": "2020-08-13T13:29:41Z",
          "updatedAt": "2020-08-13T13:29:41Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll add a FAQ and close.",
          "createdAt": "2020-08-17T15:26:20Z",
          "updatedAt": "2020-08-17T15:26:20Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IMHO: we should find a better name for this issue.\r\n\r\n- the digest semantic is always the same: digest is computed on the selected resource representation data;\r\n- digest computation depends on method and headers, because they alter the meaning of the payload body (eg. with partial representations).\r\n\r\n",
          "createdAt": "2020-09-09T10:26:44Z",
          "updatedAt": "2020-09-09T10:26:44Z"
        }
      ]
    },
    {
      "number": 973,
      "id": "MDU6SXNzdWU1MTY2ODIzMDY=",
      "title": "Add example of unpatched response with its digest.",
      "url": "https://github.com/httpwg/http-extensions/issues/973",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nan example with a  failed PATCH \r\n\r\n## Note\r\n\r\nDepending on the PATCH semantic it may return:\r\n- the Digest and etag of the unpatch item (if that is what happens);\r\n- the Digest of the error.",
      "createdAt": "2019-11-02T18:34:33Z",
      "updatedAt": "2020-01-19T14:47:39Z",
      "closedAt": "2020-01-19T14:47:39Z",
      "comments": []
    },
    {
      "number": 978,
      "id": "MDU6SXNzdWU1MTY5NzQ0NDg=",
      "title": "Secondary Cache Key",
      "url": "https://github.com/httpwg/http-extensions/issues/978",
      "state": "OPEN",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "variants"
      ],
      "body": "Vary concepts are changing in http-core; variants will need to catch up.",
      "createdAt": "2019-11-04T06:17:28Z",
      "updatedAt": "2019-11-04T06:17:28Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 980,
      "id": "MDU6SXNzdWU1MTcwNzE2NDA=",
      "title": "digest examples: explicit base64-encoding",
      "url": "https://github.com/httpwg/http-extensions/issues/980",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nin this example (and other),  \r\n\r\n- https://tools.ietf.org/html/draft-ietf-httpbis-digest-headers-01#section-2\r\n\r\nsomething like that:\r\n\r\n> \u00a0 \u00a0Message body is shown as base64 encoded for representation purpose.\r\n",
      "createdAt": "2019-11-04T10:46:28Z",
      "updatedAt": "2019-11-25T14:04:02Z",
      "closedAt": "2019-11-25T14:04:02Z",
      "comments": []
    },
    {
      "number": 982,
      "id": "MDU6SXNzdWU1MTk0OTAyMjI=",
      "title": "Round-tripping float is still hard",
      "url": "https://github.com/httpwg/http-extensions/issues/982",
      "state": "CLOSED",
      "author": "clelland",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "(Related to now-closed #896)\r\n\r\nShould implementations be able to store parsed floats in IEEE754 binary64? And if so, should we expect that they round trip between parsing and serialization? It seems like the current limits were designed to support that notion, but there are cases where they do not.\r\n\r\n(Note, this isn't about being able to serialize arbitrary C++ doubles; the spec sensibly only supports a tiny subset of all possible 64-bit floats. This is about whether `x == Serialize(Parse(x))` should always be true)\r\n\r\nIEEE 754 guarantees that if a string with no more than 15 digits is converted to a double and then back to a string, it should result in the original string, but that appears to require rounding in some cases; truncation, which the serialization algorithm calls for, can change the string representation.\r\n\r\nParsing the string \"12345678901234.1\" as a float, for instance, results in a binary64 representation with value 0x42a674e79c5fe433, whose exact decimal expansion is 12345678901234.099609375. Following the text of the serialization algorithm, `fractional_digits_avail` will be 1, and so the number will be serialized as \"12345678901234.0\"\r\n\r\nIt appears, as an implementer, that the only way to ensure that a float parsed from a valid string can be serialized back to the original string is to store it as a fixed point decimal in two parts, or else use a float with >64 bits of precision for storage.",
      "createdAt": "2019-11-07T20:19:54Z",
      "updatedAt": "2020-01-08T00:14:48Z",
      "closedAt": "2020-01-08T00:14:48Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Would it be adequate to change truncation to rounding in step 9 of Serializing a Float?",
          "createdAt": "2019-11-07T23:13:05Z",
          "updatedAt": "2019-11-07T23:13:05Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a can of worms. Which rounding? (nearest-or-even, nearest-or-away from zero, to zero, up, down?)",
          "createdAt": "2019-11-08T01:43:18Z",
          "updatedAt": "2019-11-08T01:43:18Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I know nearest-or-even is the recommended rounding technique.  Can we specify that?\r\n\r\n```\r\nirb(main):047:0> 12345678901234.0498046874.round(1)\r\n=> 12345678901234.0\r\nirb(main):048:0> 12345678901234.0498046875.round(1)\r\n=> 12345678901234.1\r\n```",
          "createdAt": "2019-11-08T02:05:18Z",
          "updatedAt": "2019-11-08T02:05:18Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Round, nearest-or-even, to *fractional_digits_avail* digits?\r\n\r\nWhile we're at it, should the spec be stricter about trailing zeros? My implementation currently strips any trailing zeros after the first position past the decimal point (so 1.230000 is serialized as 1.23, but 1.000000 is serialized as 1.0, as is 1.0000001, after rounding/truncation), which passes the test cases in https://github.com/httpwg/structured-header-tests. The spec just says \"at most  *fractional_digits_avail* digits, but that allows multiple \"correct\" serializations of a given float.",
          "createdAt": "2019-11-08T15:24:23Z",
          "updatedAt": "2019-11-08T15:24:23Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's also weird to only require roundtripping for floats that *can* be represented in binary64.\r\n\r\nThe simplest might solution here might be to just accept that floats are lossy. If an implementer needs precision, use a string. This trade-off seems to work well enough for JSON parsers.",
          "createdAt": "2019-11-08T15:38:24Z",
          "updatedAt": "2019-11-08T15:38:24Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It's also weird to only require roundtripping for floats that *can* be represented in binary64. \r\n\r\nThe spec already restricts floats to those which can theoretically be round-tripped into a binary64 and back; this is just about ensuring that that actually happens, if a binary64 is used as the backing store (which is natural for at least C++ and JS implementations)",
          "createdAt": "2019-11-08T20:29:41Z",
          "updatedAt": "2019-11-08T20:29:41Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "nearest-or-even SGTM. Stripping trailing zeros as well as leading ones in the integer component sounds good as well. I'll do a PR...",
          "createdAt": "2019-11-09T03:07:49Z",
          "updatedAt": "2019-11-09T03:07:49Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "PTAL at the commit.\r\n\r\nI've added a test for this (\"tricky precision float\") -- @clelland are you using the tests?\r\n\r\n",
          "createdAt": "2019-11-12T09:31:06Z",
          "updatedAt": "2019-11-12T09:31:06Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "/me reads above - yes you are, sorry for the noise.",
          "createdAt": "2019-11-12T09:31:58Z",
          "updatedAt": "2019-11-12T09:31:58Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I do not think we should make stripping trailing zeros decimal digits a strict requirement, the number of decimals presented can be out-of-band metadata about the actual precision involved.\r\n\r\nFor instace  a timeinterval serialized as 3.0 vs 3.000 vs. 3.000000 might be used to communicate the precision of the measurements as tenths of seconds / milliseconds / microseconds respectively.\r\n\r\nBut we should probably recommend stripping trailing zero decimal digits for bandwidth reasons, if there is no communicative reason to retain them.",
          "createdAt": "2019-11-12T10:49:20Z",
          "updatedAt": "2019-11-12T10:50:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "If someone wants to use the precision of measurement that way, it'd need to be available in all implementations to be interoperable -- i.e., we'd have to require implementations to preserve that precision. \r\n\r\nI'm pretty dubious on that being possible and correctly implemented across the board. E.g., requiring every implementation to parse \"0.42000\" and make the trailing zeros correctly available.\r\n\r\n\r\n\r\n",
          "createdAt": "2019-11-12T21:56:16Z",
          "updatedAt": "2019-11-12T21:56:16Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we're going to round, we probably need to do it before serializing the integer part, since the rounded fractional part may round up to 1.0, as well.",
          "createdAt": "2019-11-14T15:41:41Z",
          "updatedAt": "2019-11-14T15:41:41Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For floats, I think there are two things that we want from this spec (and please let me know if that's not right):\r\n\r\n - Any string which parses as an float can have that float's value stored in a binary64, and serializing that value should reproduce the original string. (modulo some number of 0's at either end)\r\n - Any ~~binary64~~real value (regardless of storage implementation) in the range -(1e14-0.05) to (1e14-0.05), exclusive, should serialize to its closest valid sh-float representation. (rounding ties towards an even least-significant-digit)\r\n\r\nIs that reasonable?",
          "createdAt": "2019-11-14T17:57:54Z",
          "updatedAt": "2019-11-15T15:27:46Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed in Singapore: will discuss on list, but sense in the room is to have a fixed point. Hum in the room prefers fixed point. (Need to still determine number of decimals; q-value uses 3).",
          "createdAt": "2019-11-21T06:44:15Z",
          "updatedAt": "2019-11-21T06:44:15Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Specifically pinging @phluid61 @evert @bsdphk for thoughts re: moving float to fixed-point (straw-man: three digits). This seemed to have strong support in the room, but wanted to make sure you're comfortable with it.",
          "createdAt": "2019-11-27T23:57:41Z",
          "updatedAt": "2019-11-27T23:57:41Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Would fixed point be materially different that what is currently specced? Currently, the spec implies a fixed-point with 6 digits of precision, and a maximum of 15 total digits, which (not at all coincidentally) is the same range that is guaranteed to round trip through an IEEE-754 binary64 representation, which is useful for actual implementations.\r\n\r\nEdit: I see the three-digit difference now; would the integer portion be restricted to 12 digits in that case?",
          "createdAt": "2019-11-28T21:52:27Z",
          "updatedAt": "2019-11-28T21:53:51Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes.",
          "createdAt": "2019-11-28T23:28:04Z",
          "updatedAt": "2019-11-28T23:28:04Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't have a strong opinion on switching to 12+3 fixed; I think it would cover all of the use cases that I can currently imagine (and I'm trying hard to discount any sunk costs from implementing the previous draft :stuck_out_tongue:)\r\n\r\nIf implementation complexity (or perceived complexity) factors in to the decision at all, Chrome's current sh-float serializer, which passes the public test suite, is [here](https://cs.chromium.org/chromium/src/third_party/blink/common/http/structured_header.cc?l=526)",
          "createdAt": "2019-11-29T16:12:41Z",
          "updatedAt": "2019-11-29T16:12:41Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "If people think it's useful to have a fixed-point number, and can settle on the optimal number of digits for most of their use-cases, then \ud83d\udc4d ",
          "createdAt": "2019-11-30T08:36:55Z",
          "updatedAt": "2019-11-30T08:36:55Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The (only!) two \"real\" reason we have float/decimal in the first place is `q=` values and subsecond resolution time-{intervals,stamps}, and the one \"unreal\" reason is that JSON offered that.\r\n\r\nI think `q=` has three decimals, either by norm or convention.\r\n\r\nTime-intervals such as \"process-time for this request\" are often sub-millisecond, and that has by and large been the argument for \"at least six decimals\".\r\n\r\nTime-intervals do not convincingly overcome Gettys 1st rule[1] or Phil Karltons rule[2].\r\n\r\nso 12.3 would be fine with me.\r\n\r\n[1] Do not add new functionality unless an implementor cannot complete a real application without it.\r\n\r\n[2] The only thing worse than generalizing from one example is generalizing from no examples at all.\r\n       \r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-12-02T13:36:54Z",
          "updatedAt": "2019-12-02T13:36:54Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think `q=` has three decimals, either by norm or convention.\r\n\r\nThese days at least, it's by specification.  It's a number in the range 0.000 to 1.000, and all algorithms I know of that use it would be just as well served by an integer from 0 to 1000.  So the only reason to include the dot is if we want to backport existing headers as-is.  Not backporting existing headers was a justification for some decisions earlier on, so if that's been reversed, should we revisit some of those other decisions?",
          "createdAt": "2019-12-02T23:24:58Z",
          "updatedAt": "2019-12-02T23:24:58Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Although thinking more about it, most of the earlier decisions are sort of OBE, so it's maybe not such a big deal.",
          "createdAt": "2019-12-03T01:28:10Z",
          "updatedAt": "2019-12-03T01:28:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "PTAL",
          "createdAt": "2019-12-11T05:57:09Z",
          "updatedAt": "2019-12-11T05:57:09Z"
        }
      ]
    },
    {
      "number": 984,
      "id": "MDU6SXNzdWU1MjEyNDg0MDg=",
      "title": "Top-level serialise",
      "url": "https://github.com/httpwg/http-extensions/issues/984",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "... is written as if you can infer the header type from the type of the input data. That isn't true any more; we probably need something like the parse algo's concept of `header_type`.",
      "createdAt": "2019-11-11T23:44:04Z",
      "updatedAt": "2019-11-13T22:07:02Z",
      "closedAt": "2019-11-13T22:07:02Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Feels like you're edging towards specifying an API.  You _can_ infer header if the types defined in the spec are real bona fide types.  And the mapping between $LANG's array type and SH's List is an API choice.",
          "createdAt": "2019-11-11T23:53:21Z",
          "updatedAt": "2019-11-11T23:53:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes; right now we have this uneasy balance between the two, and it's muddy. I think we need to specify unambiguously while allowing it to be surfaced in different ways.",
          "createdAt": "2019-11-12T00:01:19Z",
          "updatedAt": "2019-11-12T00:01:19Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "oops",
          "createdAt": "2019-11-12T00:02:14Z",
          "updatedAt": "2019-11-12T00:02:14Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I keep mulling over what it would take to define them as actual types, like specifying the sorts of operations that can be performed on them.  For the most part I think it would just add a lot of text for stuff that seems obvious (integers support arithmetic operations \ud83e\udd14) but it might be worthwhile?\r\n\r\nMaybe just giving them silly trademarkable names, like SHList and SHInteger, could help.",
          "createdAt": "2019-11-12T00:10:12Z",
          "updatedAt": "2019-11-12T00:10:12Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I realise that having the spec say \"If the value is an SHToken..\" doesn't help you map your native string one way or another, but it might highlight that you need to explicitly build that mapping.",
          "createdAt": "2019-11-12T00:12:13Z",
          "updatedAt": "2019-11-12T00:12:13Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We discussed the \"point blank parsing\" issue a fair bit long time ago, and I think the conclusion was that it would have to be (header-)syntax directed parsing in most cases, and that the few cases which were not (presumably debugging) could live with a back-tracking parsing algorithm.\r\n\r\nWith respect to defining SH elements as actual types:  Please Dont, it would add a lot of text for no discernable benefit to anybody.",
          "createdAt": "2019-11-12T10:56:35Z",
          "updatedAt": "2019-11-12T10:56:35Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "This isn't the parsing issue.  Given a (native) string, how do you know whether to serialize it as a token, string, or binary?  It's not just a matter of assuming token and then 'upgrading' every time you hit an illegal character \u2013 native `\"xy\"` could legitimately become `xy`, `\"xy\"`, or `*eHk=*`.\r\n\r\nLooking at it from the parser side, **Parsing a Token** says:\r\n\r\n```\r\nGiven an ASCII string as input_string, return a token.\r\n[...]\r\n2. Let output_string be an empty string.\r\n[...]\r\n4. Return output_string.\r\n```\r\n\r\nSo is it saying that a token is a string?  Because the algorithm for parsing a string says roughly the same thing.  If **Parsing an Item** emits `[\"foo\", {}]` as a tuple, there's no way to tell if that _foo_ was a token or a string. What the parser emits should be enough to feed into the serialiser (although not vice versa).",
          "createdAt": "2019-11-12T13:41:21Z",
          "updatedAt": "2019-11-12T13:41:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "See commit; I think this addresses the issue in the most minimal way possible. ",
          "createdAt": "2019-11-13T05:55:07Z",
          "updatedAt": "2019-11-13T05:55:07Z"
        }
      ]
    },
    {
      "number": 986,
      "id": "MDU6SXNzdWU1MjU3NDc4NTc=",
      "title": "Add capability for sending HTTP metadata (trailer fields) in mid-stream",
      "url": "https://github.com/httpwg/http-extensions/issues/986",
      "state": "CLOSED",
      "author": "royfielding",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "For a very long time (since early 1995) there have been various attempts to send metadata in parallel with the request or response bodies. The use cases have ranged from group chat to chained digital signatures to performance metrics to long download checkpoints to a heck of a lot of other things that I pretend to no longer remember for sanity purposes.\r\n\r\nFixing that in HTTP/1.1 was only possible within chunked extensions. For a variety of reasons that had nothing to do with the use cases, chunked extensions didn't work well over intermediaries and the chicken never hatched. Nevertheless, they did work over HTTP/1.1 when the applications had control over both sides of a connection. I vaguely recall such metadata being present in HTTPng as well.\r\n\r\nI would like for HTTP/2 to have a mechanism for communicating metadata (like trailers) in mid-stream, both for requests (e.g., priority) and responses (e.g., chained sigs).\r\n\r\nI believe that this can be done with an extension frame type that carries trailer data, just like HEADERS, but that doesn't imply the end of DATA. However, I don't really have an opinion on what is the right way to do this in HTTP/2. I'd appreciate if people more familiar with HTTP/2 extensions could choose the best specific syntax.\r\n\r\nThis is not a semantics change for HTTP because the fields are just optional trailers that arrive early. A recipient that is not prepared to handle these fields, for whatever reason, can discard them in the same way as trailers, as specified in http-core [Semantics](/httpwg/http-core/draft-ietf-httpbis-semantics-latest.html).\r\n\r\nRelated to quicwg/base-drafts#3265",
      "createdAt": "2019-11-20T11:35:52Z",
      "updatedAt": "2020-03-17T04:59:27Z",
      "closedAt": "2020-03-17T04:59:26Z",
      "comments": [
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "Use cases:\r\n\r\n- [progress meter](https://datatracker.ietf.org/doc/draft-lnageleisen-http-chunked-progress)\r\n- midstream timing, like [server timing](https://www.fastly.com/blog/supercharging-server-timing-http-trailers)\r\n- priority updates\r\n- non-critical-path metadata (reduced latency vs headers)\r\n   - [alternates](https://tools.ietf.org/html/draft-ietf-http-alternates-01) (reactive content negotiation)\r\n   - [link preload nopush](https://www.w3.org/TR/preload/#server-push-http-2)\r\n   - metadata determined while sending body\r\n- long poll metadata\r\n     - chained signatures\r\n     - related resource notifications\r\n     - changed-while-sending notifications\r\n     - \"typing...\" notifications\r\n     - application-level backpressure",
          "createdAt": "2019-11-21T04:59:56Z",
          "updatedAt": "2019-11-21T04:59:56Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is the [HTTP/2 METADATA draft](https://docs.google.com/document/d/1DsPjl6qWxhcF28vzJey0xQJ2O2eRKHv7CBXt3EZyDjc/edit#heading=h.49cyuw1fzpul), which is already implemented in Envoy (see: https://github.com/envoyproxy/envoy/issues/2394), but I'm not sure what's the status of standardizing it.\r\n\r\ncc @birenroy @soya3129",
          "createdAt": "2019-11-21T05:38:36Z",
          "updatedAt": "2019-11-21T05:38:59Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "Oh, cool, that is exactly what I was thinking of (even the same frame type name). The only thing we would need to add is the semantic model of being equivalent to trailers.",
          "createdAt": "2019-11-21T05:58:58Z",
          "updatedAt": "2019-11-21T05:58:58Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for sharing @PiotrSikora this is pretty interesting. \r\n\r\n> The payload contains a block of key-value pairs, encoded using the HPACK Literal Header Field Never Indexed representation. \r\n\r\nThis is the first instance that I've seen that constrains the behaviour of a HPACK-related frame, I really like that! It would be interesting to understand the motivation behind the constraint, in order to understand how HTTP/3 METADATA would map to QPACK .\r\n\r\nOn a completely different topic, the document says\r\n\r\n> A METADATA frame with a stream ID of 0 represents connection-level metadata.\r\n\r\nI'm curious what is the definition / use case for connection-level metadata? That seems to be something different than what Roy is asking for.",
          "createdAt": "2019-11-21T06:13:42Z",
          "updatedAt": "2019-11-21T06:13:42Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "It is probably for performance metrics applicable to the mesh in general as opposed to a specific request/response stream. It makes sense to spec it that way even if there is no immediate use case.",
          "createdAt": "2019-11-21T06:19:54Z",
          "updatedAt": "2019-11-21T06:19:54Z"
        },
        {
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "body": "More like an OPTIONS push.",
          "createdAt": "2019-11-21T06:20:43Z",
          "updatedAt": "2019-11-21T06:20:43Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This is the first instance that I've seen that constrains the behaviour of a HPACK-related frame, I really like that! It would be interesting to understand the motivation behind the constraint, in order to understand how HTTP/3 METADATA would map to QPACK.\r\n\r\nThis constraint was added to simplify adding this to the existing implementations (i.e. to avoid messing with the HPACK dynamic table).\r\n\r\n> On a completely different topic, the document says\r\n> \r\n> > A METADATA frame with a stream ID of 0 represents connection-level metadata.\r\n> \r\n> I'm curious what is the definition / use case for connection-level metadata? That seems to be something different than what Roy is asking for.\r\n\r\nThis is mostly about endpoint and/or constant metadata (e.g. peer's identity). It would be wasteful to repeat the same metadata in each request/stream, so it's bound to a connection and all requests/streams inherit it.\r\n\r\nYes, our use case is slightly different from what Roy is asking for. Notably, our HTTP/2 METADATA is intended to be used to carry metadata within internal infrastructure, and the frame is not forwarded to the client (think \"internal\" HEADERS), but we can make it work for both cases. ",
          "createdAt": "2019-11-21T06:43:54Z",
          "updatedAt": "2019-11-21T06:49:09Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc @alyssawilk, FYI",
          "createdAt": "2019-11-21T06:47:56Z",
          "updatedAt": "2019-11-21T06:47:56Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "NONE",
          "body": "I have a few questions.\r\n\r\n1. What does \"semantic model of being equivalent to trailers\" mean here?\r\n1. Would the proposed frames require a new form of flow control?\r\n1. Are the proposed frames supposed to be associated with a specific position in HTTP response body?\r\n1. How would this interact with caching?",
          "createdAt": "2019-11-25T15:39:31Z",
          "updatedAt": "2019-11-25T15:39:31Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closed in favour of https://github.com/httpwg/http-core/issues/313",
          "createdAt": "2020-03-17T04:59:26Z",
          "updatedAt": "2020-03-17T04:59:26Z"
        }
      ]
    },
    {
      "number": 991,
      "id": "MDU6SXNzdWU1MjkxMjkwODk=",
      "title": "The best use for `*`",
      "url": "https://github.com/httpwg/http-extensions/issues/991",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "I'm running my SH implementation against the HTTP Archive dumps (400,000,000+ HTTP requests) to see how the [Directly Represented Fields](https://mnot.github.io/I-D/binary-structured-headers/#direct) from BSH parse in something like the real world.\r\n\r\nIt looks like some headers are failing because `*` is commonly used in things that are parsed as tokens; e.g., the `Accept*` headers, and `Access-Control-Allow-Origin`. \r\n\r\nIf we were to use a different character to delimit Byte Sequences, we could include `*` in Token (necessarily as a first character, as well as in the rest, I assume).\r\n\r\nWorthwhile? If so, what should we use for Byte Sequences?",
      "createdAt": "2019-11-27T05:41:52Z",
      "updatedAt": "2019-12-11T05:40:54Z",
      "closedAt": "2019-12-11T05:40:54Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`token` (via `tchar`) already allows `*`, but not as a first character.\r\n\r\n'%' is short in HPACK and unlikely to trigger funny handling, but maybe it will conflict with pct-encoding to start.\r\n\r\n'=' has the virtue of being already allowed.  It has the drawback of causing byte array parameters to look funny (`x==AA===` for instance).  Interestingly, it makes removal of padding easier (base64 padding is silly).",
          "createdAt": "2019-11-27T08:40:09Z",
          "updatedAt": "2019-11-27T08:40:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "How about `:`? I don't' think `=` is a good idea; if an implementation enforces padding (which we caution against, but do not prohibit), it's confusing.",
          "createdAt": "2019-11-27T23:55:01Z",
          "updatedAt": "2019-11-27T23:55:01Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Checking with @mikewest @jyasskin - any issues changing byte sequence delimiters from `*` to `:`?",
          "createdAt": "2019-11-29T01:49:11Z",
          "updatedAt": "2019-11-29T01:49:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "(the only conflicting use that comes to mind ATM for `:` is that if someone wants to refer to H2 pseudo-headers like `:scheme` in a field that uses tokens, they'll be out of luck. I think that's OK, because _existing_ fields that take header names as a list-of-tokens don't refer to pseudo-headers, and new fields can be defined as lists of tokens-or-strings.)",
          "createdAt": "2019-11-29T01:51:07Z",
          "updatedAt": "2019-11-29T01:51:15Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83c\udfa8\ud83d\udd8c\ufe0f `$ABC=$` is free",
          "createdAt": "2019-11-30T08:49:02Z",
          "updatedAt": "2019-11-30T08:49:02Z"
        }
      ]
    },
    {
      "number": 992,
      "id": "MDU6SXNzdWU1MjkxMjk1MzM=",
      "title": "Optional Dictionary values",
      "url": "https://github.com/httpwg/http-extensions/issues/992",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "I'm running my SH implementation against the HTTP Archive dumps (400,000,000+ HTTP requests) to see how the [Directly Represented Fields](https://mnot.github.io/I-D/binary-structured-headers/#direct) from BSH parse in something like the real world.\r\n\r\nA number of headers are failing because they have valueless dictionary members; e.g., `Cache-Control`, `Pragma`, `Surrogate-Control`.\r\n\r\nIt should be pretty easy to accommodate these, as we already have optional values on parameters.",
      "createdAt": "2019-11-27T05:43:20Z",
      "updatedAt": "2019-12-04T01:18:27Z",
      "closedAt": "2019-12-04T01:18:27Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "PTAL at the PR, especially the note about using True for missing parameter values.",
          "createdAt": "2019-11-28T00:36:47Z",
          "updatedAt": "2019-11-28T00:36:47Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Ping @bsdphk @phluid61 ",
          "createdAt": "2019-11-28T00:37:18Z",
          "updatedAt": "2019-11-28T00:37:18Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems like a reasonable change. I'm happy to remove the 'null' from parameters too.",
          "createdAt": "2019-11-30T08:28:52Z",
          "updatedAt": "2019-11-30T08:28:52Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(already OK'ed in the PR)",
          "createdAt": "2019-12-02T13:23:18Z",
          "updatedAt": "2019-12-02T13:23:18Z"
        }
      ]
    },
    {
      "number": 994,
      "id": "MDU6SXNzdWU1MzAxMDE4NTg=",
      "title": "Cache-Status granularity issues, reintroduce summary token?",
      "url": "https://github.com/httpwg/http-extensions/issues/994",
      "state": "CLOSED",
      "author": "triblondon",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "cache-header"
      ],
      "body": "The last time I reviewed this spec it had essentially a single key, the header itself, and an enum of possible values, which would be repeated if the response passed through multiple cache layers:\r\n\r\n```\r\ncache-action   = %s\"HIT_FRESH\"\r\n               / %s\"HIT_STALE\"\r\n               / %s\"HIT_REFRESH_MODIFIED\"\r\n               / %s\"HIT_REFRESH_NOT_MODIFIED\"\r\n               / %s\"HIT_REFRESH_STALE\"\r\n               / %s\"MISS\"\r\n               / %s\"MISS_CLIENT\"\r\n               / %s\"BYPASS\"\r\n               / %s\"ERROR\"\r\n```\r\n\r\nThere was certainly scope to make this more detailed, but it seemed elegant enough and was essentially a like for lie replacement of what most caches already do.  The current version goes too far in my opinion.  I see the following use cases:\r\n\r\n1. Developer of site using the header interactively for debugging\r\n2. Developers' CI tools asserting expected behaviours against the header for smoke testing\r\n3. Developers monitoring their CDN partner's cache efficacy (via RUM, I guess, ideally)\r\n4. Cache operators optimising their behaviour based on a better understanding of upstream cache status\r\n5. Researchers wanting to understand the state of the web more generally\r\n\r\nMany of these use cases arguably call for the most granular and detailed possible information to be included, but I would argue that 95% of the value of this type of header is use case 1.  And in the latest revision, we have lost a simple, clear status token.\r\n\r\nI'd propose reintroducing an enum of statuses, and support the additional params as enrichment. So a complexish example:\r\n\r\n```\r\nCache-Status: MISS; cache=fastly-bwi-1234; collapse-hit=?1,\r\n              HIT_FRESH; cache=akamai; res-fresh=289\r\n```\r\n\r\nThe current proposal already has a keyless param, for the cache name.  I'm essentially proposing that we add a key to that param, and introduce a new keyless param, for the summary cache status.\r\n\r\nThe result is that this is MUCH easier for developers to scan, a minimal implementation is more immediately useful (because as a cache you need only implement the keyless status param, not any of the others) and therefore implementation/adoption could be faster.  A minmal example could be (exactly as per the earlier spec draft):\r\n\r\n```\r\nCache-Status: HIT_FRESH\r\n```\r\n\r\nWhereas the minimal implementation of the current draft would be something like `Cache-Status: ExampleCache` and (at least for use case 1) that's unlikely to tell anyone anything they don't already know.",
      "createdAt": "2019-11-28T23:47:32Z",
      "updatedAt": "2020-07-15T08:23:48Z",
      "closedAt": "2020-07-15T08:23:48Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "So, the background for this is #766. In a nutshell:\r\n\r\n* The PREFIX_SUFFIX approach to defining cache tags was imprecise and difficult to extend / maintain\r\n* We wanted a clean break from the `X-Cache` syntax to emphasise that this need to be re-implemented, not just ported over (i.e., incompatibility with exisiting syntax is a feature, not a bug)\r\n\r\nSeveral people also liked the alignment with `Proxy-Status` in terms of using the node name as the \"primary\" key that parameters are put onto.\r\n\r\nLooking at your example:\r\n\r\n~~~\r\nCache-Status: MISS; cache=fastly-bwi-1234; collapse-hit=?1,\r\n              HIT_FRESH; cache=akamai; res-fresh=289\r\n~~~\r\n\r\nit would look like this in the current draft;\r\n\r\n~~~\r\nCache-Status: fastly-bwi-1234; fwd=uri-miss; collapse-hit=?1,\r\n            Akamai; res-fresh=289\r\n~~~\r\n\r\nWould it be helpful if we spelled it slightly differently, e.g.:\r\n\r\n~~~\r\nCache-Status: fastly-bwi-1234; type=URI_MISS; collapse-hit=?1,\r\n            Akamai; type=FRESH, res-fresh=289\r\n~~~\r\n\r\nThat uses a few more bytes, of course.",
          "createdAt": "2019-12-03T08:11:41Z",
          "updatedAt": "2019-12-03T08:11:41Z"
        },
        {
          "author": "triblondon",
          "authorAssociation": "NONE",
          "body": "This suggestion seems to be basically what I want except that the new `type` subfield should be keyless, and the keyless subfield should be keyed as `cache`, resulting in:\r\n\r\n```\r\nCache-Status: URI_MISS; cache=fastly-bwi-1234; collapse-hit=?1,\r\n              FRESH; cache=akamai; res-fresh=289\r\n```\r\n\r\nThe purpose of the header is to communicate the cache status, not the name of the cache.  Put the cache status info up front.",
          "createdAt": "2019-12-04T05:43:11Z",
          "updatedAt": "2019-12-04T05:45:58Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I don't think we're going to reintroduce the all-in-one tokens for reasons previously discussed, but I've tweaked things to be a bit friendlier (see most recent editors' draft); e.g., the examples above would be:\r\n\r\n~~~\r\nCache-Status: fastly-bwi-1234; fwd=uri-miss; collapsed,\r\n            Akamai; hit; ttl=289\r\n~~~\r\n",
          "createdAt": "2020-02-25T05:03:44Z",
          "updatedAt": "2020-02-25T05:03:44Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Talked to @triblondon, he thinks this has been addressed by recent changes.",
          "createdAt": "2020-07-15T08:23:48Z",
          "updatedAt": "2020-07-15T08:23:48Z"
        }
      ]
    },
    {
      "number": 995,
      "id": "MDU6SXNzdWU1MzIzNzY0NjE=",
      "title": "Empty parameters should default to True",
      "url": "https://github.com/httpwg/http-extensions/issues/995",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "... as per #992 ",
      "createdAt": "2019-12-04T01:18:33Z",
      "updatedAt": "2019-12-09T00:03:48Z",
      "closedAt": "2019-12-09T00:03:48Z",
      "comments": []
    },
    {
      "number": 997,
      "id": "MDU6SXNzdWU1MzIzOTcwMTU=",
      "title": "Duplicate Structured Headers fields",
      "url": "https://github.com/httpwg/http-extensions/issues/997",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "[RFC 7230 section 3.2.2](https://tools.ietf.org/html/rfc7230#section-3.2.2) allows a sender to generate multiple header fields with the same name, if the field is _defined as a comma-separated list [i.e., #(values)]_, and that such duplicates are semantically equivalent to them concatenated into a single header field.\r\n\r\nI think that this property has been useful for us, when annotating header fields.\r\n\r\nCan we allow such duplicates for Structured Headers too, when a list or a dictionary is being used? Note that we have merged #993 based on the assumption that it is okay to require the consumer of SH header fields to have the knowledge on what the top type is.",
      "createdAt": "2019-12-04T02:01:16Z",
      "updatedAt": "2020-01-14T03:48:24Z",
      "closedAt": "2020-01-14T03:48:24Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "That's always been the intent; are you saying that we should have text specifically enabling this for serialisation of dictionaries and lists?",
          "createdAt": "2019-12-04T03:17:50Z",
          "updatedAt": "2019-12-04T03:17:50Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good to know that that has been the intent.\r\n\r\nYes, I think we should clarify that explicitly for dictionaries and lists, because RFC 7230 can be interpreted to allow duplicates only for those using `#(values)` notation (which we do *not* use in SH).\r\n\r\nAlso, it might be a good idea to revisit the rule for duplicate dictionary values, as I'd assume that people would try to append a header field without checking the values that already exist. IMO, the rule should be that the dictionary element that appears later overwrites the one that precedes.",
          "createdAt": "2019-12-04T03:27:07Z",
          "updatedAt": "2019-12-04T03:27:07Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "PTAL",
          "createdAt": "2019-12-11T04:01:11Z",
          "updatedAt": "2019-12-11T04:01:11Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot Thank you! cb76bf1 looks good to me.\r\n\r\nIs your intention to retain the forbidding of duplicate dictionary values, even when the dictionary members are split into different header fields?\r\n\r\nFor example, in the hypothetical world where cache-control is sent using SH, all the cache-control directives in the following example would be considered invalid and ignored.\r\n\r\n```\r\ncache-control: ..., no-store\r\ncache-control: no-store\r\n```\r\n\r\nI am not strongly opposed to that, though my weak preference goes to requiring decoders to use the dictionary member that appears later when there is a collision.",
          "createdAt": "2019-12-11T04:08:01Z",
          "updatedAt": "2019-12-11T04:08:01Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@kazuho the problem is that ignoring duplicates can cause security issues for some headers (the headers that WebAppSec in the W3C are particularly sensitive about this).\r\n\r\nThe only way to address it would be to add a flag to the API to control what to do with dups -- but that adds complexity (more to specifications than to implementations, but still). I'm not crazy about that; what do others think?",
          "createdAt": "2019-12-11T09:37:52Z",
          "updatedAt": "2019-12-11T09:37:52Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot Thank you for the explanation.\r\n\r\nBut I wonder if it is actually the case that what those specifications forbid is having duplicate header fields, rather than forbidding duplicate dictionary members (or maybe both). By quickly searching on https://www.w3.org/TR/CSP2/, I was able to find the prohibition on having duplicate header fields, but could not find a rule that forbids having duplicate policy tokens.\r\n\r\nAssuming that at least such specifications forbid having duplicate header fields, and based on the fact that SH draft does not forbid that (when a list or dictionary is used), I think there is no reason for the SH draft to forbid having duplicate dictionary members.",
          "createdAt": "2019-12-11T11:29:41Z",
          "updatedAt": "2019-12-11T11:29:41Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@mikewest @annevk any comments re: the above? Specifically, if SH swallowed duplicate dictionary values rather than raising an error, would that be a concern from a security standpoint?",
          "createdAt": "2019-12-11T23:42:48Z",
          "updatedAt": "2019-12-11T23:42:48Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Given a header like `k1=v1, k2=v2, k1=v3`, it seems like we have a few options:\r\n\r\n1.  Fail parsing.\r\n2.  Return `{ k1: v1, k2: v2 }`.\r\n3.  Return `{ k1: v3, k2: v2 }`.\r\n4.  Return `{ k1: [v1, v3], k2: v2 }`.\r\n\r\nI think I can come up with arguments for any of these options, though I'd find 4 a bit surprising as a spec author, insofar as I'd have to deal with unexpected lists for all my dictionary values.\r\n\r\n> By quickly searching on https://www.w3.org/TR/CSP2/, I was able to find the prohibition on having duplicate header fields, but could not find a rule that forbids having duplicate policy tokens.\r\n\r\n2.5 of https://w3c.github.io/webappsec-csp/#abstract-opdef-parse-a-serialized-csp skips duplicate CSP directives. That is, it picks 2 out of the list above, choosing to retain only the first value for a given name.\r\n\r\nI do wonder whether that was the right decision, but it is consistent across browsers and provides developers with predictable behavior. We throw a warning into the console in Chrome for this case, and that's probably Good Enough\u2122.",
          "createdAt": "2019-12-12T05:56:05Z",
          "updatedAt": "2019-12-12T05:56:05Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "> I'd assume that people would try to append a header field without checking the values that already exist.\r\n\r\nThis sounds like a bad API for working with structured header values. I'd hope that eventually we offer better APIs for operating on (what Fetch calls) header lists.\r\n\r\nI think historically there were some arguments for always using first or last based on likelihood of where header injection would happen. But I'm not sure how sound any of that rationale was. I don't think a client can reasonably protect against it.\r\n\r\nTherefore, what's most important is that the result is unambiguous and that it doesn't matter how you \"spell\" multiple values (commas or multiple fields or a combination) in the traditional header syntax.",
          "createdAt": "2019-12-12T10:31:03Z",
          "updatedAt": "2019-12-12T10:31:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Anyone have preferences between Mike's options 2 and 3?",
          "createdAt": "2019-12-12T23:03:43Z",
          "updatedAt": "2019-12-12T23:03:43Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot I think option 3 is preferable, because that would allow server administrators to override parameters by appending header fields.\r\n\r\nI agree that @annevk that it's a hack, though sadly, I do not think we can get rid of such practice through API design on the server side. People are so used to dealing with each line of header fields than working through a API that deals with a set of header fields as a whole.",
          "createdAt": "2019-12-13T00:35:31Z",
          "updatedAt": "2019-12-13T00:35:31Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "There are CDNs that offer JS or Wasm APIs effectively using `fetch()` et al. Once structured header values are more baked and have dedicated on-the-wire support I'd definitely like to add first-class support to `Headers` objects.",
          "createdAt": "2019-12-13T06:48:48Z",
          "updatedAt": "2019-12-13T08:12:42Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I weakly prefer \"first one wins\" (2). It's only an aesthetic preference, however: I don't have any principled reason to pick 2 over 3 or vice-versa. I can live with either for the reasons @annevk spells out.",
          "createdAt": "2019-12-13T07:22:25Z",
          "updatedAt": "2019-12-13T07:22:25Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If I had pick, I probably agree with @kazuho's reasoning.",
          "createdAt": "2019-12-13T11:24:36Z",
          "updatedAt": "2019-12-13T11:24:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "PTAL",
          "createdAt": "2020-01-08T00:32:52Z",
          "updatedAt": "2020-01-08T00:32:52Z"
        }
      ]
    },
    {
      "number": 998,
      "id": "MDU6SXNzdWU1MzI0MTQzMDY=",
      "title": "Tabs?",
      "url": "https://github.com/httpwg/http-extensions/issues/998",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Right now we use OWS, and #983 suggests moving from SP to RWS for inner list separation.\r\n\r\nShould we allow tabs in SH? Error on them? \r\n\r\nIf we want to allow them, 983 makes sense, as it's more consistent. However, we'll need to test for tabs...",
      "createdAt": "2019-12-04T02:53:44Z",
      "updatedAt": "2019-12-11T04:05:03Z",
      "closedAt": "2019-12-11T04:05:03Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "What's the reason to allow tabs? Compatibility with current headers? Do actual tab characters show up in the wild that often?",
          "createdAt": "2019-12-04T04:55:32Z",
          "updatedAt": "2019-12-04T04:55:32Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We had them in there because we were reusing OWS, not purposefully. AFAICT they don't appear in the wild much at all. So +1 for #1002.\r\n\r\n",
          "createdAt": "2019-12-06T23:08:11Z",
          "updatedAt": "2019-12-06T23:08:11Z"
        }
      ]
    },
    {
      "number": 1003,
      "id": "MDU6SXNzdWU1MzM2MDA3NzU=",
      "title": "HTTP variants example is out of date",
      "url": "https://github.com/httpwg/http-extensions/issues/1003",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "variants"
      ],
      "body": "The introduction in the variants draft gives the following example:\r\n~~~\r\nHTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Language: en\r\nVary: Accept-Language\r\nVariants: Accept-Language;de;en;jp\r\nVariant-Key: en\r\nTransfer-Encoding: chunked\r\n~~~\r\n\r\nBut the syntax has since changed and now it is a dictionary, as of c392ad8836a21f57d1f175e8a264d881a56720ab:\r\n~~~\r\n   HTTP/1.1 200 OK\r\n   Content-Type: image/gif\r\n   Content-Language: en\r\n   Cache-Control: max-age=3600\r\n   Variants: Accept-Language=(en de)\r\n   Variant-Key: (en)\r\n   Vary: Accept-Language\r\n   Transfer-Encoding: chunked\r\n~~~",
      "createdAt": "2019-12-05T21:09:52Z",
      "updatedAt": "2020-01-14T03:49:00Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1005,
      "id": "MDU6SXNzdWU1MzQxMzk2MjQ=",
      "title": "digest use case: resume upload",
      "url": "https://github.com/httpwg/http-extensions/issues/1005",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I wish\r\n\r\nto use `Digest` to implement resumeable uploads.\r\n\r\n## Note\r\n\r\nSee https://cloud.google.com/storage/docs/hashes-etags:\r\n\r\n- approach similar to digest 1\r\n\r\n>  The checksum(s) returned when downloading data from Cloud Storage cover the complete object \r\n> content. Thus, if you specify a request range there's no way to detect data corruption for that byte \r\n> range alone. \r\n\r\n- approach similar to digest 2\r\n\r\n> To protect against data corruption, Cloud Storage supports two types of hashes: CRC32C and \r\n> MD5 (described below). Google recommends that customers use CRC32C for all cases,\r\n \r\n\r\n ",
      "createdAt": "2019-12-06T16:53:27Z",
      "updatedAt": "2020-08-17T11:10:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't understand exactly what this issue is trying to track. In more human-readable terms are you suggesting that we make an editorial change to add a resumable upload use case",
          "createdAt": "2019-12-10T14:21:21Z",
          "updatedAt": "2019-12-10T14:21:21Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wanted to track this use-case to see if digest can cover it. No changes are expected to the spec for now.",
          "createdAt": "2019-12-10T23:34:08Z",
          "updatedAt": "2019-12-10T23:34:08Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for clarifying. We should be mindful of feature creep in this spec, for instance there is a difference in documenting how Digest **is used** today for a use case vs attempting to apply Digest to this use case that is satisfied already by other approaches.\r\n\r\nThat said, a survey of present approaches may be useful to help determine if/what the Digest header specification might chose to mention. So to that end, in the context of Google Cloud Storage, a better link would seem to be https://cloud.google.com/storage/docs/resumable-uploads \r\n\r\n> In addition, we recommend that you request an integrity check of the final uploaded object to be sure that it matches the source file. You can do this by calculating the MD5 digest of the source file and adding it to the Content-MD5 request header. Checking the integrity of the uploaded file is particularly important if you are uploading a large file over a long period of time, because there is an increased likelihood of the source file being modified over the course of the upload operation.\r\n\r\nSimilarly, AWS provides guidance such as \r\n https://aws.amazon.com/premiumsupport/knowledge-center/data-integrity-s3/\r\n\r\n> To verify the MD5 checksum value of the object during its upload to Amazon S3, use the AWS Command Line Interface (AWS CLI) command aws s3api put-object and include the --content-md5 option. For the value of --content-md5, enter the base64-encoded MD5 checksum value that you calculated, similar to the following:\r\n> \r\n> aws s3api put-object --bucket awsexamplebucket --key awsexampleobject.txt --body awsexampleobjectpath --content-md5 examplemd5value1234567==\r\n> \r\n> Optionally, if you want to store the MD5 checksum value as metadata (custom HTTP header), you can also add the --metadata option in the command, similar to the following:\r\n> \r\n> aws s3api put-object --bucket awsexamplebucket --key awsexampleobject.txt --body awsexampleobjectpath --content-md5 examplemd5value1234567== --metadata md5checksum=examplemd5value1234567==\r\n> \r\n> If the checksum that Amazon S3 calculates during the upload doesn't match the value that you entered for --content-md5, Amazon S3 won't store the object. Instead, you receive an error message in response.\r\n\r\nThere is also the `tus` protocol which is described as a _\"protocol provides a mechanism for resumable file uploads via HTTP/1.1 (RFC 7230) and HTTP/2 (RFC 7540).\"_. For uploads it says  \r\nhttps://tus.io/protocols/resumable-upload.html#checksum\r\n\r\n> A Client MAY include the Upload-Checksum header in a PATCH request. Once the entire request has been received, the Server MUST verify the uploaded chunk against the provided checksum using the specified algorithm. Depending on the result the Server MAY respond with one of the following status code: 1) 400 Bad Request if the checksum algorithm is not supported by the server, 2) 460 Checksum Mismatch if the checksums mismatch or 3) 204 No Content if the checksums match and the processing of the data succeeded. In the first two cases the uploaded chunk MUST be discarded, and the upload and its offset MUST NOT be updated.\r\n> \r\n> The Server MUST support at least the SHA1 checksum algorithm identified by sha1. The names of the checksum algorithms MUST only consist of ASCII characters with the modification that uppercase characters are excluded.\r\n> \r\n> The Tus-Checksum-Algorithm header MUST be included in the response to an OPTIONS request.\r\n> \r\n> If the hash cannot be calculated at the beginning of the upload, it MAY be included as a trailer. If the Server can handle trailers, this behavior MUST be announced by adding checksum-trailer to the Tus-Extension header. Trailers, also known as trailing headers, are headers which are sent after the request\u2019s body has been transmitted already. Following RFC 7230 they MUST be announced using the Trailer header and are only allowed in chunked transfers.\r\n",
          "createdAt": "2019-12-11T11:57:04Z",
          "updatedAt": "2019-12-11T11:57:04Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @LPardue for the survey :D !",
          "createdAt": "2019-12-11T13:12:21Z",
          "updatedAt": "2019-12-11T13:12:21Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "About feature creep:\r\n- yes, we should not add features;\r\n- but we must investigate how legitimate usage of digest can improve existing use cases.\r\n\r\nThis:\r\n- will avoid spec proliferation;\r\n- avoid usage of deprecated content-md5;\r\n\r\nFor example, the usage of content-md5 by CSP like goog and amz may be mitigated by their knowledge and architecture; it may not be the same for a generic implementor ( that's why http deprecated content-md5).\r\n\r\nHth, R",
          "createdAt": "2019-12-26T11:42:13Z",
          "updatedAt": "2019-12-26T11:42:13Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IIUC this is not the semantics of content-md5. Am I wrong? @LPardue \r\n\r\n> we recommend that you request an integrity check of the final uploaded object to be sure that it matches the source file. You can do this [..] adding it to the Content-MD5 request header",
          "createdAt": "2019-12-26T12:38:03Z",
          "updatedAt": "2019-12-26T12:38:03Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let's try to decide if we want to pursue this or not. @mnot my concern here is that we don't have IETF specs to link to wrt to resumable uploads, I'm wary about speculating on the applicability of digest to a use case that doesn't seem to use it. Someone could always follow up with a separate document that attempts to do this work.",
          "createdAt": "2020-08-13T13:33:42Z",
          "updatedAt": "2020-08-13T13:33:42Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree this shouldn't be a show stopper, and I can prepare a new I-D on using Digest for resuming upload if you suggest to do so.",
          "createdAt": "2020-08-17T11:10:57Z",
          "updatedAt": "2020-08-17T11:10:57Z"
        }
      ]
    },
    {
      "number": 1007,
      "id": "MDU6SXNzdWU1MzYxMjYzNzY=",
      "title": "[SH] dictionary with default True value doesn't accept parameters",
      "url": "https://github.com/httpwg/http-extensions/issues/1007",
      "state": "CLOSED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "In section **4.2.2 Parsing a Dictionary** step 2.4.2 initialises an empty set of parameters, but never parses any from input_string.  This corresponds with the ABNF rule `dict-member = member-name [ \"=\" member-value ]` where `member-value` includes the parameters.\r\n\r\nThis conflicts with a [recently-added test](https://github.com/httpwg/structured-header-tests/pull/24/files#diff-6976ba7e46d6978bde81530178302e1fR112-R118).\r\n\r\nRelated to #992 ",
      "createdAt": "2019-12-11T03:48:48Z",
      "updatedAt": "2019-12-11T06:07:24Z",
      "closedAt": "2019-12-11T06:07:24Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Nope, I just has a moment. Fixed.",
          "createdAt": "2019-12-11T06:07:24Z",
          "updatedAt": "2019-12-11T06:07:24Z"
        }
      ]
    },
    {
      "number": 1014,
      "id": "MDU6SXNzdWU1NDEyMTc3NDI=",
      "title": "RFC6265bis: \"The SameSite Attribute\" summary makes no mention to setting limitations.",
      "url": "https://github.com/httpwg/http-extensions/issues/1014",
      "state": "CLOSED",
      "author": "sbingler",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis",
        "samesite"
      ],
      "body": "Section \"4.1.2.7.  The SameSite Attribute\" of rfc6265bis-03 currently talks about SameSite's effects on which cookies will be attached to requests. The attribute also affects which cookies are allowed to be set by responses, as detailed in \"5.4.  Storage Model\" step #14. \r\nSomebody looking to learn more about how the SameSite attribute is used is unlikely to work their way into the storage model (which also won't show up when searching the text for \"SameSite\") but would very likely be interested in knowing this detail.\r\n\r\nSection 4.1.2.7 should probably be expanded to include information on how SameSite affects cookies being set.",
      "createdAt": "2019-12-20T21:54:19Z",
      "updatedAt": "2020-01-20T13:15:52Z",
      "closedAt": "2020-01-20T13:15:52Z",
      "comments": []
    },
    {
      "number": 1015,
      "id": "MDU6SXNzdWU1NDE0Mjk3Njk=",
      "title": "Structured Headers and GREASE",
      "url": "https://github.com/httpwg/http-extensions/issues/1015",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "@mikewest's Fetch Metadata will add a bunch of headers that are supposedly structured headers, but given their simplicity can be compared using equality on servers. If servers did that it would likely prevent adding parameters in the future however or making other supposedly-compatible extensions.\r\n\r\nShould we accept this for headers clients transmit to servers or should we do something akin to TLS's GREASE?",
      "createdAt": "2019-12-22T09:46:47Z",
      "updatedAt": "2020-01-29T04:52:16Z",
      "closedAt": "2020-01-29T04:52:16Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "In general, greasing HTTP headers is interesting -- although I'm a little wary, given the extent of the grease-related discussions we've had in QUIC.\r\n\r\nAs a baseline -- I think that the goal of grease should be to prevent casually incomplete implementation (e.g., someone using regex or splitting on commas and extracting the raw values). It can never assure complete and correct implementation overall.\r\n\r\nI *think* the interesting thing to grease in SH is parameters, since that's a primary extensibility mechanism, and is (now) uniform across values. Ideally, grease parameters would contain values that frustrate the casual approaches above; e.g., strings with commas in them.\r\n\r\nA couple of options I can see;\r\n\r\n* We could advise / require sending implementations to generate extra parameters sporadically (not super-often, so as to limit bandwidth consumption, but not so rarely that it creates debugging nightmares). To be recognisable as grease to the receiving application, their names would have to have some convention.\r\n\r\n* We could advise / require headers using SH to define their own greasing mechanisms when appropriate. \r\n\r\nI suspect that truly automatic greasing might increase friction against adoption of SH, since some people's reaction will be \"what is this thing doing to my header?!?\". Invoking in on a header-by-header basis (perhaps by adding an appendix with guidance) might help.\r\n\r\n",
          "createdAt": "2020-01-06T04:16:56Z",
          "updatedAt": "2020-01-06T04:16:56Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I think the main benefit is derived from clients doing this so the main party to convince would be the user agents (who are already generally on board with SH).",
          "createdAt": "2020-01-06T08:46:27Z",
          "updatedAt": "2020-01-06T08:46:27Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "So, should anything in the spec change? \r\n\r\nAt this point the most I can see is adding something like:\r\n\r\n> To help assure that extensibility is available in the future, and to encourage consumers to use a fully capable Structured Headers parser, a header definition can specify that \"grease\" parameters be added by senders. For example, a specification could stipulate that all parameters beginning with the letter 'q' are reserved for this use.\r\n",
          "createdAt": "2020-01-08T00:36:32Z",
          "updatedAt": "2020-01-08T00:36:32Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I guess I'm mainly interested if implementations are willing to do this uniformly. @mikewest @ddragana @youennf?",
          "createdAt": "2020-01-08T11:06:03Z",
          "updatedAt": "2020-01-08T11:06:03Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I think @mnot's suggestion is reasonable to recommend (though it risks a quagmire when we attempt to ship a new header defining a quotient of quietly quixotic quilting), but I'll defer to @davidben or @MattMenke2 to weigh in from Chromium's networking team's broader perspective for headers generally.",
          "createdAt": "2020-01-08T11:28:09Z",
          "updatedAt": "2020-01-08T11:28:09Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am, unsurprisingly, in favor of GREASEing things on general principle. :-) Although the network stack only produces a few core headers while others, like Fetch metadata, mostly come from outside anyway. GREASE would want to be applied where the header is produced, most likely. (Well, we could implement some generic post-processing scheme, but then all the headers would need compatible mechanisms and we'd need to know which they are.)",
          "createdAt": "2020-01-14T20:48:16Z",
          "updatedAt": "2020-01-14T20:48:16Z"
        },
        {
          "author": "MattMenke2",
          "authorAssociation": "NONE",
          "body": "I also think this sounds reasonable.  One problem is reproducibility - if we modify a header 1 in 100 times, then a developer would have trouble reproducing the issue.  If we apply the same modification per browser session, it would become a new cross-site tracking vector, unless we also took NIK into account when deciding whether/how to modify the header.",
          "createdAt": "2020-01-15T17:46:12Z",
          "updatedAt": "2020-01-15T17:46:12Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For TLS, we've never fed state in as input to GREASE, which is the safest option privacy-wise. But you're right that you then need to worry about reproducibility. To that end, if we GREASE some TLS codepoint, we *always* GREASE it, with the randomness coming in only in the particular values, as a low-pass discouragement against hardcoding values. But if the implementation is intolerant to only values that start with 5, it is indeed unlikely to be reproducible enough.",
          "createdAt": "2020-01-15T19:09:04Z",
          "updatedAt": "2020-01-15T19:09:04Z"
        },
        {
          "author": "MattMenke2",
          "authorAssociation": "NONE",
          "body": "If we always grease something, couldn't that result in problems around servers always expecting an extra value?",
          "createdAt": "2020-01-15T19:18:20Z",
          "updatedAt": "2020-01-15T19:18:20Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It could, but that'd be a really weird bug for servers to have, whereas not properly skipping over unknown keys is much easier to do on accident. (Maybe I just parse the whole thing with a giant regex and make assumptions about the order.)",
          "createdAt": "2020-01-15T22:23:43Z",
          "updatedAt": "2020-01-15T22:23:43Z"
        },
        {
          "author": "MattMenke2",
          "authorAssociation": "NONE",
          "body": "I don't think it's that weird - if I want to test parsing something with a variable number of fields, I'd test on 0, 1, 2, and possible something much greater than 2 (like 3!).  I think it's very easy to mess up on any one of those cases, and get the others right.  Could assume an initiate search for a delimiter will always succeed, or use a regexp with \"+\" instead of \"*\", etc.",
          "createdAt": "2020-01-15T22:30:47Z",
          "updatedAt": "2020-01-15T22:30:47Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Beyond the text above, we could add a character to those allowed to start keys, and reserve it for greasing. E.g., `_`. \r\n\r\nI think I'd do that purely at the parse/serialise layer, so a grease value never appears in the actual data model.\r\n\r\nIs that attractive?",
          "createdAt": "2020-01-20T00:33:46Z",
          "updatedAt": "2020-01-20T00:33:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot I'm not sure if that is beneficial.\r\n\r\nI think our goal is to let every HTTP extension that uses a SH list or a SH dictionary to be extensible. To achieve that, greasing has to carry a value that can be recognized by the extensions.\r\n\r\nAssuming that that would happen for a fair number of HTTP extensions, the SH codec shared among those HTTP extensions would encode / decode arbitrary number of undefined values. I think that would be sufficient.",
          "createdAt": "2020-01-20T00:51:25Z",
          "updatedAt": "2020-01-20T00:51:25Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe you can use \"X-\".\r\n\r\nOne of the reasons we avoided reserving a range of values was to make grease values a little harder to separate from genuine values. The point being that they need to be seen by the code that processes them without filtering.\r\n\r\nFrom that, I take two conclusions:\r\n\r\n1. A prefix won't work as it is too easy to distinguish.\r\n2. Having a generic processor strip grease values would mean that the code we want inoculated would never get the opportunity to benefit from our attempts at inoculation.\r\n\r\nTherefore, I suggest that we find a subset of valid strings that we will reserve. Maybe that is all strings of 8 characters or more that fit a certain pattern. We don't have any established pattern for strings, but anything should do as long as new values can be generated cheaply and it doesn't take too much of the available space.",
          "createdAt": "2020-01-20T00:53:10Z",
          "updatedAt": "2020-01-20T00:53:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'm going to disagree on pretty much all points, @martinthomson.\r\n\r\nThe target here is assuring that a consuming implementation isn't grepping, string-mangling, etc. If they're aware of it being a SH and actively NOT using a SH parser, there's not much we can do, reasonably.\r\n\r\nTo that end, `foo; _bar=baz` is just as effective as`foo; x-bar=baz`, and hiding it from the application is a benefit, because we don't pollute their data model, we don't make them think about it, and once it's parsed into the data model, they CAN'T interfere in the ways we're trying to prevent.",
          "createdAt": "2020-01-20T01:04:09Z",
          "updatedAt": "2020-01-20T01:04:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@kazuho what does \"recognised by the extensions\" mean? Are you saying that a recipient has to be aware of grease's presence AFTER parsing to serve the purpose? ",
          "createdAt": "2020-01-20T01:05:20Z",
          "updatedAt": "2020-01-20T01:05:20Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot Let me use an example.\r\n\r\nConsider the case of the Priority header field. The header would be generated, encoded, decoded, and used in the following manner:\r\n\r\n```\r\n[1. generate priority header] -> [2. SH serializer] -> [3. SH parser] -> [4. use priority header]\r\n```\r\n\r\nWe would definitely want to grease (4), so that it would be possible to define new keys. Therefore, there is no benefit in letting (3) absorb the keys used for greasing. We should prohibit (3) doing such thing. That is my argument.\r\n\r\nWho adds the greasing keys is debatable. That could happen purely in (1) or in cooperation between (1) and (2). Or we could define a common vocabulary, so that it could be done purely in (2). I do not have a strong opinion here.",
          "createdAt": "2020-01-20T01:49:59Z",
          "updatedAt": "2020-01-20T01:49:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK, so you want to protect against an additional case -- someone using an SH parser (rather than grep, etc.) but raising an error if any parameters are present.\r\n\r\nPersonally, I'm not as concerned about this case; someone is going to have to go out of their way to write that code. What I'm concerned about is lazy programmers doing some quick string hacks.",
          "createdAt": "2020-01-20T02:03:58Z",
          "updatedAt": "2020-01-20T02:03:58Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While I might agree that we might not need to be concerned about this case, I wonder if there would be a benefit in requiring an SH parser (3) to absorb certain keys, assuming that most, if not all of the extensions that use SH dictionary or SH array would allow future extensions.\r\n\r\nHow about saying that \"a SH encoder MAY add a greasing entry (i.e. a key that starts from \"_\"), unless the extension using SH forbids that\", and that \"a SH decoder MUST NOT absorb the greasing entries\"?\r\n\r\nThat would give us end-to-end greasing by default with least hassle.",
          "createdAt": "2020-01-20T02:15:14Z",
          "updatedAt": "2020-01-20T02:15:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'm not against that. The only thing bothering me is that \"unless the extension using SH forbids that\" means that APIs will need another bump on them...",
          "createdAt": "2020-01-20T02:17:20Z",
          "updatedAt": "2020-01-20T02:17:20Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah we can remove \"unless\", if the key names used for greasing is not going to be a valid key name in terms of the spec. E.g., grease keys added by SH encoder starts with \"_\", while applications are forbidden from using a key starting from underscores.",
          "createdAt": "2020-01-20T02:25:02Z",
          "updatedAt": "2020-01-20T02:25:02Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "That's what I was suggesting up-thread :)",
          "createdAt": "2020-01-20T02:26:20Z",
          "updatedAt": "2020-01-20T02:26:20Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah you stated \"do that purely at the parse/serialise layer,\" and my complaint was absorbing the values in the parsing logic. Sorry I wasn't clear about what I am complaining about.",
          "createdAt": "2020-01-20T02:39:38Z",
          "updatedAt": "2020-01-20T02:39:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "SGTM - anyone else have thoughts?",
          "createdAt": "2020-01-20T03:08:55Z",
          "updatedAt": "2020-01-20T03:08:55Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Looking at how to specify this, having grease parameters appear in the data model don't make me very happy; we either have to make them valid but tell people not to use them (which is likely to be abused), or we have to make them invalid but say they might appear anyway, just to be ignored, which is weird. Either way, it's confusing to write/read the spec, and I suspect some people will use the grease prefix for some purpose because it works (most of the time).\r\n\r\nStepping back, I think the scenario we're talking about is the possibility that a consumer of a specific SH header (i.e., post-parse) is likely to erroneously reject headers that has unrecognised parameters, even when the header allows them (keeping in mind that some header definitions might disallow them, even though that's not a great extensibility strategy).\r\n\r\nTo me, that's not the purpose of greasing, because there are lots of other possible erroneous constraints that a consumer (rather than an SH implementation) might put on a header, and we don't try to prevent that. If someone wants to purposefully reject something in a way that's contrary to the header's spec, they're going to do it.\r\n\r\nRather, greasing (to me) is about making sure that someone who's ignorant of the spec / too lazy to read it doesn't just do the \"natural\" thing and e.g., feed an integer into a parser, or split a string on commas. \r\n\r\nSo, to me adding parameters / dict members and \"disappearing them\" at parse is adequate. I'm not against addressing the case @kazuho points out, but I don't want to complicate things to achieve it.\r\n\r\nDo other folks on this thread have any leaning in one direction or the other?",
          "createdAt": "2020-01-22T04:02:05Z",
          "updatedAt": "2020-01-22T04:02:05Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Rather, greasing (to me) is about making sure that someone who's ignorant of the spec / too lazy to read it doesn't just do the \"natural\" thing and e.g., feed an integer into a parser, or split a string on commas.\r\n\r\nI wouldn't say that that is mutually exclusive with greasing each user (e.g., priority).\r\n\r\nObviously it is true that the SH spec would be simpler if we grease only SH parser. Though, the flip side of that would be that each user (e.g., priority) will have its own greasing scheme.\r\n\r\nThat's the reason why I tend to think that the total cost might become smaller if we recommend:\r\n* SH serializers add members using keys that users would never generate\r\n* require them to be passed through by the SH parser\r\n* so that each user would be required to ignore members using unknown keys\r\n\r\nPS. Besides, assuming that we want grease the SH parser, I think it might be a good idea to allow ordinary character to use the escaped encoding (e.g., \\x4A), so that parsers incapable of unescaping those characters can be detected at an earlier point.",
          "createdAt": "2020-01-22T04:39:02Z",
          "updatedAt": "2020-01-22T04:39:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'm not at all sure that header authors are going to find greasing desirable across the board; it's very intrusive into the application (unlike other forms of greasing). And, as I said above, it's not at all clear that all header authors are going to be happy to ignore unrecognised keys.\r\n\r\nI'd rather be conservative here -- we haven't done this kind of greasing before (into the application space, rather than just within a protocol), and we're not sure how it will work out (especially considering the potential performance overhead; for small header values, it might seriously inflate their size, even if just in the dynamic table).\r\n\r\nBut, again, folks other than us have an opinion, it'd be good to hear it.\r\n\r\n",
          "createdAt": "2020-01-22T08:28:40Z",
          "updatedAt": "2020-01-22T08:28:40Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've said my part, you disagreed, but I haven't really changed my mind.  If we're building something with must-ignore-unknown semantics, and if we do grease (and we don't have to), then it needs to reach as far as possible.",
          "createdAt": "2020-01-22T08:41:12Z",
          "updatedAt": "2020-01-22T08:41:12Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "SH is only a data model and a serialisation, it can't say anything about semantics of values (including must-ignore or must-not).  I mean, you could introduce weird sentinel values, but that seems like a bad kind of kluge.  (And adding `/(;_grease=1)?/` to my lazy regexp isn't the intended outcome.)\r\n\r\nIt is up to individual header fields' spec authors to define the semantics of values in the context of that header field, including which SH types are allowed, what parameter names are ok, what to do about unrecognised ones, etc.  That includes greasing _their header field_ for extensibility.\r\n\r\nMaybe if we had a way of discussing a schema \u2013 for example a formal grammar an application could pass to the parser to allow it to fail on valid-but-disallowed data \u2013 we could talk about greasing there.  But in the data model itself, it doesn't make much sense.",
          "createdAt": "2020-01-23T08:30:32Z",
          "updatedAt": "2020-01-23T08:30:32Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson that's the thing; we're not enforcing must-ignore-unknown, merely suggesting it as a default. Whether that's the semantic or not is up to individual header definitions. \r\n\r\nI'll do a PR shortly based upon the text above.",
          "createdAt": "2020-01-24T05:09:56Z",
          "updatedAt": "2020-01-24T05:09:56Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Late to the party...\r\n\r\nI've been doing some thinking on GREASE and request headers in the last few days as part of https://wicg.github.io/ua-client-hints/#grease\r\n\r\nAs part of the feedback that we received on that, there are [tradeoffs between GREASEing and variance](https://wicg.github.io/ua-client-hints/#grease). If the GREASEd request headers are used for content adaptation, each new GREASE variant may create another copy in the cache, at least if `Vary` is involved.\r\n\r\nNot saying that this means we should avoid GREASEing - just saying that it's a consideration that will apply to UA Client Hints, and is probably applicable in the general case as well.",
          "createdAt": "2020-01-24T07:13:01Z",
          "updatedAt": "2020-01-24T07:13:01Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'm going to merge the PR and (since this is our last open issue) cut a new I-D. ",
          "createdAt": "2020-01-29T04:52:03Z",
          "updatedAt": "2020-01-29T04:52:03Z"
        }
      ]
    },
    {
      "number": 1016,
      "id": "MDU6SXNzdWU1NDIwNTU5Njg=",
      "title": "Consider using \"User Agent\" and \"Origin Server\" instead of \"end client\"",
      "url": "https://github.com/httpwg/http-extensions/issues/1016",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "## I suggest\r\n\r\nto replace the terms client and server with user-agent and origin server https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#operation when appropriate.\r\n\r\n## because\r\n\r\nIIUC  priority is an end-to-end header. \r\n\r\n## Note\r\n\r\nI can provide a PR if this issue is correct.",
      "createdAt": "2019-12-24T09:11:14Z",
      "updatedAt": "2019-12-24T09:11:33Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1020,
      "id": "MDU6SXNzdWU1NDY3Mzk3NDU=",
      "title": "Deprecate sha-1",
      "url": "https://github.com/httpwg/http-extensions/issues/1020",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nSHA-1 to be deprecated in `digest-headers` because of https://sha-mbles.github.io/\r\n\r\n## Instead\r\n\r\nIt's NOT RECOMMENDED\r\n\r\n## Notes\r\n\r\nWhen we decided to NOT RECOMMEND sha-1, we knew that collisions were possible. \r\nNow researchers states that\r\n\r\n```\r\nWe have computed the very first chosen-prefix collision for SHA-1. In a nutshell, this means a complete and practical break of the SHA-1 hash function, with dangerous practical implications if you are still using this hash function. To put it in another way: all attacks that are practical on MD5 are now also practical on SHA-1\r\n```\r\n\r\nThe latest paper is here https://eprint.iacr.org/2020/014.pdf \r\n",
      "createdAt": "2020-01-08T09:25:08Z",
      "updatedAt": "2020-04-30T09:46:39Z",
      "closedAt": "2020-04-30T09:46:39Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Some feedback I've had is that we should deprecate. I'd like to hear from the WG if there is any pushback to doing so.",
          "createdAt": "2020-01-18T15:53:49Z",
          "updatedAt": "2020-01-18T15:53:49Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm in favour of deprecation.",
          "createdAt": "2020-01-19T14:48:54Z",
          "updatedAt": "2020-01-19T14:48:54Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "3GPP TLS Profile 6 also makes SHA-1 a \"must not\" for TLS 1.2 [1]. \r\n\r\n[1] - https://github.com/EricssonResearch/CBOR-certificates/blob/master/3GPP%20TLS%20Profile%206%20march%202020.pdf",
          "createdAt": "2020-03-07T19:47:32Z",
          "updatedAt": "2020-03-07T19:47:32Z"
        }
      ]
    },
    {
      "number": 1021,
      "id": "MDU6SXNzdWU1NDcyMzg5Mzc=",
      "title": "Reprioritization frames",
      "url": "https://github.com/httpwg/http-extensions/issues/1021",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "There has been some debate about the relative utility of frames as a means of prioritizing and reprioritizing requests.  \r\n\r\nFrames are not guaranteed to be end-to-end and don't enjoy the benefits listed in [Section 8.1](https://httpwg.org/http-extensions/draft-ietf-httpbis-priority.html#why-use-an-end-to-end-header-field).  An (unlisted) reason is that the API for header fields is better understood and more likely to be available than a new and unspecified API.  HTTP/2 defined the use of frames for reprioritization, but APIs are not widely available, nor are they consistent.\r\n\r\nFrames provide two obvious benefits:\r\n\r\n1. They are scoped to the current connection and so only propagate if the receiving endpoint explicitly propagates them.\r\n\r\n2. They can be sent at any time.  This allows for reprioritization, but the requirement to have them sent after requests are complete means that they can't be sent \"on\" a stream, they have to instead refer to a stream, which complicates the design somewhat.  The proposal to allow trailers at any time helps a little here, but only to the extent that it remains possible to send.  Stream closure is used to terminate request bodies in some cases, making any trailer-based solution limited.\r\n\r\nHowever, frames have shortcomings too:\r\n\r\n1. They are complex.  The encoding of a header field into a frame is suboptimal, but necessary for extensibility and consistency reasons.  And the manner in which they refer to requests (or pushes) makes them more complex to manage than a header field.\r\n\r\n2. They are only scoped to a connection, which means that the extent of propagation can be non-deterministic.  In particular, they depend on the connection supporting the signaling.  This is the flip side of the benefit, and - in my opinion - outweighs it.\r\n\r\n3. The API is far more difficult compared to header fields.\r\n\r\nWe know little enough about the efficacy of prioritization that we should defer the definition of frames absent strong motivation for their efficacy and desirability.  The current document makes a good case for header fields, but the motivation for frames is weaker.  It is true that cases like escalation of a speculative fetch to blocking status are *theoretically* appealing, but those cases are rare and unlikely to benefit from reprioritization.  In particular, the mismatch between end-to-end and hop-by-hop (excuse the use of deprecated terminology) characteristics here makes it very hard to reason about the outcome.\r\n\r\nI know that others (@RyanAtGoogle in particular) have questions about the header field from a different angle and would prefer frames, exclusively.  So this probably comes down to having more discussion about which approach to take: headers, frames, or both.  \r\n\r\nIn either case, I would suggest that we have a need for both clear signals that the mechanism is broadly useful and evidence that that it is likely to be widely implemented.\r\n",
      "createdAt": "2020-01-09T04:21:20Z",
      "updatedAt": "2020-09-10T14:55:37Z",
      "closedAt": "2020-09-10T14:55:25Z",
      "comments": [
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "> 1. [Frames] are complex. The encoding of a header field into a frame is suboptimal, but necessary for extensibility and consistency reasons. And the manner in which they refer to requests (or pushes) makes them more complex to manage than a header field.\r\n\r\nCan you expand on what you mean by \"complex\"? Parsing strings is more difficult and error-prone than parsing fixed-width binary fields. I think you might be concerned about ordering problems w.r.t. other frames for the same stream, but I'm not sure.\r\n\r\n> 2. They are only scoped to a connection, which means that the extent of propagation can be non-deterministic. In particular, they depend on the connection supporting the signaling. This is the flip side of the benefit, and - in my opinion - outweighs it.\r\n\r\nFunny you wrote that, because I have the exact opposite opinion.\r\n\r\nPriority is a relative concept. We must have some way to group requests before we can speak meaningfully about the priority of any individual request. This proposal does not define an explicit grouping of requests -- the grouping is implicitly per connection. Whether we communicate priorities with a header or a frame does not change this fact. It follows that this proposal defines hop-by-hop priorities. We can claim they are \"end-to-end\" but that is a lie. The proposal admits as much when it refers to proxies needing to [coalesce](https://httpwg.org/http-extensions/draft-ietf-httpbis-priority.html#coalescing-intermediaries) priorities before they are forwarded to backends.\r\n\r\nI can imagine true end-to-end priorities. One strawman proposal is to say that priorities are global: if client A sends a request with level=low, and client B sends a request with level=high, then B's request is always preferred. This is a bad idea for [obvious reasons](https://httpwg.org/http-extensions/draft-ietf-httpbis-priority.html#fairness).\r\n\r\nAnother strawman is to add a `uuid` field to each priority. Each client might generate a `uuid` and send that same value with each request. Now a proxy can blindly forward priorities to backends -- given sufficiently random uuids, there is no fear of collisions and the backend implementation is straightforward. But I think this is a bad idea for privacy reasons, if nothing else.\r\n\r\nConnections are the only available grouping mechanism I can think of.\r\n\r\nRelatedly, if we are using an \"end-to-end\" HTTP header field, then I expect that the header field should have some meaning on HTTP/1. But I'm not sure what that meaning is ... it hasn't been specified, and I'm not sure if any meaningful behavior is possible?\r\n\r\n> 3. The API is far more difficult compared to header fields.\r\n\r\nDon't agree. Reprioritization is not possible with header fields (barring a hacky repurposing of trailers, as I think you suggested), so a frame-based API is strictly more powerful.\r\n\r\nHTTP libraries typically have a type that manages information about the request, beyond just the request headers. This type is a perfectly reasonable place to put priority information. JS has [RequestInfo and RequestInit](https://fetch.spec.whatwg.org/#fetch-method), Go has [http.Request](https://golang.org/pkg/net/http/#Request), Python has [urllib.Request](https://docs.python.org/3/library/urllib.request.html#request-objects), etc. I don't see how frames make APIs \"far more difficult\"? Perhaps you had a different notion of \"API\" in mind?",
          "createdAt": "2020-01-09T08:01:51Z",
          "updatedAt": "2020-01-09T08:01:51Z"
        },
        {
          "author": "RyanTheOptimist",
          "authorAssociation": "NONE",
          "body": "> I know that others (@RyanAtGoogle in particular) have questions about the header field from a different angle and would prefer frames, exclusively. \r\n\r\nThanks for kicking this off! Indeed, I do have questions about header fields. After reading @tombergan's reply, I think we're both on the same page.\r\n\r\n1. Since reprioritization is not possible with a header it seems that frames are more powerful than headers and frames (or some other non-header mechanism at least) would be required. I'd much prefer to have only one mechanism for expression priorities.\r\n\r\n2. The end-to-end-ness of headers strikes me as a con, rather than a pro. Proxies which send requests from multiple clients over the same back-end connection and pass along the original client's priority header run the risk of creating pathological behavior. A client with only a single low priority request outstanding could end up indefinitely starved by another client issuing high priority requests. Starvation of requests is a feature when a single client's low priority requests are intentionally starved by the same client's high priority requests. Starvation of requests is a bug when one client unintentionally starves another client.\r\n\r\nIt feels like any such proxies need to make a conscious decision about how to prioritize such requests. Using a hop-by-hop mechanism makes this required. Frames are obviously hop-by-hop and they seem ideally suited here. (If we felt really passionate that headers are the right approach then perhaps a pseudo-header would be an option. But frames seem simpler in this case).\r\n\r\n3. On the API front, it's not obvious to me that headers are a simpler API than the existing APIs exposed by HTTP libraries (as @tombergan said). However, if it turned out there was a library in which headers really were a simpler API, there's nothing to prevent that library from transforming a caller's header into the protocol's frame.",
          "createdAt": "2020-01-09T22:30:07Z",
          "updatedAt": "2020-01-09T22:30:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The evidence we've seen with HTTP/2 is that no one really experimented with priorities and that there were scant APIs that enabled doing so. Putting priority information in _request_ objects does make sense but we have not seen that in practice, why not? Is it a by product of the complicated tree? Would a simpler priority scheme make it people more inclined to take this up?\r\n\r\nIn contrast, everything I'm familiar with has methods to set or get headers with a K-V. Handling headers is a common activity, so the code is probably battle tested, more familiar to developers, and easily migrates between implemention environments and language. What's more, endpoint applications could experiment today without any needing their libraries to update. The code implementing the priority scheduling does need to understand these signals, but in my experience the internals of this are not exposed to applications, which is probably a good thing.\r\n\r\n> there's nothing to prevent that library from transforming a caller's header into the protocol's frame.\r\n\r\nI think this point came up in some design team meetings and its a good one. Would consuming a header meet the expectations of developers? Are there other examples of that?\r\n\r\n",
          "createdAt": "2020-01-09T23:21:42Z",
          "updatedAt": "2020-01-09T23:21:42Z"
        },
        {
          "author": "RyanTheOptimist",
          "authorAssociation": "NONE",
          "body": "> The evidence we've seen with HTTP/2 is that no one really experimented with priorities and that there were scant APIs that enabled doing so. Putting priority information in _request_ objects does make sense but we have not seen that in practice, why not? Is it a by product of the complicated tree? Would a simpler priority scheme make it people more inclined to take this up?\r\n\r\nFor what it's worth, Chrome's URLRequest object has a priority field:\r\n\r\nhttps://cs.chromium.org/chromium/src/net/url_request/url_request.h?sq=package:chromium&g=0&l=900\r\n\r\nThat being said, it's a simple enum. We had many discussions about exposing HTTP/2's prioritzation mechanism up the stack, but decided against it. Among other things the inter-stream dependencies in HTTP/2 made it really challenging to create an higher level abstraction that made sense here. The proposed priority scheme (enum priority + bool interleave) would be simple to expose, on the other hand.",
          "createdAt": "2020-01-10T00:07:39Z",
          "updatedAt": "2020-01-10T00:07:39Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interesting, thanks!\r\n\r\n>  The proposed priority scheme (enum priority + bool interleave) would be simple to expose, on the other hand.\r\n\r\nSomething to consider is that the proposal's extensibiliy capability. If that is desirable, then a less rigid structure is desireable, and we settled on structured headers for this purpose in the current design (including PRIORITY_UPDATE frame holding a field that carries `ASCII text, encoded using Structured Headers.`).\r\n\r\nA more binary-friendly format with extensibility, in HTTP/2, is a bit of a tricky problem to solve. So it will be interesting to see what APIs would think is sane,",
          "createdAt": "2020-01-10T00:24:04Z",
          "updatedAt": "2020-01-10T00:24:53Z"
        },
        {
          "author": "RyanTheOptimist",
          "authorAssociation": "NONE",
          "body": "The extensibility is an interesting issue! On one handing, simply passing around ascii text which can store information on any prioritization scheme is really convenient and attractive. On the other hand, as something to expose on, for example, Chrome's URLRequest object it's not a great fit. In Chrome at least, requests are typically initiated at a layer that is entirely ignorant of the underlying connection that will be used to satisfy the request. (Many requests result in a new connection being created, for example). As such, the caller does not know if it's going to be HTTP/1, HTTP/2, HTTP/3, HTTP/3+priority extension X, etc. This means that the caller is not in a great position to know what underlying prioritization scheme will be used on the wire. As a result, the API that we want to expose on the request needs to be relatively generic. (HTTP/2 stream dependencies is the opposite extreme :>) Further,  along the way from the Request to the connection there are various throttles and internal prioritization decisions which take the Request's priority into consideration. As such it's important at this code be able to understand priority and a free-from priority string is problematic in this respect.\r\n\r\nAll of this being said, I think the issue of API design should be largely orthogonal from the on-the-wire prioritization encoding and I wonder if we (HTTP and QUIC WGs) would be well served to focus on the protocol and not the API?  But I'm not sure about this...",
          "createdAt": "2020-01-10T01:14:59Z",
          "updatedAt": "2020-01-10T01:14:59Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "Extensibility is an interesting argument for using headers. I will have to think about that some more.\r\n\r\n> The evidence we've seen with HTTP/2 is that no one really experimented with priorities and that there were scant APIs that enabled doing so. Putting priority information in request objects does make sense but we have not seen that in practice, why not? Is it a by product of the complicated tree? Would a simpler priority scheme make it people more inclined to take this up?\r\n\r\nThese are good questions. My attempt at answers:\r\n\r\nBrowsers use 10s to 100s of HTTP requests to render a complex document with many parts and dependencies, often for users over slow networks, making prioritization important. That might be a special case. Outside of browser land, I suspect that most programs fetch no more than one or a few URLs at a time and wouldn't benefit from priorities. (I don't have any evidence for this, it's just a suspicion.)\r\n\r\nOne exception is RPC-over-HTTP, such as gRPC. Developers have requested priority support for gRPC, but the maintainers have pushed back with complexity concerns:\r\nhttps://github.com/grpc/grpc-go/issues/1448\r\nhttps://github.com/grpc/grpc-java/issues/2390\r\n\r\nOne thing to note about gRPC is that its API does not expose the underlying HTTP headers directly (see [here](https://grpc.io/docs/quickstart/cpp/) and [here](https://godoc.org/google.golang.org/grpc)), but it does expose [Custom-Metadata](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md) which is serialized as ordinary HTTP header fields. These fields are defined to be application-specific and are not interpreted by gRPC. Our new Priority header field does not match the `grpc-*` pattern that is reserved for gRPC use, so it's not clear that gRPC could use our Priority header in the first place, as it might conflict with existing app-specific metadata.\r\n\r\nThere has been interest in exposing priorities to JavaScript. I'm not sure what the status of that is -- @yoavweiss might know more.",
          "createdAt": "2020-01-10T01:24:10Z",
          "updatedAt": "2020-01-10T01:24:10Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tombergan \r\n> Parsing strings is more difficult and error-prone than parsing fixed-width binary fields. \r\n\r\nMy understanding is that the frame is just the header-field value (i.e., text) shoved into a frame with some additional fields that allow the frame to reference the subject.  That referential information is where the added complexity comes in.\r\n\r\n> if we are using an \"end-to-end\" HTTP header field, then I expect that the header field should have some meaning on HTTP/1. But I'm not sure what that meaning is ... \r\n\r\nThis is, I think a good place to take this discussion.  I agree that we can only realistically use priority information if they share a common reference point.  Priority signals from different sources are unlikely to share a reference frame (which is another reason that [merging](#1026) is probably a bad idea - servers might not share the frame the client uses).  However, we have a number of ways in which we might determine that two requests share a common reference frame.\r\n\r\nConnections are probably the obvious way to tie requests together, but they fall short in a few ways.  The coalescing intermediary described in the draft is one.  And then we have HTTP/1.1, as you say.\r\n\r\nThe use of IP- and transport-layer fields to correlate requests is similarly fraught, but I'll bet that it happens already, so I wouldn't rule it out completely.  Weaknesses due to competition of incompatible endpoints behind a NAT are probably rare enough (outside large-scale NAT) that you could deploy something that used source IP with moderate confidence that it wouldn't do significant harm.  The [X-]Forwarded-For fields are still useful at origin servers that are fronted by an intermediary.\r\n\r\nBut the obvious grouping construct here is cookies.  As much as we despise them, they are almost perfect for this purpose.\r\n\r\nIt is conceivable that HTTP/1.1 requests could use priority using the above, though I suspect that the implementation challenges are such that we won't see it happen.  If you had a server with multiple HTTP/1.1 connections to it from the same source, it could implement shared prioritization and congestion control for that set of connections.  You might say that HTTP/2 is probably a good idea at that point and you'd be right, but I've seen stranger things.\r\n\r\n@RyanAtGoogle \r\n> This means that the caller is not in a great position to know what underlying prioritization scheme will be used on the wire. As a result, the API that we want to expose on the request needs to be relatively generic. \r\n\r\nThis is why I like header fields.  It avoids creating any strong linkage between the API and the eventual connection.  We know that they get through, even if they might not be acted upon in precisely the same way.  Have you considered continuing to respect `URLRequest.setHeader(\"priority\", \"5\")` or similar as a method for reprioritization?  If frames aren't available, then it does nothing, but you can feed that through the pipeline as you choose from there.  That includes adjusting the value based on local policy.",
          "createdAt": "2020-01-10T03:33:18Z",
          "updatedAt": "2020-01-10T03:33:18Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "> My understanding is that the frame is just the header-field value (i.e., text) shoved into a frame with some additional fields that allow the frame to reference the subject. That referential information is where the added complexity comes in.\r\n\r\nYou are [right](https://httpwg.org/http-extensions/draft-ietf-httpbis-priority.html#http2-priorityupdate-frame). I must have been remembering an older draft that used a 32 bit field. This seems to give frames identical extensibility as headers.",
          "createdAt": "2020-01-10T15:50:07Z",
          "updatedAt": "2020-01-10T15:50:07Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Putting priority information in _request_ objects does make sense but we have not seen that in practice, why not? Is it a by product of the complicated tree? Would a simpler priority scheme make it people more inclined to take this up?\r\n\r\nA tree-based API is difficult to expose easily in a comprehensible way.  You could go object-oriented, and pass a request object to another request's method to establish a relationship.  Or you could pass IDs around for the same effect in a more declarative style.  But regardless, it requires that the caller understand the universe of other requests that are open on the connection -- and therefore requires knowing the relationship between requests and connections, which might be better to abstract away.\r\n\r\nHowever, this style of priority is an independent declaration about each request -- the caller doesn't need to know any relationships; it just describes the resource's importance.  That's a much easier API to expose and an easier API to understand how to use.",
          "createdAt": "2020-01-10T15:58:14Z",
          "updatedAt": "2020-01-10T15:58:46Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW that `PRIORITY_UPDATE` layout is based on us starting with the headers axiom. \r\n\r\nIf starting with a frame axiom, one might wish to create a extensible frame format. HTTP/2 [SETTINGS](https://tools.ietf.org/html/rfc7540#section-6.5.1) provides fixed-size key-value parameters but that that might be too restrictive for the needs of extensions. If might be possible to define some nested binary structure that would allow for lists, dictionaries etc. But that might lead to divergence between HTTP/2 and HTTP/3. \r\n\r\nAs mentioned somewhere (Singapore maybe?), it might be prudent to stick with Structured headers as a canonical definition and maybe later we can lean on the proposed [Binary Structured Headers](https://tools.ietf.org/html/draft-nottingham-binary-structured-headers-01) for a less bespoke, more efficient(?) serialization.",
          "createdAt": "2020-01-10T16:05:48Z",
          "updatedAt": "2020-01-10T16:05:48Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "Trying to return this to something more concrete:\r\n\r\nI see two ways this can go. One is that we drop the header and use a frame only. I prefer this for a number of reasons already mentioned. The other is that we keep the header. I am open to this (despite preferring the frame) if we can resolve the following questions:\r\n\r\n* What happens at proxies that don't understand the header? For example, what happens if a proxy merges many client requests onto a single proxy-to-origin connection and blindy forwards the header across that connection?\r\n\r\n* What is an H1 server expected to do with this header?\r\n\r\n* I know that Martin and others believe the header will simplify APIs. Even if we assume this is true, we need some other API to support reprioritization. It follows that implementations will use a second API for reprioritization, or they'll use a single non-header API for all cases, or they will drop reprioritization entirely. It seems that we cannot get this (potential) benefit of header-based APIs without dropping reprioritization entirely?\r\n\r\nMartin had a good comment [earlier](https://github.com/httpwg/http-extensions/issues/1021#issuecomment-572857972) regarding the first two questions. What I got from that comment was: cookies could work, but many people dislike cookies; IP could work, except for large-scale NATs; you could use cookies or IPs to do something on H1, but it seems unlikely anyone will do so due to the complexity. Therefore, in practice, we'll likely end up in the same place that we would with frames: priority will apply within individual H2/H3 connections.",
          "createdAt": "2020-01-28T22:12:14Z",
          "updatedAt": "2020-01-28T22:12:14Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "~~Going back to the OP, MT said~~\r\n\r\n~~> In either case, I would suggest that we have a need for both clear signals that the mechanism is broadly useful and evidence that that it is likely to be widely implemented.~~\r\n\r\n~~I've prepared the following PR that roughs in a new HTTP/3 frame to allow this along with some basic discussion. There's probably more to be added so comments are welcome, although we might choose to land the PR and address things further in followups.~~\r\n\r\n~~https://github.com/httpwg/http-extensions/pull/1168/files~~",
          "createdAt": "2020-04-30T13:58:37Z",
          "updatedAt": "2020-05-04T15:44:27Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My previous comment is a blatant misread on MT's. Apologies. Martin was asking for a signal that reprioritization is a mechanism that is useful, and that there is evidence that people would implement it. \r\n\r\nThe linked PR does not answer the question about reprioritization. What it allows is the use of a frame for the initial priority signal. Sending a signal on a different stream to the request means that there will be ordering edge-cases, a server that can accomodate that doesn't need to do too much work to support reprioritization while a response is in flight.",
          "createdAt": "2020-05-04T15:46:59Z",
          "updatedAt": "2020-05-04T15:46:59Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson I don't think it's possible to conclude that the old prioritization scheme wasn't widely used because it was a frame.  The main reason I've heard cited for why it wasn't widely used was excess complexity for implementers and for developers who used it.  If the scheme had been simpler, I believe APIs would be widespread by now.\r\n\r\nAbove, you talk about using priorities across multiple HTTP 1.1 connections and how it might work.  For every load balancer setup I've ever heard of, that would be somewhere between impractical and impossible.  Either way, I can't imagine anyone doing this.  Cookies are a particularly bad example, because they are visible long after the connection has been load-balanced.\r\n\r\nAlso, the frame solves a problem besides re-prioritization, which is how to convey a hop-by-hop signal when a header indicates an E2E signal, such as on a multiplexed connection behind a load balancer.\r\n\r\nSome points that came out of the design team that are still important:\r\n1) Re-prioritization is used today and was believed to be useful.  I realize you're questioning that here, but it seems like your real goal is to get rid of the frame.\r\n2) The design team decided that the header should not be exposed directly to Javascript, at least not without the agreement of the W3C that was the right thing to do, so it's not as simple as making it  a header and the API is done.\r\n3) It was pretty clear consensus would never be obtained on a single option(header or frame), due to the varied set of use cases.\r\n\r\nMy personal opinion is that the header is primarily useful for server infrastructure to fix poor or non-existent client prioritization, which is the use case Cloudflare was successful with.  I've seen no evidence the header has any advantages over the frame in the browser use case, and it does introduce complexity, since now my multi-tier load balancer infrastructure needs to do special case handling for a new header based on whether it's directly user-facing.  Realistically, stripping it may be the safest option for load balancers.",
          "createdAt": "2020-06-08T21:00:37Z",
          "updatedAt": "2020-06-08T21:00:37Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think I ever suggested a causal relationship between the frame and the failure of the old scheme.  There are plenty of aspects in the overall design that you might point to, and I'm happy to concede that being a frame is probably the least problematic.\r\n\r\nI didn't mean to suggest that cross-connection prioritization was something you might expect to have implemented - at least at the server end.  But browsers might be in a better position to do something.\r\n\r\nAddressing your points in order.\r\n\r\n1. Yes, I think that the frame is insufficiently motivated.  Both as a HBH signal and for reprioritization.  I think that the HBH aspects are insufficiently strong to motivate its inclusion, though I'm happy to put forth my reasons for why I think a field is superior in that case also.  It honestly sounds like you have some proprietary use cases, for which I think that this discussion isn't likely going to be informative.\r\n\r\n2. I don't understand this conclusion.  And I disagree with it.  I realize that the implications of allowing untrusted script to determine what is essentially policy on browser prioritization logic seem scary, but we let content to do a whole lot more than that.  I personally have no issue with allowing content to set priority.  After all, the effect on performance is something that a site ultimately answers for.\r\n\r\nAre you suggesting that you can't or wont access a header field?",
          "createdAt": "2020-06-09T07:08:33Z",
          "updatedAt": "2020-06-09T07:08:33Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think @icing made an interesting point in https://lists.w3.org/Archives/Public/ietf-http-wg/2020AprJun/0268.html, by using as an example an H2/H3 reverse proxy in front of a legacy H1 server.\r\n\r\nFor a deployment that can only have limited concurrency between H2/H3 reverse proxy and the backend, having a guarantee that the priority signal is delivered alongside the request itself is important. That is because the processing order of requests cannot be changed once the request is being forwarded to the backend server.\r\n\r\nThis sounded to me like an argument against using a frame sent on a stream other than the request stream *for indicating initial priority*, as we do not have ordering guarantee across multiple streams in QUIC.\r\n\r\nI am not sure how strong that argument is, though at least we (H2O) provides a knob to change the backend concurrency independently from frontend concurrency to prevent attackers from issuing huge amount of requests in parallel, while providing enough concurrency to fulfill the BDP between the end-client and the reverse proxy.",
          "createdAt": "2020-06-17T08:04:02Z",
          "updatedAt": "2020-06-17T08:04:02Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Coming back to this after leave.\r\n\r\n1. The use cases I have in mind are Chrome and other clients that want to re-prioritize requests, particularly due to a change in viewport, so definitely not proprietary in anyway.  But I see there's a separate thread on the value of whether people intend to use reprioritization, so I'll catch up on that.\r\n2. At the time, people felt exposing this was too dangerous to assume, and at the very least it'd need to be confirmed with the W3C.  Even so, browsers may decide to limit its usage(ie: not allow the very highest priority/etc).\r\n\r\nI certainly can access a header, I'm just saying it adds complexity and risk to a very complex and risk-averse environment on the server side, and I can't see the value outside of a multiplexed connection.  I'm not saying we shouldn't include the header in the draft, but I don't see it as being that useful past the first hop.",
          "createdAt": "2020-07-27T20:03:39Z",
          "updatedAt": "2020-07-27T20:03:39Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From the chairs' email on August 26 2020 https://lists.w3.org/Archives/Public/ietf-http-wg/2020JulSep/0118.html\r\n\r\n> After reviewing list and issue discussion, as well as the results of our previous request for implementer intent, the Chairs believe that there is rough consensus forming to support reprioritisation in draft-ietf-httpbis-priority. \r\n\r\n> If you object, please state so (ideally giving reasons).\r\n\r\n12 days on there's been no objections. We should start thinking about closing this issue soon.",
          "createdAt": "2020-09-07T22:48:09Z",
          "updatedAt": "2020-09-07T22:48:42Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing this issue.\r\n\r\nIf folks want to open new specific issues on the draft text, editor's copy or when we cut draft -02, that's fine.",
          "createdAt": "2020-09-10T14:55:25Z",
          "updatedAt": "2020-09-10T14:55:37Z"
        }
      ]
    },
    {
      "number": 1022,
      "id": "MDU6SXNzdWU1NDcyNDAzNDg=",
      "title": "Coalescing intermediaries and fairness",
      "url": "https://github.com/httpwg/http-extensions/issues/1022",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "In [Section 7.1](https://httpwg.org/http-extensions/draft-ietf-httpbis-priority.html#coalescing-intermediaries) there is a rather firm recommendation to erase priorities at servers that are served by coalescing intermediaries:\r\n\r\n> the server SHOULD prioritize the response as if it was assigned the priority of u=1, i=?1 (i.e. round-robin) \r\n\r\nThis seems wrong to me.  The Priority header field provides information about what the User Agent thinks of priority.  This might be adjusted by intermediaries on the path, and it might not be globally consistent, but that does not mean the information should be discarded.  Instead, I would prefer that we say that when an intermediary coalesces requests from multiple clients, servers need to be aware of that and account for that in their processing.\r\n\r\nThe remainder of this text is fine in the sense that it identifies information the server can use to more fairly allocate resources to different requests, but - again - this is just information the server uses when making prioritization decisions.\r\n\r\nThe model we operate on should not assume be that Priority is an instruction to the server, but that it provides the server (or intermediary) clues about how it might decide to allocate resources.",
      "createdAt": "2020-01-09T04:26:10Z",
      "updatedAt": "2020-09-28T11:18:50Z",
      "closedAt": "2020-09-28T11:18:50Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No one responded to this for a while, sorry. The text is mostly untouched but I did change the example to just `u=1,i`.\r\n\r\nMy read of this today, I'm concerned that the requirement is a bit specific. It's not clear if a server applying this would also discard any additional priority parameters. I don't know if @martinthomson's original point was along those lines or not, but I'll try to make a PR to address what I think needs fixing",
          "createdAt": "2020-09-17T00:28:29Z",
          "updatedAt": "2020-09-17T00:28:29Z"
        }
      ]
    },
    {
      "number": 1023,
      "id": "MDU6SXNzdWU1NDcyNDI5OTQ=",
      "title": "Semantics for priorities",
      "url": "https://github.com/httpwg/http-extensions/issues/1023",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "The [explanation of the rationale behind assigning semantics to priority levels](https://httpwg.org/http-extensions/draft-ietf-httpbis-priority.html#why-do-urgencies-have-meanings) is not especially convincing.\r\n\r\nThe idea that we might have consistent labeling of priorities is something this shares with DSCP, but there the semantics are given more precise semantics than this document does for its levels.  If these semantics are to carry any weight, then it needs to be really clear what the client might expect a server to do with each different value.  It seems to me that if a server was to complete all requests at priority N before allocating anything other than opportunistic resources to N+1 then you get pretty much the semantics as described.  Priority 0 gets completed first, and 7 last.\r\n\r\nThe idea that different clients might share an understanding of different values is nice, but for that to work you need to trust that clients will label things similarly.  Right now, I don't see any incentive to do so.  If one implementation were to shift their priorities one higher or one lower, the effect probably wouldn't be any different.\r\n\r\nI do strongly agree with the idea that the number of buckets needs to be small.  8 is a reasonable number on balance.  But the associated trappings need far stronger motivation.\r\n\r\nKeep the last paragraph of that section though.  That concept deserves greater prominence in the document.  It does that by largely contradicting the argument for assigned semantics though.",
      "createdAt": "2020-01-09T04:35:14Z",
      "updatedAt": "2020-03-04T11:33:10Z",
      "closedAt": "2020-03-04T11:33:09Z",
      "comments": [
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "I mostly agree with Martin here, though if I'm reading the proposal correctly, this is mostly a dup of\u00a0#1026? If there's no specification for merging client-generated and server-generated priorities, then there's no need to give semantics for each priority level.\r\n\r\n>\u00a0I do strongly agree with the idea that the number of buckets needs to be small.\r\n\r\nWhat is your objection to using 16 or 32 bit integers (or perhaps 15 or 31, to reserve a bit for \"incremental\")?\r\n\r\nThe current number of levels is copied from Chrome's current implementation, which is subject to change. For example, we've considered deprioritizing iframes, which you might imagine doing by creating two sets of levels, one for the main frame and another for iframes. This needs 2x as many levels. A similar thing might happen for foreground vs background tabs, which needs another 2x. It would be unfortunate to prevent future experimentation like this.",
          "createdAt": "2020-01-09T07:00:19Z",
          "updatedAt": "2020-01-09T08:02:46Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Constraints on the system mean that there is a greater chance that people will implement this.  If you have 4G different levels, it's almost certain that implementations will be forced to quantize.  A smaller set might make some choices harder, but when the primary reason for inconsistent implementation of h2 priorities was that there were too many choices, that seems justified now.  I would rather start with a very small set of options at the first level and then offer augments (incremental, visible/not, whatever) that refine that.  The risk that we get a very flexible design that isn't consistently implemented remains one of my biggest concerns here. A very simple core that can be extended was the main reason I am hopeful that this approach could work.",
          "createdAt": "2020-01-10T01:29:04Z",
          "updatedAt": "2020-01-10T01:29:04Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson \r\n> The idea that different clients might share an understanding of different values is nice, but for that to work you need to trust that clients will label things similarly. Right now, I don't see any incentive to do so.\r\n\r\nMaybe we should better point out that a small number of well-defined urgency levels gives you collaboration, using JavaScript API as an example in addition to client-server collaboration.\r\n\r\nIf we are to allow JavaScript code running on web browsers specify the priority of requests that that code generates, the priorities need to have a well-defined meaning so that those requests can be prioritized against the requests issued by the browser, regardless of the web browser being used.",
          "createdAt": "2020-01-14T05:48:35Z",
          "updatedAt": "2020-01-14T05:48:35Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For that to work reliably, you would have to eliminate any freedom that browsers might exercise in terms of using different priority markings on requests.  I'm not comfortable saying that.  That's the other part of the semantic thing.  I can understand 5>3, but as soon as we get to saying that all browsers need to mark image loads as X, then we lose the ability to apply a different strategy.\r\n\r\nI realize that this doesn't help JS integrate into this very well.  The best I can offer is the possibility of an API that takes abstract concepts and interprets those through the lens of the browser's strategy.  Either that or having the browser compress or reinterpret the values provided by content.  The latter might only be necessary during page load and only when the requests share the same connection as default loads.",
          "createdAt": "2020-01-16T03:45:07Z",
          "updatedAt": "2020-01-16T03:45:07Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson I understand your concern, and I would point out that status quo provides a workaround.\r\n\r\nThe draft defines four levels: prerequisite, document, supplementary, background. I think that these four levels can be defined well.\r\n\r\nThe flexibility that we need is within the supplementary level. As you point out, it would be beneficial to give more (or less) precedence to some supplementary resources. That's why we provide the client three levels (i.e. 3 to 5), while 4 being the default of the supplementary level.\r\n\r\nAt the same time, a logic that is specific to the website (i.e. the server, but we might want to say that JavaScript on the browser-side also belongs to this category) might have better knowledge regarding how its resources should be prioritized. Therefore, we allow these site-specific logic to use levels 2 and 6 to intervene even harder.\r\n\r\nI think that this design is on-balance a good middle ground in providing web browsers enough wiggle room, at the same time allowing site-specific logic to tune priorities in a browser-agnostic manner.",
          "createdAt": "2020-01-16T04:17:45Z",
          "updatedAt": "2020-01-16T04:17:45Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "Thinking about this some more, especially after @martinthomson's comment [here](https://github.com/httpwg/http-extensions/issues/1026#issuecomment-577456924), I have no objections to 8 levels. We can always add more later if there is a strong motivation for doing so.\r\n\r\n> For that to work reliably, you would have to eliminate any freedom that browsers might exercise in terms of using different priority markings on requests. I'm not comfortable saying that.\r\n\r\nI strongly agree with this.\r\n\r\nThis issue is merging with #1026, especially after [this comment](https://github.com/httpwg/http-extensions/issues/1026#issuecomment-577465626).",
          "createdAt": "2020-01-23T02:15:06Z",
          "updatedAt": "2020-01-23T02:15:06Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this issue can be closed together with #1026.",
          "createdAt": "2020-03-04T06:06:15Z",
          "updatedAt": "2020-03-04T06:06:15Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "agreed, lets close this and open new issues for any specific problems with the document.",
          "createdAt": "2020-03-04T11:33:09Z",
          "updatedAt": "2020-03-04T11:33:09Z"
        }
      ]
    },
    {
      "number": 1024,
      "id": "MDU6SXNzdWU1NDcyNDM3MDU=",
      "title": "Capitalize \"incremental\" section and others",
      "url": "https://github.com/httpwg/http-extensions/issues/1024",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "priorities"
      ],
      "body": "The lowercase headings in the document imply that they represent field or parameter names, but these are concepts.  For instance \"incremental\" doesn't appear on the wire, \"i\" does.",
      "createdAt": "2020-01-09T04:37:42Z",
      "updatedAt": "2020-03-04T05:18:35Z",
      "closedAt": "2020-03-04T05:18:35Z",
      "comments": []
    },
    {
      "number": 1025,
      "id": "MDU6SXNzdWU1NDcyNDQxMzg=",
      "title": "\"i=?1\" -> \"i\"",
      "url": "https://github.com/httpwg/http-extensions/issues/1025",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "priorities"
      ],
      "body": "Changes in structured headers means that boolean parameter values are reduced to their parameter name:\r\n\r\n> Parameters whose value is Boolean true MUST omit that value when serialised. \r\n\r\n-- https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#param",
      "createdAt": "2020-01-09T04:39:06Z",
      "updatedAt": "2020-03-04T05:18:35Z",
      "closedAt": "2020-03-04T05:18:35Z",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Q: should this be labeled `header-structure` ?",
          "createdAt": "2020-01-09T11:16:33Z",
          "updatedAt": "2020-01-09T11:16:33Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No, this issue addresses the minor editorial problem that needs fixing in the priorities spec \r\n\r\ne.g. https://tools.ietf.org/html/draft-kazuho-httpbis-priority-04#section-3.2 just needs some tweaks to be compliant with structured headers.",
          "createdAt": "2020-01-09T11:32:10Z",
          "updatedAt": "2020-01-09T11:32:54Z"
        }
      ]
    },
    {
      "number": 1026,
      "id": "MDU6SXNzdWU1NDcyNDU2MDY=",
      "title": "Merging priorities",
      "url": "https://github.com/httpwg/http-extensions/issues/1026",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "The document implies that [server priorities *override* client ones](https://httpwg.org/http-extensions/draft-ietf-httpbis-priority.html#merging).  I think that is a mistake.  The current approach seems strongly biased toward the role that a gateway provides.\r\n\r\nBoth values provide some information and an intermediary can use that information as it chooses.  Including advice that suggests the server information might be more complete and thus worthy of greater attention is probably the right way to address this question.  I can definitely see gateways throwing out client priorities in favour of server ones, but you don't have to *require* that.",
      "createdAt": "2020-01-09T04:43:55Z",
      "updatedAt": "2020-03-04T11:33:02Z",
      "closedAt": "2020-03-04T11:33:02Z",
      "comments": [
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "I agree with this. As Martin alludes, the server has de facto power to do whatever it wants. It's not necessary to spec anything beyond that.\r\n\r\nFurther, I think the specific proposal is a mistake at a technical level. Expanding on that:\r\n\r\nIIUC, the design is largely motivated by the work behind [this blog post](https://blog.cloudflare.com/better-http-2-prioritization-for-a-faster-web/), which argues that current browsers either don't use H2 priorities or use suboptimal priorities, therefore CloudFlare gets benefit from server-driven priorities. But as that blog post observes, Chrome's priorities are almost optimal. The only problem is that images are serialized, rather than concurrent, and this happens because H2 does not allow constructing the optimal schedule with concurrent images. This is fixed by the new priority scheme. I fully expect that Chrome and other browsers will use the optimal schedule for H3 ... at which point, what is the server going to do?\r\n\r\nHere's a more concrete problem. Suppose a web site uses the same image in two contexts: as the main image of an article, and as a thumbnail image in a list of related articles. In the first context, the image is prominently above-the-fold and should have high priority. In the second context, the image is below the main content and should have low priority. The browser knows this and can prioritize the image accordingly. But how will the server know this? The server sees one request at a time. Given a request for the image, in isolation, it cannot distinguish these two cases.\r\n\r\nThere are other examples like this, such a script that is sync in one context and async/defer in another context, or a stylesheet that is used by the main frame in one context and an iframe in another context. In general, it appears that the client has strictly more information than the server and thus can do a strictly better job generating priorities.\r\n\r\nMixing client and server-generated priorities might be a good idea, but it appears to be a research problem. IMO, even setting aside Martin's concern, this idea is not mature enough to be accepted by this working group.",
          "createdAt": "2020-01-09T06:56:37Z",
          "updatedAt": "2020-01-09T06:56:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there are two aspects to Martin's issue:\r\n\r\n1) the use of prose that says _override_ rather than _maybe prefer server priorities_. I think that can be straightforwardly addressed by expanding the description of priority collaboration\r\n\r\n2) reservation of [supplementary](https://httpwg.org/http-extensions/draft-ietf-httpbis-priority.html#rfc.section.3.1.3) levels for use only by the server. Although a gateway can use the information as it sees fit, the specification gives more leverage to the server. Is that ok?\r\n\r\n@tombergan thanks for the examples. Similar edge cases have come up in design team discussions. Some possible ways to address these are:\r\n\r\n* consider that a server delivering resources can combine `priority` with other client information. For example, [Fetch Metadata](https://www.w3.org/TR/fetch-metadata/) (which is just a proposal at this stage) defines [sec-fetch-dest-header](https://www.w3.org/TR/fetch-metadata/#sec-fetch-dest-header) which would let a server understand if a resource is intended for `document`, `embed`, `nested-document` etc.\r\n\r\n* extend `priority` to carry client information such as `in-viewport/out-of-viewport`, `thumbnail` etc\r\n\r\nFurthermore, we have examples where the server has strictly more information than the client (e.g. progressive images) and can provide information that a gateway can use to improve performance. Writing that as an extension is possible with today's model.\r\n\r\nI think it is important to agree whether the WG believes in keeping the model of collaboration in scope, even if we can't solve all problems in the initial document. Removal of collaboration would push us closer to the HTTP/2 client-only priorities, which has impact on the headers vs frames discussion.",
          "createdAt": "2020-01-09T12:28:30Z",
          "updatedAt": "2020-01-10T14:22:11Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> * [Fetch Metadata](https://www.w3.org/TR/fetch-metadata/) (which is just a proposal at this stage) defines [sec-fetch-dest-header](https://www.w3.org/TR/fetch-metadata/#sec-fetch-dest-header) which would let a server understand if a resource is intended for `document`, `embed`, `nested-document` etc.\r\n\r\nFetch metadata is shipping in Chrome (and likely to be the same for many Chromium browsers). The `destination` part of the feature is [planned to ship in Chrome 80](https://www.chromestatus.com/features/5206259592593408) (so, very soon).\r\n\r\n> * extend `priority` to carry client information such as `in-viewport/out-of-viewport`, `thumbnail` etc\r\n\r\nBeyond destination and in/out of viewport info, there are other considerations that the server may or may not be aware of. \r\nIf we take a look at scripts: they may be render blocking, async or defer. They may be independent, or part of an ES module dependency chain which delays execution for other, already downloaded, scripts.\r\n\r\nAnd both clients and servers can use e.g. RUM data to deduce long blocking dependency chains, and upgrade relevant resources' priority, beyond the simple rules of \"a blocking script has priority X\".\r\n\r\nAll that to say that when servers are merging priorities, they need to take caution when overriding the client's prioritization, and need to do that only when certain that they know better.\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2020-01-09T13:16:02Z",
          "updatedAt": "2020-01-09T13:16:02Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Fetch metadata is shipping in Chrome (and likely to be the same for many Chromium browsers). The destination part of the feature is planned to ship in Chrome 80 (so, very soon).\r\n\r\nTIL. thanks!\r\n\r\n> All that to say that when servers are merging priorities, they need to take caution when overriding the client's prioritization, and need to do that only when certain that they know better.\r\n\r\nI think we can all agree there are many variables that can play into prioritization. That is maybe part of the answer as to @tombergan's question on https://github.com/httpwg/http-extensions/issues/1023#issuecomment-572420480\r\n\r\n> > I do strongly agree with the idea that the number of buckets needs to be small.\r\n> \r\n> What is your objection to using 16 or 32 bit integers (or perhaps 15 or 31, to reserve a bit for \"incremental\")?\r\n> \r\n\r\nDescribing the client's usage intent and environment with a richer vocabulary, rather than an integer space, makes it possible for a server to make better prioritization decisions  - independent of any origin that adds more information (i.e. the problems are tangential). So Yoav's suggestion is sound advice for a server that makes any active choice about prioritization.",
          "createdAt": "2020-01-09T13:46:43Z",
          "updatedAt": "2020-01-09T13:47:38Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": ">\u00a0I think it is important to agree whether the WG believes in keeping the model of collaboration in scope, even if we can't solve all problems in the initial document.\r\n\r\nI strongly believe that client/server collaboration should be out-of-scope:\r\n\r\n1. This forces us to give a precise specification for each priority level, which limits future flexibility (#1023).\r\n\r\n2. Request context is a known problem, as discussed above, and extensions like \"in-viewport/out-of-viewport, thumbnail etc\" add complexity to the spec and to the browser for questionable benefit.\r\n\r\n3. AFAICT there is no evidence that servers will be able to produce better priorities than browsers once this new priority spec is fully implemented (see the blog post discussion in [this comment](https://github.com/httpwg/http-extensions/issues/1026#issuecomment-572419307)).\r\n\r\nI don't believe that client/server collaboration is a bad idea, only that the idea is too complex and too immature to justify its inclusion at this time. Also, there may be better ways to encourage client/server collaboration. One idea is to invert the relationship: send context from server -> client, instead of client -> server. For example, the server might communicate extra priority hints via new attributes in `<link rel=preload>` elements (or equivalent Link header fields).",
          "createdAt": "2020-01-09T17:25:10Z",
          "updatedAt": "2020-01-09T17:27:04Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> AFAICT there is no evidence that servers will be able to produce better priorities than browsers once this new priority spec is fully implemented (see the blog post discussion in this comment).\r\n\r\nWe (Cloudflare) have experience with using response headers to adjust resource sending of progressive images in order to improve performance. This is detailed in the blog post https://blog.cloudflare.com/parallel-streaming-of-progressive-images/. The `cf-priority-change` header described there could be refactored into a `priority` extension parameter to allow the same thing. Do you think it would help the WG discussion to present some data on this?\r\n\r\n> I don't believe that client/server collaboration is a bad idea, only that the idea is too complex and too immature to justify its inclusion at this time. Also, there may be better ways to encourage client/server collaboration. One idea is to invert the relationship: send context from server -> client, instead of client -> server. For example, the server might communicate extra priority hints via new attributes in <link rel=preload> elements (or equivalent Link header fields).\r\n\r\nSending information to the client might allow it to then reprioritize the request based on new information. The problem is that the extra RTT's imposed on that interaction can negate the benefits of doing it.\r\n",
          "createdAt": "2020-01-09T17:47:01Z",
          "updatedAt": "2020-01-09T17:47:01Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "> We (Cloudflare) have experience with using response headers to adjust resource sending of progressive images in order to improve performance. This is detailed in the blog post https://blog.cloudflare.com/parallel-streaming-of-progressive-images/. \r\n\r\nI like this idea but I believe it can be implemented without any of the machinery to merge priorities. The client can send priorities however it wants. Suppose the priorities are:\r\n\r\nurgency=1, incremental=false: a.css\r\nurgency=2, incremental=true: b.jpg\r\nurgency=3, incremental=true: c.jpg, d.jpg\r\n\r\nSuppose also that the server knows that each image can be rendered progressively. The server SHOULD deliver `b.jpg` first since it has higher priority. When the server gets to urgency=3, instead of using a naive round robin to share bandwidth between `c.jpg` and `d.jpg`, it can share bandwidth by splitting each image into header / preview / remainder parts, then doing a round robin at each part, as described in that blog post.\r\n\r\nSince the CloudFlare frontend doesn't know how to split those images into parts, you still need a way to learn the splitting from the backend, but that communication is outside the scope of this spec IMO.\r\n\r\n> Sending information to the client might allow it to then reprioritize the request based on new information. The problem is that the extra RTT's imposed on that interaction can negate the benefits of doing it.\r\n\r\nIf the information is sent in the HTML or DOM, as it would be with `<link rel=preload>`, there's no extra RTT. The client learns that information before the request is sent. Note that the progressive image optimization doesn't need to send anything to the client -- the optimization happens entirely server-side and does not mutate the client-specified priotities.",
          "createdAt": "2020-01-09T21:09:46Z",
          "updatedAt": "2020-01-09T21:10:39Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> urgency=1, incremental=false: a.css\r\nurgency=2, incremental=true: b.jpg\r\nurgency=3, incremental=true: c.jpg, d.jpg\r\n\r\nThe design as it stands reserves urgency 2 for the server, so lets shift them for the purpose of discussion. I'm assuming `b`, `c` and `d` are all progressive images:\r\n\r\nurgency=1, incremental=false: a.css\r\nurgency=3, incremental=true: b.jpg\r\nurgency=4, incremental=true: c.jpg, d.jpg\r\n\r\n> The server SHOULD deliver b.jpg first since it has higher priority. When the server gets to urgency=3(sic) 4(ed), instead of using a naive round robin to share bandwidth between c.jpg and d.jpg, it can share bandwidth by splitting each image into header / preview / remainder parts, then doing a round robin at each part, as described in that blog post.\r\n\r\nA different approach that a server could take would be to promote the urgency of `b`, `c` and `d` header part to urgency 2, then drop down back to the client-indicated urgencies of 3 and 4 for the remainder parts.\r\n\r\n> Since the CloudFlare frontend doesn't know how to split those images into parts, you still need a way to learn the splitting from the backend, but that communication is outside the scope of this spec IMO.\r\n\r\nI appreciate the point. However, I think that while we are considering new semantics for prioritization, there is value in creating a common format for the signals. The alternative IMO is that server-to-frontend signals become bespoke (e.g. `cf-priority-change`) which hurts interoperability. But I do agree with the broader observation in Martin's OP that describing how an intermediary resolves client and server signals can be too presciptive.\r\n\r\n> If the information is sent in the HTML or DOM, as it would be with <link rel=preload>, there's no extra RTT.\r\n\r\nI don't follow sorry. In the case of the blog, the frontend prioritizes byte ranges of different responses. The bytes depends on the selected representation (i.e. content-encoding etc) so I don't know how one would be able to encapsulate that information in HTML or DOM.",
          "createdAt": "2020-01-09T22:24:24Z",
          "updatedAt": "2020-01-09T22:24:24Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "> A different approach that a server could take would be to promote the urgency of b, c and d header part to urgency 2, then drop down back to the client-indicated urgencies of 3 and 4 for the remainder parts.\r\n\r\nWhy would the server do that? The client has expressed that b is more important than both c and d. Perhaps c and d are below-the-fold. If the server understands the optimal priorities that much better than the client, then the server should ignore what the client says (and therefore ignore this spec entirely) and do whatever it wants.\r\n\r\n> > If the information is sent in the HTML or DOM, as it would be with , there's no extra RTT.\r\n> \r\n> I don't follow sorry. In the case of the blog, the frontend prioritizes byte ranges of different responses. The bytes depends on the selected representation (i.e. content-encoding etc) so I don't know how one would be able to encapsulate that information in HTML or DOM.\r\n\r\nSorry for the confusion. I agree the client doesn't know how the images are encoded and would have trouble communicating exactly how image bytes should be scheduled. However, I believe the progressive image optimization can be implemented without any cooperation from the client, except that the client should request images with incremental=true. Once the server is given those incremental buckets, all of the progressive image scheduling magic is contained on the server, within those buckets.\r\n\r\nIn the example above, the server would send the entire response for image b before sending any bytes for c or d. (After all, this is what the client asked for.) After sending b, the server would send the image headers for c and d, then the initial previews, then the final bytes.\r\n\r\nWhen I said \"if the information is sent in the HTML or DOM\", I was referring to scheduling decisions like \"image A is more important than image B\". I had assumed that you wanted the server to make decisions like that. I think that's a fine thing to do -- maybe the browser has a difficult time finding above-the-fold images, whereas for some web site, the server knows exactly which images are above-the-fold. My point was: that kind of priority information can be communicated in the HTML, perhaps using markup like `<img priority=high src=x.jpg>` [1]. The client can use this information, however it wants, to generate more optimal priorities. This approach seems much simpler than a complex merging of client and server priorities.\r\n\r\n[1] not a serious proposal",
          "createdAt": "2020-01-18T00:43:05Z",
          "updatedAt": "2020-01-18T00:43:05Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Why would the server do that? The client has expressed that b is more important than both c and d. Perhaps c and d are below-the-fold. If the server understands the optimal priorities that much better than the client, then the server should ignore what the client says (and therefore ignore this spec entirely) and do whatever it wants.\r\n\r\nThe client only has a partial world view, which it is basing it's initial priority signal on. Once the request is received and the server selects the representation, this new information might lead to a change of mind.\r\n\r\nIn my strawman example, there could be benefit in sending some or all requested image headers, even images below-the-fold. Or perhaps that's an awful thing to do. The point is that today it's hard to test tuning the effect of priorities.\r\n\r\nH2's prioritization scheduling is a bit of a black box in many implementations. Server-side applications get limited knowledge of what the client signalled, and limited input into the scheduling of response bytes. They do get some control-by-proxy via starving or feeding response data into the scheduler, but that's nasty. Or perhaps there is some proprietary API. I see merit in defining a more standardised priority scheme that can be used for the purpose of providing input to the scheduler from the requestor's and respondor's perspective. Others might disagree, or might disagree with peers being able to see what priority hands were played.\r\n\r\nWhile your proposal might not be serious, it does closely resemble the Priority Hints API which defines high, low and auto. [1] @yoavweiss can talk more to both the spec and the experimental data.\r\n\r\n1 - https://github.com/WICG/priority-hints\r\n\r\nEdited: to remove copy editing artefacts. Apologies to your inbox.",
          "createdAt": "2020-01-18T02:28:43Z",
          "updatedAt": "2020-01-18T02:30:42Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": ">\u00a0In my strawman example, there could be benefit in sending some or all requested image headers, even images below-the-fold. Or perhaps that's an awful thing to do. The point is that today it's hard to test tuning the effect of priorities.\r\n\r\nThis is the core of my disagreement. AFAICT, we don't have evidence that merging client and server priorities is required for optimal performance. We have some intuition that it may be useful in some cases, and that's about it. This reminds me of old H2 conversations in the ietf-http-wg archives, where people expressed an intuition that we needed priority groups or trees to support proxies, so we ended up with trees, but no one ran any large scale tests first to verify that trees were a good idea, and now H2 has a prioritization scheme that no one likes. I would like to avoid making that mistake again.\r\n\r\nI fully support experimentation, but I don't support adding experimental features to this spec. I also support browser-side experimentation, and by using fixed and inflexible semantics for each priority level, this spec potentially limits browser-side experimentation (see #1023).\r\n\r\nI believe it's sufficient to say: there are N urgency levels, of unspecified meaning, that the server is free to ignore client priorities if it chooses. Even with this simple specification, it is possible to test merging client and server priorities. For any given User-Agent, such as Chrome/79, the meaning of any urgency level X is baked into the binary. The server can run any experiment it likes, with the caveat that it may need to adjust the experiment based on User-Agent, which seems reasonable?",
          "createdAt": "2020-01-22T19:36:15Z",
          "updatedAt": "2020-01-22T19:36:15Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with some of you points around evidence. However, one difference this time around are that we have wider experience with client and server implementations of multiplexed prioritised requests. And the ways that servers succeeded or failed to implement response data schedules.\r\n\r\nWe maybe agree that the ability to experiment was hampered by the complexity of the tree-scheme. A simpler scheme could allow for data gathering without introducing normative text in the spec.\r\n\r\nOne way to answer the merging question is as MT suggested in his OP. And that could be taken further by  So not reserving urgency levels that the client cannot use.\r\n\r\nI would push back against the idea of a wide range of free form priority values. It makes the servers job incredibly difficult, especially if it introduces requirements (normative or not) to user agent sniff. Kazuho and I have experience with the fragility of sniffing for the tree-based scheme today. ",
          "createdAt": "2020-01-22T19:59:17Z",
          "updatedAt": "2020-01-22T19:59:17Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What @LPardue said, mostly.\r\n\r\nMy experience from other areas suggests that 4 levels is something of an optimum for signaling priorities.  For instance, in WebRTC we had a taxonomy that roughly equated to \"audio, video, chat, files\".  Implementing even that few levels can be interesting, but it is workable.\r\n\r\nDouble that and it probably isn't much worse.  Iterating over 8 queues is workable, for instance.  But multiply too much and you will have to find ways to reduce it to something you can manage.  Once everyone has performed similar (but likely different) reductions, the additional bits you spent on signaling aren't helping.\r\n\r\nObviously, any expectation we might have about consistent treatment from servers is a fantasy.  Once we allow for the server to have any input, we leave this open to non-determinism.  But the advantage of a header field is that you see what contributed to that.  If you have a gateway that follows server overrides, then the client will be able to observe those unless the gateway erases them (it shouldn't).  Then at least we have hope of identifying the source of performance bugs.",
          "createdAt": "2020-01-23T00:57:04Z",
          "updatedAt": "2020-01-23T00:57:04Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "There are three relevant issues:\r\n\r\n1. The number of urgency levels.\r\n2. Whether each individual level has a fixed, defined semantics.\r\n3. Whether the spec says anything specific about merging server and client priorities, or if the spec simply notes that the server has de facto power to do whatever it wants.\r\n\r\nI think @martinthomson's last message focused on (1). Let's ignore that for a moment and assume we've agreed on a fixed number N. On (2) and (3), my opinion is:\r\n\r\n2. There should be no defined semantics for any urgency level. We should delete the [urgency definition table](https://httpwg.org/http-extensions/draft-ietf-httpbis-priority.html#urgency) and the relevant subsections.\r\n3. The spec should not say anything about merging client and server priorities. For example, the spec should not reserve any levels for the server and we should delete [section 6](https://httpwg.org/http-extensions/draft-ietf-httpbis-priority.html#merging) (or replace section 6 with a note that the server SHOULD follow the client-specified priorities but has de facto power to do whatever it wants).\r\n\r\nIs there any disagreement on those points?",
          "createdAt": "2020-01-23T01:35:53Z",
          "updatedAt": "2020-01-23T01:35:53Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For the record, I agree with @tombergan on all 3 points if that weren't already clear.\r\n\r\nThanks for trying to bring this back to something more concrete.",
          "createdAt": "2020-01-23T02:51:05Z",
          "updatedAt": "2020-01-23T02:51:05Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tombergan Thank you for summarizing the points. It's good to know that we are converging on 8 urgency levels (or something minimum).\r\n\r\nAt the same time, I still think that we should have semantics, and that we should allow servers to merge priorities.\r\n\r\nIn https://github.com/httpwg/http-extensions/issues/1023#issuecomment-574968655, @martinthomson has laid down the reasons why he does not favor that. Quote:\r\n> For that to work reliably, you would have to eliminate any freedom that browsers might exercise in terms of using different priority markings on requests. I'm not comfortable saying that. That's the other part of the semantic thing. I can understand 5>3, but as soon as we get to saying that all browsers need to mark image loads as X, then we lose the ability to apply a different strategy.\r\n\r\nI do not fully agree with the observation, and I disagree with the rationale.\r\n\r\nMy observation is that, as stated in https://github.com/httpwg/http-extensions/issues/1023#issuecomment-574974419, status quo provides enough freedom to the clients. We have three supplementary levels that can be utilized. We also allow the client to promote (or demote) urgency between prerequisite / document / supplementary / background. While it is true that having the semantics reduces the amount of freedom the client has, I'd assume that it would be enough.\r\n\r\nBut moreover, I would argue against placing the ability \"to apply a different strategy\" above allowing servers to tweak priorities.\r\n\r\nAs @LPardue points out, multiple servers already tweak priorities because doing so has benefits, and the headache is that it's difficult to do so in a stable and cross-browser manner due to lack of semantics in H2 priorities. It's a real problem. Compared to that, as nice as it would be to provide freedom for applying different strategies, it's just a possibility. That's not a problem that we have now. Based on our experience in H2, I am also doubtful if we would ever come up with something very different for the web browsing case.\r\n\r\nI would very much prefer fixing the issues we have now, rather than prioritizing something that we _might_ do.\r\n",
          "createdAt": "2020-01-23T03:35:52Z",
          "updatedAt": "2020-01-23T03:35:52Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "> As @LPardue points out, multiple servers already tweak priorities because doing so has benefits, and the headache is that it's difficult to do so in a stable and cross-browser manner due to lack of semantics in H2 priorities. \r\n\r\nI addressed this in my [first comment](https://github.com/httpwg/http-extensions/issues/1026#issuecomment-572419307) in the thread, and again in [this comment](https://github.com/httpwg/http-extensions/issues/1026#issuecomment-572757365) about progressive images.\r\n\r\nI agree that browsers are doing a suboptimal job with H2 priorities, but that happens due to problems in H2 that are fixed by this spec. I have not seen any evidence that servers will need to tweak priorities after this spec is widely implemented. There are guesses that servers might want to tweak priorities in some cases, but IMO that's not a strong enough argument to support the complexity this adds to the spec. And further, I believe there are [better ways](https://github.com/httpwg/http-extensions/issues/1026#issuecomment-575846923) for servers to tweak priorities that don't require any spec support here.\r\n\r\n> I would very much prefer fixing the issues we have now, rather than prioritizing something that we might do.\r\n\r\nI completely agree with this.",
          "createdAt": "2020-01-23T16:44:47Z",
          "updatedAt": "2020-01-23T16:44:47Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm happy with saying less in the spec but want to ensure it doesn't inadvertently prevent the ability for non-client actors to provide their signals into a server that is scheduling the responses. ",
          "createdAt": "2020-01-23T17:33:30Z",
          "updatedAt": "2020-01-23T17:33:30Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tombergan \r\n> I agree that browsers are doing a suboptimal job with H2 priorities, but that happens due to problems in H2 that are fixed by this spec. I have not seen any evidence that servers will need to tweak priorities after this spec is widely implemented. \r\n\r\nI think this is what we disagree.\r\n\r\nThe limitation of browser-driven prioritization is that it cannot be specific to websites, while server-driven prioritization is mostly an attempt to provide further optimization based on knowledge specific to the website (e.g., promote urgency of hero images, tweak priority based on the knowledge of the file type).\r\n\r\nTherefore, we would continue to see benefit in having a server-sent signal, and using it.\r\n\r\nThere are two ways of implementing such signal. One is by associating priority to the initiators of the requests (e.g., [priority hints](https://wicg.github.io/priority-hints/)) as you correctly point out, and the other is by sending signal from the server (most likely as a response header). I would not go into the details, but there are pros and cons in these two approaches. That said, for both of these two approaches, it is beneficial to have semantics. Otherwise, you cannot use either of them, unless you specify the priority of all the resources that are used.\r\n\r\nTo summarize, server-sent signal will continue be useful, and for that to be useful, we need semantics.",
          "createdAt": "2020-01-24T11:48:31Z",
          "updatedAt": "2020-01-24T11:48:31Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "Can you share a link to a study showing that (a) server-driven prioritization will be useful with this new priority spec, and (b) server priorities will need to be merged with client priorities as described in this proposed spec?\r\n\r\nOver in [#1023](https://github.com/httpwg/http-extensions/issues/1023#issuecomment-572420480), I hypothesized that more than 8 priority levels will be useful because some optimizations, like deprioritizing iframes and background tabs, might benefit from 2x as many levels. I admit this is a pretty weak argument. I don't have any data to support this idea, and specifically I don't have any data which shows that 2x as many levels are necessary. Thus it seems safer to stick with 8 levels since that makes O(1) implementations easier.\r\n\r\nWe're in the same situation here. I haven't seen an argument for why we need all of this complexity, besides a hypothesis that it might be useful someday.",
          "createdAt": "2020-01-28T01:25:08Z",
          "updatedAt": "2020-01-28T01:25:08Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Are you able to elaborate on where you see the complexity if we were to adopt Martin's suggestions?\r\n\r\nSince H2 priorites were only ever a hint into the process, I presume you don't see complexity in servers having unilateral override. So is this concern about having to define rules about carriage of a prioirty signal on the non-client-facing side? Or something else?",
          "createdAt": "2020-01-28T03:25:24Z",
          "updatedAt": "2020-01-28T03:25:24Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "> Are you able to elaborate on where you see the complexity if we were to adopt Martin's suggestions?\r\n\r\nCan you clarify which suggestions you're referring to: are they [these](https://github.com/httpwg/http-extensions/issues/1026#issuecomment-577465626), which [Martin agreed with](https://github.com/httpwg/http-extensions/issues/1026#issuecomment-577481328), or something else?\r\n\r\n> I presume you don't see complexity in servers having unilateral override\r\n\r\nThat's correct.\r\n\r\n> So is this concern about having to define rules about carriage of a priority signal on the non-client-facing side?\r\n\r\nIf you're referring to [Section 6](https://httpwg.org/http-extensions/draft-ietf-httpbis-priority.html#merging), then yes, that is half of it. The other half is: in order to spec how servers merge priorities, we need to carefully define how browsers will attach priorities to requests. This is [Section 3](https://httpwg.org/http-extensions/draft-ietf-httpbis-priority.html#urgency). It is essentially saying: for all time, browsers should use 3 for ATF images, 4 for BTF images, 5 for async JS, etc. If clients ignore Section 3, then Section 6 is broken. If clients follow Section 3 religiously, then client-side experimentation is effectively disallowed, and any problems in Section 3 must necessarily be fixed at the server, even if it would be more efficient to fix those problems on the client.\r\n\r\nAlso see Martin's comment [here](https://github.com/httpwg/http-extensions/issues/1023#issuecomment-574968655).\r\n\r\nI still propose deleting Sections 3 and 6. Can you [share any data](https://github.com/httpwg/http-extensions/issues/1026#issuecomment-579035955) that would convince me otherwise?",
          "createdAt": "2020-01-28T16:19:10Z",
          "updatedAt": "2020-01-28T16:19:28Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If you're referring to Section 6, then yes, that is half of it. \r\n\r\nRemoving section 6 is tenable but I would be inclined to write some short prose to make it clear that signals can come from both client and server roles (local or remote), and that no requirements are made on how implementations consume and act on those signals.\r\n\r\nAdding extension parameters to either signal is compatible with the above. Although they may find, with evidence, that defining additional requirements is desirable or necessary. I would like to gather data with respect to the progressive image loading extension we have in mind, but can not share timelines on when that would be available.\r\n\r\n>  It is essentially saying: for all time, browsers should use 3 for ATF images, 4 for BTF images, 5 for async JS, etc. If clients ignore Section 3, then Section 6 is broken. If clients follow Section 3 religiously, then client-side experimentation is effectively disallowed,\r\n\r\nIt is my view that having a common understanding of semantics empowers a priority scheduler to make trade-offs. Having abstract weight levels might give more freedom to browsers (although arguably they never exercised this freedom with H2) but reduces the server to being just a dumb ordered-list processor. Therefore to address your proposal, I don't think deleting section 3 entirely is advisable; but iterating on section 3.1 is something we should do. Since deletion would be a design change of the adopted document, I don't agree there is a burden of evidence to validate its existence.\r\n\r\nClient experimentation away from the urgency/progressive scheme here implies some alternate strategies are desired - which may simply be incompatible with the model of prioritisation in this document. That seems an ideal opportunity for extension or substitution i.e. don't reuse urgency parameters, define new ones.\r\n\r\n \r\n\r\n",
          "createdAt": "2020-01-28T18:01:58Z",
          "updatedAt": "2020-01-28T20:47:11Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n> Having abstract weight levels might give more freedom to browsers (although arguably they never exercised this freedom with H2)\r\n\r\nThat's not accurate. You could examine the [WebKit's resource prioritization](https://github.com/WebKit/webkit/blob/master/Source/WebCore/loader/cache/CachedResource.cpp#L70) vs. [Chromium's](https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/platform/loader/fetch/resource_fetcher.cc;bpv=1;bpt=1;l=430?q=ResourceFetcher&ss=chromium&originalUrl=https:%2F%2Fcs.chromium.org%2F) for an example to the contrary.\r\n\r\nChromium's resource priorities started out very similar to WebKit's, but over the years evolved to have more complex priorities:\r\n* One of the places that evolved is ATF image reprioritization (that we're now considering to incorporate here). \r\n* Another is blocking scripts at the top of the page vs. blocking scripts at the bottom vs. async and deferred scripts. \r\n* Late-body styles also have lower priority than top-of-document ones.\r\n* Fonts are of very high priority when late-discovered, but of lower priority when preloaded.\r\n\r\nAll that is before we're talking about low-bandwidth interventions, and applying different priorities to main frame and subframe resources... \r\n\r\nSo, browsers have experimented with resource priorities, and are likely to continue to do so in the future. \r\n",
          "createdAt": "2020-01-28T20:09:21Z",
          "updatedAt": "2020-01-28T20:09:21Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interesting. Does that apply to the values sent on the wire to H2 endpoints and solely the transfer of response payload, or does it play into client implementation detail too? Is there data on the effectiveness of evolving prioritisation instanciation in a world of servers that vary in priority implementation quality?",
          "createdAt": "2020-01-28T20:19:56Z",
          "updatedAt": "2020-01-28T20:19:56Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It can definitely apply to both. @tarunban may have more details on data from past changes",
          "createdAt": "2020-01-28T20:35:12Z",
          "updatedAt": "2020-01-28T20:35:12Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "I talked with @tarunban. Here's a summary:\r\n\r\nIn Chromium, each request is assigned a priority (see Yoav's\u00a0link) which is respected by task schedulers throughout the browser (well, not every task scheduler, but at least conceptually that is the goal). When a request hits the network stack, it gets throttled if it has a relatively \"low\" priority. This is necessary on H1 where there's no response prioritization on the server, but it also happens on H2/H3 for a variety of reasons, such as the fact that pages often load third-party resources over different connections which can't share H2/H3 priorities. On H2, just before the request is sent out, its Chromium priority is [translated to an H2 priority](https://cs.chromium.org/chromium/src/net/spdy/http2_priority_dependencies.cc). The same happens for H3/QUIC.\r\n\r\nRequests may be reprioritized. For example, when the user scrolls an image into the viewport, that image's priority is increased. When a request's priority changes, we [send](https://cs.chromium.org/chromium/src/net/spdy/spdy_session.cc?rcl=690392f7ffa2044773cfb7c93d5771e7457c7761&l=1260) an updated H2 PRIORITY frame.\r\n\r\nNote that Section 3 will force browsers to use the same resource priority assignments for all time.\u00a0@tarunban echoed concerns from myself and others that this is a bad idea for browsers over the long term. As Yoav alluded, we are actively investigating new ideas, such as deprioritizing resources in iframes.\r\n\r\n>Is there data on the effectiveness of evolving prioritisation instanciation in a world of servers that vary in priority implementation quality?\r\n\r\nWe have lots of data on prioritization changes generally speaking, but we can't give a concrete answer to this question. We have [data](https://bugs.chromium.org/p/chromium/issues/detail?id=836552#c34)\u00a0which shows that throttling H2 requests at the browser speeds up page loads. While this is likely a sign of poor H2 priority implementations in servers, we can't say how much that contributes. We also have data which shows that H2 priorities have zero effect in the wild due to kernel bufferbloat on the server (even with TCP_NOTSENT_LOWAT). Fortunately, bufferbloat is less of a problem with H3/QUIC, where we've seen moderate speedups with priorities -- see \"Experimental measurements\" in [these slides](https://datatracker.ietf.org/meeting/106/materials/slides-106-httpbis-sessa-priorities-00.pdf).",
          "createdAt": "2020-01-30T00:40:11Z",
          "updatedAt": "2020-01-30T00:40:11Z"
        },
        {
          "author": "tarunban",
          "authorAssociation": "NONE",
          "body": "The comment above from @tombergan looks good to me. I also wanted to add that browsers may change priority of a resource based on the context. e.g., if two  different tabs are loading resources from the same server, then it might make sense to lower the priority of requests from the tabs that are currently in the background.\r\n\r\nI think it's also preferable for browsers to use the priority consistently throughout the loading lifetime. e.g., resources with low H2/H3 priority should also have a low priority when they hit the cache look-up queue [(bug)](https://bugs.chromium.org/p/chromium/issues/detail?id=655585).",
          "createdAt": "2020-01-30T01:02:04Z",
          "updatedAt": "2020-01-30T01:02:04Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for writing that up, and sharing.\r\n\r\nI'm getting a better impression of what works for Chrome. But I'm still unsure of a few things, perhaps we can try to distill down some desired requirements. \r\n\r\nWhat does experimenting  entail for the priority signal, is it just giving some fetches different weights in H2's available space?\r\n\r\nWe've talked about 8 levels as an acceptable compromise for number of priority values. If they had no semantic is that enough? If levels had semantic, and you wanted to try loading a class of resource at \"prerequisite\" instead of \"supplementary\" what is the concern? That the server would ignore you?",
          "createdAt": "2020-01-30T01:03:04Z",
          "updatedAt": "2020-01-30T01:03:04Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tarunban the intent of the H2 priorization tree was to allow grouping for tabs such as you describe. In the discussions we've had through 2019 nobody provided any examples of clients ever having used it that way. Dies chrome do such prioritisation without using trees today?\r\n\r\nIt's foreseeable that this scheme could be extended with a parameter that expresses something like \"view=in-focus\". Its also feasible that a server could combine the Priority signal with information from Fetch metadata.",
          "createdAt": "2020-01-30T01:27:31Z",
          "updatedAt": "2020-01-30T01:27:31Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@yoavweiss @tombergan @tarunban  Thank you for sharing the internals of the client side, as well as describing the potential changes.\r\n\r\n@tombergan \r\n> Can you share a link to a study showing that (a) server-driven prioritization will be useful with this new priority spec, and (b) server priorities will need to be merged with client priorities as described in this proposed spec?\r\n\r\nI think the paper by @rmarx et.al on https://h3.edm.uhasselt.be and https://blog.cloudflare.com/parallel-streaming-of-progressive-images/ would provide answers.\r\n\r\nQuoting from the paper, \"no single scheme performs well for all types of web pages.\" The paper then alludes that adopting different schemes based on each website might be a good solution, though we know that that's going to make things complicated.\r\n\r\nIn the mean time, what the server developers are doing is to \"refine\" client-driven signal using server-side knowledge. The blogpost linked above talks about that, including an automated approach that serves different parts of JPEG images at different priority levels improves user experience.\r\n\r\nHowever, to promote (or demote) priority, the server needs to know the semantics. Because otherwise it cannot change the priority to the correct value. Consider the case of promoting a hero image above any other images. How do you tell the correct priority without having the semantics?\r\n\r\nI continue to think that status-quo likely provides enough freedom for browsers to evolve. It has four semantic levels (prerequisite, document, supplementary, background), with a loosely-defined sub-levels at supplementary.\r\n\r\nIs it the case that some of the (potential) client-side experiments would not work well with these urgency levels?\r\n\r\nI'd also argue that we would always be possible to extend the vocabulary, as @LPardue points out in the comment right above.",
          "createdAt": "2020-01-30T01:48:31Z",
          "updatedAt": "2020-01-30T01:48:31Z"
        },
        {
          "author": "tarunban",
          "authorAssociation": "NONE",
          "body": "> In the discussions we've had through 2019 nobody provided any examples of clients ever having used it that way. Dies chrome do such prioritisation without using trees today?\r\n\r\nI do not think we ever did that experiment. We already do reprioritization of image resources (based on viewport location). We are also actively looking at reprioritization of resources within iframes.\r\n\r\n> However, to promote (or demote) priority, the server needs to know the semantics. Because otherwise it cannot change the priority to the correct value. Consider the case of promoting a hero image above any other images. How do you tell the correct priority without having the semantics?\r\n\r\nI think the priority hints API might be the right fit here for the server to give a signal to the client on the relative importance of the resource?",
          "createdAt": "2020-01-30T01:56:51Z",
          "updatedAt": "2020-01-30T01:56:51Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "NONE",
          "body": "Thanks @kazuho for mentioning our paper. I've many thoughts on this, but not a lot of time atm.\r\n\r\nThe main point to me is that users need -some- way of manipulating browser-set priorities, whether it be on the client end (e.g., priority hints, preload) or at the server side (e.g., the current proposal, Cloudflare).\r\n\r\nBoth options are currently not well supported... I asked @yoavweiss and Dom Farolino earlier about priority hints and, despite being around for years and running origin trials, they haven't been activated nor is it clear if they help (at least not outside of google) (https://twitter.com/domfarolino/status/1221803122638508032?s=20). There is, IIUC, also no indication from other browsers to support this (to which I would like to note that a lot of this current discussion is highly Google-driven from the browser side). Even then, they would not allow giving a hard priority, but mainly manipulating the browser's estimate. Other options like preload have had their own problems in the past (e.g., https://andydavies.me/blog/2019/02/12/preloading-fonts-and-the-puzzle-of-priorities/, no FF support). \r\n\r\nOn the server-side then, it's notoriously difficult to inject a resource there due to the instable nature of the trees and because all browsers/clients build different trees. The only real option is to sniff the UA (explicitly or implicitly https://twitter.com/patmeenan/status/1222559418434408450?s=20) and have custom behaviour per-browser. This is for example what Cloudflare is doing for their setup and they are (rightly?) keeping it proprietary, since it represents a significant engineering investment to get that to work. This is not something a typical developer can solve using nginx/apache. \r\n\r\nSo, I believe the current approach is motivated by the fact that it's (currently?) difficult to manipulate resources on the browser end, so let's at least make it simple on the server-side. The counter-argument seems to be: but the browsers will get there -eventually- (the references to priority hints, better preload support, etc. ). So it comes down to if you believe that or not. Similarly to how you claim to have seen no proof that server-side re-prioritization works, I have seen no proof that client-side options will become commonplace soon. \r\n\r\nAs such, my opinion would be: we're now in a place to address this problem in a browser-agnostic way, we should do that. If priority hints ends up supported everywhere: great, more flexibility.\r\n\r\nWith regards to not locking browsers into too rigid a structure and allowing experimentation: I would say something about this, but it would devolve into a rant on how things like the \"deprioritizing background tabs\" idea was proposed in 2014 (2013? https://tools.ietf.org/html/draft-chan-http2-stream-dependencies-00), influenced the dependency tree complexity, and was subsequently never actually implemented. So I'd rather refrain. \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2020-01-30T08:02:31Z",
          "updatedAt": "2020-01-30T08:02:31Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And yet experimentation has happened, even if that particular usage didn't.  Perhaps a compromise would be to have the eight priority levels without *specified* meanings, but provide the mappings as an example a hypothetical browser might employ?  Noting, of course, that browsers might find occasion to increase or decrease priority based on other factors, as might servers.",
          "createdAt": "2020-01-30T17:53:07Z",
          "updatedAt": "2020-01-30T17:53:07Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": ">@LPardue: What does experimenting entail for the priority signal, is it just giving some fetches different weights in H2's available space?\r\n\r\nAbstractly, yes, but H2/H3 are red herrings. Chromium has an internal notion of priority. This internal notion happens to be similar to what is being proposed for H3, but I believe that's an intentional aspect of H3's design more than anything. Developers can (and do) change how Chromium's internal priorities are assigned without directly thinking about the impact on H2/H3. The translation from internal priority to H2/H3 is a separate concern.\r\n\r\nInternal browser priorities can look completely different. At one time there was a proposal to replace Chromium's priority enum with a dependency\u00a0graph. This never happened (it turns out DAG-based APIs are hard) but it's a natural thing to try, especially as new features like JS modules make the DAG-based nature of page loads more explicit.\r\n\r\n>We've talked about 8 levels as an acceptable compromise for number of priority values. If they had no semantic is that enough?\r\n\r\nYes.\r\n\r\n>If levels had semantic, and you wanted to try loading a class of resource at \"prerequisite\" instead of \"supplementary\" what is the concern? That the server would ignore you?\r\n\r\nMy concern is that \"prerequisite\" and \"supplementary\" are meaningless terms in isolation. Look at the history of the code in Yoav's link -- Chrome has used 6 levels for a while, but the assignment of requests to levels has changed over time, i.e., the meaning of \"prerequisite\", \"supplementary\", etc. has changed.\r\n\r\nIn order for this idea to work, you need to guarantee that every browser will generate the exact same set of priorities for a given page load, otherwise the server might be mistaken about what priority level X means and its priority edits will be wrong. You need to define how requests map to priority levels and browsers must agree to implement that mapping. IMO this will never happen. First, recall that browser-internal priorities are separate from H2/H3 priorities. In order to implement fixed priorities for H3, browsers need to either (a) adopt H3 priorities for their internal representation and add \"thou shalt not change this\" comments to the methods that assign priorities to requests, or (b) embed enough information into their internal priorities so the net stack can translate to the appropriate H3 priority (in practice the amount of information needed might be large). Note that both options impose implementation constraints across the _entire browser_, not just the H3 stack.\r\n\r\nSecond, we have at least three main browsers to deal with: Chromium (and Edgium, etc), Firefox, and Safari. I don't know how Firefox's internal priorities work exactly, but you can see from [this enum](https://searchfox.org/mozilla-central/source/__GENERATED__/dist/include/nsIClassOfService.h#42) that it's not a simple list of 6 levels ([this older figure](http://2.bp.blogspot.com/-8FvJQaAD1uE/VK2cQKI9I3I/AAAAAAAASk4/SdE5MoBqQ_8/s1600/IMG_20150107_144530.jpg) suggests 5 levels). I don't know what Safari does either. It's based on WebKit, so it probably uses 6 levels like Chromium, but I'm sure it uses those levels differently from Chromium. How will you convince\u00a0browsers to agree on the same implementation?\r\n\r\nThird, what happens when a new web feature adds a new flavor of request? Do we need a process for browsers to agree on how to prioritize these new requests?\r\n\r\nFourth, recall that the true dependencies form a DAG. The flattening of a DAG into N levels is a heuristic. Like any other heuristic, it might be wrong. It seems short-sighted to enshrine this heuristic into browsers for all time.\r\n\r\nFifth, HTTP is not a browser-only protocol. All of these problems can reappear in non-browser contexts.\r\n\r\n>@rmarx: Similarly to how you claim to have seen no proof that server-side re-prioritization works\r\n\r\nI think you have misunderstood my comments. This is what I asked:\r\n\r\n>Can you share a link to a study showing that (a) server-driven prioritization will be useful with this new priority spec, and (b) server priorities will need to be merged with client priorities as described in this proposed spec?\r\n\r\nI want to see evidence of both (a) and (b) together. I already believe servers can have more knowledge than clients in some situations. See [Klotski](https://www.usenix.org/node/189011), [Polaris](https://www.usenix.org/node/194917), and other academic work. All of this work has a similar flavor: the server takes over the entire loading process for a page and ignores what the browser would have done. [My suggested edits to the spec](https://github.com/httpwg/http-extensions/issues/1026#issuecomment-577465626) are sufficient to support this use case.\r\n\r\nThis proposal is different: it wants browsers to set priorities in a fixed way so that servers can edit priorities of individual requests. I believe this is a bad idea because [servers don't have enough context for individual requests](https://github.com/httpwg/http-extensions/issues/1026#issuecomment-572419307) and because getting all browsers to agree on how to set priorities is not going to work (see above).\r\n\r\nAFAICT, neither of @kazuho's citations address my\u00a0question. I addressed progressive images in an [earlier comment](https://github.com/httpwg/http-extensions/issues/1026#issuecomment-572757365) -- I don't see why merging of client and server priorities is necessary to implement progressive image optimizations. I haven't had a chance to read [Robin's paper](https://h3.edm.uhasselt.be/files/HTTP3_Prioritization_extended_3jul2019.pdf) in detail, however, it doesn't seem to be evaluating client/server priority merging; it's evaluating either different priority schemes a browser could use, or something more like Klotski, where the server takes over the entire loading process.",
          "createdAt": "2020-01-30T18:19:29Z",
          "updatedAt": "2020-01-30T18:19:29Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What I find interesting in this thread is that we are debating about the merits of conveying information about the request intent - specific semantics vs more generic levels. Meanwhile the [Fetch Metadata](https://www.w3.org/TR/fetch-metadata/) spec is attempting to introduce an HTTP header-based signal that conveys information about the way a request was made and the context in which it will be usedl; all for the purpose of empowering a server to make decisions on how it handles that request. The conjecture about how to handle new web features applies equally to Fetch Metadata.\r\n\r\nThe proprosed semantic is an approximate model that provides a pretty good analogy of how a client uses resources. Some may disagree with that. A server that understands \"prerequisite\" blocks \"supplementary\" is empowered to make a judgement call on the tradeoffs when it comes to sheduling resources. If we convert that to levels \"0\" and \"1\" with no semantic, then a server can only make a value judgement based on the relative weight.\r\n\r\nChrome's internal mappings are an implementation detail, but the outcome is visible to all and is effectively an opaque API. We saw this with other H2 clients, producing different trees with similar goals. Reverse engineering this is possible but it is fragile - there is no contract, and no interoperability forum and no in-band mechanism to describe the intenr. Servers have unilateral control of priority but effectively have no real way to influence that process. Even if priority information is exposed to a server operator, meaningfully using this is a bit of a crapshoot. So typicall server operators leave things up to the server implmentation to handle everything. However, this leads into benfits for clients; a server with deterministic priority scheduling is a control that allows iterative performance improvent. IIUC one concern is that removal of the control factor could reduce this opportunity.\r\n\r\nThe above works pretty well for a lot of web resources. The counter example we keep coming back to is progressive images. In Cloudflare's work, we have shown that not all bytes of a response have equal priority. We can build a delivery schedule based on a set of priority checkpoints on byte boundaries, which serves different regions at different priorities. We can use the client's indicated priority to align these checkpoints to the relative priority of the resource in the connection context - merging. The schedule is carried in a format that the priority scheduler can consume and enact. There has been a suggestion that priority checkpoints could be passed through to the client somehow, but given that the information is representation-specific I see several barriers and think this would fail to be realized. (Aside: I'm remembering a [recent discussion](https://github.com/w3c/preload/issues/139) about security consideration for ranges that may or may not be a problem here). \r\n\r\nI think controlling server prioritization behaviour from a non-client signal is possible even if the specification doesn't say anything about merging. Having a constrained number of levels certainly helps this case.\r\n\r\nIf I could have my cake and eat it, I would suggest two modes: \r\n* a semantic-oriented model with all levels available to client and server. This works as a best-effort model that is easy for many clients to pick up and run with. \r\n* an opaque mode signalled by a parameter, that lets clients with a case for stronger control to use the levels without any implied semantics.\r\n\r\n",
          "createdAt": "2020-01-31T00:38:21Z",
          "updatedAt": "2020-01-31T00:42:05Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "IIUC, FetchMetadata is [intended to improve security and privacy](https://www.w3.org/TR/fetch-metadata/#intro) and as such it exposes fairly limited information. A lot of contextual information that will be useful for prioritization will be privacy-sensitive. One example: if the origin does not have scripting permissions, it can't observe scrolling behavior, but scrolling behavior would be leaked by a hypothetical\u00a0`in-viewport` attribute. So I'm not sure FetchMetadata is the right place for this. That said, I don't have anything to do with FetchMetadata so I could be way off base.\r\n\r\n>A server that understands \"prerequisite\" blocks \"supplementary\" is empowered to make a judgement call on the tradeoffs when it comes to scheduling resources.\r\n>...\r\n>a semantic-oriented model with all levels available to client and server. This works as a best-effort model that is easy for many clients to pick up and run with.\r\n>...\r\n>a server with deterministic priority scheduling is a control that allows iterative performance improvement. IIUC one concern is that removal of the control factor could reduce this opportunity.\r\n\r\nI'm sorry, I thought I addressed all of these things in detail in my last comment.\r\n\r\n* The terms\u00a0\"prerequisite\" and \"supplementary\" do not have obvious meanings; they need precise definitions.\r\n* Nothing about this is \"easy for many clients to pick up and run with\". We need consensus across browsers, and even after consensus, the implementation(s) will be non-trivial as there is impact beyond the H3 stack.\r\n* I'm not concerned about servers overriding client priorities. I'm not asking for the server to follow the client blindly. If the server actually knows better, and wants to do something different, that's great, I say go for it. I'm saying the proposed design will not work because of challenges reaching consensus, challenges in implementation, restrictions on future implementations, and challenges communicating enough context for servers to make correct decisions.\r\n\r\nIn an [earlier comment](https://github.com/httpwg/http-extensions/issues/1026#issuecomment-572784930) you mentioned that CloudFlare splits images into three parts -- headers, preview, and the rest of the data -- and uses a higher priority for the headers (say 2) compared to the preview and the rest of the image (say 3). It's not clear why you can't do this within one priority level. Say the client requests a few images with priority 3. You can push the headers to the front of the queue within priority 3, then the previews, then handle everything else normally. This doesn't strictly follow what the client asked for, but that's fine, you're doing something better, and it doesn't require any cooperation from the client.",
          "createdAt": "2020-01-31T02:53:43Z",
          "updatedAt": "2020-01-31T02:53:43Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Some of these challenges will continue to exist regardless of what Prioirty levels are defined. The arguments against the scheme are weighted in favour of allowing complex UAs to have a safe freedom to change aspects of its priority model. External contributors pay a non-trivial cost to try and improve on this model. This to me highlights a problem with the applicability of the draft beyond urgency levels, that the extensible priority scheme will never see additional parameters because they leak abstractions. Leaking like this harms the ability for future change. It may also have security, privacy and fingerprinting concerns.\r\n\r\nMy comments on simplicity reflect less complex UAs. Something like (lib)curl could easily synthesize request urgency levels, or pass through user-provided headers. This would avoid curl, or users, needing to define how they use all of the available level space.\r\n\r\n",
          "createdAt": "2020-01-31T04:19:24Z",
          "updatedAt": "2020-01-31T04:19:24Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The conjecture about how to handle new web features applies equally to Fetch Metadata.\r\n\r\nFetch metadata reflects Fetch related parameters to the server. Those parameters defined in the [Fetch spec](https://fetch.spec.whatwg.org/), and new features that add new requests have to think long and hard about what those parameters should be.\r\n\r\nTheoretically, the Fetch spec could similarly define strict priority levels, their semantics and what each request destination should set them to.\r\nBut, that would actually result in worse prioritization than what we have today. So I doubt browsers would be inclined to go that route.\r\nIt would also prevent any future client-side experimentation without consensus, which is another bad outcome.\r\n\r\nThe part that I'm missing is why strict semantics are required in order to perform server side experimentation? Can you describe a scenario where they would differentiate between the server doing the right thing vs. the wrong thing? \r\n\r\n",
          "createdAt": "2020-01-31T09:01:04Z",
          "updatedAt": "2020-01-31T09:01:04Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The part that I'm missing is why strict semantics are required in order to perform server side experimentation? Can you describe a scenario where they would differentiate between the server doing the right thing vs. the wrong thing?\r\n\r\nThis is a good question given the stage of discussion. Starting with the axiom that the H2 tree allowed a very free form of indicating web priorities. Some server implementers found value in reading meaning into the tree and using that information to experiment. Having that info might not be a strict requirement, but it improves the chances that experiments can operate within some sane bounds. Divining the tree is fragile, and also hard when its empty or broken. \r\n\r\nA simpler scheme negates some of these problems. It reduces the amount of context needed on the server side and avoids issues caused by H3 delivery ordering. However, it also discards some information that was in the tree such as the exclusive priority relationship. This could help indicate that a resource is blocking in some way and tinkering with its importance is probably going to result in a bad time. OTOH adjusting server behaviour to protect or improve the serving of that blocking resource (I.e. schedule I/O reads from disk, use a fast path to upstream) could make things better. Without the signal we'll never know.\r\n\r\nA good example of useful information is the incremental (aka concurrency bit). This information allows a server to make a value judgement on how to time slice. \r\n\r\nThe semantic levels indicate blocking and create some guard rails to say \"if you push a priority outside here, it's probably not going to achieve a good result in the overall page load\". What I'm hearing is that those rails are a hindrance for clients. And just having semantic free levels might be good enough, as long as servers understand which end of the space is high prioirty.\r\n\r\nThere's a lot of mights above because actually being inclined to dig in and build software to do this is hard with thebstatis quo.",
          "createdAt": "2020-01-31T09:39:50Z",
          "updatedAt": "2020-01-31T09:39:50Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, that sounds like something completely different from \"we need semantic levels for priorities and mapping of the different resources to those\".\r\n\r\nIt sounds to me that what you really need are various \"what is this resource\" indicators.\r\n\r\nFor resources that are streamingly processed, you need the concurrency bit. Some implementations that don't render images progressively may turn it off for images. Some, which streamingly parse multiple scripts at a time, may turn it on for scripts. But you want an indication for that \"streaming\" quality of the resource, regardless of its urgency.\r\n\r\nSimilarly, it seems like you want an indication that a certain resource is blocking other operations (e.g. a render blocking script or style). That's more closely tied to priority, but maybe can/should be expressed as a separate \"blocking\" bit that you can use as indication that delaying that resource would result in significant client side delays.\r\n\r\nI wouldn't object to adding such a \"blocking\" bit as it seems like something that browsers can strictly define and agree on (i.e. define a Fetch flag that translates to that bit being sent out and properly set that flag in places that call Fetch for those resources)\r\n\r\nWould that solve your problem?\r\nAre there other resource qualities that you feel the server should be aware of?\r\n\r\n",
          "createdAt": "2020-01-31T10:37:44Z",
          "updatedAt": "2020-01-31T10:37:44Z"
        },
        {
          "author": "rmarx",
          "authorAssociation": "NONE",
          "body": "@yoavweiss for some context, one of the floated ideas initially was to take what you call \"what is the resource\" indicators further with (very) fine-grained info. That discussion can be found here: https://github.com/kazuho/draft-kazuho-httpbis-priority/issues/28 (though that exact strawman isn't necessarily what I'd champion).\r\n\r\nThis was discussed and determined to be too complex for a first iteration, as we're trying to ship this with/before HTTP/3 is done. That's partly why we stuck with the current setup with \"semantic levels\", aiming to explore additional indicators/aspects in later iterations (which should be quite easy if we would use HTTP headers).\r\n\r\nA blocking bit would be helpful and might be a good compromise to explore.\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2020-01-31T11:01:22Z",
          "updatedAt": "2020-01-31T11:01:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm open to options. We had some discussion before but now the document is adopted we have wider input. Maybe older dead ends are more attractive than current ones. I appreciate everyone's patience in talking though this area. \r\n\r\n",
          "createdAt": "2020-01-31T11:18:29Z",
          "updatedAt": "2020-01-31T11:18:29Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "I open to this too, but it would be helpful to see specific examples. What does the \"blocking bit\" mean (i.e., what specifically is blocking), what are some optimizations the server wants to perform, and why does the presence of this bit prevent the server from making the wrong decision.\r\n\r\nAlthough the implementation cost of this is much lower, it is non zero, so if we're going to get buy in from all browsers to actually implement this idea, it will be helpful to point at specific examples of why it is needed.",
          "createdAt": "2020-01-31T18:41:38Z",
          "updatedAt": "2020-01-31T18:41:38Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Some of us gathered during the QUIC Interim this week, and discussed how we can go forward.\r\n\r\nWe considered the following two scenarios specifically, in which mostly client-driven prioritization + server refinement could be helpful:\r\n* A client sends a XHR (or Fetch) request that actually blocks the usability of a web page (e.g., [client-side rendering](https://developers.google.com/web/updates/2019/02/rendering-on-the-web#csr)). It could be helpful if the server-side logic could promote urgency of such requests, as high as the urgency level of the HTML, or somewhere above that.\r\n* Demoting the urgency of the bytes at the tail of a progressive JPEG image. As previously discussed, in terms of user experience, there is marginal benefit, if any, in providing those bytes at an early point. Therefore, a server might demote them to the same level as asynchronously fetched JavaScript files, or to somewhere even below, but above background downloads.\r\n\r\nIf we are to support these two scenarios, there needs to be a common understanding about where the \"default\" urgency level is (i.e. the urgency level used for fetching the HTML of the main window), and where the \"background\" level is. In case of the first scenario, the server would promote the urgency to the \"document\" level or one above that. In case of the latter, the server would demote the urgency to the level right above \"background.\"\r\n\r\nThen, we considered if we could support these scenarios at the same time minimizing the restriction to be imposed to the client-side. The rough consensus was that having a common understanding of only two levels: \"default\" and \"background\" level could be an acceptable compromise.\r\n\r\nBased on our previous agreement that having 8 levels of urgency would be sufficient, we chose 7 (the lowest) for background, and 3 (the middle of all levels excluding background) as the default.\r\n\r\nThe outcome is PR #1048.\r\n\r\nPS. This issue comment is based on _my_ understanding of the discussion. Please correct me if I am wrong.",
          "createdAt": "2020-02-06T07:42:12Z",
          "updatedAt": "2020-02-06T07:44:09Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Revisiting this in an attempt to close the loop on the original issue and subsequent suggestions related to merging, I think #1048 went a long way to a solution but I spotted some wording that could still imply that server priorities override. I opened  https://github.com/httpwg/http-extensions/pull/1065 to really nail things.",
          "createdAt": "2020-02-18T15:49:43Z",
          "updatedAt": "2020-02-18T15:49:43Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue I think we can close this issue now that #1065 has been merged?",
          "createdAt": "2020-03-04T06:04:56Z",
          "updatedAt": "2020-03-04T06:04:56Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "agreed, lets close this and open new issues for any specific problems with the document.",
          "createdAt": "2020-03-04T11:33:01Z",
          "updatedAt": "2020-03-04T11:33:01Z"
        }
      ]
    },
    {
      "number": 1027,
      "id": "MDU6SXNzdWU1NDcyNTM3NzI=",
      "title": "Key syntax",
      "url": "https://github.com/httpwg/http-extensions/issues/1027",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "I'm getting a high failure rate on parsing `Preference-Applied` (but with a very low number of occurrences; it's not exactly a popular header).\r\n\r\nThe failure seems to occur because of keys like this: `odata.include-annotations=\"*\"`\r\n\r\nAllowing `.` in key would address this, but I'm not sure it's worth the change.\r\n\r\nAdditionally, key currently only allows lowercase alpha; this is mainly to avoid confusion between `foo` and `fOo`, etc. So far this seems to be pretty supportable in cache-control, accept-* and elsewhere, with the vast majority of headers seeming to choose the lowercase form. However, it does cause issues in a couple of cases:\r\n\r\n* In `Strict-Transport-Security`, the `includeSubDomains` parameter isn't compatible, leading to a high failure rate for that header\r\n* In cookies, this makes a number of things incompatible, but it's not clear that we can treat them as a direct mapping anyway.",
      "createdAt": "2020-01-09T05:10:11Z",
      "updatedAt": "2020-01-24T02:30:46Z",
      "closedAt": "2020-01-24T02:30:46Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I have no opinion about dots.\r\n\r\nAs to case, though; I think the options are:\r\n\r\n1. say lower-case only \u2013 the current option\r\n    * we should probably instruct individual headers' specifications to define how to get into/out of SH, which is harder for extant specs\r\n2. open it up to anycase and be case-sensitive\r\n    * this means that `foo=bar; Foo=baz` parses to `{\"foo\":\"bar\", \"Foo\":\"baz\"}` and if someone wants to collapse `foo`/`Foo` they have to do it after the fact\r\n3. open it up to anycase and be case-insensitive\r\n    * still requires instructions for individual headers' specs to define how to get out of SH\r\n\r\nIncidentally we don't say anything about case for tokens, not that it matters as far as SH is concerned (we never have to compare them.)  It might not hurt to say something to the effect that \"tokens are case-sensitive so you aren't allowed to change them, but an individual specification that uses sh-token may have special rules for comparing tokens that only differ in case\".",
          "createdAt": "2020-01-13T01:17:24Z",
          "updatedAt": "2020-01-13T01:17:24Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "WRT lower-case -- I think your analysis is correct; my inclination is to either stay lc only, or to force to LC when parsing textual headers (much like H2 does for field names).\r\n\r\nWRT instructions for existing headers -- that's out of scope for SH \"officially.\"",
          "createdAt": "2020-01-13T01:31:13Z",
          "updatedAt": "2020-01-13T01:31:13Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Your patch for `.` looks good.\r\n\r\nForce-lowercasing makes me a bit nervous, because the wire form for h1 will be materially different than what appears in the data model. We'll have to be careful to distinguish between the h1 wire format and the abstract model for keys (which we currently are pretty sloppy about).\r\n\r\nMore seriously, even if we did force-lc, I realise it wouldn't be possible to round-trip things like includeSubDomains, so it probably isn't going to be useful on its own; there will always need to be some application knowledge / mapping.\r\n\r\nSo, I'm inclined to leave casing in keys as-is.",
          "createdAt": "2020-01-22T04:09:56Z",
          "updatedAt": "2020-01-22T04:09:56Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't know what you mean by \"force-lowercasing\".  Is that different from leaving it as-is?",
          "createdAt": "2020-01-22T05:48:00Z",
          "updatedAt": "2020-01-22T05:48:00Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "i.e., forcing LC when parsing textual headers, as per above.",
          "createdAt": "2020-01-22T08:25:10Z",
          "updatedAt": "2020-01-22T08:25:10Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, do you mean converting \"FooBar\" to \"foobar\" as part of some algorithm? Right, yeah, no, I don't like the idea of coercing data into the model if it can't be round-tripped back out.  ~~It's bad enough with floats.~~\r\n\r\nIf an individual header field's spec supports a different data model (e.g. strings), then it's up to that header field's spec to define how to convert their string to an sh-key, and back again. I.e. don't do anything in SH, and punt it to RFC6797bis (or draft-mnot-bsh).",
          "createdAt": "2020-01-23T08:19:45Z",
          "updatedAt": "2020-01-23T08:32:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Agreed. Could you make the `.` change into a PR?",
          "createdAt": "2020-01-23T22:13:27Z",
          "updatedAt": "2020-01-23T22:13:27Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "It is. #1036 ",
          "createdAt": "2020-01-24T02:26:58Z",
          "updatedAt": "2020-01-24T02:26:58Z"
        }
      ]
    },
    {
      "number": 1031,
      "id": "MDU6SXNzdWU1NTIzMTY4NDI=",
      "title": "Uploading a new version of RFC6265bis.",
      "url": "https://github.com/httpwg/http-extensions/issues/1031",
      "state": "CLOSED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://circleci.com/gh/httpwg/http-extensions/2785?utm_campaign=vcs-integration-link&utm_medium=referral&utm_source=github-build-link shows that uploading a new -04 draft of RFC6265bis failed, possibly because I used the wrong email address when committing the new tag.\r\n\r\nCan I delete and recreate the tag from the right account?\r\n\r\n@reschke, @mnot: can one of you help me out? The docs are not exactly extensive... :)",
      "createdAt": "2020-01-20T13:58:58Z",
      "updatedAt": "2020-02-05T09:04:31Z",
      "closedAt": "2020-02-05T09:04:31Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That seems to be related to @martinthomson 's magic I'm not familiar with.\r\n\r\nDid you try submitting directly through the IETF web page?",
          "createdAt": "2020-01-20T14:24:48Z",
          "updatedAt": "2020-01-20T14:24:48Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I can do it manually, I'm sure; I just don't want to screw things up if the repo tries to resubmit on my behalf based on that tag.",
          "createdAt": "2020-01-20T14:32:57Z",
          "updatedAt": "2020-01-20T14:32:57Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> No such user: mkwst@chromium.org\r\n\r\nThe datatracker submission API requires not only that the email address you report here matches an active account (reasonable), but that the email is the *primary* email address on the account.  Note however that the email address in the document itself does not need to match this email address.  Indeed, you could claim my email address here and it would probably work fine (please don't, though I'm considering doing that just so that I stop getting questions about this).\r\n\r\nI get the email address from the annotations on the tag.  So you can override the tag email address [as I do in QUIC](https://github.com/quicwg/base-drafts/blob/master/tag.sh) as a workaround.\r\n\r\nThis is a point of frustration for me.  The [trac issue](https://trac.tools.ietf.org/tools/ietfdb/ticket/2639) has been open for ages, blocked on a point of contention.\r\n",
          "createdAt": "2020-01-20T21:31:45Z",
          "updatedAt": "2020-01-20T21:31:45Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Poked at it manually, and it looks like it went through successfully. I'll try to make sure I use `@google.com` for this repo going forward...",
          "createdAt": "2020-01-21T07:27:35Z",
          "updatedAt": "2020-01-21T07:27:35Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "To close the loop on this: I set my email address to one matching my IETF account in the local repo (via `git config --local user.email mail@huzzah.example`), and was able to use the tagging process successfully to publish an -05. Might be worth updating https://github.com/httpwg/http-extensions/blob/master/SUBMITTING.md? I'll send a PR.",
          "createdAt": "2020-02-05T08:33:22Z",
          "updatedAt": "2020-02-05T08:33:22Z"
        }
      ]
    },
    {
      "number": 1032,
      "id": "MDU6SXNzdWU1NTI2ODg4NzI=",
      "title": "Remove \"MUST store last-access-time\" for each cookie?",
      "url": "https://github.com/httpwg/http-extensions/issues/1032",
      "state": "CLOSED",
      "author": "bagder",
      "authorAssociation": "NONE",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "The original RFC 6265 as well as the current draft (-04) says that a user-agent **MUST** store last-access-time and then goes on to explain how to store a cookie... but never says how that access time would even be used.\r\n\r\nI find no argument for saying it MUST be used. We can implement fully compliant cookie user-agents without storing that information.",
      "createdAt": "2020-01-21T08:10:01Z",
      "updatedAt": "2020-01-29T07:54:12Z",
      "closedAt": "2020-01-29T07:54:12Z",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "We use the time of last access in the eviction algorithm (way at the bottom of [Section 5.4](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-04#section-5.4) (\"If two cookies have the same removal priority, the user agent MUST evict the cookie with the earliest last-access date first.\"; see e.g. https://cs.chromium.org/chromium/src/net/cookies/cookie_monster.cc?rcl=cc550e3a16febcdf45a861071ac901666298f579&l=1602), which seems pretty reasonable to want to do.\r\n\r\nWould you suggest we drop that requirement as well? If so, which ordering would we use and why?",
          "createdAt": "2020-01-22T16:06:14Z",
          "updatedAt": "2020-01-22T16:06:14Z"
        },
        {
          "author": "bagder",
          "authorAssociation": "NONE",
          "body": "Ah, I missed that since it's not \"last-access-time\" there, it is \"last-access date\". I figured it was odd...\r\n\r\nNo, I don't think it should be removed. Maybe it could be updated to use the same name in section 5.4?",
          "createdAt": "2020-01-22T21:44:58Z",
          "updatedAt": "2020-01-22T21:44:58Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That\u2019s a good enhancement. You won\u2019t be the only one doing a text search. But we should also have an explicit reference in my opinion.",
          "createdAt": "2020-01-22T23:35:56Z",
          "updatedAt": "2020-01-22T23:35:56Z"
        }
      ]
    },
    {
      "number": 1033,
      "id": "MDU6SXNzdWU1NTI2OTIxNDU=",
      "title": "6265bis: public suffix def",
      "url": "https://github.com/httpwg/http-extensions/issues/1033",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "The spec currently says:\r\n\r\n> The term \u201cpublic suffix\u201d is defined in a note in Section 5.3 of [RFC6265]\r\n\r\nThis should actually point to Section 5.4 (right now) of 6265bis.\r\n\r\nThat said, that note is hidden there very well; instead the contents should me moved up to the terminology section.",
      "createdAt": "2020-01-21T08:17:41Z",
      "updatedAt": "2020-01-28T12:46:56Z",
      "closedAt": "2020-01-28T12:46:56Z",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Indeed, thanks. This is probably a remnant from moving the definition over from the `SameSite` draft.\r\n\r\nI suspect I know the answer to this question from the HTTP WG's perspective, but the URL spec defines both \"[public suffix](https://url.spec.whatwg.org/#host-public-suffix)\" and \"[registrable domain](https://url.spec.whatwg.org/#host-registrable-domain)\" . I wonder if it's worth aligning those references in some way rather than copying them.\r\n\r\nPerhaps there's some place that we could collectively agree to point at (where \"we\" includes folks like @annevk @mnot and whoever feels responsible for RFC3986 and RFC3987)?",
          "createdAt": "2020-01-21T13:22:31Z",
          "updatedAt": "2020-01-21T13:22:31Z"
        }
      ]
    },
    {
      "number": 1034,
      "id": "MDU6SXNzdWU1NTI3MTM2Mjc=",
      "title": "6265bis: \"site.example\" is not under \"com\" PSL!",
      "url": "https://github.com/httpwg/http-extensions/issues/1034",
      "state": "CLOSED",
      "author": "bagder",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "Section 2.3 and section 5.4, step 5 say: \r\n\r\n> For\u00a0example, \"site.example\"'s public suffix is \"com\".\r\n\r\n(mistake from #1017 )\r\n\r\nAlso mentioned on the list: https://lists.w3.org/Archives/Public/ietf-http-wg/2020JanMar/0022.html",
      "createdAt": "2020-01-21T09:03:51Z",
      "updatedAt": "2020-01-22T06:05:07Z",
      "closedAt": "2020-01-22T06:05:06Z",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Fixed in https://github.com/httpwg/http-extensions/commit/e170e90e7db369e2080166c4fbd5496eb2a67f68, thanks!",
          "createdAt": "2020-01-22T06:05:06Z",
          "updatedAt": "2020-01-22T06:05:06Z"
        }
      ]
    },
    {
      "number": 1037,
      "id": "MDU6SXNzdWU1NTMyMzI4Njc=",
      "title": "[SH] algorithm to serialise a key is lax",
      "url": "https://github.com/httpwg/http-extensions/issues/1037",
      "state": "CLOSED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "The algorithm to serialise a key allows a string that starts with any valid character, not just lcalpha.",
      "createdAt": "2020-01-22T00:22:42Z",
      "updatedAt": "2020-01-24T03:55:37Z",
      "closedAt": "2020-01-24T03:55:37Z",
      "comments": []
    },
    {
      "number": 1042,
      "id": "MDU6SXNzdWU1NTY3NDE4NTY=",
      "title": "Is Age: a concern for cookies?",
      "url": "https://github.com/httpwg/http-extensions/issues/1042",
      "state": "OPEN",
      "author": "bagder",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "RFC 6265 says\r\n\r\n> let the expiry-time be the current date and time plus delta-seconds seconds\r\n\r\nAnother, more recent, HTTP header with a \"max-age\" field is Alt-Svc: in RFC 7838. It has a max-age that explicitly [subtracts the number of seconds](https://tools.ietf.org/html/rfc7838#section-3.1) specified in [the Age: header](https://tools.ietf.org/html/rfc7234#section-5.1).\r\n\r\nThe question is then if `Age:` should be considered valid for `Alt-Svc:`, shouldn't it also be considered valid for `Set-Cookie:` ? (My assumption is that max-age values are generally large enough to make this mostly an academic discussion, but I don't know this for a fact.)\r\n\r\n(I know curl's cookie parser doesn't care about `Age:` but I have no idea if others do.)",
      "createdAt": "2020-01-29T09:35:47Z",
      "updatedAt": "2020-01-29T15:06:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "In an ideal world, it would likely make sense to work `Age` support into the cookie spec somehow. In a less-than-ideal world, I'm not actively planning on adding support to Chromium's network stack. I don't believe Firefox or Safari support that interaction either.",
          "createdAt": "2020-01-29T13:10:28Z",
          "updatedAt": "2020-01-29T13:10:28Z"
        },
        {
          "author": "bagder",
          "authorAssociation": "NONE",
          "body": "I'm not really advocating that anyone changes any stacks, more to understand what is already used and thinking a little about what the concept \"current date and time\" actually means between the treatment of different headers.\r\n\r\nIf you say no implementation cares about Age: or that no max-age is ever that small anyway to make it matter, then I suppose we don't do anything at all.",
          "createdAt": "2020-01-29T15:06:41Z",
          "updatedAt": "2020-01-29T15:06:41Z"
        }
      ]
    },
    {
      "number": 1043,
      "id": "MDU6SXNzdWU1NTcxNTIzMDU=",
      "title": "Decimal rounding",
      "url": "https://github.com/httpwg/http-extensions/issues/1043",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "... still isn't right, as Kari noticed. E.g., a value of `1.9998` won't get rounded to `2.0`.",
      "createdAt": "2020-01-29T22:21:45Z",
      "updatedAt": "2020-02-11T14:22:31Z",
      "closedAt": "2020-02-11T14:22:31Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Step 1 of all serialisation algorithms could be related to sanitising/casting/failing-on noncanonical data.\r\n\r\n1. Turn your random number into a Decimal, including rounding to three digits.\r\n2. Fail if it's `>= 1e13` or `<= -1e13`\r\n3. no worries from here on\r\n\r\nActually, Key, Integer, String, Token, Byte Sequence, and Boolean already do this, so Decimal is the only scalar type that doesn't.",
          "createdAt": "2020-01-29T23:15:11Z",
          "updatedAt": "2020-01-29T23:15:11Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With the current algorithm, if it is allowed as input, -0.0004 will get serialized as `-0.0`, rather than `0.0`.\r\n#1044 corrects that as well.",
          "createdAt": "2020-02-06T16:07:08Z",
          "updatedAt": "2020-02-06T16:07:08Z"
        }
      ]
    },
    {
      "number": 1046,
      "id": "MDU6SXNzdWU1NTk0MDkxMzM=",
      "title": "Bad link in 6265bis samesite enforcement section",
      "url": "https://github.com/httpwg/http-extensions/issues/1046",
      "state": "CLOSED",
      "author": "sbingler",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "In https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-04#section-5.3.7.1 under sub heading # 1 there is a paragraph, \"Attackers can still pop up new windows or trigger...\", which references section 2.1 for more information on that topic. However section 2.1 is \"Conformance Criteria\" so that doesn't seem the intended target.",
      "createdAt": "2020-02-04T00:06:41Z",
      "updatedAt": "2020-02-05T08:26:58Z",
      "closedAt": "2020-02-05T08:26:49Z",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2020-02-05T08:26:58Z",
          "updatedAt": "2020-02-05T08:26:58Z"
        }
      ]
    },
    {
      "number": 1051,
      "id": "MDU6SXNzdWU1NjExNDI2NzI=",
      "title": "String parser requirements do not specify quoted or unquoted characters",
      "url": "https://github.com/httpwg/http-extensions/issues/1051",
      "state": "CLOSED",
      "author": "clelland",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "The prose in [Strings](https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-15#section-3.3.3) says\r\n\r\n\"Parsers MUST support strings with at least 1024 characters.\"\r\n\r\nUnlike the similar text for byte sequences, which specifies \"after decoding\", this could be ambiguous: Is a string represented in a header as 2000 `\\` characters within the limit?\r\n\r\n(Pretty sure the answer is yes, it's decoded characters, but should be explicit)",
      "createdAt": "2020-02-06T16:55:55Z",
      "updatedAt": "2020-02-11T14:18:54Z",
      "closedAt": "2020-02-11T14:18:54Z",
      "comments": []
    },
    {
      "number": 1053,
      "id": "MDU6SXNzdWU1NjExNzc2MDc=",
      "title": "Structured headers uses COMMA without defining it",
      "url": "https://github.com/httpwg/http-extensions/issues/1053",
      "state": "CLOSED",
      "author": "clelland",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "The structured headers draft imports and uses a number of productions from RFC 5234 for typographically awkward characters and character classes (`SP`, `DQUOTE`, etc), but there is no definition of `COMMA` provided anywhere.\r\n\r\nSimilar to the way that `\":\"`, `\";\"`, `\"\\\"`, `\"(\"`, and `\")\"` are used without special treatment, `COMMA` can probably be replaced with `\",\"` wherever it occurs.",
      "createdAt": "2020-02-06T18:02:03Z",
      "updatedAt": "2020-02-07T14:27:07Z",
      "closedAt": "2020-02-07T14:26:52Z",
      "comments": []
    },
    {
      "number": 1055,
      "id": "MDU6SXNzdWU1NjE4NTkwMjQ=",
      "title": "Should structured headers serialize data which cannot be parsed?",
      "url": "https://github.com/httpwg/http-extensions/issues/1055",
      "state": "CLOSED",
      "author": "clelland",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "With the issue of rounding coming up again in #1044, @phluid61 brought up that there's a bigger question around all of the serialization algorithms -- is their input specifically defined in terms of the structured data types? (With all of the range restrictions on those types?)\r\n\r\nThe example at hand is Decimals -- since the \"Serialize a Decimal\" algorithm states that its input is a decimal, should rounding even be a possible concern? According to 3.3.2, decimals can only have three fractional digits. Unless that algorithm actually accepts arbitrary real numbers, the issue of rounding, or of the integer component being too large, should never come up.\r\n\r\nSimilarly, after saying \"Given a byte sequence as input_bytes, ...\", the \"Serializing a Byte Sequence\" algorithm includes \"If input_bytes is not a sequence of bytes, ...\", which seems like an impossible situation.\r\n\r\nStrings, tokens, and keys all do the same, guarding against situations which can't happen if the input is the correct structured data type (as opposed to a generic string in the implementation language.)\r\n\r\nI don't know if the spec just needs to be more precise about when it is talking about Structured Data Strings, Tokens, Decimals, etc., or if the serialization algorithms need to be defined as taking generic strings, numbers, and arrays as input, or maybe we need both, with a section on converting strings to Strings or Tokens, numbers to Decimals, etc., which can happen before or during serialization.\r\n\r\n(Or maybe I'm being too strict here, and the threshold for spec text should be 'understandable by a reasonable person'? :) )",
      "createdAt": "2020-02-07T20:36:59Z",
      "updatedAt": "2020-02-26T06:46:05Z",
      "closedAt": "2020-02-26T06:46:04Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Some points to consider:\r\n\r\nIt was decided to not define the structured headers data model(s) as formal types. They are more like a profile applied to generic data types. The informality becomes more apparent when you realise that Integer, Byte Sequence, and Boolean are never actually defined.\r\n\r\nThe structured headers types are modelled to map natively to JavaScript types, modulo some profiling. Not least because one half of the web (the client half) is largely restricted to working in JavaScript. It doesn't have to be stated as an explicit constraint in the spec, but it's been an underlying consideration. \r\n\r\nIf your serialisation function accepts a native JavaScript value, which is a reasonable assumption on today's web, it behooves us to provide you with a sanitisation/validation algorithm.\r\n\r\nWhat remains to be decided is where and how that algorithm is provided. For now, it's implicitly included in the serialisation algorithm. \r\n\r\nThis was also discussed in structured-header-tests#32",
          "createdAt": "2020-02-08T00:12:21Z",
          "updatedAt": "2020-02-08T00:12:21Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's really useful context, @phluid61 -- would a statement like that make sense in the introduction?\r\n\r\nThat makes the answer to the original question \"Yes\" :)\r\n\r\nIn that case, the serialization algorithms should probably be clear that they're not strictly limited to structured data types as input.",
          "createdAt": "2020-02-10T20:56:45Z",
          "updatedAt": "2020-02-10T20:56:45Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Sounds reasonable to me; there needs to be some wiggle room here, I think. Perhaps this could be in the Implementation Notes appendix?",
          "createdAt": "2020-02-11T14:17:13Z",
          "updatedAt": "2020-02-11T14:17:13Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "PTAL - is that enough?",
          "createdAt": "2020-02-18T04:57:35Z",
          "updatedAt": "2020-02-18T04:57:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "As per Kari on-list, we should clarify serialisation of non-ascii content in tokens, keys and strings. While we constrain the characters allowed in each, we don't actually talk about character sets.",
          "createdAt": "2020-02-19T01:56:12Z",
          "updatedAt": "2020-02-19T01:56:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Not hearing any more feedback, closing.",
          "createdAt": "2020-02-26T06:46:04Z",
          "updatedAt": "2020-02-26T06:46:04Z"
        }
      ]
    },
    {
      "number": 1056,
      "id": "MDU6SXNzdWU1NjIyOTI1NDY=",
      "title": "The default priority of a pushed request",
      "url": "https://github.com/httpwg/http-extensions/issues/1056",
      "state": "OPEN",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "The answer depends on if reprioritization should be part of the spec (i.e. resolution of #1021), and if browsers would use it.\r\n\r\nFor more context, see [this thread](https://github.com/httpwg/http-extensions/pull/1048#discussion_r376009024).",
      "createdAt": "2020-02-10T02:41:48Z",
      "updatedAt": "2020-05-18T20:24:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There was some previous discussion at https://github.com/kazuho/draft-kazuho-httpbis-priority/issues/91, lets continue the conversation here.",
          "createdAt": "2020-02-27T16:05:38Z",
          "updatedAt": "2020-02-27T16:05:38Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the pushed resource gets assigned a priority that means it won't get sent until the client sends the desired priority, that's effectively no different than a Link header triggering a request for the resource.  So assigning it the minimum priority is essentially useless unless the connection is otherwise idle.  But if given a priority where it *can* be sent, the resource likely can be pushed and already sent within the 1+ RTT it will take for the client to see the promise and reprioritize it.  To me, that indicates we can't rely on reprioritization of pushes, regardless of whether that feature remains in the spec.\r\n\r\nThe HTTP/2 approach of \"slightly less important than the document it was pushed on\" seems like a more sensible starting point.  In this incarnation, that probably means the same priority level, but not incremental, regardless of what the parent was.  Or perhaps one level lower, to ensure that the parent can always pre-empt the push if it becomes available in mid-transfer.",
          "createdAt": "2020-02-27T20:09:23Z",
          "updatedAt": "2020-02-27T20:09:23Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "For any given push, the correct priority is dependent on context. There is no perfect answer that will work optimally in all cases. In deciding a default, we can either (a) choose something we think is closest to correct for most cases, or (b) choose something that will minimize harm in most cases. I favor (b). It's very difficult to get (a) right for all of the reasons discussed in #1026.\r\n\r\nPush is often speculative: the server predicts that the client may need a resource, but the server doesn't know for sure (the resource might already be cached, or maybe it's not needed at all). \"Over pushing\" is a known problem and we have observed that push can be a footgun. Push is actually very hard to use well. @MikeBishop is concerned that assigning the minimum priority makes push useless unless the connection is otherwise idle, but that's exactly the point! If a push is speculative, as they often are in my experience, then idle times are the safest times to push.\r\n\r\nFurther, I would argue that no matter which priorities are chosen, push is very rarely useful on connections that are never idle. Suppose a web page has three files, HTML, CSS, and JPG, prioritized in that order. If the HTML is large enough (and can be generated quickly enough) so that the connection is never idle, then it's never beneficial to push the CSS or the JPG. The HTML is hogging the connection, so you might as well wait for the client to request each file explicitly. I can think of just two cases where push might be useful on a connection that is never idle:\r\n\r\n1. The server wants to interleave a pushed CSS file immediately after sending `<link rel=stylesheet>` from the HTML. The server will need custom logic for this anyway. The default priority is irrelevant.\r\n\r\n2. The client asks for a web page concurrently with another stream of requests. I don't have a good solution for this. It's difficult for the server to know what the correct priorities should be for a pushed resource relative to other concurrent requests (see #1026). I also believe this is an uncommon case -- the most popular motivating example for push involves a user who has never been to your site previously.\r\n\r\n@MikeBishop, I didn't grok what you meant by \"we can't rely on reprioritization of pushes\"?",
          "createdAt": "2020-02-27T23:48:02Z",
          "updatedAt": "2020-02-27T23:48:02Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe client-driven reprioritization of pushes will be useless because it takes 1 RTT for the client to receive the promise and respond with a reprioritization directive.  There are only a few realistic cases:\r\n- The default priority is low enough that the resource has not yet begun to be sent by the time reprioritization arrives.  Thus, the push was pointless and we should have just waited for the client to make a request.\r\n- The default priority is high enough that the resource has already been encrypted and sent by the time reprioritization arrives.  Thus, the reprioritization was useless because the data has already been committed.\r\n- The default priority is high enough that the resource has already been encrypted and sent by the time reprioritization arrives, *and* the resource is large enough that it's still being streamed when the client's reprioritization arrives.  We already know that pushing large resources tends to hurt more than it helps, so servers shouldn't do this anyway.\r\n\r\nIt's a fair point that push should primarily utilize idle connection time, and from that standpoint, it doesn't matter what priority it's assigned.  It might hypothetically be competing with things the client has prioritized as only being sent when the connection is idle, but that should be uncommon.",
          "createdAt": "2020-03-02T16:41:48Z",
          "updatedAt": "2020-03-02T16:41:48Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For some population of intermediaries, the action of pushing is driven using a Link \"rel=preload\" in the response of the first request. At that time, the intermediary might have very little information about the resource when it synthesizes the push; there may be an `as` parameter but the size is unlikely to be known and so the server can't execute some of the smarts suggested in case 3.\r\n\r\nThe interplay with push and request generation order is interesting, in section 3.2 of the editor's draft we currently say\r\n\r\n```\r\nServing non-incremental responses one by one, \r\nin the order in which those requests were generated \r\nis considered to be the best strategy.\r\n```\r\n\r\nIf we are pushing at \"one below the parent request priority\" non-incrementally, then there is a danger that these block real client requests at or below the same level. Pushing at too high a priority level seems to endanger client's actual authority over their usage of the priority levels - even if everyone is acting in good faith.\r\n\r\n\r\n",
          "createdAt": "2020-03-02T17:29:53Z",
          "updatedAt": "2020-03-02T17:30:10Z"
        },
        {
          "author": "tombergan",
          "authorAssociation": "NONE",
          "body": "> It's a fair point that push should primarily utilize idle connection time, and from that standpoint, it doesn't matter what priority it's assigned.\r\n\r\nThe default priority doesn't matter in case 2, I agree with that, but it matters in cases 1 and 3.\r\n\r\nFor cases 1 and 3, it's not enough to simply state that push should not have been used. While I mostly agree with that in theory, in practice it's very difficult to know which case you'll end up in a priori. Suppose the user requests A and the server considers pushing B. The server cannot predict which case it will end up in unless it precisely knows (a) how long it will take to generate the responses for A and B (to know if there will be idle time before sending the first byte of A); (b) the sizes of A and B (see Lucas' response); and (c) the effective BDP of the connection (possible to estimate in theory but this assumes the server push code has access to the current cwnd).\r\n\r\nIn practice, even well-meaning servers are going to use push in cases 1 and 3. This implies that the default priority will be important in practice, and even \"one priority below the parent request\" has problems as Lucas points out.",
          "createdAt": "2020-03-02T18:54:10Z",
          "updatedAt": "2020-03-02T18:54:10Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Revisiting this issue, I am starting to wonder if we need to provide _one_ advice. As others have noted, how a pushed resource should be prioritized depends on each use-case. And for the case of an H3 terminator not having the knowledge of how to prioritize a pushed response, the priority response header from the upstream server can provide an answer.\r\n\r\nTo summarize, maybe saying something like: _When pushing a response, it is the responsibility of the server to correctly prioritize that response against other responses. When making that decision, an HTTP server can take into consideration the value of the priority response header field of the pushed response._",
          "createdAt": "2020-05-18T11:56:36Z",
          "updatedAt": "2020-05-18T11:56:48Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've lost some context here. Looking back through the threads, in https://github.com/kazuho/draft-kazuho-httpbis-priority/issues/91#issuecomment-555416246  you (Kazuho) said:\r\n\r\n> When push is used, both the request and response headers are created by the server. If either of the two contains a priority header field, the value of that header field should be used.\r\n> The question is what to do when there is no hint.\r\n\r\nThis seems to conflict with your proposed advice.\r\n\r\n",
          "createdAt": "2020-05-18T16:25:21Z",
          "updatedAt": "2020-05-18T16:25:21Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue Thank you for resurrecting my old comment.\r\n\r\nI think I am consistent in arguing that a server _can_<sup>1</sup> use a hint provided by upstream, if such hint is provided.\r\n\r\nWhat I am arguing now is that we should encourage servers determine the priority of the pushed request, rather than trying to find a default. As we have discussed, one default does not fit all.\r\n\r\nWhen a server is the initiator of a pushed request, it would definitely know why it initiated that push. As it knows the reason, it would be possible to determine the correct urgency. When a server is obeying to an instruction from an upstream server (e.g., link rel=preload), the upstream server can provide a hint by using the priority header field in the pushed response, or make a guess based on other properties (e.g., type of the pushed resource, the fact that link rel=preload is being used, etc.).\r\n\r\nThese hints could work better than a hard-coded default in the spec. Assuming that is the case, my point is that we should encourage the use of such hints, and that maybe doing just that is enough.\r\n\r\n[1] Using \"can\" rather than \"SHOULD\", as we've reduced the guidance (see #1026).",
          "createdAt": "2020-05-18T20:11:45Z",
          "updatedAt": "2020-05-18T20:12:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Encouraging signals is good and I agree that without them bets are off. I think there is ultimately no \"good\" guidance to provide, so maybe all we can do is highlight the pitfalls.\r\n\r\nWriting this I realise a pitfall I'll need to confirm. Right now, the quiche implementation factors in the stream ID into scheduling choices. This might break down if the request and push stream IDs start to diverge or progress at different phases. This is a manifestation of my earlier comment about considering request order for scheduling.",
          "createdAt": "2020-05-18T20:24:54Z",
          "updatedAt": "2020-05-18T20:24:54Z"
        }
      ]
    },
    {
      "number": 1057,
      "id": "MDU6SXNzdWU1NjI5MzA2OTA=",
      "title": "Last-call feedback for \"Structured Headers for HTTP\"",
      "url": "https://github.com/httpwg/http-extensions/issues/1057",
      "state": "CLOSED",
      "author": "wenbozhu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-15\r\n\r\n**Nits**\r\n+ \"individual individual\"  (4.2.)\r\n\r\n**Clarification**\r\n+ re: \"lists can have their members split across multiple instances inside a block of fields\", it will be useful to add a reference on the strict order of HTTP headers (of the same key)\r\n+ max # of items for innerlist: why not 1024 too? It seems a bit arbitrary to go with a smaller number\r\n+ 3.3.5  could you mention the max length of the encoded header value, in addition?\r\n \r\n**Suggestions**\r\n+ can utf-8 be the only encoding option?\r\n+ can you add an appendix on any existing headers that already comply with this spec, or examples of some complicated headers that could have benefited from structured headers? This might encourage the implementations of \"structured headers\"\r\n+ it will be useful to mention how the authors expect this spec to be extended in future (or not), e.g. new item types, nested inner-lists\r\n\r\n---\r\n\r\nGreat work!  Look forward to implementing this soon. \r\n",
      "createdAt": "2020-02-11T01:47:02Z",
      "updatedAt": "2020-02-11T14:15:10Z",
      "closedAt": "2020-02-11T14:15:10Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the review!\r\n\r\n> \"individual individual\" (4.2.)\r\n\r\nFixed.\r\n\r\n> re: \"lists can have their members split across multiple instances inside a block of fields\", it will be useful to add a reference on the strict order of HTTP headers (of the same key)\r\n\r\nFixed.\r\n\r\n> max # of items for innerlist: why not 1024 too? It seems a bit arbitrary to go with a smaller number\r\n\r\n1024 * 1024 is a lot, especially considering the limits that most implementations will put on total header size\r\n\r\n> 3.3.5 could you mention the max length of the encoded header value, in addition?\r\n\r\nWe're trying to just limit the abstract types, so that it's consistent between different serialisations.\r\n\r\n> can utf-8 be the only encoding option?\r\n\r\nThe reference to UTF-8 is only advice; people can put whatever arbitrary binary data they want into the binary type.\r\n\r\n> can you add an appendix on any existing headers that already comply with this spec, or examples of some complicated headers that could have benefited from structured headers? This might encourage the implementations of \"structured headers\"\r\n\r\nThat's out of scope for this work, but see draft-nottingham-binary-structured-headers\r\n\r\n> it will be useful to mention how the authors expect this spec to be extended in future (or not), e.g. new item types, nested inner-lists\r\n\r\nI think we can defer that, because new extensions will have to update this specification (going through the appropriate process); it's not intended to have modular extensibility. ",
          "createdAt": "2020-02-11T14:15:10Z",
          "updatedAt": "2020-02-11T14:15:10Z"
        }
      ]
    },
    {
      "number": 1059,
      "id": "MDU6SXNzdWU1NjQ2ODA5NDI=",
      "title": "Cookie 5.4 storage model confusion",
      "url": "https://github.com/httpwg/http-extensions/issues/1059",
      "state": "CLOSED",
      "author": "essen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "https://httpwg.org/http-extensions/draft-ietf-httpbis-rfc6265bis.html#storage-model\r\n\r\nStep 8 says:\r\n\r\n```\r\nIf the cookie-attribute-list contains an attribute with an attribute-name\r\nof \u201cSecure\u201d, set the cookie\u2019s secure-only-flag to true. Otherwise,\r\nset the cookie\u2019s secure-only-flag to false.\r\n```\r\n\r\nBut then Step 12 says:\r\n\r\n```\r\nIf the cookie\u2019s secure-only-flag is not set, [...]\r\n```\r\n\r\nIt's impossible to reach step 12 with the `secure-only-flag` not set because it's always set in step 8.\r\n\r\nI believe a better wording would be `If the cookie's secure-only-flag is false,`.",
      "createdAt": "2020-02-13T13:25:42Z",
      "updatedAt": "2020-04-01T06:15:03Z",
      "closedAt": "2020-04-01T06:15:03Z",
      "comments": []
    },
    {
      "number": 1061,
      "id": "MDU6SXNzdWU1NjYzNjY0OTU=",
      "title": "Redirecting 404",
      "url": "https://github.com/httpwg/http-extensions/issues/1061",
      "state": "OPEN",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Has there ever been discussion for a status code that means \"this URL does not exist, but let me redirect you to a URL that does and might help you\"?\r\n\r\nEspecially for URLs that are meant to be human-readable this would be really helpful. Or if you want to help the user by eliding punctuation that might have ended up at the end of a URL due to bad auto-linking. (And in practice I've seen this implemented with a 3xx status code and I suppose 301 kinda fits the bill, but it's a little strange?)\r\n\r\n(This also applies a bit to 410 and maybe other 4xx status codes.)\r\n\r\n(Sorry if this is the wrong place.)",
      "createdAt": "2020-02-17T15:19:48Z",
      "updatedAt": "2020-02-17T17:29:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://tools.ietf.org/html/rfc6596 maybe?",
          "createdAt": "2020-02-17T15:21:42Z",
          "updatedAt": "2020-02-17T15:21:42Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "So say `/)` is wrong, but not wrong enough that you don't want to map it `/` to be helpful. Would the response be:\r\n```\r\n301 BLAH\r\nLink: </>;rel=canonical\r\nLocation: /\r\n```\r\n? (Please forgive any errors in the `Link` header syntax, I did not look it up.)",
          "createdAt": "2020-02-17T15:28:49Z",
          "updatedAt": "2020-02-17T15:28:49Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I haven't thought about that :-) I'd say Link/rel=canonical with 200 should be sufficient for the client to understand what's going on.",
          "createdAt": "2020-02-17T17:21:46Z",
          "updatedAt": "2020-02-17T17:21:46Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "And use HTML and `<meta http-equiv=refresh>` for the redirect you also want to make happen? (I think what happens in practice is that folks (ab)use redirects, as that gives a better experience for end users.)",
          "createdAt": "2020-02-17T17:29:42Z",
          "updatedAt": "2020-02-17T17:29:42Z"
        }
      ]
    },
    {
      "number": 1062,
      "id": "MDU6SXNzdWU1NjY2MzYxMjI=",
      "title": "Using CDN-Loop",
      "url": "https://github.com/httpwg/http-extensions/issues/1062",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "RFC8586 is very clear about other uses of `CDN-Loop`:\r\n\r\n> The header field SHOULD NOT be used for other purposes.\r\n\r\nThe current priority draft uses it to detect whether there upstream intermediaries, not loop detection. This should be removed.",
      "createdAt": "2020-02-18T04:20:39Z",
      "updatedAt": "2020-03-04T05:20:04Z",
      "closedAt": "2020-03-04T05:20:04Z",
      "comments": []
    },
    {
      "number": 1067,
      "id": "MDU6SXNzdWU1Njg2NTEzMzU=",
      "title": "Binary delimiter (again)",
      "url": "https://github.com/httpwg/http-extensions/issues/1067",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "When preparing a talk the other night, I had an example like this:\r\n\r\n~~~\r\nExample-BinaryHdr: :cHJldGVuZCB0aGlzIGmFyeSBjb250ZW50Lg==:\r\n~~~\r\n\r\n... which made me wince a bit, since the `:` is used both as a delimiter between the field name and field line value, and to denote the start of binary content. We don't have an example like this in the spec, so it was the first time I saw it \"for real.\"\r\n\r\nIt's syntactically valid in HTTP, and I don't think there are any security or interoperability issues, but I wanted to make sure folks were comfortable with this -- especially since someone came up right after the talk and pointed out the same thing :-/\r\n\r\nIf we changed this, I think a reasonable replacement would be `|`; e.g.,\r\n\r\n~~~\r\nExample-BinaryHdr: |cHJldGVuZCB0aGlzIGmFyeSBjb250ZW50Lg==|\r\n~~~\r\n\r\nWhat do folks think -- is this worth changing at this late stage?\r\n\r\nPinging @phluid61 @annevk and @clelland specifically.",
      "createdAt": "2020-02-20T23:51:33Z",
      "updatedAt": "2020-02-27T04:03:56Z",
      "closedAt": "2020-02-26T06:46:53Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd love to see it in a H2 pseudo-header some time: `:path: :L2Zvby9iYXI=:`\r\n\r\nAt this point I think it's aesthetic. `:`, `|`, `$`, pretty sure any of them would work. Just depends what's easier on the eyes.  But I would suggest that once it's settled here, it's settled for good.",
          "createdAt": "2020-02-21T00:00:54Z",
          "updatedAt": "2020-02-21T00:00:54Z"
        },
        {
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe that most people interact with HTTP these days, *not* seeing headers like this. For the most part they'll see them through libraries to read/write them or they use GUI's where they are formatted as a table... so I *think* it doesn't really matter, but ymmv",
          "createdAt": "2020-02-21T02:13:09Z",
          "updatedAt": "2020-02-21T02:13:09Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I think it's fine for the \"legacy\" (currently also only, but hey) serialization. And yeah, most APIs deal with header names and values separately so it's not a big deal.",
          "createdAt": "2020-02-21T10:44:37Z",
          "updatedAt": "2020-02-21T10:44:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I'm not hearing folks being too concerned; closing with no action.",
          "createdAt": "2020-02-26T06:46:53Z",
          "updatedAt": "2020-02-26T06:46:53Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed that this is probably fine, though its hard to say what older proxy servers will choke on. That said, colons appear everywhere in headers already, so I don't imagine any interop issues.",
          "createdAt": "2020-02-27T04:03:56Z",
          "updatedAt": "2020-02-27T04:03:56Z"
        }
      ]
    },
    {
      "number": 1068,
      "id": "MDU6SXNzdWU1Njg3MjQ1MDc=",
      "title": "* for dictionary member name",
      "url": "https://github.com/httpwg/http-extensions/issues/1068",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "In https://github.com/w3c/reporting/issues/177, @clelland asks for `*` as a dictionary member name.\r\n\r\nI think this just means adding it to valid start characters in key.",
      "createdAt": "2020-02-21T04:13:19Z",
      "updatedAt": "2020-03-04T07:17:04Z",
      "closedAt": "2020-03-04T07:17:04Z",
      "comments": []
    },
    {
      "number": 1073,
      "id": "MDU6SXNzdWU1Njk5MjMwODE=",
      "title": "[rfc6265bis] Cookie parser - UTF-8 chars",
      "url": "https://github.com/httpwg/http-extensions/issues/1073",
      "state": "OPEN",
      "author": "bakulf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "Following the RFC6265bis section 4.1.1 a cookie-value can contain only ASCII chars:\r\n\r\n```\r\n   cookie-name       = token\r\n   cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\r\n   cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\r\n                         ; US-ASCII characters excluding CTLs,\r\n                         ; whitespace DQUOTE, comma, semicolon,\r\n                         ; and backslash\r\n```\r\n\r\nModern browsers do allow UTF-8 chars too and we have web-platform-tests to enforce this behavior.\r\nI would suggest extending the cookie-octet with the range %x80-FF.",
      "createdAt": "2020-02-24T15:15:44Z",
      "updatedAt": "2020-10-16T12:22:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Thanks for raising this, I think this is basically https://github.com/whatwg/html/issues/804 again, for which we had #159, but that didn't cover everything that was identified there.\r\n\r\ncc @inikulin",
          "createdAt": "2020-02-25T16:44:50Z",
          "updatedAt": "2020-02-25T16:44:50Z"
        },
        {
          "author": "inikulin",
          "authorAssociation": "NONE",
          "body": ">  I think this is basically whatwg/html#804 again, for which we had #159, but that didn't cover everything that was identified there.\r\n\r\nCorrect. Though, at the time of testing only FF and Chrome supported UTF-8 properly, so it wasn't considered as a de-facto standard.",
          "createdAt": "2020-03-06T15:20:12Z",
          "updatedAt": "2020-03-06T15:20:12Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Non-ASCII cookies are certainly produced by servers out there in the wild, and accepted by several user agents (though not, apparently, Safari: https://wpt.fyi/results/cookies/http-state/charset-tests.html?label=experimental&label=master&aligned). I'm comfortable extending based on those test results.",
          "createdAt": "2020-03-31T15:57:34Z",
          "updatedAt": "2020-03-31T15:57:34Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "(That said, I don't think it's as simple as extending `cookie-octet`. We'll need to define the encoding, serialization, etc. in a little more detail if we're going to move outside of ASCII.)",
          "createdAt": "2020-03-31T16:03:00Z",
          "updatedAt": "2020-03-31T16:03:00Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Yeah, at the lowest level you're looking at two parsers, one that takes bytes and one that takes code points (potentially scalar values if we can make `document.cookie` a `USVString`). Which one feeds into which and how requires investigation.",
          "createdAt": "2020-03-31T16:53:48Z",
          "updatedAt": "2020-03-31T16:53:48Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Just a random comment - I would buy both of you some drinks if you could figure out a way to express the [Set-]Cookie header data model in terms of structured ~~headers~~ fields, and the define parsing and serialisation algorithms to get there...",
          "createdAt": "2020-04-01T00:23:25Z",
          "updatedAt": "2020-04-01T00:23:25Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "It seems efaa468e6af574e88152cc365deb32e262444844 (marked editorial) changed this to include 0x80-0xFF and that matches Chrome in that it does bytes-in-bytes-out. Firefox tries to decode to UTF-8 (so 0xFF becomes U+FFFD and three bytes in the Cookie header rather than staying 0xFF). Safari seems to truncate at the first non-ASCII byte which strikes me as pretty bad behavior?\r\n\r\nThe tests mentioned above should account for invalid UTF-8 as it seems they currently do not and therefore do not capture this difference between Chrome and Firefox. I suspect we should align Firefox with Chrome here unless there is interest to do the opposite?\r\n\r\n(Firefox has seen at least one compatibility problem from not having the Chrome behavior here: https://bugzilla.mozilla.org/show_bug.cgi?id=1664702.)",
          "createdAt": "2020-10-16T12:22:29Z",
          "updatedAt": "2020-10-16T12:22:29Z"
        }
      ]
    },
    {
      "number": 1074,
      "id": "MDU6SXNzdWU1Njk5MzIyMzA=",
      "title": "[rfc6265bis] Cookie parser - cookie name and value with spaces",
      "url": "https://github.com/httpwg/http-extensions/issues/1074",
      "state": "CLOSED",
      "author": "bakulf",
      "authorAssociation": "NONE",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "Similar to #1073, by spec, cookie name and value should not contain spaces, but modern browsers do allow spaces. We even have WPTs.\r\n\r\nA similar issue is the trimming of cookie-name and cookie-value. By spec: \"SetCookie: foo = bar\" is invalid.\r\n\r\nWhat I suggest is to write the BFN in this way (untested, unverified):\r\n\r\n```\r\n cookie-pair       = cookie-name *[SP] \"=\" *[SP] cookie-value\r\n cookie-name       = 1*cookie-octet\r\n cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\r\n cookie-octet      =  %20 / %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\r\n```\r\n",
      "createdAt": "2020-02-24T15:27:50Z",
      "updatedAt": "2020-04-07T11:39:00Z",
      "closedAt": "2020-04-07T11:39:00Z",
      "comments": []
    },
    {
      "number": 1075,
      "id": "MDU6SXNzdWU1NzEwOTg5NDI=",
      "title": "Parsing a Key - odd failure case",
      "url": "https://github.com/httpwg/http-extensions/issues/1075",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Parsing a Key has a bit of an odd behaviour when it encounters a character (after the first) that isn't allowed; it assumed that it's the end of the key, and returns the value so far. \r\n\r\n~~~\r\n3. While input_string is not empty:\r\n   1. If the first character of input_string is not one of lcalpha, DIGIT, \"\\_\", \"-\", \".\", or \"\\*\", return output_string.\r\n~~~\r\n\r\nThis means that a malformed key will be truncated, and the remaining data will be fed back into the parser.\r\n\r\nIn the case of Dictionary member parsing, this goes to step 2 of:\r\n\r\n~~~\r\n   1. Let this_key be the result of running Parsing a Key ({{parse-key}}) with input_string.\r\n   2. If the first character of input_string is \"=\":\r\n       1. Consume the first character of input_string.\r\n       2. Let member be the result of running Parsing an Item or Inner List ({{parse-item-or-list}}) with input_string.\r\n   3. Otherwise:\r\n      1. Let value be Boolean true.\r\n      2. Let parameters be an empty, ordered map.\r\n      3. Let member be the tuple (value, parameters).\r\n~~~\r\n\r\n... which means that a malformed key will have the a default value of Boolean True, and then the rest of the key will hit:\r\n\r\n~~~\r\n   7. Consume the first character of input_string; if it is not \",\", fail parsing.\r\n~~~\r\n\r\nIf the key is in Parameters, it treats a malformed key as the end of the parameters, because of this:\r\n\r\n~~~\r\n2. While input_string is not empty:\r\n   1. If the first character of input_string is not \";\", exit the loop.\r\n   2. Consume a \";\" character from the beginning of input_string.\r\n   3. Discard any leading SP characters from input_string.\r\n   4. let param_name be the result of running Parsing a Key ({{parse-key}}) with input_string.\r\n   5. Let param_value be Boolean true.\r\n   6. If the first character of input_string is \"=\":\r\n      1. Consume the \"=\" character at the beginning of input_string.\r\n      2. Let param_value be the result of running Parsing a Bare Item ({{parse-bare-item}}) with input_string.\r\n   7. Append key param_name with value param_value to parameters. If parameters already contains a name param_name (comparing character-for-character), overwrite its value.\r\n~~~\r\n\r\n... which puts things in a really weird state, because what happens next depends upon the inputs.\r\n\r\nI think the simple thing to do here is to change Parsing a Key to hard fail if the next character isn't `=`. Something like:\r\n\r\n~~~\r\n3. While input_string is not empty:\r\n   1. If the first character of input_string is \"=\", return output_string.\r\n   2. Let char be the result of removing the first character of input_string.\r\n   3. If char is not one of lcalpha, DIGIT, \"\\_\", \"-\", \".\", or \"\\*\", fail parsing.\r\n   4. Otherwise, append char to output_string.\r\n~~~\r\n\r\nThoughts? I mean, it works now, but the error you get back is odd, and it could potentially get things into weird states.\r\n",
      "createdAt": "2020-02-26T06:26:35Z",
      "updatedAt": "2020-02-26T08:33:15Z",
      "closedAt": "2020-02-26T08:33:15Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Ping @clelland @phluid61 for thoughts.",
          "createdAt": "2020-02-26T06:45:16Z",
          "updatedAt": "2020-02-26T06:45:16Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you have an example invalid header value that really makes it confusing? Everything I could come up with wasn't that far off the mark, as far as errors from a streaming parser are concerned.  Even appending a `;` to the key, which is insane, threw errors at the right point (`\"x; y;=bad\"` threw `parse_key: first character not lcalpha \"=\"` at the start of `=bad`).\r\n\r\nAnd regarding weird states; an error is an error, isn't it?  We're not back-tracking.\r\n\r\nThe only really weird state I could contrive required putting a `;` in the middle of a parameter key, which breaks undetectably.  (`1; x;y=\"x;y\"` means `1; x=?1; y=\"x;y\"`)\r\n\r\n> I think the simple thing to do here is to change Parsing a Key to hard fail if the next character isn't `=`.\r\n\r\nCan't do that because of the implicit true, no?",
          "createdAt": "2020-02-26T07:19:35Z",
          "updatedAt": "2020-02-26T07:19:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It came up with parsing some `Alt-Svc` headers; e.g., with parameters like `h3-Q43=...`.\r\n\r\nI realised this is the way it is because implicit true while I was eating dinner -- sorry for the noise. Closing.",
          "createdAt": "2020-02-26T08:33:15Z",
          "updatedAt": "2020-02-26T08:33:15Z"
        }
      ]
    },
    {
      "number": 1079,
      "id": "MDU6SXNzdWU1NzIxODg2MTc=",
      "title": "Can server send PRIORITY_UPDATE?",
      "url": "https://github.com/httpwg/http-extensions/issues/1079",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "_Migrating this issue originally reported by @dikhonov - https://github.com/kazuho/draft-kazuho-httpbis-priority/issues/121#issue-551513184_\r\n\r\nSection 5 discusses how client can re-prioritize using the _PRIORITY_UPDATE_ frame and Section 6 discusses how the server can override priority using the `priority` header. It seems, then, that the server cannot send the _PRIORITY_UPDATE_ frame, but it is not forbidden in the draft.\r\n\r\nMy reply on the original issue was \r\n\r\n> Thanks for raising the issue. This is a gap in the spec and will need filling. The answer depends a little on the direction that the design takes in the WG; the salient question, I think, is: _what is the collaboration story for reprioritization?_\r\n> \r\n> Once there is a answer, we can lock down some of the normative text in the TODO placeholder\r\n> \r\n> ```\r\n> TODO: add more description of how to handle things like receiving PRIORITY_UPDATE \r\n> on wrong stream, a PRIORITY_UPDATE with an invalid ID, etc.wro\r\n> ```\r\n\r\n",
      "createdAt": "2020-02-27T16:13:53Z",
      "updatedAt": "2020-09-09T21:14:20Z",
      "closedAt": "2020-09-09T21:14:20Z",
      "comments": []
    },
    {
      "number": 1081,
      "id": "MDU6SXNzdWU1NzMyOTgwNzk=",
      "title": "Cookie 5.5 empty cookie name",
      "url": "https://github.com/httpwg/http-extensions/issues/1081",
      "state": "CLOSED",
      "author": "essen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "Step 4 says:\r\n\r\n```\r\nSerialize the cookie-list into a cookie-string by processing each cookie in the cookie-list in order:\r\n1. Output the cookie\u2019s name, the %x3D (\u201c=\u201d) character, and the cookie\u2019s value.\r\n2. If there is an unprocessed cookie in the cookie-list, output the characters %x3B and %x20 (\u201c; \u201c).\r\n```\r\n\r\nHowever looking at WPT tests (for example [1] / [2]) I can see that when we have `Set-Cookie: foo` (empty name with value `foo`) the expectation is to have `Cookie: foo` back, so perhaps these instructions should include a special case when the cookie name is empty.\r\n\r\n[1] https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/0004-test\r\n[2] https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/0004-expected",
      "createdAt": "2020-02-29T13:43:16Z",
      "updatedAt": "2020-04-01T06:13:25Z",
      "closedAt": "2020-04-01T06:13:25Z",
      "comments": []
    },
    {
      "number": 1083,
      "id": "MDU6SXNzdWU1NzM3MDAyMjk=",
      "title": "Default dictionary value with parameters",
      "url": "https://github.com/httpwg/http-extensions/issues/1083",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Julian asked in e-mail why we can't have a dictionary with a default True value that is parameterised:\r\n\r\n~~~\r\nExample-Field: ;param=on-default-boolean\r\n\r\nParameter values are comparatively simpler, because they can't have any further substructure.\r\n\r\nI don't quite get the example. In the spec I see:\r\n\r\n Example-DictHeader: a=?0, b, c=?1; foo=bar\r\n\r\nIf this would be instead:\r\n\r\n Example-DictHeader: a=?0, b, c; foo=bar\r\n\r\n...what would break?\r\n~~~",
      "createdAt": "2020-03-02T03:56:57Z",
      "updatedAt": "2020-03-10T16:38:08Z",
      "closedAt": "2020-03-04T07:16:31Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think we could replace:\r\n\r\n~~~\r\n   3. Otherwise:\r\n      1. Let value be Boolean true.\r\n      2. Let parameters be an empty, ordered map.\r\n      3. Let member be the tuple (value, parameters).\r\n~~~\r\n\r\nWith:\r\n\r\n~~~\r\n   3. Otherwise:\r\n      1. Let value be Boolean true.\r\n      2. Let parameters be the result of running Parsing Parameters {{parse-param}} with input_string.\r\n      3. Let member be the tuple (value, parameters).\r\n~~~\r\n",
          "createdAt": "2020-03-02T03:57:08Z",
          "updatedAt": "2020-03-02T03:57:08Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@clelland @phluid61 @bsdphk thoughts?",
          "createdAt": "2020-03-02T03:57:50Z",
          "updatedAt": "2020-03-02T03:57:50Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "    Example-Field: ;param=on-default-boolean\r\n\r\nIs this a dictionary? What is the key here? (I see that the value is supposed to be implicit true, but I'm not grokking the implied syntax)\r\n\r\nIf I ignore that (assuming I've misinterpreted something), I like the idea of allowing implicit True.\r\n\r\nThe serialization algorithm needs a bit more surgery to support this as the canonical form, probably replacing:\r\n\r\n```\r\n3. If member_value is not Boolean true or parameters is not empty:\r\n   1. Append \"=\" to output.\r\n      2. If member_value is an array, append the result of running Serialising an Inner List ({{ser-innerlist}}) with (member_value, parameters) to output.\r\n      3. Otherwise, append the result of running Serializing an Item ({{ser-item}}) with (member_value, parameters) to output.\r\n```\r\n\r\nwith something like:\r\n\r\n```\r\n3. If member_value is Boolean True,\r\n    1. Append the result of running Serializing Parameters ({{ser-params}}) with parameters to output.\r\n4. Otherwise,\r\n    1. Append \"=\" to output.\r\n    2. If member_value is an array, append the result of running Serialising an Inner List ({{ser-innerlist}}) with (member_value, parameters) to output.\r\n    3. Otherwise, append the result of running Serializing an Item ({{ser-item}}) with (member_value, parameters) to output.\r\n```\r\n\r\n(unless we also modify Serializing an Item to optionally omit True values, but we can't just do that unconditionally, or else a simple Item header would be empty if True.)\r\n\r\nThis is the same issue as https://github.com/httpwg/http-extensions/pull/993#discussion_r352982269, I think -- back in December you thought that it would take more drastic changes. If this is everything that it needs, though, it seems reasonable. None of the canonical tests break with this (except for a couple of serialization tests, which just need to be updated), and I don't see any obvious cases that would be parsed incorrectly.",
          "createdAt": "2020-03-02T16:51:13Z",
          "updatedAt": "2020-03-02T16:53:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> Example-Field: ;param=on-default-boolean\r\n\r\nSorry, that was unrelated, accidentally copied from the email. Ignore.\r\n\r\nI'll work up a PR and see how it looks.",
          "createdAt": "2020-03-04T00:02:31Z",
          "updatedAt": "2020-03-04T00:02:31Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Awesome.\r\n\r\nNow, how about also collapsing the \"false\" value a bit. So instead of having\r\n\r\n    a=?0\r\n\r\njust say\r\n\r\n    !a\r\n\r\n?",
          "createdAt": "2020-03-10T15:05:43Z",
          "updatedAt": "2020-03-10T15:05:43Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IMHO explicit is better than implicit:\r\n- I am not sure that `!a` is a good choice. \r\n- I am not even sure that defaulting `a -> a=?1` is a good choice.\r\n  ",
          "createdAt": "2020-03-10T16:38:07Z",
          "updatedAt": "2020-03-10T16:38:07Z"
        }
      ]
    },
    {
      "number": 1085,
      "id": "MDU6SXNzdWU1NzQ2Mzc0NTk=",
      "title": "Serialize vs serialise",
      "url": "https://github.com/httpwg/http-extensions/issues/1085",
      "state": "CLOSED",
      "author": "clelland",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "The Structured Headers spec is inconsistent in its use of UK vs US forms of \"seriali{sz}e\".\r\n\r\nQuick count:\r\n\r\nserialization: 3\r\nserialize: 3\r\nserialized: 1\r\nserializer: 3\r\nserializing: 40\r\n\r\nserialisation: 25\r\nserialise: 0\r\nserialised: 3\r\nserialiser: 1\r\nserialising: 5\r\n\r\nWe should pick one -- the RFC style guide doesn't have an opinion (https://tools.ietf.org/html/rfc7322#section-3.1 says either is fine, as long as the document is internally consistent).\r\n\r\nI'm not sure if there was previous discussion on this when parameteri**s**ed lists (v10) became lists with parameteri**z**ed members (v11), but that term doesn't exist in the document anymore.\r\n\r\nCurrent count is 7 instances of `/parameteris.*/` in the document, and 0 for `/parameteriz.*/`",
      "createdAt": "2020-03-03T12:35:04Z",
      "updatedAt": "2020-03-11T03:56:20Z",
      "closedAt": "2020-03-04T21:53:30Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "RFCs standardise on US English (blech). \r\n\r\nThis is one of the things that I was planning to let the RFC Editor sort out (it's always good to give them something to do ;) -- but will take a PR if you feel inclined.",
          "createdAt": "2020-03-03T22:41:42Z",
          "updatedAt": "2020-03-03T22:41:42Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure, why not :)",
          "createdAt": "2020-03-04T14:27:55Z",
          "updatedAt": "2020-03-04T14:27:55Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not quite....  RFC 7322 says:\r\n\r\n    The RFC publication language is English.  Spelling may be either\r\n    American or British, as long as an individual document is internally\r\n    consistent.  Where both American and British English spelling are\r\n    used within a document or cluster of documents, the text will be\r\n    modified to be consistent with American English spelling.",
          "createdAt": "2020-03-10T18:58:48Z",
          "updatedAt": "2020-03-10T18:58:48Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's what I read (and referenced in https://github.com/httpwg/http-extensions/issues/1085#issue-574637459) but I figured that @mnot knows more of the processes than I do :)",
          "createdAt": "2020-03-10T19:57:51Z",
          "updatedAt": "2020-03-10T19:57:51Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "IME they're pretty aggressive about deciding that it's a \"mix\" and therefore US wins :)",
          "createdAt": "2020-03-11T03:56:20Z",
          "updatedAt": "2020-03-11T03:56:20Z"
        }
      ]
    },
    {
      "number": 1087,
      "id": "MDU6SXNzdWU1NzQ5MzIzNDU=",
      "title": "Split secondary certs SETTINGS advertisement in two",
      "url": "https://github.com/httpwg/http-extensions/issues/1087",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "The current advertisement scheme does not allow for a client to decide it is willing to implement secondary server certificates but not client certificates or vice versa.\r\n\r\nIt may be worth having two SETTINGS values, one for whether you're willing to do either of the two flows.",
      "createdAt": "2020-03-03T20:47:45Z",
      "updatedAt": "2020-05-14T19:05:06Z",
      "closedAt": "2020-05-14T19:05:06Z",
      "comments": []
    },
    {
      "number": 1088,
      "id": "MDU6SXNzdWU1NzQ5MzI1MDg=",
      "title": "Handling of invalid secondary server certificates is unclear",
      "url": "https://github.com/httpwg/http-extensions/issues/1088",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "It is very unclear from the draft how exactly the client should handle a secondary server certificate it rejects. Presumably a bad secondary certificate should not be fatal to streams which don't use it. The draft seems to handwaive at this (though not very clearly, which means uncertainty for the server) in section 4.\r\n\r\nAt the same time, the draft says:\r\n\r\n>   If a client receives a \"PUSH_PROMISE\" referencing an origin for which\r\n>   it has not yet received the server's certificate, this is a fatal\r\n>   connection error (see section 8.2 of [RFC7540]).  To avoid this,\r\n>   servers MUST supply the associated certificates before pushing\r\n>   resources from a different origin.\r\n\r\nThis is inconsistent with that idea. Suppose the server pushes some CERTIFICATE frame along with some resources it thinks the client would want. If the client rejects that certificate, this text implies the client must tear down the entire connection, interrupting unrelated requests.\r\n\r\nA useful heuristic for reasoning through all this would be to consider a client which blindly rejects every secondary certificate. This is especially relevant if the draft does not act on #1087.",
      "createdAt": "2020-03-03T20:48:00Z",
      "updatedAt": "2020-05-14T19:14:08Z",
      "closedAt": "2020-05-14T19:14:08Z",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The restriction on the server is that it not push unless it has first sent the certificate.  If the client rejects the certificate, clearly it will discard the push; the question is whether the client will be able to differentiate failure-to-send from cert-not-accepted.  That depends on whether you assume that clients will look at the certificates, even if they aren't accepted; otherwise, I suspect that it can't.\r\n\r\nHowever, I think you're right that this is an overreaction.  RFC7540 requires that a PUSH_PROMISE for an unproven origin be treated as a stream error, but doesn't specify on which stream.  The parent stream still seems excessive, since the server can't know for which origins the client considers it authoritative.",
          "createdAt": "2020-04-14T19:37:21Z",
          "updatedAt": "2020-04-14T19:37:21Z"
        }
      ]
    },
    {
      "number": 1089,
      "id": "MDU6SXNzdWU1NzQ5MzI1NDQ=",
      "title": "DoS from unbounded outstanding CERTIFICATE_REQUESTs",
      "url": "https://github.com/httpwg/http-extensions/issues/1089",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "The secondary certificates draft separates `CERTIFICATE_REQUEST` from `CERTIFICATE_NEEDED`. This seems needlessly complex and introduces a DoS on the receiver with client certificates.\r\n\r\nClients which prompt the user on client certificate decisions need a request binding before acting on a certificate request. Even without a prompt, cross-name pooling means that, without that request binding, the client doesn't even know which origin requested the certificate!\r\n\r\nHowever, secondary certificates splits the request and the binding into two separate frames. There are no rules preventing a server from queuing up unboundedly meany `CERTIFICATE_REQUEST` frames to be matched with `CERTIFICATE_NEEDED` later. This means the server can easily DoS such a client by sending unboundedly many `CERTIFICATE_REQUEST`s.\r\n\r\nWhy is there a split in the first place? If they are associated with a stream, this neatly bounds the certificate requests by the bound of open streams and also means that, if a stream is canceled, any outstanding certificate requests on that stream may be aborted.",
      "createdAt": "2020-03-03T20:48:04Z",
      "updatedAt": "2020-03-03T20:48:04Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1090,
      "id": "MDU6SXNzdWU1NzQ5MzI1Nzg=",
      "title": "Semantics of secondary client certificates are unclear",
      "url": "https://github.com/httpwg/http-extensions/issues/1090",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "The secondary certificates draft leaves the authentication state of exchanges like the following unclear:\r\n\r\n```\r\n   Client                                      Server\r\n      -- (stream 1) GET /a --------------->\r\n      <---------- (stream 0) CERTIFICATE_REQUEST --\r\n      <----- (stream 0) CERTIFICATE_NEEDED (S=1) --\r\n      -- (stream 0) CERTIFICATE A ------------------>\r\n      -- (stream 0) USE_CERTIFICATE (S=1) -------->\r\n      <----------------------- (stream 1) 200 OK --\r\n\r\n      -- (stream 3) GET /b --------------->\r\n      <----------------------- (stream 3) 200 OK --\r\n```\r\n\r\nIn stream 1, the client is unambiguously using certificate A in the request to `/a`. Is it also using it for `/b`? If the client believes the answer is no, while the server believes the answer is yes, secondary certificates introduces a [confused deputy problem](https://en.wikipedia.org/wiki/Confused_deputy_problem). Some examples to consider:\r\n\r\n* HTTP/2 cross-name pooling means one connection may service multiple origins. The client may choose to use a client certificate with some origins but not others.\r\n* The web platform makes both anonymous and credentialed requests (see CORS). Keeping those straight is critical to avoid CSRF attacks. For now, browsers do not pool them due to various problematic connection-level auth mechanisms in HTTP/1.1, but there is discussion on relaxing this for the vast majority of connections that don't use these. This puts a heavier dependency on protocols getting these kinds of details right.\r\n\r\nThis is especially important to make unambiguous because the original renegotiation-based hack for reactive client auth *did* rely on ambient authority. Once you renegotiated with a certificate, the unwritten interpretation was that all subsequent requests on this connection pick up the certificate. A server implementation may then be tempted to apply a similar logic to client certificates. The spec needs a MUST-level requirement not to do this, and make it clear that this is a server security vulnerability. Instead, client wishing to approximate the original renegotiation-based hack would send proactive `USE_CERTIFICATE` frames on subsequent credentialed requests.\r\n\r\nThis is especially important for HTTP/2, where there is both larger scope of pooling from cross-name bits and where multiplexing means we requests overlap temporally.",
      "createdAt": "2020-03-03T20:48:10Z",
      "updatedAt": "2020-05-14T19:21:58Z",
      "closedAt": "2020-05-14T19:21:58Z",
      "comments": []
    },
    {
      "number": 1092,
      "id": "MDU6SXNzdWU1NzQ5Mzg3MDY=",
      "title": "Scope of server USE_CERTIFICATE frames is unclear",
      "url": "https://github.com/httpwg/http-extensions/issues/1092",
      "state": "OPEN",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "All the examples of server `USE_CERTIFICATE` frames show them applying to stream 0, which I guess means they ambiently apply to the entire connection, but there isn't clear specification text describing this. The draft in general does not clearly specify the semantics and timing of a `USE_CERTIFICATE` frame, only alluding to problems in [security considerations](https://tools.ietf.org/html/draft-ietf-httpbis-http2-secondary-certs-05#section-6.5). (Incidentally, that section is missing an RFC6919 citation. ;-) )\r\n\r\nQuestions of server certificate scope need to further consider whether HTTP authentication is simply a property of the `Host` header and being willing to respond to the name, or whether the exact server certificate is relevant. In particular, it's unclear how this interacts with the [tls-server-end-point](https://tools.ietf.org/html/rfc5929#section-4) channel binding, especially if the draft does not try to bind server certificates to streams. (Note that, if you do decide to bind them, the binding needs to be set *before* the request is sent, which makes the timing is quite different from client certificates.)",
      "createdAt": "2020-03-03T20:58:12Z",
      "updatedAt": "2020-03-03T20:58:12Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1093,
      "id": "MDU6SXNzdWU1NzUwMzU2ODM=",
      "title": "CH editorial feedback",
      "url": "https://github.com/httpwg/http-extensions/issues/1093",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-hints",
        "editorial"
      ],
      "body": "Some of this is very nit-picky; feel free to do what you like with it...\r\n\r\n## 1. Introduction\r\n\r\n> Applications that want to allow the server to optimize content delivery and user experience based on such capabilities have, historically, had to rely on passive identification (e.g., by matching User-Agent (Section 5.5.3 of [RFC7231]) header field against an established database of client signatures), used HTTP cookies [RFC6265] and URL parameters, or use some combination of these and similar mechanisms to enable ad hoc content negotiation.\r\n\r\n^ There's something weird going on with tense in this sentence.\r\n\r\n> Such techniques are expensive to setup and maintain, are not portable across both applications and servers, and make it hard to reason for both client and server about which data is required and is in use during the negotiation:\r\n\r\n\"Such techniques are expensive... are not portable... and make it hard...\" The third doesn't fit with the first two.\r\n\r\n* \"Client Hints mitigate the performance concerns...\" probably just \"Client Hints mitigate performance concerns...\" Likewise for \"the privacy concerns\" below.\r\n\r\n* \"This document defines the Client Hints infrastructure, a framework that enables servers to opt-in to specific proactive content negotiation features, which will enable them to adapt their content accordingly.\" --> \"This document defines Client Hints, a framework that enables servers to opt-in to specific proactive content negotiation features, adapting their content accordingly.\"\r\n\r\n* `[UA-CH]` as a normative reference probably isn't going to fly, given its status. Why is it normative?\r\n\r\n## 2.1. Sending Client Hints\r\n\r\n> Clients control which Client Hints are sent in requests, based on their default settings, user configuration, and server preferences.\r\n\r\nmaybe instead:\r\n\r\n> Clients choose what Client Hints to send in a request based on their default settings, user configuration, and server preferences expressed in `Accept-CH`.\r\n\r\n## 2.2. Server Processing of Client Hints\r\n\r\n> When doing so, and if the resource is cacheable, the server MUST also generate a Vary response header field (Section 7.1.4 of [RFC7231]) to indicate which hints can affect the selected response and whether the selected response is appropriate for a later request.\r\n\r\nBe aware that HTTP doesn't _require_ presence of `Vary` when proactive conneg is in use; if the response is truly uncacheable, it isn't necessary.\r\n\r\n> Further, depending on the hint used, the server can generate additional response header fields to convey related values to aid client processing.\r\n\r\nmaybe instead:\r\n\r\n> Furthermore, the server can generate additional response header fields (as specified by the hint or hints in use) that convey related values to aid client processing.\r\n\r\n## 3.1. The Accept-CH Response Header Field\r\n\r\n> The Accept-CH response header field or the equivalent HTML meta element with http-equiv attribute (Section 4.2.5.3 of [HTML]) indicate server support for particular hints indicated in its value.\r\n\r\ninstead:\r\n\r\n> The Accept-CH response header field indicates server support for the hints indicated in its value. This information can also be conveyed by the HTML meta element with the http-equip attribute (Section 4.2.5.3 of [HTML]).\r\n\r\nBTW, nothing is said about precedence between the two different mechanisms; separate issue?\r\n\r\n> When a client receives an HTTP response advertising support for provided list of Clients Hints, it SHOULD process it as origin ([RFC6454]) opt-in to receive Client Hint header fields advertised in the field-value, for subsequent same-origin requests.\r\n\r\nThe reference to 6454 is spurious, and it's pretty indirect. Perhaps:\r\n\r\n> When a client receives an HTTP response containing Accept-CH, it indicates that the origin wishes to receive the indicated request header fields for subsequent same-origin requests.\r\n\r\n~~~\r\n* The opt-in MUST be delivered over a secure transport.\r\n* The opt-in SHOULD be persisted and bound to the origin to enable delivery\r\n   of Client Hints on subsequent requests to the server\u2019s origin, and MUST NOT\r\n  be persisted for an origin that isn\u2019t HTTPS.\r\n~~~\r\n\r\nIt's kind of weird to have this list just appear. Perhaps turn these into prose?\r\n\r\n> For example, based on the Accept-CH example above,\r\n\r\nPut \"For example\" above the example to introduce it.\r\n\r\n## 3.2. Interaction with Caches\r\n\r\n> When selecting an optimized response based on...\r\n\r\nLimits CH to just \"optimisation.\" Probably should just be:\r\n\r\n> When selecting a response based on...\r\n\r\n",
      "createdAt": "2020-03-03T23:55:46Z",
      "updatedAt": "2020-03-05T06:43:17Z",
      "closedAt": "2020-03-05T06:43:17Z",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for reviewing! :) PR underway\r\n\r\n> Be aware that HTTP doesn't _require_ presence of `Vary` when proactive conneg is in use; if the response is truly uncacheable, it isn't necessary.\r\n\r\nThe `MUST` here is conditional on cacheability. Is that OK? \r\n\r\n \r\n\r\n> > This information can also be conveyed by the HTML meta element with the http-equip attribute (Section 4.2.5.3 of [HTML]).\r\n> \r\n> BTW, nothing is said about precedence between the two different mechanisms; separate issue?\r\n\r\nWe're now considering removing http-equiv support for this: https://github.com/WICG/client-hints-infrastructure/issues/21\r\n\r\nMaybe it's best to simply remove that reference here?",
          "createdAt": "2020-03-04T13:20:53Z",
          "updatedAt": "2020-03-04T13:20:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "> The MUST here is conditional on cacheability. Is that OK?\r\n\r\nAh, I missed that, sorry.\r\n\r\nWRT http-equiv; that might be best, then.",
          "createdAt": "2020-03-04T21:21:54Z",
          "updatedAt": "2020-03-04T21:21:54Z"
        }
      ]
    },
    {
      "number": 1096,
      "id": "MDU6SXNzdWU1NzUzNDUzMTY=",
      "title": "Multiple PRIORITY_UPDATE frame types instead of internal bitfield ",
      "url": "https://github.com/httpwg/http-extensions/issues/1096",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "This issue channels the original issue, https://github.com/kazuho/draft-kazuho-httpbis-priority/issues/120, opened by @ianswett but reflects the final state of discussion.\r\n\r\nThe PRIORITY_UPDATE frame is inspired by the HTTP/3 PRIORITY frame (RIP) and it reserves a byte to act as a bit-field that indicates the target of signal: a request or a push. The frame layout spends a byte for a single bit and is also inconsistent with the layout of other HTTP/3 frames, which makes things mildly more difficult for implementations.\r\n\r\nIan suggested we use different frame type codepoints to signal the target of the PRIORITY_UPDATE frame. There is already precendence for this and Kazuho noted that \r\n\r\n> In IETF 106, we had a similar discussion IIRC with regard to the QUIC datagram extension, and the WG seemed to favor allowing extensions to reserve a couple of adjacent frame types instead of using bits in the payload. Based on that, I am incliend to changing our design to use two frame types values.\r\n\r\nThe use of a frame for the initial priority is dependent on other issues such as the headers vs frame debate. If we needed a frame for that purpose, we probably want three frame types and the earliest code point with 3 spaces is 0xF, thus:\r\n\r\n* Initial Priority - 0xF - one and only one sent on request stream, contains priority-value\r\n*  Priority Update - 0x10 - reprioritize request stream, sent on control stream, contains ID and priority-value\r\n*    Priority Update - 0x11 - reprioritize push stream, sent on control stream, contains ID and priority-value\r\n\r\nIn order to make progress independent of the discussion on initial priority frame, we could shift the PRIORITY_UPDATE frame codepoint from 0xF to 0x10, but reserve 0xF for now.",
      "createdAt": "2020-03-04T11:58:42Z",
      "updatedAt": "2020-09-09T21:14:16Z",
      "closedAt": "2020-09-09T21:14:16Z",
      "comments": []
    },
    {
      "number": 1099,
      "id": "MDU6SXNzdWU1NzU0NzI3MjE=",
      "title": "Client normative text seems poorly placed",
      "url": "https://github.com/httpwg/http-extensions/issues/1099",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "In the Security Considerations, section 7.1.3 discusses fairness and it says:\r\n\r\n```\r\nAlso, a client MAY use the priority values for making local scheduling choices for the requests it initiates.\r\n```\r\nThis seems to be misplaced and easily overlooked. We might want to consider if this text belongs elsewhere, and if it does relate to fairness then add a cross-reference.\r\n",
      "createdAt": "2020-03-04T14:58:27Z",
      "updatedAt": "2020-07-13T01:07:56Z",
      "closedAt": "2020-07-13T01:07:55Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Damn, #1218 was actually a dupe of this. Ah well, it was fixed there so closing the OP.",
          "createdAt": "2020-07-13T01:07:55Z",
          "updatedAt": "2020-07-13T01:07:55Z"
        }
      ]
    },
    {
      "number": 1102,
      "id": "MDU6SXNzdWU1NzU4NjY2NDY=",
      "title": "Bumping up decimal precision?",
      "url": "https://github.com/httpwg/http-extensions/issues/1102",
      "state": "CLOSED",
      "author": "eeeps",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "I've been working on [integrating the Content-DPR header into HTML](https://github.com/whatwg/html/pull/5112). One of the [use cases](https://github.com/eeeps/content-dpr-explainer) is for downscaled \"placeholder\" images that have the same intrinsic size as the full-res image.\r\n\r\nHowever, Content-DPR is spec'd as being either an sh-decimal or sh-integer, and the rounding errors that fall out of sh-decimal's definition (at most 3 fractional digits) end up causing intrinsic size differences > 1px, leading to noticeable visual jumps.\r\n\r\nSee a rough demo here: https://observablehq.com/@eeeps/content-dpr-placeholders-and-rounding-errors (Chrome-only, as that's the only browser that currently supports the header)\r\n\r\nI'm sure this isn't the only use case that could benefit from a digit or two more on the right side of the dot. I'm also sure that this has been discussed, perhaps at length. So:\r\n\r\n1. Is there anything that can be done from a structured-headers-spec perspective?\r\n2. If not, is my best option to move to define Content-DPR as a string, with custom decimal parsing, instead?",
      "createdAt": "2020-03-04T23:14:13Z",
      "updatedAt": "2020-03-09T22:13:41Z",
      "closedAt": "2020-03-09T22:13:41Z",
      "comments": [
        {
          "author": "eeeps",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One more thought on this... even with perfect precision, the intrinsic size of the placeholder will almost always be off in one dimension or the other; the server must choose when setting Content-DPR. I suppose to eliminate layout jumps you'd usually want to lock in the exact height. Hm.\r\n\r\nMore precision would still be nice!",
          "createdAt": "2020-03-05T01:02:25Z",
          "updatedAt": "2020-03-05T01:02:25Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It looks like we need to give you at least two more digits of precision for that use case -- probably three, for future-proofing. \r\n\r\nWhen we discussed the precision before, the sentiment seemed to be that cases that needed more precise values could use two integers; e.g.,\r\n\r\n> Content-DPR: int=1, frac=4432\r\n\r\nWould that work for you? I know it's not pretty. If you used a string, you'd have to define your own parser, and we're trying to get folks out of that business.\r\n\r\nOtherwise, we could discuss moving some digits from the integer to the fractional component; I think it's a reasonable argument that folks who need very large values probably don't want Decimal, so maybe we could do 10.5 or 9.6 rather than 12.3.\r\n\r\nIt's pretty late in the day, though; Working Group Last Call has already closed. Not that that's an argument against a change on its own; we just don't want to be polishing this thing in perpetuity... \r\n\r\n@martinthomson @phluid61 @clelland @bsdphk thoughts?",
          "createdAt": "2020-03-05T01:21:07Z",
          "updatedAt": "2020-03-05T01:21:07Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have to ask why DPR is the weapon of choice here and not \"I want an image of the following dimensions\".  I saw the demo, and the round errors are clear, but the demo works fine if you pin down the width and that is already an accepted best practice.\r\n\r\nThat said, it seems possible that a fractional DPR could occur (2:3 ratios perhaps), which leads to some amount of error.  But in the end, that error will exist unless we effectively allow arbitrary precision.  So I'm of the view that we leave as-is and accept that some cases that need some sophistication will have to find ways to cope.  I don't think DPR makes that grade (though the change in height is definitely awkward.",
          "createdAt": "2020-03-05T03:52:43Z",
          "updatedAt": "2020-03-05T03:52:43Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson - the scenarios where `Content-DPR` is currently needed are ones where the markup is outside the control of the image optimization service.\r\n\r\nA replacement to DPR that would do what you're suggesting while tackling those use cases would be e.g. `Width` and `Height` response headers. ",
          "createdAt": "2020-03-05T08:14:18Z",
          "updatedAt": "2020-03-05T08:14:18Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The only applications I can think of for large numbers with extra decimal digits are high-precision timestamps for performance reporting, but those are often represented in two components anyway (epoch time in seconds + explicit micro/nanosecond offset), so we could probably borrow a digit or two for this.\r\n\r\nEchoing @martinthomson, though, I'm not sure that even four or five digits would be enough to avoid all rounding errors, once you multiply by the arbitrarily large image or screen dimensions. If the underlying data is specifically a ratio, would expressing it as such be possible? A token like `2:3` or `1:40` is an exact representation of the real ratio. Or even `Content-DPR: w=2,h=3`, though a bit more verbose, doesn't require any custom parsing.",
          "createdAt": "2020-03-05T13:03:31Z",
          "updatedAt": "2020-03-05T13:03:31Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK, so it sounds like there isn't much interest in adding digits for this particular use case, and I suspect that can be generalise; other use cases that need more precision can quickly fall into a trap where whatever value we choose _isn't enough_, so we should \"encourage\" them to choose alternative representations of the value that avoid such problems.\r\n\r\nI think we should close this with no action, any further thoughts?",
          "createdAt": "2020-03-05T22:54:44Z",
          "updatedAt": "2020-03-05T22:54:44Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "The more I think about decimals, the more I convince myself they cause more harm than good.  They're a convenient hammer, if you want to approximate every solution with a nail. And they're so easy to accidentally break (`<?php header('Content-DPR: ' . $x/$y);` leads to occasional silent failure) ",
          "createdAt": "2020-03-06T23:07:48Z",
          "updatedAt": "2020-03-06T23:07:48Z"
        }
      ]
    },
    {
      "number": 1103,
      "id": "MDU6SXNzdWU1NzU4OTY2MzU=",
      "title": "Digest editorial reordering",
      "url": "https://github.com/httpwg/http-extensions/issues/1103",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n@LPardue WDYT about this roadmap? I'd address each one in a separate PR.\r\nIf you agree, I can cherry-pick the first ones from your PR so you won't have to do it twice :)\r\n\r\nDigest Headers to be reordered:\r\n\r\n- [x] move the \"deprecated algorithms\" security consideration directly in {{digest-agorithms}} #1109\r\n- [x] merge the {{digest-algorithm-encoding-examples}} in its parent section {{representation-digest}} #1110\r\n- [x] move Digest Header and Want-Digest header outside Header Field Specifications #1111 #1116\r\n- [x] move {{representation-digest}} under {{digest-header}} #1117\r\n- [x] move {{digest-algorithms}} down #1112\r\n- [x] move {{resource-representation}} examples to Annex B #1122 \r\n- [x] ensure people start reading from  {{representation-digest}} #1123 \r\n- [x] refactor Digest to be more direct #1124 \r\n\r\nOptional:\r\n\r\n- [ ] integrate examples from #1091 into {{resource representation}}\r\n",
      "createdAt": "2020-03-05T00:01:41Z",
      "updatedAt": "2020-03-08T20:02:25Z",
      "closedAt": "2020-03-08T19:55:13Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That sounds like a good plan, thanks. Please action it and I'll review promptly.\r\n\r\nThis is a set of editorial changes that I think would add value to the specification readability. My jumbo PR (#1091) had some problems, so lets focus on landing the easy-to-agree items and not try to rush everything through before the submission deadline if we are uncomfortable. We can continue working on the thornier editorials even after the submission deadline. ",
          "createdAt": "2020-03-05T18:50:31Z",
          "updatedAt": "2020-03-05T18:50:31Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here's a first bunch of PRs. PTAL :) thanks for all the support!",
          "createdAt": "2020-03-05T21:41:42Z",
          "updatedAt": "2020-03-05T21:41:42Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue I'm trying to refactor and I have this proposal:\r\n\r\nhttps://httpwg.org/http-extensions/ioggstream-1103-test/draft-ietf-httpbis-digest-headers.html\r\n\r\nwe need rewording but just look at the sections ordering and let me know.\r\n\r\nThe next PR to merge is #1122 ",
          "createdAt": "2020-03-06T16:17:52Z",
          "updatedAt": "2020-03-06T18:11:57Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This section outline looks good. I approved, #1122 so let's merge it. What's next?",
          "createdAt": "2020-03-06T19:37:13Z",
          "updatedAt": "2020-03-06T19:37:29Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This section outline looks good. I approved, #1122 so let's merge it. What's next?\r\n\r\nNow we have #1123 and #1124 which should end the refactoring.\r\nI think that's a reasonable cutout for IETF107 but we are clearly not over :) ",
          "createdAt": "2020-03-07T15:36:04Z",
          "updatedAt": "2020-03-07T15:38:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "All the PRs look good, even the optional one. Thanks for your work on this.\r\n\r\nLet's get them merged, then take a once-over review to catch any basic errors that might have crept in. Then one of us can cut the release.",
          "createdAt": "2020-03-08T18:36:38Z",
          "updatedAt": "2020-03-08T18:36:38Z"
        }
      ]
    },
    {
      "number": 1119,
      "id": "MDU6SXNzdWU1NzY5NDQ3MDE=",
      "title": "rfc6265bis: definition of OWS differs from HTTP core specs",
      "url": "https://github.com/httpwg/http-extensions/issues/1119",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "Optimally, they'd be the same.\r\n\r\nOtherwise, renaming might be a good idea in order to avoid confusion.",
      "createdAt": "2020-03-06T13:50:59Z",
      "updatedAt": "2020-04-07T11:39:00Z",
      "closedAt": "2020-04-07T11:39:00Z",
      "comments": []
    },
    {
      "number": 1129,
      "id": "MDU6SXNzdWU1NzgyOTM3ODU=",
      "title": "Specify a default extension model",
      "url": "https://github.com/httpwg/http-extensions/issues/1129",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "JSON ultimately acquired a *de-facto* model for extensions that effectively boils down to \"ignore object fields you don't understand\".  It looks a little like SH aims for some of the same approach, but maybe we can be more assertive about it.\r\n\r\nRight now, the spec says \"you should probably allow unknown things\" in a couple of ways.  There is pretty strong encouragement regarding parameters in particular (#1128 does similar things for dictionaries).\r\n\r\nBut this could be the default mode rather than a suggestion.  That is, you say that *unless explicitly stated to the contrary* values in dictionaries and parameters for keys that are not specified MUST be ignored.\r\n\r\nI think that is how people will build this in many cases, so it's not a stretch.  It might just take a little finesse to get the text right.",
      "createdAt": "2020-03-10T02:20:16Z",
      "updatedAt": "2020-03-11T05:29:52Z",
      "closedAt": "2020-03-11T05:29:52Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Is it reasonable for this spec to impose a constraint like that? Like, SH doesn't care one way or another what the _values_ of dictionary keys are, only that they de/serialise consistently.",
          "createdAt": "2020-03-10T03:38:03Z",
          "updatedAt": "2020-03-10T03:38:03Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, having read #1128 I see what you're getting at. Sort of RFC 6919 levels of assertiveness. That's reasonable; if you want to apply it to parameters as well can't you just twiddle that proposal?",
          "createdAt": "2020-03-10T03:46:47Z",
          "updatedAt": "2020-03-10T03:46:47Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would prefer to discuss first :) and then probably run with a follow-up.",
          "createdAt": "2020-03-10T04:24:10Z",
          "updatedAt": "2020-03-10T04:24:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It's worded like it is now because that's a constraint on the software that's consuming / producing the header for a specific purpose -- NOT a SH implementation (i.e., an implementer of this spec).\r\n\r\nGeneric SH software *can't* make such decisions, since it doesn't have knowledge of the domain-specific requirements. I don't think we can put 2119-style requirements on other specs like that (even if we can encourage certain patterns of use, which got us here).",
          "createdAt": "2020-03-11T04:25:23Z",
          "updatedAt": "2020-03-11T04:25:23Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, after looking at this more, I don't think that this is feasible.  For the reasons @mnot cited, but also from the perspecting of finding the right words.  After all, it ends up in 6919-land pretty fast.",
          "createdAt": "2020-03-11T05:29:47Z",
          "updatedAt": "2020-03-11T05:29:47Z"
        }
      ]
    },
    {
      "number": 1133,
      "id": "MDU6SXNzdWU1NzkwOTU3MjE=",
      "title": "client-hints: section structure borked",
      "url": "https://github.com/httpwg/http-extensions/issues/1133",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Apparently the removal of one appendix now has moved all remaining appendics into the main section. They need to be moved back.",
      "createdAt": "2020-03-11T08:42:18Z",
      "updatedAt": "2020-03-11T08:58:37Z",
      "closedAt": "2020-03-11T08:58:37Z",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed by #1134 ",
          "createdAt": "2020-03-11T08:58:37Z",
          "updatedAt": "2020-03-11T08:58:37Z"
        }
      ]
    },
    {
      "number": 1136,
      "id": "MDU6SXNzdWU1NzkyMDM2MzM=",
      "title": "rfc6265bis UA requirements and WPT mismatch",
      "url": "https://github.com/httpwg/http-extensions/issues/1136",
      "state": "OPEN",
      "author": "essen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "I have implemented most of rfc6265bis from scratch for an HTTP client library, using the algorithms described in Section 5. I have found a few cases in WPT's `http-state` suite that do not pass and seem to go against the current editor draft of rfc6265bis (or vice versa). I figured this would be useful to share:\r\n\r\n* [ ] attribute0023: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/attribute0023-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/attribute0023-expected) _The current spec takes the last path while the test expects the first path to be used?_\r\n* [x] chromium0009: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/chromium0009-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/chromium0009-expected) _The current spec accepts this with the cookie name being empty._\r\n* [x] chromium0010: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/chromium0010-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/chromium0010-expected) _The current spec accepts this with the cookie name being empty._\r\n* [x] chromium0012: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/chromium0012-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/chromium0012-expected) _The current spec accepts this with the cookie name being empty._\r\n* [ ] disabled-chromium0020: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/disabled-chromium0020-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/disabled-chromium0020-expected) _The current spec accepts this with the cookie name being empty. Maybe this is a test of Chromium's limit on cookie names, but the current spec doesn't parse it as a name._\r\n* [ ] disabled-chromium0022: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/disabled-chromium0022-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/disabled-chromium0022-expected) _I'm not sure what should be expected to be honest._\r\n* [x] mozilla0012: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/mozilla0012-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/mozilla0012-expected) _I expect the second Set-Cookie to also be sent back to the server, with an empty name._\r\n* [x] mozilla0014: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/mozilla0014-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/mozilla0014-expected) _The current spec accepts this with the cookie name being empty._\r\n* [x] mozilla0015: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/mozilla0015-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/mozilla0015-expected) _The current spec accepts this with the cookie names being empty._\r\n* [x] mozilla0016: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/mozilla0016-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/mozilla0016-expected) _The current spec accepts this with the cookie names being empty._\r\n* [x] mozilla0017: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/mozilla0017-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/mozilla0017-expected) _The current spec accepts this with the cookie names being empty, except for the last Set-Cookie which has a name provided._\r\n* [x] name0017: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/name0017-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/name0017-expected) _The current spec accepts this with the cookie name being empty and the value everything after the first =._\r\n* [x] name0023: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/name0023-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/name0023-expected) _The current spec accepts this with the cookie name being empty._\r\n* [x] name0025: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/name0025-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/name0025-expected) _The current spec accepts this with the cookie name being empty and the value everything after the first =._\r\n* [x] name0028: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/name0028-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/name0028-expected) _The current spec accepts this with the cookie name being empty and the value everything after the first =._\r\n* [x] name0031: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/name0031-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/name0031-expected) ~~The current spec accepts this with the cookie name being `\"foo;bar\"` and the value everything after the first =.~~\r\n* [x] name0032: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/name0032-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/name0032-expected) ~~The current spec accepts this with the cookie name being `\"foo\\\"bar;baz\"` and the value everything after the first =.~~\r\n* [x] name0033: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/name0033-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/name0033-expected) _The current spec accepts this with the first cookie name being empty and the value everything after the first =, and the second cookie name being empty and the value being `aaa`._\r\n* [ ] optional-domain0042: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/optional-domain0042-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/optional-domain0042-expected) _The current spec takes the last domain while the test expects the first domain to be used?_\r\n\r\nHope it's useful.\r\n\r\nEverything else works, although note that I have not implemented SameSite checks at this point so I cannot comment on those.",
      "createdAt": "2020-03-11T11:43:40Z",
      "updatedAt": "2020-10-13T09:08:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Thanks for this. That WPT directory is a straight port from the original test repository at https://github.com/abarth/http-state, and I still need to do a pass through them to sanity check them against the spec (and vice-versa). I appreciate you going through the tests and spec, and I'll try to honor that work by investing some time in cleaning up the repository this week.",
          "createdAt": "2020-03-31T08:44:54Z",
          "updatedAt": "2020-03-31T08:44:54Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "A few of these seem easy:\r\n\r\n* The change in https://github.com/httpwg/http-extensions/issues/159 is responsible for:\r\n  * chromium0009\r\n  * chromium0010\r\n  * chromium0012\r\n  * mozilla0012\r\n  * mozilla0014\r\n  * mozilla0015\r\n  * mozilla0016\r\n  * mozilla0017\r\n  * name0017\r\n  * name0023\r\n  * name0025\r\n  * name0033\r\n\r\n  Addressing these in https://github.com/web-platform-tests/wpt/pull/22560 (https://chromium-review.googlesource.com/c/chromium/src/+/2129528).\r\n\r\n* After the change above, name0031 and name0032 show Chrome and Firefox aligned on treating `\"foo;bar\"=baz` as a nameless cookie with a value of `\"foo`, and `\"foo\\\"bar;baz\"=qux` as a nameless cookie with a value of `\"foo\\\"bar`. That is, they both stop parsing the name/value pair when they hit a `;`. This seems aligned with step 1 of https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-05#section-5.3, which defines the `name-value-pair` as everything up to but not including the first `;`.\r\n\r\n  Addressing these in https://github.com/web-platform-tests/wpt/pull/22559 (https://chromium-review.googlesource.com/c/chromium/src/+/2128135).\r\n\r\nI'll look at the remainder after lunch.",
          "createdAt": "2020-03-31T10:44:38Z",
          "updatedAt": "2020-03-31T12:12:55Z"
        },
        {
          "author": "essen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "About `name0031` and `name0032` you are of course right, my analysis above was incorrect. My implementation does the same as Chromium/Firefox and the draft.",
          "createdAt": "2020-03-31T11:49:49Z",
          "updatedAt": "2020-03-31T11:49:49Z"
        },
        {
          "author": "essen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For `name0017` the updated test shows an unfortunate effect of the parsing algorithms, where the server may send a cookie without a name and a value containing equal signs, and then when it parses the cookie header it gets a cookie with name `a` and the value after the equal sign. `name0025` is a similar scenario.\r\n\r\nMaybe this issue with empty names and equal signs in the value should be mentioned specifically in the Implementation Considerations section?\r\n\r\nEdit: I've updated the description to better show which tests have been fixed in WPT, at the time of writing this comment.",
          "createdAt": "2020-04-20T11:03:24Z",
          "updatedAt": "2020-04-20T11:16:34Z"
        },
        {
          "author": "miketaylr",
          "authorAssociation": "NONE",
          "body": "@essen @mikewest - I had a look at the remaining tests with open questions (I'm assuming that the tests with checkmarks from the OP are no longer problematic). It seems like of the 4, `disabled-chromium0022` is the most confusing and could possibly use some spec language tweaks.\r\n\r\n> * [ ]  attribute0023: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/attribute0023-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/attribute0023-expected) _The current spec takes the last path while the test expects the first path to be used?_\r\n> *\r\n\r\nThis test seems like it was just incorrect -- it was fixed downstream by Ehsan in https://bugzilla.mozilla.org/show_bug.cgi?id=1549389.\r\n\r\n----------\r\n\r\n> * [ ]  disabled-chromium0020: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/disabled-chromium0020-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/disabled-chromium0020-expected) _The current spec accepts this with the cookie name being empty. Maybe this is a test of Chromium's limit on cookie names, but the current spec doesn't parse it as a name._\r\n> *\r\n\r\nSo this test has 4097 `a`s. [Section 6.1](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-06#section-6.1) mentions a limit of 4096 bytes (\"as measured by the sum of the length of the cookie's name, value, and attributes\")\r\n\r\nChromium: https://source.chromium.org/chromium/chromium/src/+/master:net/cookies/parsed_cookie.h;l=25?q=4096%20cookie&ss=chromium\r\nGecko: https://searchfox.org/mozilla-central/source/netwerk/cookie/CookieCommons.h#58\r\n(I'm not aware of a nice code-search tool for WebKit, but it passes the test, so presumably it does the same thing).\r\n\r\nThis test is fine, it's just *kinda* confusing to figure out what's happening at a glance.\r\n\r\n-----------\r\n> * [ ]  disabled-chromium0022: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/disabled-chromium0022-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/disabled-chromium0022-expected) _I'm not sure what should be expected to be honest._\r\n> *\r\n\r\nBlink and WebKit agree here, and Gecko fails this test. Looking at the extended commit message in https://github.com/web-platform-tests/wpt/commit/89637ce97bb8073a2db5182fc100125acba01481 (which added this test), that links to https://github.com/whatwg/xhr/issues/165, which likely explains why Gecko fails this test -- it doesn't (yet?) reject null bytes in the header. But... the test case shows that Chrome and Safari are just ignoring the content after `\\n`, while Firefox is parsing as `\"AAA=BB; ZYX\"`. AFAICT, this test doesn't even have `\\0` (NULL) in it, but `\\n`. \ud83e\udd14 \r\n\r\nAnd https://github.com/whatwg/xhr/issues/165#issuecomment-337805050 suggests that LF can be legal (in `obs-fold`) as a value. \r\n\r\nAlso, `cookie-octet` contains `US-ASCII characters excluding CTLs`, and `CTL` is defined as `%x00-1F / %x7F`. A reasonable way to read that is to expect a parser to stop consuming US-ASCII once it hit `CTL` (at least that's how I interpreted it).\r\n\r\nI see in https://source.chromium.org/chromium/chromium/src/+/master:net/cookies/parsed_cookie.cc;l=362-372;drc=1f5bcd95363404f6c80dcf24730feb78cb4b1187?q=FindFirstTerminator&ss=chromium - that's pretty much what Chromium does.\r\n\r\nBut in Step 1 of https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-06#section-5.3, in the Otherwise clause (which is where this test ends up because it lacks `\";\"`), it says:\r\n\r\n> 1.  The name-value-pair string consists of all the characters\r\n           contained in the set-cookie-string, and the unparsed-\r\n           attributes is the empty string.\r\n\r\nMaybe that language could use some tightening to make it more explicit? \r\n\r\n\r\n-----\r\n\r\n> * optional-domain0042: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/optional-domain0042-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/optional-domain0042-expected) _The current spec takes the last domain while the test expects the first domain to be used?_\r\n\r\nCurrently the test looks like `Set-Cookie: foo=bar; domain=foo.example.org; domain=` -- so this seems like expected behavior?\r\n",
          "createdAt": "2020-10-12T20:01:59Z",
          "updatedAt": "2020-10-12T20:01:59Z"
        },
        {
          "author": "essen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > * [ ]   attribute0023: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/attribute0023-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/attribute0023-expected) _The current spec takes the last path while the test expects the first path to be used?_\r\n> \r\n> This test seems like it was just incorrect -- it was fixed downstream by Ehsan in https://bugzilla.mozilla.org/show_bug.cgi?id=1549389.\r\n\r\nRight but I had this fix when I tested. I may be confused as to why it's not supposed to set or return the cookie, what the test paths are supposed to be, or just because I'm not familiar enough with Javascript. Could you clarify whether the cookie should be set or not, and explain what goes on in that particular test case?\r\n\r\nFrom my reading of the spec, the set-cookie will lead to the second Path attribute to be accepted, and later on when doing a Path-Match it will use `/` (because there is only one slash) which matches and therefore send the cookie.\r\n\r\n> > * [ ]   disabled-chromium0020: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/disabled-chromium0020-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/disabled-chromium0020-expected) _The current spec accepts this with the cookie name being empty. Maybe this is a test of Chromium's limit on cookie names, but the current spec doesn't parse it as a name._\r\n> \r\n> So this test has 4097 `a`s. [Section 6.1](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-06#section-6.1) mentions a limit of 4096 bytes (\"as measured by the sum of the length of the cookie's name, value, and attributes\")\r\n\r\nOK so failure depends on configuration. Thanks for figuring it out!\r\n\r\n> > * [ ]   disabled-chromium0022: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/disabled-chromium0022-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/disabled-chromium0022-expected) _I'm not sure what should be expected to be honest._\r\n> \r\n> Blink and WebKit agree here, and Gecko fails this test. Looking at the extended commit message in [web-platform-tests/wpt@89637ce](https://github.com/web-platform-tests/wpt/commit/89637ce97bb8073a2db5182fc100125acba01481) (which added this test), that links to [whatwg/xhr#165](https://github.com/whatwg/xhr/issues/165), which likely explains why Gecko fails this test -- it doesn't (yet?) reject null bytes in the header. But... the test case shows that Chrome and Safari are just ignoring the content after `\\n`, while Firefox is parsing as `\"AAA=BB; ZYX\"`. AFAICT, this test doesn't even have `\\0` (NULL) in it, but `\\n`. \r\n> \r\n> And [whatwg/xhr#165 (comment)](https://github.com/whatwg/xhr/issues/165#issuecomment-337805050) suggests that LF can be legal (in `obs-fold`) as a value.\r\n\r\n`obs-fold` is `CRLF 1*( SP / HTAB )` so that's probably not it.\r\n\r\nI think it might just be a second header that doesn't have a colon or value. I don't think this belongs in a cookie test suite.\r\n\r\n> > * optional-domain0042: [Test](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/optional-domain0042-test) [Expected](https://github.com/web-platform-tests/wpt/blob/master/cookies/http-state/resources/test-files/optional-domain0042-expected) _The current spec takes the last domain while the test expects the first domain to be used?_\r\n> \r\n> Currently the test looks like `Set-Cookie: foo=bar; domain=foo.example.org; domain=` -- so this seems like expected behavior?\r\n\r\nOK then it takes the last Domain attribute and I think we fall under this rule:\r\n\r\n`If the attribute-value is empty, the behavior is undefined. However, the user agent SHOULD ignore the cookie-av entirely.`\r\n\r\nhttps://httpwg.org/http-extensions/draft-ietf-httpbis-rfc6265bis.html#name-the-domain-attribute-2\r\n\r\nAnd in this case this would be my code that doesn't respect this rule. It currently treats missing Domain and empty Domain the same.\r\n\r\nThanks for the help!",
          "createdAt": "2020-10-13T09:08:48Z",
          "updatedAt": "2020-10-13T09:08:48Z"
        }
      ]
    },
    {
      "number": 1137,
      "id": "MDU6SXNzdWU1Nzk2MTIzNjY=",
      "title": "Digest is a message field in the new parlance",
      "url": "https://github.com/httpwg/http-extensions/issues/1137",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "The phrase \"header field\" is no longer the accepted form.  The generic form is \"message field\".\r\n\r\nThis matters more for Digest, which is a good candidate for a trailer.",
      "createdAt": "2020-03-12T00:04:53Z",
      "updatedAt": "2020-03-17T13:59:59Z",
      "closedAt": "2020-03-17T13:59:59Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Just \"field\" actually.",
          "createdAt": "2020-03-12T00:10:29Z",
          "updatedAt": "2020-03-12T00:10:29Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm sorry, I have no idea how to resolve this. Looking at core semantics I still see many instances of header field, so I don't think the solution is a global replace. Are there correct examples I can use to base a PR on?",
          "createdAt": "2020-03-12T01:19:27Z",
          "updatedAt": "2020-03-12T01:19:27Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "If it's purposefully designed to only be used in a header section, \"header field\" is fine. If it might appear in trailers, use \"field\" or \"header or trailer field\" as appropriate.",
          "createdAt": "2020-03-12T01:25:09Z",
          "updatedAt": "2020-03-12T01:25:09Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ok, does this require a change to the document title?",
          "createdAt": "2020-03-12T01:25:38Z",
          "updatedAt": "2020-03-12T01:25:38Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I recommend \"The HTTP Digest Field\"",
          "createdAt": "2020-03-12T01:31:14Z",
          "updatedAt": "2020-03-12T01:31:14Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Or \"HTTP Digests\"",
          "createdAt": "2020-03-12T01:31:27Z",
          "updatedAt": "2020-03-12T01:31:27Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "and as an aide memior, it seems we'll need to change registration details to overwrite the \"digest\" defintion that will get migrated to the new table https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#rfc.section.12.4",
          "createdAt": "2020-03-12T01:37:17Z",
          "updatedAt": "2020-03-12T01:37:17Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I recommend \"The HTTP Digest Field\"\r\n\r\nSounds reasonable.",
          "createdAt": "2020-03-13T14:06:42Z",
          "updatedAt": "2020-03-13T14:06:42Z"
        }
      ]
    },
    {
      "number": 1138,
      "id": "MDU6SXNzdWU1Nzk2MTcwNDE=",
      "title": "sum and cksum aren't cryptographic either",
      "url": "https://github.com/httpwg/http-extensions/issues/1138",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [
        "digest-headers"
      ],
      "body": "Section 11.2 rightly acknowledges that MD5 and SHA-1 don't provide certain properties.  But `sum` and `cksum` provide even weaker guarantees.  It might pay to reframe this to say that the Digest field is can provide cryptographic properties, but only if an algorithm with the desired properties is used.  I would be very happy to see MD5 in the same bucket as `sum`.",
      "createdAt": "2020-03-12T00:19:57Z",
      "updatedAt": "2020-08-26T13:04:45Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds fair, let's see if we can make a PR that captures your phrasing.",
          "createdAt": "2020-03-12T01:02:42Z",
          "updatedAt": "2020-03-12T01:02:42Z"
        }
      ]
    },
    {
      "number": 1139,
      "id": "MDU6SXNzdWU1Nzk2MjA4MTk=",
      "title": "If ADLER32 isn't good enough, why is sum OK?",
      "url": "https://github.com/httpwg/http-extensions/issues/1139",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [
        "digest-headers"
      ],
      "body": "Section 11.3 says that ADLER32 was removed because it fails to detect certain errors.  I realize that `cksum` might be better as it uses the well-regarded CRC32 (or is that CRC32c? I didn't check; the original CRC32 had weaknesses of its own...).  But the 16-bit `sum` is clearly woefully inadequate for anything other than a sanity check.\r\n\r\nI'm not going to say that anything other than a good cryptographic algorithm is acceptable here, but I want to understand the rationale for inclusion.  Making `sum` obsolete would be an improvement; we almost get better guarantees from the TCP checksum.  I tend to think that `cksum` obsolete would also be a good choice.  Right now, both are 'standard'.",
      "createdAt": "2020-03-12T00:33:17Z",
      "updatedAt": "2020-08-26T13:04:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the status quo is a side-effect of the discussion about ADLER32 in https://github.com/httpwg/http-extensions/issues/828. In particular, https://github.com/httpwg/http-extensions/issues/828#issuecomment-517095275\r\n\r\n> ADLER32 and CRC32c are well-defined, standardised, algorithms. But there is no spec specifically registering them for use in the HTTP Digest header. My judgement at the time (as the designated expert for that IANA table of HTTP Digest Algs) was that it was sufficient for the algorithms to have specs, without demanding an extra spec just to added them to the table.\r\n...snip\r\nI suggest adding ADLER32 and CRC32c to draft-ietf-httpbis-digest-headers. That tidies up the registration.\r\n\r\nIt sounds fair to obsolete these algorithms. Typically we've just cited somebody else's work to explain why that is the case, if there are no such references for `sum` then we might need more text than is present for other obsoleted algorithms.",
          "createdAt": "2020-03-12T01:11:16Z",
          "updatedAt": "2020-03-12T01:11:51Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It might be sufficient to rely on the absence of evidence of strength algorithms.  The question should be what the algorithm claims to provide.  By my reckoning:\r\n\r\n* sum is at best a sanity check that is approximately as good as the one in TCP (it might be better)\r\n* cksum is CRC32(c?) and is intended to catch bit-level errors in transmission (there are likely papers that state the bounds on this and where the weaknesses lie, but my understanding is that this is a pretty good algorithm for this purpose still)\r\n* MD5 and SHA-1 are intended to be cryptographically secure in the sense that they provide collision, pre-image, and second pre-image resistance.  They are known to fail at the first and the other properties are in question.\r\n* The SHA-2 family are widely regarded as being cryptographically sound in the aforementioned sense.\r\n\r\nThe https://tools.ietf.org/html/rfc3309 is a good reference for ADLER32, though I will note that the claim about deprecation isn't quite accurate.  That deprecation was specifically in relation to its use in SCTP.  I think that this document needs to effect the deprecation directly.",
          "createdAt": "2020-03-12T01:30:36Z",
          "updatedAt": "2020-03-12T01:30:36Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Making sum obsolete would be an improvement; we almost get better guarantees from the TCP\r\n> checksum.\r\n> I tend to think that cksum obsolete would also be a good choice. Right now, both are 'standard'\r\n\r\nIf you don't want to change the status of `adler32` wdyt to rename this issue as `make sum and cksum obsolete`?\r\n\r\nWhile your question is reasonable, Lucas explained our approach:\r\n\r\n>  if there are no such references for sum then we might need more text than is present for other obsoleted algorithms.\r\n\r\nDo you know of any implementors use-cases that is affected by that?",
          "createdAt": "2020-03-17T09:21:23Z",
          "updatedAt": "2020-03-17T09:21:23Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If there are no further comments I would close this.",
          "createdAt": "2020-08-24T15:15:14Z",
          "updatedAt": "2020-08-24T15:15:14Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd like to try and address both of Martin's point that relate to sum/cksum (here and on #1138) in a single PR. So I vote for keeping this open until we merge some text.",
          "createdAt": "2020-08-26T13:03:41Z",
          "updatedAt": "2020-08-26T13:03:41Z"
        }
      ]
    },
    {
      "number": 1141,
      "id": "MDU6SXNzdWU1ODI3ODE0NDg=",
      "title": "fwd-protocol type",
      "url": "https://github.com/httpwg/http-extensions/issues/1141",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "proxy-status"
      ],
      "body": "Right now `fwd-protocol` is a `sh-token`. Given that its payload is an ALPN identifier, we probably need to allow `sh-string` here too, and define an encoding. Or maybe just `sh-token` or `sh-binary` if it doesn't fit there...",
      "createdAt": "2020-03-17T06:17:23Z",
      "updatedAt": "2020-07-16T06:33:07Z",
      "closedAt": "2020-07-16T06:33:07Z",
      "comments": []
    },
    {
      "number": 1143,
      "id": "MDU6SXNzdWU1ODMxOTcxMDg=",
      "title": "Digest in requests with no payload body",
      "url": "https://github.com/httpwg/http-extensions/issues/1143",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nAn example of using Digest in a request with no payload body.\r\nThere is a misconceptions that Digest does not apply to request with no payload body. \r\n\r\nAs it's not a special case https://github.com/httpwg/http-extensions/issues/849#issuecomment-558096111 for sha-256 we can just use \r\n\r\n```\r\nIn [120]: sha256(b'').hexdigest()                                                                                                                                                                                                            \r\nOut[120]: 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'\r\n```\r\n\r\nOther algorithms are free to define a different computation, and the examples will only be tied to sha-256\r\n\r\n",
      "createdAt": "2020-03-17T18:00:16Z",
      "updatedAt": "2020-05-04T17:32:59Z",
      "closedAt": "2020-05-04T17:32:59Z",
      "comments": []
    },
    {
      "number": 1147,
      "id": "MDU6SXNzdWU1OTYwMTQxMDE=",
      "title": "Add example for Tokens?",
      "url": "https://github.com/httpwg/http-extensions/issues/1147",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "In Section 3.3.4. Tokens, there isn't an example `Example-TokenHeader:`. It's pretty trivial for this case, but since other types all provide an example, it might be nice to include one here as well.\r\n\r\nAlso, on the topic of examples, the existing examples are inconsistent with naming it \"Header\" or \"Hdr\"\r\n\r\n`Example-IntegerHeader`\r\n`Example-DecimalHeader`\r\n`Example-StringHeader`\r\n`Example-BinaryHdr`\r\n`Example-BoolHdr`",
      "createdAt": "2020-04-07T16:55:01Z",
      "updatedAt": "2020-05-05T04:46:48Z",
      "closedAt": "2020-05-05T04:46:48Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Argh, forgot to do this in -18; will consider this a LC comment and do it then. Sorry.",
          "createdAt": "2020-04-20T06:36:05Z",
          "updatedAt": "2020-04-20T06:36:05Z"
        }
      ]
    },
    {
      "number": 1148,
      "id": "MDU6SXNzdWU1OTYwMTQ5OTM=",
      "title": "Serialization vs Serialisation",
      "url": "https://github.com/httpwg/http-extensions/issues/1148",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "The structured header document has inconsistent American/British spelling of serialization.\r\n\r\n`serialization` shows up 23 times, while `serialisation` shows up 8 times.",
      "createdAt": "2020-04-07T16:56:35Z",
      "updatedAt": "2020-04-07T23:40:30Z",
      "closedAt": "2020-04-07T23:40:30Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Already fixed in editor's copy",
          "createdAt": "2020-04-07T23:40:30Z",
          "updatedAt": "2020-04-07T23:40:30Z"
        }
      ]
    },
    {
      "number": 1149,
      "id": "MDU6SXNzdWU1OTgxNDI2NDA=",
      "title": "Insecure IP addresses can overwrite a Secure cookie with an insecure cookie",
      "url": "https://github.com/httpwg/http-extensions/issues/1149",
      "state": "CLOSED",
      "author": "chlily1",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Typically a preexisting Secure cookie cannot be overwritten by an equivalent insecure cookie coming from an insecure source. (\"Leave Secure cookies alone\").\r\n\r\n[RFC 6265bis](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-05#section-5.4) says:\r\n```\r\n   12.  If the cookie's secure-only-flag is not set, and the scheme\r\n        component of request-uri does not denote a \"secure\" protocol,\r\n        then abort these steps and ignore the cookie entirely if the\r\n        cookie store contains one or more cookies that meet all of the\r\n        following criteria:\r\n\r\n        1.  Their name matches the name of the newly-created cookie.\r\n\r\n        2.  Their secure-only-flag is true.\r\n\r\n        3.  Their domain domain-matches the domain of the newly-created\r\n            cookie, or vice-versa.\r\n\r\n        4.  The path of the newly-created cookie path-matches the path\r\n            of the existing cookie.\r\n\r\n        Note: The path comparison is not symmetric, ensuring only that a\r\n        newly-created, non-secure cookie does not overlay an existing\r\n        secure cookie, providing some mitigation against cookie-fixing\r\n        attacks.  That is, given an existing secure cookie named 'a'\r\n        with a path of '/login', a non-secure cookie named 'a' could be\r\n        set for a path of '/' or '/foo', but not for a path of '/login'\r\n        or '/login/en'.\r\n```\r\n\r\nHowever, the [algorithm](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-05#section-5.1.3) for `domain-matches` excludes IP addresses:\r\n```\r\n   A string domain-matches a given domain string if at least one of the\r\n   following conditions hold:\r\n\r\n   o  The domain string and the string are identical.  (Note that both\r\n      the domain string and the string will have been canonicalized to\r\n      lower case at this point.)\r\n\r\n   o  All of the following conditions hold:\r\n\r\n      *  The domain string is a suffix of the string.\r\n\r\n      *  The last character of the string that is not included in the\r\n         domain string is a %x2E (\".\") character.\r\n\r\n      *  The string is a host name (i.e., not an IP address).\r\n```\r\n\r\nThus a cookie such as `A=B; Secure` that was set by `https://1.2.3.4` might be overwritten by an insecure cookie `A=C` that is set by `http://1.2.3.4`.\r\n\r\nThis seems unintentional and undesirable?",
      "createdAt": "2020-04-10T23:44:38Z",
      "updatedAt": "2020-04-10T23:45:25Z",
      "closedAt": "2020-04-10T23:45:25Z",
      "comments": [
        {
          "author": "chlily1",
          "authorAssociation": "NONE",
          "body": "Oh, I can't read. Nevermind. This is covered by `The domain string and the string are identical`.",
          "createdAt": "2020-04-10T23:45:25Z",
          "updatedAt": "2020-04-10T23:45:25Z"
        }
      ]
    },
    {
      "number": 1158,
      "id": "MDU6SXNzdWU2MDA0MTg2MTY=",
      "title": "Channel ID and Token Binding are undefined",
      "url": "https://github.com/httpwg/http-extensions/issues/1158",
      "state": "CLOSED",
      "author": "sleevi",
      "authorAssociation": "NONE",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "https://github.com/httpwg/http-extensions/blob/5469d515d8876196900078806d07813765aa9a49/draft-ietf-httpbis-rfc6265bis.md#L1974\r\n\r\n\"Token Binding\" and \"Channel ID\" are undefined here.\r\n\r\nIt's unclear whether informative references, such as to [RFC 8471](https://datatracker.ietf.org/doc/rfc8471/) and [draft-balfanz-tls-channelid](https://datatracker.ietf.org/doc/draft-balfanz-tls-channelid/) would be useful, or if just rewording this would be better.",
      "createdAt": "2020-04-15T16:12:15Z",
      "updatedAt": "2020-04-20T08:50:37Z",
      "closedAt": "2020-04-20T08:50:37Z",
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@mikewest Looks like I can't label this as 6265bis for you.",
          "createdAt": "2020-04-15T16:12:39Z",
          "updatedAt": "2020-04-15T16:12:39Z"
        }
      ]
    },
    {
      "number": 1159,
      "id": "MDU6SXNzdWU2MDA0MjQ0MTk=",
      "title": "6265bis should not normatively depend on the Public Suffix List",
      "url": "https://github.com/httpwg/http-extensions/issues/1159",
      "state": "CLOSED",
      "author": "sleevi",
      "authorAssociation": "NONE",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "Within 6265bis, the use of the PSL is currently specified normatively:\r\nhttps://github.com/httpwg/http-extensions/blob/5469d515d8876196900078806d07813765aa9a49/draft-ietf-httpbis-rfc6265bis.md#L104-L106\r\n\r\nConcrete suggestion: Move this to an informative reference, instead, and update the text relying upon it to capture this. \r\n\r\nIn 6265, this was effectively an informative reference, per [Section 5.3's](https://tools.ietf.org/html/rfc6265#section-5.3) note. This is somewhat related to https://github.com/httpwg/http-extensions/issues/1033 which moved it into terminology, instead of Section 5.4.\r\n\r\nIn terms of \"rough consensus and running code\", in terms of widely deployed clients, the algorithm specified in the Public Suffix List is not consistently implemented, the algorithm itself is ambiguous for edge cases, and perhaps most importantly, none of the major implementations ship the same version of the Public Suffix List. Several implementations, including Google Chrome, further fork and modify that list to support their implementation needs.\r\n\r\nThus, it's really more of an informative dependency, similar to how 6265 captured this problem. [SAC070](https://www.icann.org/en/system/files/files/sac-070-en.pdf) similarly called out and acknowledged there may be many static lists used by applications, of differing versions and algorithms.",
      "createdAt": "2020-04-15T16:20:39Z",
      "updatedAt": "2020-04-20T08:50:37Z",
      "closedAt": "2020-04-20T08:50:37Z",
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@mikewest Also editorial and related to 6265bis",
          "createdAt": "2020-04-15T16:20:56Z",
          "updatedAt": "2020-04-15T16:20:56Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I don't think it's pedantically \"editorial\" since it removes a normative reference, but I'm fine with doing so. Do you have a proposal for new text? If not, I'll make something up.",
          "createdAt": "2020-04-15T16:47:25Z",
          "updatedAt": "2020-04-15T16:47:25Z"
        }
      ]
    },
    {
      "number": 1161,
      "id": "MDU6SXNzdWU2MDMwODA1ODc=",
      "title": "rfc6562bis draft-6 section 4.1.1 syntax says US-ASCII but is not?",
      "url": "https://github.com/httpwg/http-extensions/issues/1161",
      "state": "CLOSED",
      "author": "bagder",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "News in draft-06 is the %80-FF range added here:\r\n~~~\r\ncookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E / %x80-FF\r\n                      ; US-ASCII characters excluding CTLs,\r\n                      ; whitespace DQUOTE, comma, semicolon,\r\n                      ; and backslash\r\n~~~\r\n... so the text below the syntax define doesn't match the syntax description anymore, as %x80-FF is certainly not US-ASCII...",
      "createdAt": "2020-04-20T09:20:52Z",
      "updatedAt": "2020-04-27T17:28:14Z",
      "closedAt": "2020-04-27T17:28:14Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See https://github.com/httpwg/http-extensions/pull/1162",
          "createdAt": "2020-04-20T13:29:50Z",
          "updatedAt": "2020-04-20T13:29:50Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Merged @reschke's PR. Thank you both!",
          "createdAt": "2020-04-27T14:36:49Z",
          "updatedAt": "2020-04-27T14:36:49Z"
        }
      ]
    },
    {
      "number": 1163,
      "id": "MDU6SXNzdWU2MDg1NDAzNTI=",
      "title": "document.cookie should not be able to access SameSite cookies in cross-site iframes",
      "url": "https://github.com/httpwg/http-extensions/issues/1163",
      "state": "OPEN",
      "author": "chlily1",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis",
        "samesite"
      ],
      "body": "[Per mikewest](https://crbug.com/1075610#c5): \r\n\r\n> No, cross-site frames should not be able to access `SameSite=AnythingButNone` cookies via `document.cookie`. The spec doesn't make this clear (you have to read between the lines of bullet 5 of step 1 of https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-06#section-5.5), so we should change the spec.",
      "createdAt": "2020-04-28T18:55:56Z",
      "updatedAt": "2020-09-30T14:52:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bakulf",
          "authorAssociation": "NONE",
          "body": "I recently wrote this https://github.com/web-platform-tests/wpt/pull/23113 to cover the opposite of what you suggest but I'm happy to revert it as soon as we have consensus.\r\n\r\nIn particular, the reason why I wrote that PR is this:\r\n\r\n1. A.com as an anchor element pointing to B.com\r\n2. the user clicks on the link. The browser navigates to B.com\r\n3. B.com runs: `document.cookie = 'a=b; sameSite=strict'; console.log(document.cookie);`\r\n4. Should the console show 'a=b' or an empty string?\r\n\r\nIn theory, a=b should be shown only if the navigation is same-origin, but here we don't have navigation (document.cookie doesn't trigger navigation). And if we consider the document loading, this is not same-site (A.com -> B.com).\r\n\r\nChrome shows 'a=b'. Firefox before [bug 1627653](https://bugzilla.mozilla.org/show_bug.cgi?id=1627653) used to show an empty string.\r\n\r\nA way to cover this scenario and what you suggest is to not expose `sameSite=AnythingButNone` cookies to iframed cross-origin documents.",
          "createdAt": "2020-05-12T09:33:07Z",
          "updatedAt": "2020-05-12T09:33:07Z"
        },
        {
          "author": "chlily1",
          "authorAssociation": "NONE",
          "body": "If I'm understanding correctly, the changes in https://bugzilla.mozilla.org/show_bug.cgi?id=1627653#c11 make it so that all SameSite cookies are exposed in `document.cookie` queries regardless of the ancestor frames' origins. The WPT change also seems to test this behavior. This is more permissive than just showing SameSite=Strict cookies in \"laxly same-site\" (i.e. all document ancestors are same-site) contexts regardless of navigation initiator, which is what Chrome does.",
          "createdAt": "2020-05-12T16:37:53Z",
          "updatedAt": "2020-05-12T16:37:53Z"
        },
        {
          "author": "bakulf",
          "authorAssociation": "NONE",
          "body": "> If I'm understanding correctly, ...\r\n\r\nThis is correct. And reading the spec, the firefox implementation seems to be the correct one, even if I prefer to have something more restrictive.",
          "createdAt": "2020-05-13T16:44:25Z",
          "updatedAt": "2020-05-13T16:44:25Z"
        }
      ]
    },
    {
      "number": 1164,
      "id": "MDU6SXNzdWU2MDk2ODk0MjU=",
      "title": "Dictionary serialisation algo problem",
      "url": "https://github.com/httpwg/http-extensions/issues/1164",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [
        "mnot"
      ],
      "labels": [
        "header-structure"
      ],
      "body": "@annevk noticed that [dictionary serialisation](https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#ser-dictionary) is messed up.\r\n\r\nI _think_ the fix is to indent the top-level 2-5 -- but I want to have a good look at it, compare to implementation, and I'd like others to verify, as I'm wary of making changes at this late stage.\r\n\r\nBlame seems to be [this commit](https://github.com/httpwg/http-extensions/commit/4f3252bbc73844559bf7bc8891424de08531f7da), which I vaguely remember as being... surprising. That will teach me to slow down when something weird happens with Git...",
      "createdAt": "2020-04-30T08:02:04Z",
      "updatedAt": "2020-05-05T05:05:15Z",
      "closedAt": "2020-05-05T05:05:15Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Ping @bsdphk @phluid61 @clelland to look over my shoulder...",
          "createdAt": "2020-04-30T08:02:33Z",
          "updatedAt": "2020-04-30T08:02:33Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Looking at https://github.com/httpwg/http-extensions/pull/999/files the problem is that what became top-level 3 and 4 should have been steps inside top-level 2. Further changes have happened so now that applies to top-level 5 as well. (Top-level 2 itself seems good as that initiates the loop.)\r\n\r\n(Other for each statements do appear to have correct indenting.)",
          "createdAt": "2020-04-30T08:20:56Z",
          "updatedAt": "2020-04-30T08:20:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Like that?",
          "createdAt": "2020-05-05T04:41:09Z",
          "updatedAt": "2020-05-05T04:41:09Z"
        }
      ]
    },
    {
      "number": 1170,
      "id": "MDU6SXNzdWU2MTI5OTc5NjU=",
      "title": "Redirect scope",
      "url": "https://github.com/httpwg/http-extensions/issues/1170",
      "state": "OPEN",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [
        "mnot"
      ],
      "labels": [
        "bcp56bis"
      ],
      "body": "People using HTTP for non-browser cases seem to keep on assuming that redirects are 'sticky' -- i.e., that once I redirect a client, it will somehow magically know to redirect future requests (even with different URLs) to the updated server. We should clarify this specifically so there's text we can point these people to.\r\n\r\nOne could read the current specs as saying that a POST to URL A that permanently redirects to URL B should imply that future POSTs to URL A should automatically be sent to URL B. I think that's reasonable, but AFAICT it isn't implemented anywhere, so we should caution folks that it's only advisory and not widely implemented.",
      "createdAt": "2020-04-01T00:58:04Z",
      "updatedAt": "2020-05-06T23:29:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Actually, I think this might be better in BCP56bis.",
          "createdAt": "2020-05-06T01:46:49Z",
          "updatedAt": "2020-05-06T01:46:49Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is that related to the `ought`s I find in  https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#status.301 ?",
          "createdAt": "2020-05-06T10:36:37Z",
          "updatedAt": "2020-05-06T10:36:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes.",
          "createdAt": "2020-05-06T23:29:23Z",
          "updatedAt": "2020-05-06T23:29:23Z"
        }
      ]
    },
    {
      "number": 1174,
      "id": "MDU6SXNzdWU2MjI3NDM5MjA=",
      "title": "[Client-Hints] Impact assessment requested",
      "url": "https://github.com/httpwg/http-extensions/issues/1174",
      "state": "CLOSED",
      "author": "jwrosewell",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "The current draft does a good job of explaining the implementation of HTTP Client Hints in engineering terms. It is a shame the [reservations expressed in the W3C](https://github.com/w3ctag/design-reviews/issues/467) relating to HTTP Client Hints do not appear to have surfaced in the debate or have not been considered worthy of a acknowledgement in the final draft.\r\n\r\nThe document does not recognise the wide adoption of HTTP User-Agent header value optimisations, the benefits they provide or the reliability of the techniques used. The justification for the existence of HTTP Client Hints is framed almost entirely from the singular position of privacy. The justification concerning improving performance is at best weak.\r\n\r\nThe document does not consider use cases that would be removed by adoption in practice, the impact to the open web of such removal, societal harms, or the competition issues that would result from web browser vendor implementations when considered alongside related proposals such as privacy budget.\r\n\r\nUses cases that will be removed include performance optimisation, the detection of fraud, and problem diagnosis as a few examples. \r\n\r\nOther use cases associated with knowledge of the user\u2019s agent are tacitly acknowledged by a [browser vendor that implements the X-Client-Data](https://9to5google.com/2020/02/06/google-chrome-x-client-data-tracking/) specifically for the purpose of receiving such information on first request. The implementation of X-Client-Data limits this information to services operated by the browser vendor, happens by default and without user consent or knowledge. For the same browser vendor to support a proposal that seeks to remove such information from others is disingenuous.\r\n\r\nWhere mitigations have been suggested they would in practice depend on a related proposal concerning privacy budget. Whoever controls the privacy budget and the default settings will therefore control the realisation of such use cases.\r\n\r\nWhere existing standards for interoperability are used to deliver vital content to people the provider of such services will need to modify their service to support HTTP Client Hints. This will be the case for millions of websites currently utilising accurate information contained in the User-Agent HTTP header value. This will consume untold developer effort running two parallel solutions and will take them away from more productive activity. The problem will be particularly acute in societies where mobile devices dominate access to information and will be a particular concern for people whose only method of accessing information is via a mobile device.\r\n\r\nAssuming it is not the role of this body to pick winners and losers I urge participants to consider a further review to engage a wide range of stakeholders to better understand fully the implications before progressing.",
      "createdAt": "2020-05-21T19:55:37Z",
      "updatedAt": "2020-05-21T23:12:08Z",
      "closedAt": "2020-05-21T23:12:08Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Spec already shipped, so this is too late.\r\n\r\nBeyond that, the issue you reference and what you raise here is about migrating form UA to clint hints, which is not part of this document. ",
          "createdAt": "2020-05-21T23:12:08Z",
          "updatedAt": "2020-05-21T23:12:08Z"
        }
      ]
    },
    {
      "number": 1176,
      "id": "MDU6SXNzdWU2MjQ0OTc0MTQ=",
      "title": "Confusing guidance on algorithm and key identification",
      "url": "https://github.com/httpwg/http-extensions/issues/1176",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The current draft encourages determining the Algorithm metadata property from the `keyId` field, both in the guidance for the use of `algorithm` and `keyId`, and the definition for the `hs2019` algorithm and deprecation of the other algorithms in the registry.  The current state arose from concern that a malicious party could change the value of the `algorithm` parameter, potentially tricking the verifier into accepting a signature that would not have been verified under the actual parameter.\r\n\r\nPunting algorithm identification into `keyId` hurts interoperability, since we aren't defining the syntax or semantics of `keyId`.  It actually goes against that claim, as we are dictating that the signing algorithm must be specified by `keyId` or derivable from it.  It also renders the algorithm registry essentially useless.  Instead of this approach, we can protect against manipulation of the Signature header field by adding support for (and possibly mandating) including Signature metadata within the Signature Input.",
      "createdAt": "2020-05-25T21:49:55Z",
      "updatedAt": "2020-10-20T14:55:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "TL;DR we should sign the signature algorithm... like we sign JWS headers... How can we mandate this?",
          "createdAt": "2020-10-20T01:56:37Z",
          "updatedAt": "2020-10-20T01:56:37Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Propagating my jabber comment from today's interim meeting: I think [draft-ietf-httpbis-message-signatures](https://httpwg.org/http-extensions/draft-ietf-httpbis-message-signatures.html) should say that specs for protocols built on this header MUST define how the `keyId` field maps to a key, and then that the key MUST determine the algorithm. That would let this document avoid algorithm identifiers entirely.",
          "createdAt": "2020-10-20T14:15:07Z",
          "updatedAt": "2020-10-20T14:15:07Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "P-256 -> ES256 ? This approach might not work for keys that support multiple signature types, such as secp256k1.",
          "createdAt": "2020-10-20T14:55:52Z",
          "updatedAt": "2020-10-20T14:55:52Z"
        }
      ]
    },
    {
      "number": 1177,
      "id": "MDU6SXNzdWU2MjQ0OTgxNTU=",
      "title": "Lack of definition of keyId hurts interoperability",
      "url": "https://github.com/httpwg/http-extensions/issues/1177",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The current text leaves the format and semantics of `keyId` completely up to the implementation.  This is primarily due to the fact that most implementers of Cavage have extensive investment in key distribution and management, and just need to plug an identifier into the header.  We should support those cases, but we also need to provide guidance for the developer that doesn't have that and just wants to know how to identify a key.  It may be enough to punt this to profiling specs, but this needs to be explored more.",
      "createdAt": "2020-05-25T21:53:10Z",
      "updatedAt": "2020-10-31T21:01:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "I think its fine to leave the identifier constrained too valid utf-8 / strings / URIs... certainly there will be a profile for working with DIDs in the future, where keyId is a DID_URL.",
          "createdAt": "2020-10-31T21:01:59Z",
          "updatedAt": "2020-10-31T21:01:59Z"
        }
      ]
    },
    {
      "number": 1178,
      "id": "MDU6SXNzdWU2MjQ0OTgyOTY=",
      "title": "Algorithm Registry duplicates work of JWA",
      "url": "https://github.com/httpwg/http-extensions/issues/1178",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "RFC7518 already defines an IANA registry for cryptographic algorithms.  This wasn't used by Cavage out of concerns about complexity of JOSE, and issues with JWE and JWS being too flexible, leading to insecure combinations of options.  Using JWA's definitions does not need to mean we're using JOSE, however. We should look at if/how we can leverage JWA's work without introducing too many sharp edges for implementers.\r\n\r\nIn any use of JWS algorithms, this spec would define a way to create the JWS Signing Input string to be applied to the algorithm.  It should be noted that this is incompatible with JWS itself, which requires the inclusion of a structured header in the signature input.\r\n\r\nA possible approach is to incorporate all elements of the JWA signature algorithm registry into this spec using a prefix or other marker, such as `jws-RS256` for the RSA 256 JSON Web Signature algorithm.",
      "createdAt": "2020-05-25T21:53:44Z",
      "updatedAt": "2020-10-31T20:57:45Z",
      "closedAt": null,
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "I would prefer a clean mapping to support for JWS, and not to reinvent yet another crypto registry... \r\n\r\nI am implemented support for https://www.iana.org/assignments/jose/jose.xhtml\r\n\r\nIn https://w3c-ccg.github.io/lds-jws2020/\r\n\r\nJOSE is not complicated, and is reasonably well supported in many different languages (as is HTTP).... IMO, It would be a complete disaster not to start with support for it.",
          "createdAt": "2020-10-20T01:54:56Z",
          "updatedAt": "2020-10-20T01:54:56Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "PROPOSAL: use IANA / JOSE + detached JWS.",
          "createdAt": "2020-10-31T20:57:45Z",
          "updatedAt": "2020-10-31T20:57:45Z"
        }
      ]
    },
    {
      "number": 1179,
      "id": "MDU6SXNzdWU2MjQ0OTg3MzU=",
      "title": "Algorithm Registry should not be initialized with deprecated entries",
      "url": "https://github.com/httpwg/http-extensions/issues/1179",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The initial entries in this document reflect those in Cavage.  The ones that are marked deprecated were done so because of the issue explained in #1176, with the possible exception of `rsa-sha1`.  We should probably just remove that one.\r\n\r\n",
      "createdAt": "2020-05-25T21:55:29Z",
      "updatedAt": "2020-10-20T01:52:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "Why not just say we support https://www.iana.org/assignments/jose/jose.xhtml\r\n\r\nand leave it to implementers to choose which algorithms to use?",
          "createdAt": "2020-10-20T01:52:14Z",
          "updatedAt": "2020-10-20T01:52:14Z"
        }
      ]
    },
    {
      "number": 1180,
      "id": "MDU6SXNzdWU2MjQ0OTkwMzI=",
      "title": "No percent-encoding normalization of path/query",
      "url": "https://github.com/httpwg/http-extensions/issues/1180",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The canonicalization rules for `(request-target)` do not perform handle minor, semantically meaningless differences in percent-encoding, such that verification could fail if an intermediary normalizes the effective request URI prior to forwarding the message.  \r\n\r\nAt a minimum, they should be case and percent-encoding normalized as described in sections 6.2.2.1 and 6.2.2.2 of RFC3986.\r\n\r\nSee: [issue #26 in old Cavage repo](https://github.com/w3c-dvcg/http-signatures/issues/26)",
      "createdAt": "2020-05-25T21:56:48Z",
      "updatedAt": "2020-05-25T23:15:28Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1181,
      "id": "MDU6SXNzdWU2MjQ0OTkxMjQ=",
      "title": "Misleading name for headers parameter",
      "url": "https://github.com/httpwg/http-extensions/issues/1181",
      "state": "CLOSED",
      "author": "richanna",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The Covered Content list contains identifiers for more than just headers, so the `header` parameter name is no longer appropriate.  Some alternatives: \"content\", \"signed-content\", \"covered-content\".",
      "createdAt": "2020-05-25T21:57:10Z",
      "updatedAt": "2020-10-23T23:06:28Z",
      "closedAt": "2020-10-23T23:06:28Z",
      "comments": []
    },
    {
      "number": 1182,
      "id": "MDU6SXNzdWU2MjQ0OTkyNjY=",
      "title": "Changes to whitespace in header field values break verification",
      "url": "https://github.com/httpwg/http-extensions/issues/1182",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "Some header field values contain RWS, OWS, and/or BWS.  Since the header field value canonicalization rules do not address whitespace, changes to it (e.g., removing OWS or BWS or replacing strings of RWS with a single space) can cause verification to fail.",
      "createdAt": "2020-05-25T21:57:40Z",
      "updatedAt": "2020-05-25T23:15:29Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1183,
      "id": "MDU6SXNzdWU2MjQ0OTkzNTQ=",
      "title": "Multiple Set-Cookie headers are not well supported",
      "url": "https://github.com/httpwg/http-extensions/issues/1183",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The Set-Cookie header can occur multiple times but does not adhere to the list syntax, and thus is not well supported by the header field value concatenation rules.",
      "createdAt": "2020-05-25T21:58:03Z",
      "updatedAt": "2020-05-25T23:15:29Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1184,
      "id": "MDU6SXNzdWU2MjQ0OTk0MDM=",
      "title": "Signature parameters are not signed",
      "url": "https://github.com/httpwg/http-extensions/issues/1184",
      "state": "CLOSED",
      "author": "richanna",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The Covered Content list, Algorithm, and Verification Key identifier should all be part of the Signature Input, to protect against malicious changes.",
      "createdAt": "2020-05-25T21:58:18Z",
      "updatedAt": "2020-10-23T23:06:29Z",
      "closedAt": "2020-10-23T23:06:29Z",
      "comments": []
    },
    {
      "number": 1185,
      "id": "MDU6SXNzdWU2MjQ0OTk3MjM=",
      "title": "Max values, precision for Integer String and Decimal String not defined",
      "url": "https://github.com/httpwg/http-extensions/issues/1185",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The definitions for Integer String and Decimal String do not specify a maximum value.  The definition for Decimal String (used to provide sub-second precision for Expiration Time) does not define minimum or maximum precision requirements.  It should set a reasonable requirement here (e.g., MUST support up to 3 decimal places and no more).\r\n\r\nBetter yet, are there existing definitions we can reference?",
      "createdAt": "2020-05-25T21:59:42Z",
      "updatedAt": "2020-10-25T00:12:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe S-H draft can help.\r\n\r\nimho we should just not mandate for subsecond precision and allow both `int` and `float`",
          "createdAt": "2020-05-26T15:42:31Z",
          "updatedAt": "2020-05-26T15:42:31Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@richanna we are using structured fields: can we close? :)",
          "createdAt": "2020-10-25T00:12:02Z",
          "updatedAt": "2020-10-25T00:12:02Z"
        }
      ]
    },
    {
      "number": 1186,
      "id": "MDU6SXNzdWU2MjQ0OTk3OTg=",
      "title": "keyId parameter value could break list syntax",
      "url": "https://github.com/httpwg/http-extensions/issues/1186",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The `keyId` parameter value needs to be constrained so as to not break list syntax (e.g., by containing a comma).",
      "createdAt": "2020-05-25T22:00:02Z",
      "updatedAt": "2020-05-25T23:15:30Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1187,
      "id": "MDU6SXNzdWU2MjQ1MDAzMzY=",
      "title": "Creation Time and Expiration Time do not allow for clock skew",
      "url": "https://github.com/httpwg/http-extensions/issues/1187",
      "state": "CLOSED",
      "author": "richanna",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The processing instructions for Creation Time and Expiration Time imply that verifiers are not permitted to account for clock skew during signature verification.",
      "createdAt": "2020-05-25T22:01:15Z",
      "updatedAt": "2020-10-01T19:26:33Z",
      "closedAt": "2020-10-01T19:26:33Z",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This can safely be fixed adding a `nbf`-like claim, so that the signer remains in control of the signature validity. This is especially important if the signature is created with the signer's private key.\r\n\r\nimho this kind of document should not define a clock-skew tolerance threshold, and implementors shoud be suggested to fix their clocks.\r\n\r\nThere may be corner cases (eg. IoT/disconnected devices ) that we should address properly ",
          "createdAt": "2020-05-26T09:26:51Z",
          "updatedAt": "2020-05-26T09:26:51Z"
        }
      ]
    },
    {
      "number": 1188,
      "id": "MDU6SXNzdWU2MjQ1MDA1NDU=",
      "title": "Require lowercased header field names as identifiers",
      "url": "https://github.com/httpwg/http-extensions/issues/1188",
      "state": "CLOSED",
      "author": "richanna",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The current text allows mixed-case header field names when they are being used as content identifiers. This is unnecessary \u2013 header field names are case-insensitive \u2013 and creates opportunity for incompatibility.  Instead, content identifiers should always be lowercase.",
      "createdAt": "2020-05-25T22:02:09Z",
      "updatedAt": "2020-10-01T19:26:33Z",
      "closedAt": "2020-10-01T19:26:33Z",
      "comments": []
    },
    {
      "number": 1189,
      "id": "MDU6SXNzdWU2MjQ1MDA2MjY=",
      "title": "Reconcile Date header and Creation Time",
      "url": "https://github.com/httpwg/http-extensions/issues/1189",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The draft is missing guidance on if/how the Date header relates to signature Creation Time.  There are cases where they may be different, such as if a signature was pre-created.  Should Creation Time default to the value in the Date header if the `created` parameter is not specified?",
      "createdAt": "2020-05-25T22:02:26Z",
      "updatedAt": "2020-05-26T13:09:36Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Explicit is better than implicit :)\r\n\r\nimho:\r\n-  `created` MUST be always present\r\n- relations between `Date` and `created` MAY not be explicited",
          "createdAt": "2020-05-26T13:09:36Z",
          "updatedAt": "2020-05-26T13:09:36Z"
        }
      ]
    },
    {
      "number": 1190,
      "id": "MDU6SXNzdWU2MjQ1MDA3OTQ=",
      "title": "Remove algorithm-specific rules for content identifiers",
      "url": "https://github.com/httpwg/http-extensions/issues/1190",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The rules that restrict when the signer can or must include certain identifiers appear to be related to the pseudo-revving of the Cavage draft that happened when the `hs2019` algorithm was introduced.  We should drop these rules, as it can be expected that anyone implementing this draft will support all content identifiers.",
      "createdAt": "2020-05-25T22:03:06Z",
      "updatedAt": "2020-05-25T23:15:31Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1191,
      "id": "MDU6SXNzdWU2MjQ1MDA5MjM=",
      "title": "Add guidance for signing compressed headers",
      "url": "https://github.com/httpwg/http-extensions/issues/1191",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The draft should provide guidance on how to sign headers when RFC7541 is used. This guidance might be as simple as \"sign the uncompressed header field value.\"",
      "createdAt": "2020-05-25T22:03:36Z",
      "updatedAt": "2020-10-25T00:14:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think that header compression (HPACK or QPACK) really needs to be mentioned. This is because the signature operates over header fields at the HTTP semantic level, this whereas compression is a version-specific aspect of serialization. An encoder takes a header or trailer field section and produces an output that is sent on the wire, the semantic layer has sort of left the control loop at this phase.",
          "createdAt": "2020-05-26T11:59:40Z",
          "updatedAt": "2020-05-26T11:59:40Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@richanna do you think we can close this according to Lucas' comment?",
          "createdAt": "2020-10-25T00:14:50Z",
          "updatedAt": "2020-10-25T00:14:50Z"
        }
      ]
    },
    {
      "number": 1192,
      "id": "MDU6SXNzdWU2MjQ1MDEwMDY=",
      "title": "Transformations to Via header field value break verification",
      "url": "https://github.com/httpwg/http-extensions/issues/1192",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "Intermediaries are permitted to strip comments from the `Via` header field value, and consolidate related sequences of entries.  The canonicalization rules do not account for these changes, and thus they cause signature verification to fail if the `Via` header is signed. At the very least, guidance on signing or not signing `Via` headers needs to be included.",
      "createdAt": "2020-05-25T22:03:54Z",
      "updatedAt": "2020-05-26T15:34:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let's add a paragraph with some caveats and header examples.",
          "createdAt": "2020-05-26T15:34:53Z",
          "updatedAt": "2020-05-26T15:34:53Z"
        }
      ]
    },
    {
      "number": 1193,
      "id": "MDU6SXNzdWU2MjQ1MDEwOTU=",
      "title": "Case changes to case-insensitive header field values break verification",
      "url": "https://github.com/httpwg/http-extensions/issues/1193",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "Some header field values are case-insensitive, in whole or in part. The canonicalization rules do not account for this, thus a case change to a covered header field value causes verification to fail.",
      "createdAt": "2020-05-25T22:04:13Z",
      "updatedAt": "2020-05-26T15:33:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While I'd just put a warning on that, it would be great to have some examples/use cases for that.",
          "createdAt": "2020-05-26T15:33:26Z",
          "updatedAt": "2020-05-26T15:33:26Z"
        }
      ]
    },
    {
      "number": 1194,
      "id": "MDU6SXNzdWU2MjQ1MDExNjg=",
      "title": "Expiration not needed",
      "url": "https://github.com/httpwg/http-extensions/issues/1194",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "In many cases, putting the expiration of the signature into the hands of the signer opens up more options for failures than necessary.  Instead of the `expires`, any verifier can use the `created` field and an internal lifetime or offset to calculate expiration.  We should consider dropping the `expires` field.",
      "createdAt": "2020-05-25T22:04:33Z",
      "updatedAt": "2020-10-31T20:54:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The private key's owner must to be able to constraint the time validity of the signature because he has no ability to control on the internal lifetime of the verifier.\r\n\r\n\r\n\r\n\r\nDropping `expires` is dangerous.",
          "createdAt": "2020-05-26T12:45:48Z",
          "updatedAt": "2020-05-26T12:45:48Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can we close this? :)",
          "createdAt": "2020-10-25T00:28:03Z",
          "updatedAt": "2020-10-25T00:28:03Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "+1 to closing.",
          "createdAt": "2020-10-31T20:54:49Z",
          "updatedAt": "2020-10-31T20:54:49Z"
        }
      ]
    },
    {
      "number": 1195,
      "id": "MDU6SXNzdWU2MjQ1MDEzMjQ=",
      "title": "Define more content identifiers",
      "url": "https://github.com/httpwg/http-extensions/issues/1195",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "It should be possible to independently include the following content and metadata properties in Covered Content:\r\n\r\n- The signature's Algorithm\r\n- The signature's Covered Content\r\n- The value used for the `keyId` parameter\r\n- Request method\r\n- Individual components of the effective request URI: scheme, authority, path, query\r\n- Status code\r\n- Request body (currently supported via Digest header RFC3230)",
      "createdAt": "2020-05-25T22:05:08Z",
      "updatedAt": "2020-05-26T13:39:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Covering the payload body is not trivial as the http semantics impact on that: that includes all representation metadata (content-type, content-encoding), partial responses (range-requests), empty payload body methods (HEAD) and status (No Content).\r\n\r\nI suggest having a look at the [I-D.ietf-httpbis-digest-headers](https://github.com/httpwg/http-extensions/blob/master/draft-ietf-httpbis-digest-headers.md) to check all the possibilities.",
          "createdAt": "2020-05-26T13:39:57Z",
          "updatedAt": "2020-05-26T13:39:57Z"
        }
      ]
    },
    {
      "number": 1196,
      "id": "MDU6SXNzdWU2MjQ1MDE0NTQ=",
      "title": "Support expected authority changes",
      "url": "https://github.com/httpwg/http-extensions/issues/1196",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "In some cases, the authority of the effective request URI may be expected to change, for example from \"public-service-name.example.com\" to \"service-host-1.public-service-name.example.com\".  This is commonly the case for services that are hosted behind a load-balancing gateway, where the client sends requests to a publicly known domain name for the service, and these requests are transformed by the gateway into requests to specific hosts in the service fleet.\r\n\r\nOne possible way to handle this would be to special-case the Host header field to allow verifier to substitute a known expected value, or a value provided in another header field (e.g., `Via`) when generating the Signature Input, provided that the verifier also recognizes the real value in the `Host` header.  Alternatively, this logic could apply to an `(audience)` content identifier.",
      "createdAt": "2020-05-25T22:05:41Z",
      "updatedAt": "2020-05-26T13:32:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd add the following tasks:\r\n\r\n- [ ] add an example of request-response\r\n- [ ] add paragraph in Security Considerations\r\n\r\nAn `(audience)` can be reasonable as that decouples the verifier identity from the target.\r\n\r\n",
          "createdAt": "2020-05-26T13:32:51Z",
          "updatedAt": "2020-05-26T13:32:51Z"
        }
      ]
    },
    {
      "number": 1197,
      "id": "MDU6SXNzdWU2MjQ1MDE1MTA=",
      "title": "Support for signing specific cookies",
      "url": "https://github.com/httpwg/http-extensions/issues/1197",
      "state": "OPEN",
      "author": "richanna",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "A signer may only wish to sign one or a few cookies, for example if the website requires its authentication state cookie to be signed, but also sets other cookies (e.g., for analytics, ad tracking, etc.)",
      "createdAt": "2020-05-25T22:05:58Z",
      "updatedAt": "2020-05-25T23:15:32Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1198,
      "id": "MDU6SXNzdWU2MjQ1MDUyMjA=",
      "title": "Use Structured Headers",
      "url": "https://github.com/httpwg/http-extensions/issues/1198",
      "state": "CLOSED",
      "author": "richanna",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "Redefine the Signature header field to use [Structured Headers](https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html). This will simplify both the definition and the parsing of this header field value.",
      "createdAt": "2020-05-25T22:21:44Z",
      "updatedAt": "2020-10-23T23:06:28Z",
      "closedAt": "2020-10-23T23:06:28Z",
      "comments": []
    },
    {
      "number": 1203,
      "id": "MDU6SXNzdWU2MjQ4ODc4Nzc=",
      "title": "Rebrand Signatures draft",
      "url": "https://github.com/httpwg/http-extensions/issues/1203",
      "state": "OPEN",
      "author": "jricher",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The core function of the signatures draft is actually two-fold:\r\n\r\n - normalization of an HTTP request to create an input for a signature algorithm\r\n - attachment of a signature to an HTTP request\r\n\r\nThe first part is arguably the harder and more important part for why this is here in this WG, but it gets lost. What if we rebrand/rename the signatures draft?\r\n\r\n\"HTTP Message Normalization and Signing\"\r\n\r\n",
      "createdAt": "2020-05-26T13:33:57Z",
      "updatedAt": "2020-05-26T13:33:57Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1204,
      "id": "MDU6SXNzdWU2MjQ5ODk4MjI=",
      "title": "Use case: non repudiation",
      "url": "https://github.com/httpwg/http-extensions/issues/1204",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "## I wish\r\n\r\nI wish to use the `Signature` header for non repudiation.\r\n\r\nExample:\r\n\r\n  - client sends a request with a Signature of given headers and payload\r\n  - server replies with a Signature that may contain e.g. the request hash\r\n\r\n### Non repudiation\r\n\r\nSee [nist 800-32](https://csrc.nist.gov/publications/detail/sp/800-32/final) and  [nist glossary](https://csrc.nist.gov/glossary/term/Non__Repudiation)\r\n\r\nAssurance that:\r\n\r\n  - the sender is provided with proof of delivery \r\n  - and that the recipient is provided with proof of the sender's identity \r\n\r\nso that neither can later deny having processed the data.\r\n\r\nTechnical non repudiation refers to the assurance a Relying Party has that if a public key is used to validate a digital signature, that signature had to have been made by the corresponding private signature key. \r\n\r\nLegal non-repudiation refers to how well possession or control of the private signature key can be established.\r\n\r\n### Elements for non repudiation\r\n\r\nNon repudiation via PKI is usually achieved adding\r\n\r\n1- in a request\r\n\r\n  - an hash of the request representation\r\n  - a signature of the above hash and further elements, eg: `issuer, audience, subject, issued_at, not_before, expires`, similar to JWS claims\r\n  - sender informations\r\n\r\n2- in a response\r\n\r\n  - an hash of the response representation\r\n  - a signature of the above hash and further elements, including an hash of the original request\r\n  - original request informations (eg. the hash) may be added in the response representation\r\n\r\n\r\nFurther informations may include:\r\n\r\n  - URL or content of the certificate to be used for validating the signature\r\n\r\n### Signature and Non Repudiation\r\n\r\nThere are various similarities b/w the informations contained in this spec and Non Repudiation.\r\n\r\n  - `Digest` can be used to guarantee the integrity of the representation (eg. with other values of Content-Encoding)\r\n  - `Signature` covers a list of `Signed-Headers` which may cover all necessary headers\r\n\r\n\r\n## References\r\n\r\nAn example of non-repudiation via HTTP Headers is defined in:\r\n\r\n-  [Berlin Group Financial API \u00a711](https://docs.wixstatic.com/ugd/c2914b_5351b289bf844c6881e46ee3561d95bb.pdf) based on [https://tools.ietf.org/html/draft-cavage-http-signatures-10](draft-cavage-http-signatures-10)\r\n\r\n\r\n## Notes\r\n\r\nRelated to https://github.com/WICG/webpackage/issues/248\r\n\r\n",
      "createdAt": "2020-05-26T15:49:12Z",
      "updatedAt": "2020-06-08T08:20:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that you will find that most digital signature algorithms do not provide non-repudiation.  It's a common myth.\r\n\r\nA recent example of this myth biting us is [in ACME](https://www.agwa.name/blog/post/duplicate_signature_key_selection_attack_in_lets_encrypt), where the duplicate signature key selection attack was quite serious.",
          "createdAt": "2020-05-27T01:50:06Z",
          "updatedAt": "2020-05-27T01:50:06Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that a signature is \"just a number\" and it is responsibility of the parties to establish a suitable context when using digital signatures (algorithms, constraints, interactions, ..).\r\n\r\nNonetheless current frameworks rely on digital signatures as a building block for non repudiation and \r\nthe design of Signatures should try to support this use case - with all the caveats.\r\n",
          "createdAt": "2020-06-08T08:20:48Z",
          "updatedAt": "2020-06-08T08:20:48Z"
        }
      ]
    },
    {
      "number": 1205,
      "id": "MDU6SXNzdWU2MjQ5OTI4NzM=",
      "title": "Signature: Header or Field",
      "url": "https://github.com/httpwg/http-extensions/issues/1205",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "## Investigate\r\n\r\nCan `Signature` be used in trailers? In this case it should be a `field` and not an `header`.\r\n\r\n## Note\r\n\r\nMay be related to https://github.com/httpwg/http-extensions/pull/1157/files",
      "createdAt": "2020-05-26T15:53:31Z",
      "updatedAt": "2020-05-26T15:53:45Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1206,
      "id": "MDU6SXNzdWU2MjQ5OTYwNDg=",
      "title": "Relations with Signed Exchanges",
      "url": "https://github.com/httpwg/http-extensions/issues/1206",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "## I expect\r\n\r\nTo clarify the relations b/w message signatures and [Signed Exchanges](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html)\r\n\r\n## Note\r\n\r\nSimilar headers are:\r\n\r\n[Signed-Headers](\r\nhttps://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#name-signed-headers-header-field): contains a list of headers to be signed\r\n\r\n[Signature](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#section-3.1.1) containing the following data\r\n\r\n```\r\nSignature:\r\n sig1;\r\n  sig=*MEUCI..Y=*;\r\n  integrity=\"digest/mi-sha256\";\r\n  validity-url=\"https://example.com/resource.validity.1511128380\";\r\n  cert-url=\"https://example.com/oldcerts\";\r\n  cert-sha256=*W7uB969dFW3Mb5ZefPS9Tq5ZbH5iSmOILpjv2qEArmI=*;\r\n  date=1511128380; expires=1511733180,\r\nsig2;\r\n  ...\r\n```\r\n\r\n",
      "createdAt": "2020-05-26T15:57:54Z",
      "updatedAt": "2020-05-26T16:10:16Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1207,
      "id": "MDU6SXNzdWU2MjQ5OTcxODU=",
      "title": "Signature negotiation",
      "url": "https://github.com/httpwg/http-extensions/issues/1207",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "## Question\r\n\r\nDo we want to support negotiation, eg. [see webpack Accept-Signature](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#name-the-accept-signature-header) ?",
      "createdAt": "2020-05-26T15:59:24Z",
      "updatedAt": "2020-05-26T15:59:32Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1208,
      "id": "MDU6SXNzdWU2MjUwNjYwMTY=",
      "title": "Intermediaries altering content-coding",
      "url": "https://github.com/httpwg/http-extensions/issues/1208",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nTo clarify \r\n\r\n- [x] why Draft indicates protection against buggy compression, doesn't seem to actually do that as specified.\r\n- [ ] that intermediaries MUST NOT alter Digest\r\n- [x] protection from transforming proxies\r\n\r\n## Notes\r\n\r\nThis is a good question and probably should be addressed explicitly in the spec, either in the FAQ or in a proper section or [here](https://github.com/httpwg/http-extensions/blob/master/draft-ietf-httpbis-digest-headers.md#digest-for-end-to-end-integrity).\r\nProbably we can even refine the introduction.\r\nHere's a general answer.\r\n\r\n1- Digest protects the representation-data from a buggy transfer-coding; \r\n\r\n2- Digest was not originally designed to protect from a buggy content-coding (that could compress, encrypt or alter in any way the content-type bits) because the content-coding is a property of the representation;\r\n\r\n3- If the content-coding changes, the representation-data changes and the Digest validation is supposed to fail;\r\n\r\n4- In the new draft the introduction of the `id-sha-*` algorithms provide a mechanism that protects from buggy content-coding.\r\n\r\nInfrastructures delegating content-coding to reverse proxies can delegate them the digest computation too; such a reverse proxy is probably seen as an Origin Server from an User Agent.\r\n\r\nMy opinion on integrity is that intermediaries should not generally alter the content-coding (nor the content-type :P): some considerations are expressed in Semantics https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#message.transformations  where there's a hint about `Cache-control: no-trasform`.\r\n\r\n\r\n",
      "createdAt": "2020-05-26T17:46:38Z",
      "updatedAt": "2020-10-20T14:38:34Z",
      "closedAt": "2020-10-20T14:38:34Z",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@wbl thanks for the question! I think we should address it better in the spec. I stubbed a bullet-point answer: if that works for you we'll try to integrate it in the spec.\r\n\r\n",
          "createdAt": "2020-05-26T17:50:06Z",
          "updatedAt": "2020-05-26T17:50:06Z"
        },
        {
          "author": "wbl",
          "authorAssociation": "NONE",
          "body": "That works for me. I think we also should mention that it does work for Transport-Encoding compression.",
          "createdAt": "2020-05-26T21:14:38Z",
          "updatedAt": "2020-05-26T21:14:38Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is a good issue but I have a concern that it is easy to go overboard on describing a case, Transfer-encoding compression, that in practice isn't used much. \r\n\r\nValidating that the Transport-Coding didn't mangle the Content-Coding only works when a full payload has been transferred. It won't work for a partial resource. So this is a subset of a subset. \r\n\r\nI'm more inclined to simply remove the mention of protecting against \"buggy compression\" and add some other prose. For example, in the Introduction where we say\r\n\r\n> However, there are cases where relying on this alone is insufficient. An HTTP-level integrity mechanism that operates independent of transfer can be used to detect programming errors and/or corruption of data at rest, be used across multiple hops in order to provide end-to-end integrity guarantees, aid fault diagnosis across hops and system boundaries, and can be used to validate integrity when reconstructing a resource fetched using different HTTP connections.\r\n\r\nWe can augment that to say `An HTTP-level integrity mechanism that operates independent of transfer can be used to detect programming errors and/or corruption of data in flight or at rest`.\r\n\r\nThen in the section `Digest for End-to-End Integrity` we might want to add some guidance about considerations for intermediaries that want to fiddle with content and/or content-coding. CDNs ability to modify content is one of their main value propositions - we see this where new compression schemes like brotli, or new formats like WebP. With other types of intermediary, I figure that they either care to respect end-to-end headers or they don't; there's not much to enactable write about here IMO.",
          "createdAt": "2020-05-27T00:28:42Z",
          "updatedAt": "2020-05-27T00:28:42Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "## Buggy compression\r\n\r\n> remove the mention of protecting against \"buggy compression\"\r\n\r\n+1 \r\n\r\n> An HTTP-level integrity mechanism that operates independent of transfer \r\n> can be used to detect programming errors and/or corruption of data in flight or at rest\r\n\r\n+1 \r\n\r\n@LPardue can you please PR on that when you've time? No hurry :)\r\n\r\n## CDN guidance\r\n> add some guidance about considerations for intermediaries that want to fiddle\r\n> with content and/or content-coding\r\n\r\n+1. I'll PR next week.\r\n\r\nAbout CDN altering content-type and content-coding, I found this [gcloud document](https://cloud.google.com/storage/docs/transcoding) containing a caveat about integrity checks and transcoding.\r\nProbably it's the kind of caveat CDN implementors should include in their documentation when allowing users to configure those behaviors.\r\n\r\nIf the CDN does not care for integrity (eg. serving webp photos for a gallery) probably it's not needed though.",
          "createdAt": "2020-05-27T12:29:44Z",
          "updatedAt": "2020-05-27T12:31:54Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> About CDN altering content-type and content-coding, I found this gcloud document containing a caveat about integrity checks and transcoding.\r\nProbably it's the kind of caveat CDN implementors should include in their documentation when allowing users to configure those behaviors.\r\n\r\nMy intuition of the Google Cloud documentation is that this is a corner they've painted themselves into with the `x-goog-hash` header. Using Digest would actually be advantageous in such a scenario because a client can upload a compressed coding representation and include `id-sha-256`, any transcoding in the cloud won't invalidate this.\r\n\r\nBut that is tangential to the concerns of what the Digest specification needs to do.",
          "createdAt": "2020-05-27T12:53:12Z",
          "updatedAt": "2020-05-27T12:53:12Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I #1294 I replaced \"buggy compression\" with undesired Trasforming Proxies. As they are defined in {{SEMANTICS}} I think we can omit further explanations. WDYT?",
          "createdAt": "2020-10-17T17:51:36Z",
          "updatedAt": "2020-10-17T17:51:36Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed via #1294 ",
          "createdAt": "2020-10-20T14:38:34Z",
          "updatedAt": "2020-10-20T14:38:34Z"
        }
      ]
    },
    {
      "number": 1209,
      "id": "MDU6SXNzdWU2MjYzNDE0Mjg=",
      "title": "Case and dictionary/parameter keys",
      "url": "https://github.com/httpwg/http-extensions/issues/1209",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "One of the bits of feedback we got in IESG review was regarding the case sensitivity of dictionary and parameter keys. I think we dealt with the immediate issue, but it reminded me of a concern that's been in the back of my mind for a while -- that the forced-lowercase nature of these keys might be surprising and unwelcome, especially for developers who are encultured to use camelCase. \r\n\r\nThat was increased by seeing the Signatures presentation at the interim this week, where the proposal had a camelCased key, even though it was supposed to be a structured field.\r\n\r\nThe most obvious place that this would have effect is if we tried to backport `Set-Cookie` into a Structured Field, because it has a number of camelCase parameters. I had a chat with @mikewest who reassuringly pointed out that `Set-Cookie` parameters are case-insensitive, and they have tests to prove it. \r\n\r\nStill, I have a lingering concern here, and I wanted to clear it up before we publish the spec. I think the options are:\r\n\r\n1. Make editorial adjustments to make it super-clear that keys are case-forced to lowercase.\r\n\r\n2. Open up keys to allow uppercase characters, both on the wire and in the data model.\r\n\r\n3. Change the parsing algorithm to accept uppercase characters, but to force them to lowercase in the data model.\r\n\r\nIf we do (1), we can update the spec and ship it. The other options would require taking it to the mailing list, getting consensus and then updating the spec, tests and implementations.\r\n\r\nThoughts? I'm personally hovering between (1) and (3); I don't think (2) is good, in that it will make keys case-sensitive. I think the question, then, is how much appetite we have for change at this late stage.\r\n\r\n/cc @clelland @phluid61 @bsdphk ",
      "createdAt": "2020-05-28T08:59:20Z",
      "updatedAt": "2020-06-08T14:41:17Z",
      "closedAt": "2020-06-03T05:15:56Z",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see how 3) is helpful, unless you have parsing existing fields in mind.\r\n\r\n1) Works for me, so would 2).",
          "createdAt": "2020-05-28T10:08:54Z",
          "updatedAt": "2020-05-28T10:08:54Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, I recently reviewed the CTA-5004 draft for Common-Media-Client-Data which includes a request field definition. In the context of case sensitivity, it appears that document has competing statements of definition that I cherry picked below; note \"payload\" effectively means field value in this case\r\n\r\n> All information in the payload MUST be represented as `<key>=<value>` pairs.\r\n\r\n> All key names are case-sensitive.\r\n\r\n> The data payload syntax is intended to be compliant with Structured Field Values for HTTP [7].\r\n\r\nI initially raised an issue about sensitivity https://github.com/cta-wave/common-media-client-data/issues/37 without appreciating the problem with Structured Field. The issue was closed with no action with the comment \"Group consensus to maintain case-sensitivity for keys\".",
          "createdAt": "2020-05-28T12:30:48Z",
          "updatedAt": "2020-05-28T12:35:18Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm firmly for option one.",
          "createdAt": "2020-05-29T07:01:14Z",
          "updatedAt": "2020-05-29T07:01:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "(3) would be similar to how field names work in HTTP/2; it allows people to use camelCase etc. if they wish to informally, but in the data model, it's forced to be case insensitive.\r\n\r\nI don't know how successful (1) will be. That's why my preference is (3), although I can live with (1) if there's strong resistance.\r\n\r\nAnyone else with an opinion? This is the only thing preventing us from shipping.",
          "createdAt": "2020-06-01T01:18:45Z",
          "updatedAt": "2020-06-01T01:18:45Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "Well, IMHO (3) doesn't provide much value over (1) for the long term, but still requires case-insensitive processing that's more painful and error-prone.",
          "createdAt": "2020-06-01T03:22:15Z",
          "updatedAt": "2020-06-01T03:22:15Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to option (1).\r\n\r\nThere is no benefit in allowing new specifications using Structured Headers to use CamelCase. \r\n\r\nWhen converting existing header fields to Structured Headers, assuming that those existing header fields use case-insensitive names, we can require the transformation process from existing format to the Structured Headers to lower-case the names. Requiring such conversion is no more complex than dealing with case-sensitivity on the receiver side.\r\n\r\nTo put it differently, option (3) does not help supporting existing specifications, while it adds complexity when only supporting new specifications.\r\n\r\nOption (2) does help specifications that are CamelCased, but we've already agreed to not support them.",
          "createdAt": "2020-06-01T05:06:30Z",
          "updatedAt": "2020-06-01T05:06:30Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm for 1.\r\n\r\n* This is a new thing, so there's no backward compatibility issue, only old habits. \\</ivory-tower>\r\n* Keys aren't strings, they're atoms. Saying that `foo` is the same as `Foo` is kind of arbitrary, and reinforces wrong-thinking. \\</even-taller-ivory-tower>\r\n* I'm a bit \ud83d\udc4e for 3 because it's rewriting data. We rewrite invalid inputs when serialising, but the only time we break the deserialise-serialise roundtrip is to erase booleans. And it feels like erasing is less egregious than modifying.",
          "createdAt": "2020-06-01T05:10:22Z",
          "updatedAt": "2020-06-01T05:11:12Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 for 1. Moreover:\r\n\r\n- if a spec switches to structured-headers,  it should probably update keys to be lowercase.",
          "createdAt": "2020-06-01T09:48:31Z",
          "updatedAt": "2020-06-01T09:48:31Z"
        },
        {
          "author": "tigertoes",
          "authorAssociation": "NONE",
          "body": "I'm in favour of option 1 as no existing draft is mandating any keys that are uppercase, but this decision might require editorial changes to draft-ietf-httpbis-variants.\r\n\r\nFirstly, looking at all drafts that I could find that contain reference to the structured headers draft:\r\n\r\n```bash\r\n$ rsync -avz rsync.tools.ietf.org::tools.id ./id && cd id\r\n$ ag --nocolor -l -G '\\.txt$' 'I-D.ietf-httpbis-header-structure' \\\r\n\t| sed 's=-[0-9][0-9].txt==' \\\r\n\t| sort -u\r\n```\r\nThen looking at each draft at its latest version, asserting if either for a dictionary or a parameter which might be affected.\r\n\r\n|                 Draft Name                 | Dictionary? | Keys?  |\r\n|--------------------------------------------|-------------|--------|\r\n| draft-cedik-http-warning                   | \u274c |       N/A       |\r\n| draft-gruessing-sdp-http                   | \u2b55\ufe0f | Lower-case only |\r\n| draft-ietf-httpbis-bcp56bis                | \u274c |       N/A       |\r\n| draft-ietf-httpbis-cache-header            | \u2b55\ufe0f | Lower-case only |\r\n| draft-ietf-httpbis-client-hints            | \u274c |       N/A       |\r\n| draft-ietf-httpbis-proxy-status            | \u2b55\ufe0f | Lower-case only |\r\n| draft-ietf-httpbis-variants                | \u2b55\ufe0f | See below       |\r\n| draft-kazuho-httpbis-priority              | \u2b55\ufe0f | Lower-case only |\r\n| draft-nottingham-bikeshed-length           | \u274c |       N/A       |\r\n| draft-nottingham-binary-structured-headers | \u274c |       N/A       |\r\n| draft-nottingham-cache-header              | \u2b55\ufe0f | Lower-case only |\r\n| draft-nottingham-proxy-status              | \u2b55\ufe0f | Lower-case only |\r\n| draft-ohanlon-transport-info-header        | \u2b55\ufe0f | Lower-case only |\r\n| draft-pot-prefer-push                      | \u274c |       N/A       |\r\n| draft-thomson-http-mice                    | \u274c |       N/A       |\r\n| draft-thomson-protocol-freedom             | \u274c |       N/A       |\r\n| draft-west-http-state-tokens               | \u2b55\ufe0f | Lower-case only |\r\n| draft-west-lang-client-hint                | \u274c |       N/A       |\r\n| draft-west-ua-client-hints                 | \u274c |       N/A       |\r\n| draft-yasskin-http-origin-signed-responses | \u2b55\ufe0f | Lower-case only |\r\n\r\nWith regards to draft-ietf-httpbis-variants, it [defines a `sh-dict`](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-variants#section-2) and gives multiple examples with mixed casing, but also goes on to say:\r\n\r\n> Note that as always, field-name is case-insensitive.\r\n\r\nThis should be updated if consensus is made.",
          "createdAt": "2020-06-01T11:32:42Z",
          "updatedAt": "2020-06-01T11:32:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK, seems like option 1 is where people want to go.\r\n\r\nFor the record, I think this is going to confuse / surprise people no matter what we write, but hopefully implementation consistency will drive them in the right direction.",
          "createdAt": "2020-06-03T00:25:37Z",
          "updatedAt": "2020-06-03T00:25:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "See commit; if I don't hear any pushback soon, we'll ship this.",
          "createdAt": "2020-06-03T05:16:10Z",
          "updatedAt": "2020-06-03T05:16:10Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would have had a slight preference for 3), if only for consistency with field names, but I can live with 1).\r\n\r\n`Set-Cookie` might just have to be a special case; if we do redefine it as a structured field, then at that point the old syntax just gets deprecated, but like any other deprecated feature, clients will just continue to recognize it until usage drops below some threshold.\r\n\r\nOr maybe it's just one of the legacy non-structured fields. Reinterpreting old fields as structured is nice-to-have, but the goal isn't to get all of them.",
          "createdAt": "2020-06-08T14:41:17Z",
          "updatedAt": "2020-06-08T14:41:17Z"
        }
      ]
    },
    {
      "number": 1210,
      "id": "MDU6SXNzdWU2Mjc2MjIxODc=",
      "title": "Note that cookie serialisation algorithm may produce output that doesn't match cookie-string",
      "url": "https://github.com/httpwg/http-extensions/issues/1210",
      "state": "OPEN",
      "author": "gsnedders",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "Ideally we'd define server-side parsing of cookie-string (or at least recommend behaviour here for things that don't match cookie-string!), given this does cause problems for some servers (e.g. https://github.com/aio-libs/aiohttp/issues/2683).\r\n\r\nUntil then we should at least make it clear that the \"the algorithm to compute the cookie-string from a cookie store and a request-uri\" can create things that don't match cookie-string (e.g., nameless cookies after #1144). There's a number of WPT expected results that don't match cookie-string.",
      "createdAt": "2020-05-30T01:29:32Z",
      "updatedAt": "2020-06-01T01:15:27Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1211,
      "id": "MDU6SXNzdWU2MjgzMDM0NzQ=",
      "title": "digest-algorithms SHOULD be lowercase (wrt structured headers)",
      "url": "https://github.com/httpwg/http-extensions/issues/1211",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [
        "digest-headers"
      ],
      "body": "## I suggest\r\n\r\nthat digest-algorithms `SHOULD` be lowercase\r\n\r\n## Note\r\n\r\ndigest-algorithms are currently case insensitive.\r\nWe won't break specs suggesting to express them in lowercase.\r\nThis could make it easy a future transition to S-H\r\n",
      "createdAt": "2020-06-01T09:51:20Z",
      "updatedAt": "2020-09-07T15:23:58Z",
      "closedAt": "2020-09-07T15:23:58Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The encoded digest output seems like it's often case-sensitive, but it's a token, so this header won't 'fit' into Structured Fields naturally anyway. ",
          "createdAt": "2020-08-18T02:13:12Z",
          "updatedAt": "2020-08-18T02:13:12Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, so I'll close sh-related issues, though I'm still in favor of suggesting `lowercase` digest-algorithms :) ",
          "createdAt": "2020-08-18T07:48:30Z",
          "updatedAt": "2020-08-18T07:48:30Z"
        }
      ]
    },
    {
      "number": 1214,
      "id": "MDU6SXNzdWU2Mjg0OTA5OTI=",
      "title": "Ensure Signatures is independent from HTTP/1.1 + use http-core ",
      "url": "https://github.com/httpwg/http-extensions/issues/1214",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "## I expect\r\n\r\nThe spec relies only on HTTP Semantics\r\nand not on HTTP/1.1 messaging.\r\n\r\n- [ ] improve wording #1310 \r\n- [ ] switch to http-core\r\n\r\n## Notes\r\n\r\nCheck all references to Messaging and consider replacing them using Semantic.\r\n\r\nSee https://github.com/httpwg/http-core/pull/362/files",
      "createdAt": "2020-06-01T14:43:27Z",
      "updatedAt": "2020-10-24T22:55:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@richanna @jricher @reschke I was re-reading the spec after the more recent filed issues, and I think that switching this draft to HTTP Core terminology (eg. I-D.ietf-httpbis-semantics ) we could have a more consistent background for taking the right decisions about things like transformations, intermediaries.\r\n\r\n",
          "createdAt": "2020-10-24T22:54:34Z",
          "updatedAt": "2020-10-24T22:54:34Z"
        }
      ]
    },
    {
      "number": 1215,
      "id": "MDU6SXNzdWU2Mjg0OTE0NDc=",
      "title": "Ensure digest is independent from http/1.1",
      "url": "https://github.com/httpwg/http-extensions/issues/1215",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nDigest to be indepentent from http/1.1 (messaging)\r\n\r\nSee https://github.com/httpwg/http-core/pull/362/files",
      "createdAt": "2020-06-01T14:44:08Z",
      "updatedAt": "2020-08-17T13:17:42Z",
      "closedAt": "2020-08-17T13:17:42Z",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke iiuc the only MESSAGING-depending parts is:\r\n\r\n- https://github.com/httpwg/http-extensions/blob/master/draft-ietf-httpbis-digest-headers.md#usage-in-trailers\r\n\r\nThe spec references the term \"message body\" 3 times too, which is defined in MESSAGING.\r\nDo you think we should replace it?\r\nHow would you do it?",
          "createdAt": "2020-08-04T08:17:01Z",
          "updatedAt": "2020-08-04T08:17:30Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "trailers: you may want to reference https://greenbytes.de/tech/webdav/draft-ietf-httpbis-semantics-latest.html#trailer.fields\r\n\r\nmessage body: this might be \"payload\" (https://greenbytes.de/tech/webdav/draft-ietf-httpbis-semantics-latest.html#payload)\r\n",
          "createdAt": "2020-08-04T13:56:29Z",
          "updatedAt": "2020-08-04T13:58:38Z"
        }
      ]
    },
    {
      "number": 1216,
      "id": "MDU6SXNzdWU2MzEyODgzODc=",
      "title": "What signals are subsumed by priority hints?",
      "url": "https://github.com/httpwg/http-extensions/issues/1216",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "The last [email to the list](https://www.w3.org/mid/CALGR9obRjBSADN1KtKF6jvFVzNS1+JzaS0D0kCVKHKkd4sn+MQ@mail.gmail.com) makes it quite clear that request ordering is still a useful signal about priority that can be combined with the proposed new field.  That is, a server can use both explicit signals AND the order of requests to determine how it prioritizes responses.\r\n\r\n(For this, we should probably clarify that it is stream ID - as an indicator of when the request was sent - and not when the request is received that matters.  That creates some interesting side effects for intermediaries though.  If a proxy receives requests out of order, but then forwards them in a different order, does that alter or suppress an otherwise useful signal?)\r\n\r\nWhat isn't clear from the draft is how other signals that were historically used for prioritization might be either used in combination with explicit signals or are rendered invalid by the priority signal being present.  The obvious one is the h2 PRIORITY frame, which I assume has to be superseded.  \r\n\r\nFor instance, can a server that would ordinarily use media type to prioritize requests still do so when the priority signals don't indicate clear preferences?  Or does that server have to use only request order and explicit priority signals?\r\n\r\nTo be clear, this isn't about \"have to\" or \"MUST\", but more about what expectations we set for clients.",
      "createdAt": "2020-06-05T03:43:03Z",
      "updatedAt": "2020-09-30T12:02:46Z",
      "closedAt": "2020-09-30T12:02:46Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That is, a server can use both explicit signals AND the order of requests to determine how it prioritizes responses.\r\n\r\nI think this is a good observation. Stream ordering's role in how a server allocates resources is a bit buried. I think promoting it will help towards some of this discussion, so lets make a PR to do that. Personally, I see that as a property of the client-server connection with no need to recommend forward action. IMO whether the server has to fetch the file from a remote backend or just read it from a cache, there is no one-size-fits all answer.\r\n\r\nSo far our approach has been to adopt HTTP/2's general \"expressing priority is only a suggestion\" sentiment.  HTTP/2 does, while explaining the mechanics of trees, state how an implementation should allocate resources to them. We describe expectations for urgency and increment without normative language, generally leaning to making no recommendations. \r\n\r\n> What isn't clear from the draft is how other signals that were historically used for prioritization might be either used in combination with explicit signals or are rendered invalid by the priority signal being present. The obvious one is the h2 PRIORITY frame, which I assume has to be superseded.\r\n\r\nWe do spend some text explaining the more complicated case in H2 where SETTINGS is needed to disable tree-priorities, and how a client might send both signals until then. A client could expect either scheme to take effect until then, maybe we can spell that out.\r\n\r\n> For instance, can a server that would ordinarily use media type to prioritize requests still do so when the priority signals don't indicate clear preferences? Or does that server have to use only request order and explicit priority signals?\r\n\r\nSo https://httpwg.org/http-extensions/draft-ietf-httpbis-priority.html#merging does say something like \"the client could be wrong because the server might have additional information\". This is mainly to describe how to merge client and server extensible priority signals. But I think it holds true for something such as learning the content-type after receiving a request for \"accept: image/*\". I'm not sure how extensible priorities makes this situation any different than today.\r\n\r\nWithout formal definition of other signals, it seems hard to predict how an implementation might decide their order of importance. \r\nI wonder if this is issue is really identifying that \r\nI'm not so sure how to address \"other signals\" such as this because it doesn't seem covered by anything in HTTP/2, nor anywhere else really. We do provide text that explains how a proxy might respond to client and origin server extensible priority signals,\r\n\r\n",
          "createdAt": "2020-07-06T14:26:07Z",
          "updatedAt": "2020-07-06T14:26:07Z"
        },
        {
          "author": "jonglezb",
          "authorAssociation": "NONE",
          "body": "It would make sense to give examples of signals that the server could use to make a scheduling decision (and of course, stress that this is non-exhaustive). For instance: content length, media type, request order, but people might find other interesting signals.\r\n\r\nSince the priority hints sent by the client are, well, just hints, the server should be allowed to override them if it has a good reason.\r\n\r\nTo some extent, section \"Merging Client- and Server-Driven Parameters\" already lists some signals _and_ allows the server to override the client hints. It would benefit from having a section to itself, dedicated to give guidance on how a server can make its scheduling decision. The \"Merging\" section would then just describe how to deal with the resulting inconsistencies between client and server priorities.",
          "createdAt": "2020-08-31T13:24:30Z",
          "updatedAt": "2020-08-31T13:24:30Z"
        }
      ]
    },
    {
      "number": 1217,
      "id": "MDU6SXNzdWU2MzEzMDMzOTE=",
      "title": "Fairness section isn't a security consideration",
      "url": "https://github.com/httpwg/http-extensions/issues/1217",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [
        "priorities"
      ],
      "body": "The whole discussion about fairness is worth having, but it doesn't really go to the usual security concerns.  Security concerns might cover things like DoS through over-use of prioritization (see #1021), or use of priority to starve others (which might cross-reference the fairness text).  But I think that the fairness text should be bumped up to the top level.",
      "createdAt": "2020-06-05T04:31:52Z",
      "updatedAt": "2020-07-13T00:23:39Z",
      "closedAt": "2020-07-13T00:23:39Z",
      "comments": []
    },
    {
      "number": 1218,
      "id": "MDU6SXNzdWU2MzEzMDM3Mjc=",
      "title": "Local scheduling decisions",
      "url": "https://github.com/httpwg/http-extensions/issues/1218",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [
        "priorities"
      ],
      "body": "The text in [Section 7.1.3](https://httpwg.org/http-extensions/draft-ietf-httpbis-priority.html#intentional-introduction-of-unfairness) about the client using priority to inform request scheduling is a good one, but it belongs elsewhere.",
      "createdAt": "2020-06-05T04:33:05Z",
      "updatedAt": "2020-07-13T01:02:58Z",
      "closedAt": "2020-07-13T01:02:58Z",
      "comments": []
    },
    {
      "number": 1221,
      "id": "MDU6SXNzdWU2NDEwODI2NTg=",
      "title": "duplicate digest-algorithms in field value",
      "url": "https://github.com/httpwg/http-extensions/issues/1221",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nTo clarify usage of duplicate algorithms, eg. with different parameters\r\n\r\n## Instead\r\n\r\nIt is not specified\r\n\r\n## Note\r\n\r\nRFC3230 does not forbid duplicate digest-algorithm in field value, because the receiver MAY ignore one or more representation-digest eg:\r\n\r\n```\r\nDigest: sha-256=bxxx.., sha-256=axxx...\r\n```\r\n\r\n[multihash](https://multiformats.io/multihash/#examples) encodes the algorithm and its parameters inside the string, and this is a use-case for duplicate digest-algorithms. This behavior is not in line with S-F though. \r\n\r\n```\r\nDigest: mh=fafafaf, mh=fbfbfbf\r\n```\r\n\r\nIn case of digest-algorithms with parameters, this is more complex. The following valid example shows a duplicate digest-algorithm `bs` with two different parameter values.\r\n\r\n```\r\nDigest: bs=axxx; p=1,    bs=bxxx; p=2\r\n```\r\n\r\n\r\nDo we need an example for that?\r\nWhich is a suitable way to define it using structured fields/headers?\r\n\r\n@LPardue ",
      "createdAt": "2020-06-18T10:09:48Z",
      "updatedAt": "2020-10-17T17:18:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is tightly coupled with the parameter discussion on #850. ",
          "createdAt": "2020-08-13T13:37:20Z",
          "updatedAt": "2020-08-13T13:37:20Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Forbidding parameters would fix this.",
          "createdAt": "2020-08-17T09:58:31Z",
          "updatedAt": "2020-08-17T09:58:31Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@msporny do you see any drawback in this? PTAL :) ",
          "createdAt": "2020-09-08T16:43:01Z",
          "updatedAt": "2020-09-08T16:43:01Z"
        },
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "Multihash doesn't have any parameter use cases that I can think of since you're supposed to encode all of those parameters via the multihash header. That is, it's always one multibase encoded multihash-header plus value. Multihash specifically would be fine w/ forbidding parameters.\r\n\r\nIt does raise the question on what happens if multiple multihash values are expressed. They would probably all be valid... one is a sha-256, one is a blake2b-32, etc. So, there is a strong use case for multiple \"duplicate\" \"mh\" digest algorithms (without parameters).\r\n\r\nI can't comment on other hash expression schemes as it's not an area with which I'm an expert.\r\n\r\nDoes that help, @ioggstream?",
          "createdAt": "2020-09-08T18:22:29Z",
          "updatedAt": "2020-09-08T18:22:29Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@msporny thanks for your feedback!\r\n\r\n> Multihash specifically would be fine w/ forbidding parameters.\r\n\r\nOk!\r\n\r\n> ... if multiple multihash values are expressed. They would probably all be valid\r\n\r\nThat is fine with the current Digest definition, but does not fit with structured-fields where every token is an unique keyword.\r\nSeems that a future transition to a S-F scheme has many points to tackle...\r\n\r\nA solution could be the following (but I suggest you to get in touch with people working on SF):\r\n\r\n- digest-algorithms that supports multiple digest-value should be declared;\r\n- in that case, those algorithms can be serialized as an InnerList;\r\n- `mh` digest-algorithm should be serialized as a sf-item or sf-itemlist\r\n- we should *extend* the serialization of digest-algorithms to support double quotes or bytes...\r\n\r\n\r\nexample\r\n\r\n```\r\nDigest: sha-256=\"xxx\", sha-512=\"yyy\", mh=(\"zzz\" \"qqq\")\r\n```\r\n",
          "createdAt": "2020-09-09T08:02:33Z",
          "updatedAt": "2020-09-09T10:10:51Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As of now it's ok having duplicates, as that depends on the digest-algorithm. We could at most spend a couple of words on the subject in the security considerations (eg if one receives multiple values for  `sha-256`, ..)",
          "createdAt": "2020-10-17T17:18:50Z",
          "updatedAt": "2020-10-17T17:18:50Z"
        }
      ]
    },
    {
      "number": 1227,
      "id": "MDU6SXNzdWU2NTc5Mzc4NjE=",
      "title": "TLS [Untrusted, Expired] Peer Certificate",
      "url": "https://github.com/httpwg/http-extensions/issues/1227",
      "state": "CLOSED",
      "author": "mnot-fastly",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "proxy-status"
      ],
      "body": "Looking at what to map x509 errors (as returned by [openssl](https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get_error.html) into, the most obvious one is `tls_untrusted_peer_certificate`. \r\n\r\nHowever, there's also `tls_expired_peer_certificate`, which is one of these errors. It seems odd to have these two, but not any of the many other verification errors.\r\n\r\nAt first glance, I suspect it may be better to have a single `tls_peer_certificate_verification` error, and let the `detail` convey the reason - whether it's expiration or something else.",
      "createdAt": "2020-07-16T07:36:46Z",
      "updatedAt": "2020-08-11T02:22:30Z",
      "closedAt": "2020-08-11T02:22:30Z",
      "comments": [
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ultimately, there is a fine balance between providing a generic \"catch-all\" error, and enumerating all possible errors.\r\n\r\nThe linked [OpenSSL man page](https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get_error.html) lists 69 possible reasons for success or failure, and including all of them clearly doesn't make sense, especially when only a few of them will happen in practice.\r\n\r\nHowever, having only a generic \"catch-all\" error with the real reason \"hidden\" in a free-form text in `details`, that's going to vary from implementation to implementation, is going to make this less useful for any kind of automated processing and/or analysis.\r\n\r\nIdeally, I think, we should have specific enums that cover 95%+ of reasons happening in production, and only use the generic \"catch-all\" error for things not covered by them... So, playing the devil's advocate, perhaps we should add a few more?\r\n\r\n(Note that there is already `tls_unexpected_peer_certificate` raised on mismatched identity, SHA256, SPKI or other missed expectations.)\r\n\r\nAlso, if you can get your hands on errors happening in production, that could help us make more informed decision here.",
          "createdAt": "2020-07-21T22:57:29Z",
          "updatedAt": "2020-07-21T22:57:29Z"
        },
        {
          "author": "mnot-fastly",
          "authorAssociation": "NONE",
          "body": "I agree we shouldn't do a  1:1 mapping (especially with a library), but the hierarchy needs to be clear, and mapped to terminology used in the standards. I.e., there should be a generic catch-all 'cert error' code, and then more specific ones for the major classes of problems.",
          "createdAt": "2020-07-24T07:21:59Z",
          "updatedAt": "2020-07-24T07:21:59Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "TLS itself also contains a pile of certificate-verification-related alerts. Although I think the set is mostly just carried over from SSL.\r\nhttps://tools.ietf.org/html/rfc8446#section-6.2\r\n\r\n```\r\n   bad_certificate:  A certificate was corrupt, contained signatures\r\n      that did not verify correctly, etc.\r\n\r\n   certificate_revoked:  A certificate was revoked by its signer.\r\n\r\n   certificate_expired:  A certificate has expired or is not currently\r\n      valid.\r\n\r\n   certificate_unknown:  Some other (unspecified) issue arose in\r\n      processing the certificate, rendering it unacceptable.\r\n\r\n   unknown_ca:  A valid certificate chain or partial chain was received,\r\n      but the certificate was not accepted because the CA certificate\r\n      could not be located or could not be matched with a known trust\r\n      anchor.\r\n\r\n   access_denied:  A valid certificate or PSK was received, but when\r\n      access control was applied, the sender decided not to proceed with\r\n      negotiation.\r\n\r\n   certificate_required:  Sent by servers when a client certificate is\r\n      desired but none was provided by the client.\r\n```\r\n\r\n@sleevi may also have some thoughts on certificate verification error-reporting.",
          "createdAt": "2020-07-24T15:27:57Z",
          "updatedAt": "2020-07-24T15:27:57Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Despite what libraries may provide, for their developers, [RFC 5280](https://tools.ietf.org/html/rfc5280) is fairly clear: the only defined result is a [boolean value](https://tools.ietf.org/html/rfc5280#section-6.1.6)\r\n\r\nI think coupling any protocol-level expectation about diagnostics for errors is fundamentally misaligned. It should not matter, for example, whether a particular library checks the validity period of the certificate before the signature. We know, empirically, that different libraries do very different things there: macOS vs Mozilla NSS vs Microsoft CryptoAPI each verify something like validity at different points within their verification algorithms.\r\n\r\nWe know it's deeply flawed to view there being \"the\" certificate chain for a server, because by definition, the chain is defined by the client's policy and set of trust anchors. As a consequence, we know that clients SHOULD implement certificate path building, to explore possible certificate chains, and we know that TLS 1.3 was explicitly updated to reflect those decades of running code and the emergent rough consensus that the `Certificate` message, beyond the first `Certificate`, is an attempt to aid/influence that.\r\n\r\n[RFC 4158](https://tools.ietf.org/html/rfc4158) is a huge collection of different ways verifiers can process and examine errors, during forward path building and reverse verification, and notes that the trade-offs are heavily dependent upon client and use cases.\r\n\r\nWhile I can understand the appeal for providing 'informational' statuses, any suggestion beyond a level of `MAY` is probably too normative, and unsupported by the underlying specifications and best practices.",
          "createdAt": "2020-07-24T15:41:52Z",
          "updatedAt": "2020-07-24T15:41:52Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@sleevi the context here is a CDN or other reverse proxy reporting back errors in HTTP response headers, for debugging. There are no requirements around sending them (and senders are cautioned against leaking information that could aid an attacker).\r\n\r\nSo, at one end a Boolean doesn't really help, and at the other end, the full list of errors by any one library (or all of them) is impractical. \r\n\r\nThe list of alerts from @davidben seems promising, and I note that we already have [tls_error](https://httpwg.org/http-extensions/draft-ietf-httpbis-proxy-status.html#tls-error), whose value can be any TLS Alert string. However, That's intended to convey alerts _received_ (and perhaps we should communicate that more clearly). \r\n\r\nThe desired semantics here are that the problem indicated by the alert is generated _in the client itself_, not received by it. \r\n\r\nThat leads me to believe that there are two viable paths forward:\r\n\r\n1. Rearrange the `tls_*` errors so that they mirror the alerts above (leaving `tls_error`'s semantic as stated above); e.g., we'd have `tls_bad_certificate`, `tls_certificate_revoked`, `tls_certificate_unknown` and so forth\r\n\r\n2. Reduce everything into two errors, `tls_error_received` and `tls_error_generated` or similar. Both would carry the TLS Alert value as an additional payload item.\r\n\r\nI think the difference is mostly stylistic, so @PiotrSikora and I can figure that out. The bigger question is whether this is the right set of errors to focus upon.",
          "createdAt": "2020-07-27T03:57:45Z",
          "updatedAt": "2020-07-27T03:57:45Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> So, at one end a Boolean doesn't really help, and at the other end, the full list of errors by any one library (or all of them) is impractical.\r\n\r\nBut I think this is missing an important detail: from the perspective of a client, the only stable output is the boolean. For example, OpenSSL's reporting of errors is symptomatic of deeper flaws within its certificate verification; fixing those errors necessarily means some existing errors can't effectively be reported. This is covered at some length in [RFC 4158, Section 3.2](https://tools.ietf.org/html/rfc4158#section-3.2).\r\n\r\nUltimately, the set of errors that are relevant are, to an extent, subject to local policy: it's rare for certificate validators to think of errors in the ontology laid out by the TLS layer. Typically, a client just does a \"best guess\" (or just maps straight to `bad_certificate`) when trying to map to the TLS layer, in part so it doesn't disclose extra information. This is certainly true when you think about local policy, such as limits on validity or the requirement of associated metadata, potentially delivered over TLS, such as Certificate Transparency or OCSP Must-Staple.\r\n\r\nI think the core question is whether you expect the client and the proxy to be in the same management domain. If they aren't, and the ED seems to be oriented around this scenario (where server and proxy are likely same administrative domain, but proxy and client aren't), then it seems better served as an opaque diagnostic string. As RFC 4158 calls out, beyond the 'boolean' is really just an administrative/diagnostic capability, not something meant to be semantically rich, meaningful, or stable, and certainly not to allow next-hop policy decision making.",
          "createdAt": "2020-07-27T04:11:33Z",
          "updatedAt": "2020-07-27T04:11:33Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Just to be clear - the user agent isn't involved in this at all, beyond receiving the header so as to make it available to someone diagnosing a problem (Likely someone from the origin, from the CDN/reverse proxy operator, and/or a help desk talking to an end user).\r\n\r\nWhat I think I hear you saying is that we should define a generic error and allow implementations to convey textual detail in it. Does that make sense? \r\n\r\nI also still see some value in distinguishing a TLS alert received from the origin by the proxy (in its role as TLS client) from this case (a problem it encounters *as* a TLS client).",
          "createdAt": "2020-07-27T05:22:58Z",
          "updatedAt": "2020-07-27T05:22:58Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> What I think I hear you saying is that we should define a generic error and allow implementations to convey textual detail in it. Does that make sense?\r\n\r\nYes. This matches with Criterion 2 of https://tools.ietf.org/html/rfc4158#section-2.2 and the dual mode trade-off in https://tools.ietf.org/html/rfc4158#section-3.2 , which perhaps more clearly highlights the local policy aspect (\"Ultimately, the developer determines how to handle the trade-off between efficiency and provision of information\").\r\n\r\n> I also still see some value in distinguishing a TLS alert received from the origin by the proxy (in its role as TLS client) from this case (a problem it encounters _as_ a TLS client).\r\n\r\n100% agreed here. I was only commenting to the extent at which the proxy validates the peer certificate independent of the TLS layer framing. Perhaps poorly stated, but my comment in https://github.com/httpwg/http-extensions/issues/1227#issuecomment-664108708 was trying to capture that Option 2 from https://github.com/httpwg/http-extensions/issues/1227#issuecomment-664105951 (`tls_error_generated`) would likely just reduce to a boolean anyways, in a well-behaved TLS client.",
          "createdAt": "2020-07-27T06:08:56Z",
          "updatedAt": "2020-07-27T06:08:56Z"
        }
      ]
    },
    {
      "number": 1228,
      "id": "MDU6SXNzdWU2NTc5MzkzODI=",
      "title": "Make it more clear what to do with read and write errors",
      "url": "https://github.com/httpwg/http-extensions/issues/1228",
      "state": "CLOSED",
      "author": "mnot-fastly",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "proxy-status"
      ],
      "body": "Right now the likely candidates are `connection_terminated` and `http_incomplete_response`, but it's not obvious, and also this depends on the implementation knowing whether the response has started yet or not -- which may be difficult to retrofit onto an existing implementation. ",
      "createdAt": "2020-07-16T07:38:54Z",
      "updatedAt": "2020-07-24T07:23:26Z",
      "closedAt": "2020-07-24T07:23:25Z",
      "comments": [
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, proxies must know that anyway, since if the response has already started and HTTP headers were already sent, then the only way to transmit this information in `Proxy-Status` is via HTTP trailers.",
          "createdAt": "2020-07-21T23:18:52Z",
          "updatedAt": "2020-07-21T23:18:52Z"
        },
        {
          "author": "mnot-fastly",
          "authorAssociation": "NONE",
          "body": "Ah, good point - never mind.",
          "createdAt": "2020-07-24T07:23:25Z",
          "updatedAt": "2020-07-24T07:23:25Z"
        }
      ]
    },
    {
      "number": 1229,
      "id": "MDU6SXNzdWU2NTc5Mzk4OTM=",
      "title": "Proxy configuration error",
      "url": "https://github.com/httpwg/http-extensions/issues/1229",
      "state": "CLOSED",
      "author": "mnot-fastly",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "proxy-status"
      ],
      "body": "Right now the only way to indicate bad configuration is `proxy_internal_error`, which isn't terribly helpful.",
      "createdAt": "2020-07-16T07:39:40Z",
      "updatedAt": "2020-08-04T05:05:17Z",
      "closedAt": "2020-08-04T05:05:17Z",
      "comments": [
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Could you elaborate on the use case here? I think `proxy_internal_error` should be fine for misconfiguration errors that we don't want to advertise (e.g. fleet-wide misconfiguration that broke the Internet), but perhaps we could use something else for customer-provided configuration that breaks proxying for a specific hostname? Is that what you had in mind?",
          "createdAt": "2020-07-21T23:00:49Z",
          "updatedAt": "2020-07-21T23:00:49Z"
        },
        {
          "author": "mnot-fastly",
          "authorAssociation": "NONE",
          "body": "Yes, exactly.",
          "createdAt": "2020-07-24T07:22:49Z",
          "updatedAt": "2020-07-24T07:22:49Z"
        }
      ]
    },
    {
      "number": 1230,
      "id": "MDU6SXNzdWU2NTc5NDAzMTI=",
      "title": "Missing server certificate",
      "url": "https://github.com/httpwg/http-extensions/issues/1230",
      "state": "CLOSED",
      "author": "mnot-fastly",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "proxy-status"
      ],
      "body": "for parity with other errors",
      "createdAt": "2020-07-16T07:40:16Z",
      "updatedAt": "2020-07-24T07:22:34Z",
      "closedAt": "2020-07-24T07:22:34Z",
      "comments": [
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't believe that this can happen at the TLS level (i.e. talking to a TLS server without a certificate).",
          "createdAt": "2020-07-21T22:35:24Z",
          "updatedAt": "2020-07-21T22:35:24Z"
        },
        {
          "author": "mnot-fastly",
          "authorAssociation": "NONE",
          "body": "Will have to double-check (I came across it as a distinct error code), but #1227 probably makes this unnecessary. Closing. ",
          "createdAt": "2020-07-24T07:22:34Z",
          "updatedAt": "2020-07-24T07:22:34Z"
        }
      ]
    },
    {
      "number": 1231,
      "id": "MDU6SXNzdWU2NjEyMzY5NTg=",
      "title": "Escape valve for implementation-specific info",
      "url": "https://github.com/httpwg/http-extensions/issues/1231",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "cache-header"
      ],
      "body": "`details` or similar; maybe an inner-list?",
      "createdAt": "2020-07-20T01:19:16Z",
      "updatedAt": "2020-08-04T07:19:23Z",
      "closedAt": "2020-08-04T07:19:23Z",
      "comments": []
    },
    {
      "number": 1232,
      "id": "MDU6SXNzdWU2NjMyMTMxNjY=",
      "title": "Nice to have guidance about reponding to priority signals when received",
      "url": "https://github.com/httpwg/http-extensions/issues/1232",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "On https://lists.w3.org/Archives/Public/ietf-http-wg/2020JulSep/0063.html @ekinnear provided some feedback:\r\n\r\n> For the document as a whole, we\u2019ve gotten some feedback internally that it would be really nice if there were some (minimal, recommendation only) guidance as to how to respond to the priority signals when received. This wouldn\u2019t be restrictive, as we\u2019re really excited to experiment here and see what awesome results we can achieve, but having a baseline of \u201cimplement this as written and you\u2019ll do okay\u201d might be worth considering to increase the likelihood that we have a large group of generally-performant implementations.\r\n> \r\n> An example here would be if two requests of the same urgency arrive back-to-back, the first with the incremental bit set and the second without. What gets sent when? What do you do next if a third request arrives with the incremental bit also set before the first is complete? There are lots and lots of permutations, but a general approach of handling new items coming in is something that I think we\u2019ve all been imagining during discussions, but we haven\u2019t really written it down explicitly. Internally, as we discussed with some folks new to the topic, we discovered that our imaginations of what to do in cases like these didn\u2019t actually align as well as we thought.\r\n\r\nI'm wondering how much this crosses over with https://github.com/httpwg/http-extensions/issues/1216, and how the editors might choose to address this feedback.",
      "createdAt": "2020-07-21T18:15:51Z",
      "updatedAt": "2020-09-30T12:04:49Z",
      "closedAt": "2020-09-30T12:04:48Z",
      "comments": [
        {
          "author": "guoye-zhang",
          "authorAssociation": "NONE",
          "body": "I think everyone is in agreement how it should work if everything is incremental (round-robin), or everything is non-incremental (sequential delivery). The question is when they are mixed at the same urgency level.\r\n\r\nOur goal is that client can signal incremental whenever it make sense without worrying about regressions. Let's imagine two cases:\r\n\r\n1. At the same urgency level, a huge non-incremental file download has started, then a small incremental resource is requested.\r\n2. At the same urgency level, an incremental hanging GET is waiting for response, while a non-incremental file download is requested.\r\n\r\nMany proposed solutions would severely regress these cases, delaying delivery of resources or keeping the connection idle.",
          "createdAt": "2020-07-24T20:38:06Z",
          "updatedAt": "2020-07-24T20:38:52Z"
        },
        {
          "author": "guoye-zhang",
          "authorAssociation": "NONE",
          "body": "A solution I want to propose to always perform round robin: For example, if there are 2 incremental loads and 3 non-incremental loads at the same urgency level, we perform round robin with 5 slots, 1 for each incremental load, and the remaining 3 for the first non-incremental load that has data available.\r\n\r\nThis generalizes the model and would be least disruptive in my opinion.",
          "createdAt": "2020-07-24T20:38:26Z",
          "updatedAt": "2020-07-24T20:38:26Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If everything is served round-robin, then there is no point having an increment distinguisher. Or am I missing something?",
          "createdAt": "2020-07-24T20:53:43Z",
          "updatedAt": "2020-07-24T20:53:43Z"
        },
        {
          "author": "guoye-zhang",
          "authorAssociation": "NONE",
          "body": "Non-incremental stream is handled differently in my suggested round-robin scheme. I'll describe example above in more detail:\r\n\r\n5 streams at the same urgency level. Stream 0, 1, 2 are non-incremental, stream 3, 4 are incremental.\r\n\r\nWe would have 5 slots, 3 of which is dedicated to the first non-incremental stream with data available, which is stream 0. Other two slots are for stream 3 and 4.\r\n\r\nLet's stream 0 is blocked waiting for server application to generate data. All its 3 slots would be used by the next non-incremental stream in the queue which is stream 1.\r\n\r\nThis round-robin scheme degenerates into sequential delivery when all streams are non-incremental, and degenerates into regular round-robin when all streams are incremental.",
          "createdAt": "2020-07-25T19:04:10Z",
          "updatedAt": "2020-07-25T19:04:10Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This sounds a bit like Pat Meenan's scheme, which we decided we didn't\nneed. It does differ in so far as being an implementation choice rather\nthan a signal.\n\nWhen you say slots are you thinking time or bytes?\n\nWould it be better to send incremental streams first?\n\nOn Sat, 25 Jul 2020, 20:04 Guoye Zhang, <notifications@github.com> wrote:\n\n> Non-incremental stream is handled differently in my suggested round-robin\n> scheme. I'll describe example above in more detail:\n>\n> 5 streams at the same urgency level. Stream 0, 1, 2 are non-incremental,\n> stream 3, 4 are incremental.\n>\n> We would have 5 slots, 3 of which is dedicated to the first\n> non-incremental stream with data available, which is stream 0. Other two\n> slots are for stream 3 and 4.\n>\n> Let's stream 0 is blocked waiting for server application to generate data.\n> All its 3 slots would be used by the next non-incremental stream in the\n> queue which is stream 1.\n>\n> This round-robin scheme degenerates into sequential delivery when all\n> streams are non-incremental, and degenerates into regular round-robin when\n> all streams are incremental.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/httpwg/http-extensions/issues/1232#issuecomment-663889717>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ABSELNKA7Q5ZNHX4FY2S4YLR5MUDNANCNFSM4PD3T6VA>\n> .\n>\n",
          "createdAt": "2020-07-25T19:57:12Z",
          "updatedAt": "2020-07-25T19:57:12Z"
        },
        {
          "author": "guoye-zhang",
          "authorAssociation": "NONE",
          "body": "> When you say slots are you thinking time or bytes?\r\n\r\nIn ideal conditions, time and bytes are equivalent. I think whatever definition of \"slot\" implementations are using in plain round robin scheme would work, so I don't have a preference.\r\n\r\n> Would it be better to send incremental streams first?\r\n\r\nThat would work if it solves the second scenario I described above (incremental hanging GET followed by non-incremental file download).\r\n\r\nHowever, it creates unfairness between incremental and non-incremental streams. I think the goal is that client can opt in to non-incremental whenever it makes sense. For example, if JSON responses can only be processed after received in full, they can be marked non-incremental; images can be rendered progressively, so they are incremental. But it's not our intention that images preempt JSON.",
          "createdAt": "2020-07-25T20:43:33Z",
          "updatedAt": "2020-07-25T20:43:33Z"
        },
        {
          "author": "guoye-zhang",
          "authorAssociation": "NONE",
          "body": "Where I'm coming from is that we own a client API, and we have convenience mode where you receive the entire response in one callback, and advanced mode where you receive data in chunks. We currently automatically opt in to non-incremental delivery when convenience mode is used. However, that wouldn't be safe if this causes any unfairness.",
          "createdAt": "2020-07-25T20:56:56Z",
          "updatedAt": "2020-07-25T20:56:56Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding how to handle mixture of incremental and non-incremental requests, I think there could be various strategies that can be adopted.\r\n\r\nTo give an example, as stated in https://github.com/kazuho/draft-kazuho-httpbis-priority/issues/94#issuecomment-572032461, when the server knows that the first few bytes of the responses are more important than the remainder (consider progressive JPEG), it makes sense for the server to send the first few bytes of those responses before other non-incremental responses.\r\n\r\nOr, when the server knows that the response cannot be processed incrementally, there is no reason for the server to interleave some bytes of that response with others. A prominent example of such response is a zip file. A zip file cannot be processed until it is completely downloaded, because the central directory exists at the end of the file.\r\n\r\nConsidering these examples, I tend to think that recommending one behavior would not be very helpful. Priorities indicated by clients are merely hints, my preference goes to allowing servers to do whatever they think are beneficial, using various hints where the extensible priorities being _one_ of them.",
          "createdAt": "2020-07-28T14:52:27Z",
          "updatedAt": "2020-07-28T14:54:41Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I better understand @guoye-zhang's concern. I'll attempt a PR that describes the general problem in order to inform readers of pitfalls and recommend they avoid them. I don't think we want to be specific about how to do that. ",
          "createdAt": "2020-07-28T19:01:38Z",
          "updatedAt": "2020-07-28T19:01:38Z"
        },
        {
          "author": "guoye-zhang",
          "authorAssociation": "NONE",
          "body": "I think there is still value in providing an example algorithm. The problem is nuanced enough that it'd be difficult to address all corner cases in a first attempt. The algorithm I proposed does not depend on any server heuristics of content type or even content length. It provides a low bar of \"you'd be fine if you don't want to think about it and just implement this\". You can totally discard it and implement whatever heuristics you want since it's just a hint, but it should be at least as good as this.",
          "createdAt": "2020-07-29T07:26:22Z",
          "updatedAt": "2020-07-29T07:26:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In my experience, many implementers will just assume an example is the correct single solution. If clients assume too much about servers behaving a certain way, it can cause problems. \r\n\r\nWe have little broad data to back it up athink it is single recommendation, which worries me. I  better to highlight the nuances and pitfalls.",
          "createdAt": "2020-07-29T09:10:43Z",
          "updatedAt": "2020-07-29T09:10:43Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What @LPardue says. If we are to suggest some type of logic, it has to work well across the board.\r\n\r\nI see at least three logics being discussed in this issue, that are to be used when the only hint given to the server is the extensible priority signals:\r\n1. divide the bandwidth between incremental and non-incremental responses based on their numbers (https://github.com/httpwg/http-extensions/issues/1232#issuecomment-663724301)\r\n2. serve incremental responses first, then the non-incremental ones (https://github.com/httpwg/http-extensions/issues/1232#issuecomment-663896182)\r\n3. first few bytes of incremental responses are given priority above non-incremental requessts, the remainders are given lower precedence (https://github.com/kazuho/draft-kazuho-httpbis-priority/issues/94#issuecomment-572032461, linked from https://github.com/httpwg/http-extensions/issues/1232#issuecomment-665087636)\r\n\r\nAssuming that the goal of prioritization is to maximize the amount of meaningful output provided to the user at earlier moments, both (1) and (2) have downsides.\r\n\r\nThe problem with (1) is that it devotes some bandwidth to non-incremental responses when incremental responses are inflight. During the early stages of a connection, spending all available bandwidth on incremental responses is beneficial, because a server can assume that sending *some* portion of the response provides benefit to the user, if that response can be processed incrementally. To give an example, sending 10% of 5 incremental responses is better than sending 50% of a non-incremental response.\r\n\r\nIn contract, (2) suffers during the mid stages of a connection, because it significantly delays the transfer of non-incremental responses. As an example, when a non-incremental response carrying a JSON file and an incremental response carrying a progressive JPEG image is competing at the same urgency level, it is natural to assume that completing the transfer of the JSON file is more important than completing the transfer of the progressive JPEG image.\r\n\r\nAs can be seen, my point is that the significant of sending a byte changes during the stages of a connection, or between the byte ranges of each response, if the response is incremental. That is why I tend to prefer (3), though the downside is that the logic is bit complex.\r\n\r\nAnd going back to my previous point, this whole discussion is about servers not using other knowledge that are likely to be available. It could well be the case that the server could make better decision, had it been given the knowledge that the application has.\r\n\r\nThat's why I tend to think that suggesting pitfalls (and the possibility of using other signals) is the answer here.",
          "createdAt": "2020-07-29T23:46:37Z",
          "updatedAt": "2020-07-29T23:46:37Z"
        },
        {
          "author": "guoye-zhang",
          "authorAssociation": "NONE",
          "body": "@kazuho I agree with you that server should be more intelligent about data delivery if it has more knowledge about the content. However, it still needs a fallback algorithm when other sources of signaling are not available, for example if a new application sends a new image format that it does not understand. 10% is a good heuristic for JPG, but might not be applicable for, for example, streaming video files, as stalling at 10% would not be ideal.\r\n\r\nYour argument that \"10% of 5 incremental responses is better than sending 50% of a non-incremental response\" is completely valid. I'd even say that completing 99% of non-incremental response is equivalent to completing 0%. However, percentage is only part the story. Let's consider a situation where incremental response is 1MB and non-incremental response is 1KB, do we send 1KB after 10% of 1MB? Round-robin is a safe default. There might also be cases where we don't know the length ahead of time.\r\n\r\nThe question that matters to me is \"Is this algorithm worse than not supporting incremental-signaling at all?\" I'd be happy to support other algorithms if they can achieve this (not being worse).",
          "createdAt": "2020-07-30T02:18:45Z",
          "updatedAt": "2020-07-30T02:18:45Z"
        },
        {
          "author": "guoye-zhang",
          "authorAssociation": "NONE",
          "body": "The answer could also be \"if there is a single incremental response, all responses at the same urgency level are treated as incremental and just keep reusing your existing server heuristics\"",
          "createdAt": "2020-07-30T02:46:34Z",
          "updatedAt": "2020-07-30T02:46:34Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The question that matters to me is \"Is this algorithm worse than not supporting incremental-signaling at all?\"\r\n\r\nIIRC, at one point there was discussion regarding if we need incremental flag at all. Note that Chrome does not use weight-based prioritization at all in H2. Based on these points, I tend to think that it would not be that terrible for a server to not support incremental signaling at all, or to not do incremental when the responses being served are mixed.",
          "createdAt": "2020-07-30T03:37:01Z",
          "updatedAt": "2020-07-30T03:37:01Z"
        },
        {
          "author": "guoye-zhang",
          "authorAssociation": "NONE",
          "body": "Ability to mark all resources non-incremental is critical for Low Latency HLS, so I'd say it is very useful for us.\r\n\r\nOverall, I just want to get a sense of if:\r\n1. Incremental-signaling significantly changes how resources are delivered, and in some cases negatively, so don't change it unless you are absolutely sure what you're doing.\r\n2. Incremental-signaling significantly changes how resources are delivered, but it is well-thought-out and with all corner cases considered, so you can set it wherever it makes sense.\r\n3. Incremental-signaling is just a hint and mostly ignored by servers, setting it will probably be fine.",
          "createdAt": "2020-07-30T04:13:30Z",
          "updatedAt": "2020-07-30T04:13:30Z"
        },
        {
          "author": "jonglezb",
          "authorAssociation": "NONE",
          "body": "This is the first question that came to mind when reading the document: what happens when mixing incremental and non-incremental resources at the same priority level? It's definitely a difficult problem.\r\n\r\nFYI, I published some theoretical results ([IEEE paper](https://ieeexplore.ieee.org/document/9142713), [open-access version](https://hal.inria.fr/hal-02570686)) that basically use the following approach on the server side:\r\n\r\n- always respect the strict priority classes (what's called \"urgency\" here)\r\n- within a priority class, send resources with the smallest \"remaining completion time\" first. In practice, it can be approximated by the remaining amount of data to send for this resource. If it's unknown, assume it's infinite, or estimate the remaining completion time some other way.\r\n- within a priority class, a new resource will preempt an existing resource if it has a smaller estimated completion time (approximation: if it has smaller content length compared to what remains to be sent for the existing resource)\r\n\r\nIt's an adaptation of SRPT (Shortest Remaining Processing Time first).\r\n\r\nI deal with incremental resources by assuming they can be modeled as several successive resources. If this is not possible, then the problem becomes much harder.",
          "createdAt": "2020-08-31T13:41:41Z",
          "updatedAt": "2020-08-31T13:41:41Z"
        },
        {
          "author": "jonglezb",
          "authorAssociation": "NONE",
          "body": "To clarify the last part: let's assume that a progressive image can be split into three \"virtual\" resources: for the sake of example, let's say 16 KB (metadata), 256 KB (low-res part), 4 MB (high-res part).\r\n\r\nIf it's in the same priority class as a 64 KB js file and a 512 KB non-progressive image, here is the order in which resources would be scheduled:\r\n\r\n- 16 KB of the progressive image (metadata)\r\n- 64 KB js file\r\n- 256 KB of the progressive image (low-res part)\r\n- 512 KB non-progressive image\r\n- 4 MB of the progressive image (high-res part)\r\n\r\nIf there are several concurrent progressive images with the same 16K/256K/4M \"split\":\r\n\r\n- send all 16 KB metadata sequentially, then\r\n- send all 256 KB low-res parts sequentially, then\r\n- send all 4 MB high-res parts sequentially. Since they will likely have different sizes, start with the smallest ones.",
          "createdAt": "2020-08-31T13:57:01Z",
          "updatedAt": "2020-08-31T13:57:01Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for sharing the paper. I took a skim read. It seems like some of the assumptions do not hold in certain kinds of Internet deployments such as reverse proxies or CDNs e.g.\r\n\r\n> We also assume that the scheduler has access to the total size S of the message, for instance through a HTTP/2 header, and that application data is always available when the scheduler needs it.\r\n\r\nThe paper does acknowledge that some assumptions might not hold and provides some different strategies.\r\n\r\nThe modelling of incremental resources as a series of successive resources is interesting. It is similar to the work that was presented on https://blog.cloudflare.com/parallel-streaming-of-progressive-images/. Notably, in contrast to my earlier statement, by using response headers an upstream can inform the Cloudflare edge to schedule different byte ranges within our priority scheme e.g:\r\n\r\n```\r\ncf-priority: 30/0\r\ncf-priority-change: 512:20/1, 15000:10/n\r\n```\r\n\r\nThe hope is that extensible priorities allows the community to define an extension parameter similar to `cf-priority-change` but that is beyond the scope of this document.\r\n\r\nGetting back to the core issue here. I hope people will agree with me that there is going to be no universal perfect scheduler that is deployable. This document needs to contain widely-actionable text. My intent is to create a PR that describes some of the challenges without procsribing any particular solution.",
          "createdAt": "2020-08-31T14:54:13Z",
          "updatedAt": "2020-08-31T14:54:13Z"
        },
        {
          "author": "jonglezb",
          "authorAssociation": "NONE",
          "body": "Indeed, I had forgotten about it, but this \"metadata / low-res / high-res\" example above is inspired by the blog post.\r\n\r\n> Getting back to the core issue here. I hope people will agree with me that there is going to be no universal perfect scheduler that is deployable. This document needs to contain widely-actionable text. My intent is to create a PR that describes some of the challenges without procsribing any particular solution.\r\n\r\nI completely agree. While I'm happy we have found a generic scheduling scheme that has good theoretical properties, ultimately the \"best\" scheduling scheme really depends on the application. Well, thanks to @rmarx and others, we at least know that Round-Robin is a terrible idea in general ;)",
          "createdAt": "2020-08-31T15:22:01Z",
          "updatedAt": "2020-08-31T15:22:01Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We didn't get any pushback on the PR, so I'm going assume it addresses this problem as understood at the end of the discussion. If that's not the case, please open new, specific issues targetted at the new text.",
          "createdAt": "2020-09-30T12:04:48Z",
          "updatedAt": "2020-09-30T12:04:48Z"
        }
      ]
    },
    {
      "number": 1233,
      "id": "MDU6SXNzdWU2NjQ2NjE2NDQ=",
      "title": "Specify how non-HTTP cookies should be exposed to sites",
      "url": "https://github.com/httpwg/http-extensions/issues/1233",
      "state": "OPEN",
      "author": "DCtheTall",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "Currently, 6265bis only really talks about storing cookies that come from non-HTTP sources (e.g. document.cookie, CookieStore), but there is nothing in the spec about what cookies should be included in non-HTTP reads except that HttpOnly cookies should be ignored.\r\n\r\nThis lack of guidance has led to some [disagreements between browsers](https://github.com/httpwg/http-extensions/issues/1163) about whether `SameSite=AnythingButNone` cookies should be accessible in cross-origin frames.\r\n\r\nI am opening this issue to start a discussion about whether non-HTTP cookie access is in scope of 6265bis, and if so, what changes should be made to the spec.",
      "createdAt": "2020-07-23T17:53:18Z",
      "updatedAt": "2020-10-06T04:05:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DCtheTall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "CC @mikewest ",
          "createdAt": "2020-07-23T17:54:44Z",
          "updatedAt": "2020-07-23T17:54:44Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "It certainly needs to be defined somewhere. It might well make sense for HTML to define some filtering mechanism for the particular set of user agents that care about HTML (along with its definition of `document.cookie`), but I expect that definition to require some infrastructure in this document to support it.",
          "createdAt": "2020-07-24T06:58:35Z",
          "updatedAt": "2020-07-24T06:58:35Z"
        },
        {
          "author": "DCtheTall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> but I expect that definition to require some infrastructure in this document to support it.\r\n\r\n@mikewest can you elaborate?",
          "createdAt": "2020-07-24T13:34:32Z",
          "updatedAt": "2020-07-24T13:34:45Z"
        },
        {
          "author": "chlily1",
          "authorAssociation": "NONE",
          "body": "Another consideration is that the definition in `5.2.  \"Same-site\" and \"cross-site\" Requests` applies to \"requests\" and is defined in terms of the \"request's client\", IIUC as defined in Fetch, which doesn't really cover cookie accesses from non-HTTP APIs. This part may also need to be reformulated to cover non-HTTP APIs.",
          "createdAt": "2020-07-24T16:26:01Z",
          "updatedAt": "2020-07-24T16:26:01Z"
        }
      ]
    },
    {
      "number": 1234,
      "id": "MDU6SXNzdWU2NjQ2NjE4Mjk=",
      "title": "RFC 6265bis: Specify that empty name and empty value cookies should be ignored in 5.4",
      "url": "https://github.com/httpwg/http-extensions/issues/1234",
      "state": "CLOSED",
      "author": "DCtheTall",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "Currently according to the spec, any cookies set with a `Set-Cookie` header should be ignored if their name *and* value are empty. However, this check is not applied in section 5.4 of the spec, and as a result the CookieStore had a [bug](https://github.com/WICG/cookie-store/issues/149) allowed for sites to work around this check.\r\n\r\nTo me, this is a symptom of a bigger issue: 6265bis treats non-HTTP cookies as an afterthought, [e.g. not specifying how non-HTTP cookies should be accessed other than to ignore `HttpOnly` cookies](https://github.com/httpwg/http-extensions/issues/1233).\r\n\r\nI think it's worth opening a separate issue just to track whether we add the empty-name-empty-value check to 5.4 of 6265bis, and if there are other checks on the `Set-Cookie` header in 5.3 that are implied in 5.4 but not made explicit.",
      "createdAt": "2020-07-23T17:53:37Z",
      "updatedAt": "2020-07-28T15:41:17Z",
      "closedAt": "2020-07-28T15:41:17Z",
      "comments": [
        {
          "author": "DCtheTall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "CC @mikewest",
          "createdAt": "2020-07-23T17:54:37Z",
          "updatedAt": "2020-07-23T17:54:37Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "As you've noticed, the document currently assumes that 5.4 is only going to be exercised after 5.3. I think this particular issue is distinct from the issue you raise in the other bug, as the only non-HTTP APIs that existed before the async API you're working through used cookie strings, which were parsed just as the header was.\r\n\r\nGiven that new mechanism, it does make sense to move \"If both the name string and the value string are empty, ignore the set-cookie-string entirely.\" from 5.3 to 5.4. Skimming through, I think that's the only restriction that causes cookies to be ignored at the parsing stage.",
          "createdAt": "2020-07-24T06:58:47Z",
          "updatedAt": "2020-07-24T06:58:47Z"
        }
      ]
    },
    {
      "number": 1237,
      "id": "MDU6SXNzdWU2Njc1MjYwMDc=",
      "title": "Reference(s) for certificate verification",
      "url": "https://github.com/httpwg/http-extensions/issues/1237",
      "state": "OPEN",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "BCP56bis currently states that 'Applications using HTTP should specify that TLS certificates are to be checked according to [RFC2818] when HTTPS is used.' That doesn't seem right.\r\n\r\nRelated: https://github.com/httpwg/http-core/issues/404  and https://github.com/httpwg/http-core/issues/263\r\n\r\n/cc @ekr @stpeter @davidben @sleevi\r\n\r\n",
      "createdAt": "2020-07-29T03:49:29Z",
      "updatedAt": "2020-07-29T03:49:29Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1238,
      "id": "MDU6SXNzdWU2Njk4OTU5NDM=",
      "title": "Clearing Client Hint preferences with browser history seems odd",
      "url": "https://github.com/httpwg/http-extensions/issues/1238",
      "state": "OPEN",
      "author": "amtunlimited",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "> User agents MUST clear persisted opt-in preferences when any one of site data, browsing history, browsing cache, cookies, or similar, are cleared.\r\n\r\nBrowsing history seems to stand out to me here. There are a couple of pedantic questions (does this mean full history, or back beyond a certain amount of time?) and doesn't seem to fit with precedent. In general, I don't expect much other information to be cleared when removing history information, but that might very well just be me.",
      "createdAt": "2020-07-31T14:49:44Z",
      "updatedAt": "2020-08-13T12:19:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree the text seems a bit overprescriptive here. I could imagine UAs that want to clear it with browsing history and UAs that don't, depending on what they're trying to accomplish. It's a question of which \"please forget this\" use cases the browser is aiming to meet with each option.\r\n\r\nPerhaps the UA has an option whose aim is \"please make this site forget about me\". Then the UA should clear client hint preferences, site data, and cache, but may or may not decide history is separate. (Assuming the history is not web-visible!) Or perhaps the aim is \"I don't want these links to appear in address bar completions\". Then perhaps the UA will clear just history but not any site data because the user didn't ask to be logged out. Or perhaps the UA wants to combine these two into one option. Or perhaps the option is for developers, to clear particular pieces of cache to diagnose some issue. Then maybe the client hint cache should be cleared or maybe the option is just about the HTTP cache.\r\n\r\nIdeally the text would capture enough that UAs can make the correct decision for each of their features. (And, since it has privacy implications when UAs forget, probably explicitly call out clearing this in \"please make this site forget about me\" cases like clearing cookies and site data.)",
          "createdAt": "2020-07-31T16:34:26Z",
          "updatedAt": "2020-07-31T16:34:26Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, the spec has been approved early July and is in the RFC Editor queue (see https://datatracker.ietf.org/doc/draft-ietf-httpbis-client-hints/). Changes at this stage can only be done with a lot of care.",
          "createdAt": "2020-08-12T14:44:36Z",
          "updatedAt": "2020-08-12T14:44:36Z"
        },
        {
          "author": "amtunlimited",
          "authorAssociation": "NONE",
          "body": "@reschke I was unaware, thank you.\r\n\r\n@davidben I guess the question is is the issue worth poking? I don't think it'd consider it a blocker for publishing, but I'm not super experienced in the standards processes, where I suppose things are less \"tweakable\" after-the-fact",
          "createdAt": "2020-08-12T15:15:40Z",
          "updatedAt": "2020-08-12T15:15:40Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah yeah, the timing is awkward. At the same time, I don't think it does anyone any good if the document does not match what people intend to implement. Since browsing history is, well, a browser notion, I suppose the main question is what browser implementors would do.\r\n\r\nChecking Firefox, it has separate dialogs altogether for \"Clear [Site] Data\" and \"Clear History\", with the latter sectioned under what Firefox remembers, not what the site remembers. The clear history dialog does have separate checkboxes for \"Browsing & Download History\" vs \"Cookies\" and \"Cache\", but if I tell it to just clear the browser-side history it, as one would expect, does not clear HTML localStorage (to pick an example of site state not explicitly covered under here).\r\n\r\nThat and the description suggests to me that, like in Chrome, the \"Browsing & Download History\" option is a \"I don't want to see this in browser completions\" feature, not a \"I want the site to forget about me\" feature, and so it would not make sense to associate the Client Hint cache with browsing history, only cookies and/or cache. @martinthomson, would you agree with this?\r\n\r\nIf so, I think that supports https://github.com/httpwg/http-extensions/issues/1238#issuecomment-667216778 and the current text is too prescriptive. Since it's late in the process and we probably don't want to make large changes, perhaps we should simply strike \"browsing history\" from the list. Then implementors can make a judgement as to whether \"or similar\" covers browsing history for their particular context.",
          "createdAt": "2020-08-12T16:30:52Z",
          "updatedAt": "2020-08-12T16:30:52Z"
        },
        {
          "author": "amtunlimited",
          "authorAssociation": "NONE",
          "body": "> perhaps we should simply strike \"browsing history\" from the list. Then implementors can make a judgement as to whether \"or similar\" covers browsing history for their particular context.\r\n\r\nSounds good to me; I can adjust the PR to match. Is there any process for getting changes propagated not that it's moved on to the next step?",
          "createdAt": "2020-08-12T16:39:44Z",
          "updatedAt": "2020-08-12T16:39:44Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That and the description suggests to me that, like in Chrome, the \"Browsing & Download History\" option is a \"I don't want to see this in browser completions\" feature, not a \"I want the site to forget about me\" feature, and so it would not make sense to associate the Client Hint cache with browsing history, only cookies and/or cache. @martinthomson, would you agree with this?\r\n\r\nThere are two models in conflict here and we have tried over time to make that clear.  History is not site state, so you are right.  We do couple some of our capabilities around this: if a user asks the browser to forget a site, that also means that the browser will forget everything it stores for that site which (ideally, in principle) results in the site also forgetting about the user.",
          "createdAt": "2020-08-13T01:13:41Z",
          "updatedAt": "2020-08-13T01:13:41Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> There are two models in conflict here and we have tried over time to make that clear. History is not site state, so you are right. We do couple some of our capabilities around this: if a user asks the browser to forget a site, that also means that the browser will forget everything it stores for that site which (ideally, in principle) results in the site also forgetting about the user.\r\n\r\nInteresting! So if the user picks \"forget my history\", site data remains intact, while them picking \"forget this site\" results in both the site removed from history *and* site data being removed?\r\n\r\nIn that case, just removing \"browser history\" from the current paragraph (as David suggested) will still cover the latter case, right? (as \"site data\" is still explicitly mentioned)\r\n ",
          "createdAt": "2020-08-13T10:16:34Z",
          "updatedAt": "2020-08-13T10:16:34Z"
        },
        {
          "author": "amtunlimited",
          "authorAssociation": "NONE",
          "body": "> In that case, just removing \"browser history\" from the current paragraph (as David suggested) will still cover the latter case, right? (as \"site data\" is still explicitly mentioned)\r\n\r\nI would agree, and I've adjusted the PR to match.",
          "createdAt": "2020-08-13T12:19:38Z",
          "updatedAt": "2020-08-13T12:19:38Z"
        }
      ]
    },
    {
      "number": 1240,
      "id": "MDU6SXNzdWU2NzI1MjAxMjM=",
      "title": "Give guidance about how to choose an error code",
      "url": "https://github.com/httpwg/http-extensions/issues/1240",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "proxy-status"
      ],
      "body": "",
      "createdAt": "2020-08-04T05:39:53Z",
      "updatedAt": "2020-08-11T02:53:26Z",
      "closedAt": "2020-08-11T02:53:26Z",
      "comments": []
    },
    {
      "number": 1241,
      "id": "MDU6SXNzdWU2NzM1OTk0Njk=",
      "title": "Incrementally Better Cookies vs RFC6265bis",
      "url": "https://github.com/httpwg/http-extensions/issues/1241",
      "state": "OPEN",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "Could someone please explain the history behind why we have two drafts (https://tools.ietf.org/html/draft-west-cookie-incrementalism and https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis) that are somewhat incompatible with each other? Could the proposals that have support from the WG move into RFC6265bis?",
      "createdAt": "2020-08-05T14:49:01Z",
      "updatedAt": "2020-09-22T06:47:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I see `draft-west-cookie-incrementalism` as a proposal for modifying RFC6265bis; @mikewest is that the intent?\r\n\r\n",
          "createdAt": "2020-08-06T02:56:25Z",
          "updatedAt": "2020-08-06T02:56:25Z"
        },
        {
          "author": "krgovind",
          "authorAssociation": "NONE",
          "body": "I humbly accept the mantle of moving these drafts along, and will be discussing logistics with @mikewest  in two weeks.\r\n\r\nChrome is already shipping Lax-by-default and requires \"Secure\" for \"SameSite=None\", and is now tackling [Schemeful SameSite](https://www.chromestatus.com/feature/5096179480133632). I think it make sense to at least fold those parts of draft-west-cookie-incrementalism-01 into RFC6265bis.\r\n",
          "createdAt": "2020-09-15T16:26:56Z",
          "updatedAt": "2020-09-15T16:26:56Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Great to hear you'll be taking on cookies @krgovind! Mozilla supports adding those to that draft and effectively having the HTTP WG adopt them.",
          "createdAt": "2020-09-16T11:40:22Z",
          "updatedAt": "2020-09-16T11:40:22Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The bar for getting something into 6265bis is what '[reflects implementation experience](https://lists.w3.org/Archives/Public/ietf-http-wg/2015OctDec/0165.html).' So, I think the next step here is to have a Call for Adoption for the draft; I've opened up https://github.com/httpwg/admin/issues/13 to track that.",
          "createdAt": "2020-09-22T06:47:44Z",
          "updatedAt": "2020-09-22T06:47:44Z"
        }
      ]
    },
    {
      "number": 1244,
      "id": "MDU6SXNzdWU2Nzg0MDk5NTU=",
      "title": "Feedback on draft-ietf-httpbis-priority-01",
      "url": "https://github.com/httpwg/http-extensions/issues/1244",
      "state": "CLOSED",
      "author": "olnrao",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "**URL**: https://tools.ietf.org/html/draft-ietf-httpbis-priority-01\r\n**Summary**: In many places, response is used than request\r\n**Details**:\r\n\r\n**Section**: 4. The Priority HTTP Header Field\r\n**Revision**: \r\nThe Priority HTTP header field can appear in requests and responses. A client uses it to specify the priority of the **~~response~~ request**.  A server uses it to inform the client that the priority was overwritten.  An intermediary can use the Priority information from client requests and server responses to correct or amend the precedence to suit it  (see Section 6).\r\n\r\n**Section**: 5. Reprioritization\r\n**Revision**: \r\nAfter a client sends a request, it may be beneficial to change the priority of the **~~response~~ request**.  As an example, a web browser might issue a prefetch request for a JavaScript file with the urgency parameter of the Priority request header field set to \"u=7\" (background).  Then, when the user navigates to a page which references the new JavaScript file, while the prefetch is in progress, the browser would send a reprioritization frame with the priority field value set to \"u=0\".\r\n\r\nIn HTTP/2 and HTTP/3, after a request message is sent on a stream, the stream transitions to a state that prevents the client from sending additional frames on the stream.  Therefore, a client cannot reprioritize a **~~response~~ request** by using the Priority header field.\r\n\r\n**Section**: 6. Merging Client- and Server-Driven Parameters\r\n**Revision**:\r\nIt is not always the case that the client has the best understanding of how the HTTP **~~responses~~ requests** deserve to be prioritized. The server might have additional information that can be combined with the client's indicated priority in order to improve the prioritization of the **~~response~~ request**.\r\n...\r\nAn origin can use the Priority ~~response~~ header field to indicate its view on how an HTTP **~~response~~ request** should be prioritized.  \r\n...\r\n\r\n(Ok, I think it's not wise for me to give every occurrence. I hope you get the point)\r\n",
      "createdAt": "2020-08-13T12:47:13Z",
      "updatedAt": "2020-08-13T15:25:47Z",
      "closedAt": "2020-08-13T15:19:47Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The use of response is intentional because the interoperability of extensible priority signals is premised on hinting to the server how it should schedule sending of response data.\r\n\r\nUsing the term request everywhere makes the intention of the document unclear. Although a server _might_ consider the priority of an incoming request to make local scheduling decisions, e.g. decide to do work for one request over another before sending, that is not the intention of this document and we say nothing about it today.",
          "createdAt": "2020-08-13T12:59:53Z",
          "updatedAt": "2020-08-13T13:03:15Z"
        },
        {
          "author": "olnrao",
          "authorAssociation": "NONE",
          "body": "Thanks for the quick feedback, @LPardue.  I am bit confused here.  Unless server attends to the request at priority, it can't even know the priority.  Indirectly response priority is driven by priority requested by client in request headers.  Of course, after server reads the request, we can then talk about whether it should respond fast.  If we really want that level of clarity then we should have two headers - request priority to make sure this request is queued ahead of other normal requests, response priority to queue the response ahead of existing normal responses.  Unless we have both in place, I am not sure if we can achieve the desired goal you have stated.  I think I may be missing something.  It would be great if you can expand a bit more on where my thinking is faltered.  Thanks again for your help.",
          "createdAt": "2020-08-13T14:14:40Z",
          "updatedAt": "2020-08-13T14:14:55Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "RFC 7540 S 5.3 says:\r\n\r\n>    The purpose of prioritization is to allow an endpoint to express how\r\n>    it would prefer its peer to allocate resources when managing\r\n>    concurrent streams.  Most importantly, priority can be used to select\r\n>    streams for transmitting frames when there is limited capacity for\r\n>    sending.\r\n\r\nIn practice, this means HTTP/2 prioritization is concerned with managing how response bytes are sent in DATA frames on streams when multiplexing is taking place. Many HTTP/2 servers do consume priority signals (in HEADERS or PRIORITY frames) and adapt scheduling to these signals. Sadly, some servers do not.\r\n\r\nExtensible priorities is applicable to HTTP/2 and HTTP/3, so we need to select terminology that applies to both and accomodates the subtle differences when it comes to stream lifecycle.\r\n\r\nSince HTTP/2 prioritization was mainly focused on response multiplexing, we choose to use the term `response` to make the primary purpose of extensible priorities unambiguos.\r\n\r\nI have not heard anyone making a serious case for the need to control prioritizing request processing. So I'm of the opinion that we can not go to the effort of specifying anything.\r\n\r\n",
          "createdAt": "2020-08-13T14:50:54Z",
          "updatedAt": "2020-08-13T14:50:54Z"
        },
        {
          "author": "olnrao",
          "authorAssociation": "NONE",
          "body": "Thank you, @LPardue.  I did not connect the extensibility part in first go.  Thanks for taking time to expand.  Will close this.",
          "createdAt": "2020-08-13T15:19:47Z",
          "updatedAt": "2020-08-13T15:19:47Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No problem. People do use the terms `request prioritization` and `response prioritization` interchangable, so I get why it's confusing. Since the signal here is a header that can appear on either message, I want to be especially careful with consistency of terms in the document. ",
          "createdAt": "2020-08-13T15:25:47Z",
          "updatedAt": "2020-08-13T15:25:47Z"
        }
      ]
    },
    {
      "number": 1250,
      "id": "MDU6SXNzdWU2ODA5NTY0Njg=",
      "title": "Digest editorial refresh before WGLC",
      "url": "https://github.com/httpwg/http-extensions/issues/1250",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## Tasks\r\n\r\n- [x] digest-algorithm lowercase #1253 \r\n- [x] deprecate parameters and wait for feedback :) #1259 @LPardue \r\n- [x] Algorithm agility #1284 \r\n- [x] sha-1 deprecated o obsoleted? #1292 \r\n- [x] detail encrypted quirks eg with content-coding #1285 \r\n- [x] clean up Representation Digest https://github.com/httpwg/http-extensions/pull/937#discussion_r472018411\r\n- [x] remove reference to \"validator fields\" if they are not used anymore\r\n- [x] consistent usage of backticks #1255 \r\n\r\n```\r\n`Digest` vs Digest vs \"Digest\"\r\n`digest-algorithms` vs digest-algoritms vs \"digest-algorithms\"\r\n```\r\n\r\n- [x] consistent usage of \"-\" #1256  \r\n\r\n```\r\ndigest-algorithms vs digest algorithms\r\n\r\n```\r\n\r\n- [x] consistent usage of lowercase digest-algorithms with double quote \"sha-256\" in text #1255\r\n\r\n- [ ] close #1139 and #1138  about old algorithms unless somebody comes with a proposal. @LPardue ",
      "createdAt": "2020-08-18T11:14:37Z",
      "updatedAt": "2020-10-17T12:03:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": " @LPardue do you have any news on #1139 and #1138 about old algorithms?\r\n",
          "createdAt": "2020-10-16T22:38:54Z",
          "updatedAt": "2020-10-16T22:38:54Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll propose some new text shortly",
          "createdAt": "2020-10-17T11:43:35Z",
          "updatedAt": "2020-10-17T11:43:35Z"
        }
      ]
    },
    {
      "number": 1251,
      "id": "MDU6SXNzdWU2ODA5NjU1Mjk=",
      "title": "Inconsistent rules around whitespace",
      "url": "https://github.com/httpwg/http-extensions/issues/1251",
      "state": "OPEN",
      "author": "zcorpan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html\r\n\r\nI found https://github.com/httpwg/http-extensions/pull/1173\r\n\r\nThe current grammar with both SP and OWS in different places. I don't quite understand the motivation for SP in some places instead of OWS everywhere. If OWS was allowed in some places for more robust parsing, wouldn't allowing OWS everywhere be more robust still?\r\n\r\nAlso, there are some places where no whitespace is allowed but maybe it should be. In particular, before the `;` in the parameters. Should whitespace be allowed there?\r\n\r\ncc @mnot",
      "createdAt": "2020-08-18T11:29:33Z",
      "updatedAt": "2020-10-06T04:05:36Z",
      "closedAt": null,
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "cc @valenting",
          "createdAt": "2020-08-18T12:03:17Z",
          "updatedAt": "2020-08-18T12:03:17Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW and AFAIR, \"OWS\" was needed because sender/recipient have no control about how other components rombine multiple field lines into one. The other places are actually intentionally strict.",
          "createdAt": "2020-08-18T12:28:03Z",
          "updatedAt": "2020-08-18T12:28:03Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "So SP is used where you could not have whitespace as a result of combining? So basically whenever there's no possible comma adjacent to it?\r\n\r\n(That would still leave the parameters thing.)",
          "createdAt": "2020-08-18T12:37:59Z",
          "updatedAt": "2020-08-18T12:37:59Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> (That would still leave the parameters thing.)\r\n\r\nYes, there are multiple questions here.\r\n\r\nI would say that it really doesn't matter that much as long as it is well-defined and implementations agree on it (and there's a test suite for a reason). In which case the outcome IMHO should be not to make another change, given the fact that the spec is approved already.",
          "createdAt": "2020-08-18T12:54:39Z",
          "updatedAt": "2020-08-18T12:54:39Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Making this a bit more concrete, in `N: \\tV` (assuming \\t is HT) does `V` end up parsing as a structured value or not? If it does because HTTP removed the HT, why does SFV feel the need to remove SP in step 2 of https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#text-parse?",
          "createdAt": "2020-08-18T13:49:55Z",
          "updatedAt": "2020-08-18T13:49:55Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "AFAIU, the invidual parsers (list, item, ...) assume that leading SP has already been consumed.",
          "createdAt": "2020-08-18T14:00:05Z",
          "updatedAt": "2020-08-18T14:00:05Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I'm not sure how that addresses the question. Are you saying \\tV cannot parse as a structured field value? So if you defined a header value as \"sometoken\" (or case-sensitive variant) in the past it's not forward-compatible with SFV?",
          "createdAt": "2020-08-18T14:09:23Z",
          "updatedAt": "2020-08-18T14:09:23Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It parses, as the leading HTAB is part of the OWS that surrounds the field value. See <https://greenbytes.de/tech/webdav/rfc7230.html#header.fields>.",
          "createdAt": "2020-08-18T14:19:37Z",
          "updatedAt": "2020-08-18T14:19:37Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Okay and OWS includes SP, so why does https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#text-parse remove SP? How can there be SP at that point?",
          "createdAt": "2020-08-18T14:22:30Z",
          "updatedAt": "2020-08-18T14:22:30Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good question.",
          "createdAt": "2020-08-18T14:26:14Z",
          "updatedAt": "2020-08-18T14:26:14Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": ">  Are you saying \\tV cannot parse as a structured field value?\r\n\r\nIt can't, but also it should never try to, because by the time the field value gets to the Structured Fields parser, the `\\t` should have been eaten by the HTTP parser. So in a sane environment, step 2 is a noop. I guess we just forgot about that, because we've not been working in that sane environment (the test suite doesn't use any HTTP machinery, so there's no guarantee that what gets fed into `parse()` is even remotely sensible.)\r\n\r\nI think it shouldn't be a problem to remove it.\r\n\r\nFor the parameters thing: there's a discussion in #954 (from October last year, so I can't remember precise details.) I think it was that the algorithm doesn't look ahead, so couldn't distinguish between `\"x ;\"` and `\"x y\"`, so it gobbled up the space after `x`, which broke the inner-list parser which expected a space character before the `y`.",
          "createdAt": "2020-08-18T23:57:25Z",
          "updatedAt": "2020-08-18T23:57:25Z"
        },
        {
          "author": "zcorpan",
          "authorAssociation": "NONE",
          "body": "Thanks for the clarifications. I think it would be helpful with a note in \"Parsing Structured Fields\" to clarify that leading and trailing OWS are \"removed\" per RFC7230. Also I suggest removing the (no-op) steps that skip SP.",
          "createdAt": "2020-08-19T09:56:17Z",
          "updatedAt": "2020-08-19T09:56:17Z"
        }
      ]
    },
    {
      "number": 1252,
      "id": "MDU6SXNzdWU2ODE4Njk2MjQ=",
      "title": "Content-Disposition: whitespace in filename parameter without quotes",
      "url": "https://github.com/httpwg/http-extensions/issues/1252",
      "state": "OPEN",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Firefox is feeling forced to support whitespace without quotes in the filename parameter of the Content-Disposition header. See https://bugzilla.mozilla.org/show_bug.cgi?id=1440677.\r\n\r\nIn https://bugs.chromium.org/p/chromium/issues/detail?id=1006345 @MattMenke2 suggests removing whitespace without quotes support is not worth it to Chrome.\r\n\r\nI haven't surveyed other clients, but it seems pretty clear what servers are doing (perhaps not in detail, but they're emitting whitespace without quotes).",
      "createdAt": "2020-08-19T14:06:42Z",
      "updatedAt": "2020-08-19T15:28:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I haven't surveyed other clients, but it seems pretty clear what servers are doing (perhaps not in detail, but they're emitting whitespace without quotes).\r\n\r\nMy assumption is that they just string-concat filenames without *any* care; the problem just happens to surface with whitespace most of the time. I'm pretty sure that servers that send unquoted whitespace *also* have trouble with non-ASCII characters, or with other ASCII characters not allowed in tokens (such as \"(\" and \")\"). ",
          "createdAt": "2020-08-19T14:39:52Z",
          "updatedAt": "2020-08-19T14:39:52Z"
        },
        {
          "author": "MattMenke2",
          "authorAssociation": "NONE",
          "body": "Note that truncating at whitespace can change file extensions, which can have security implications.  So if we want to reach consensus on doing something other than what Chrome does here, I don't think we want to do what FireFox does.",
          "createdAt": "2020-08-19T14:51:41Z",
          "updatedAt": "2020-08-19T14:51:41Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Truncating isn't a good idea, indeed. The \"proper\" approach would be to ignore the filename information, as the parameter does not parse as spec'd.",
          "createdAt": "2020-08-19T14:57:35Z",
          "updatedAt": "2020-08-19T14:57:35Z"
        },
        {
          "author": "MattMenke2",
          "authorAssociation": "NONE",
          "body": "The entire header doesn't parse as specced, though, not just some subset of it.  Of course, just ignoring the header results in other potential security issues.  Ideally, we'd just reject responses with invalid headers, but that would likely result in way too much breakage for anyone to ship.\r\n\r\nEven just ignoring the filename will likely result in widespread breakage. Not sure if there'll be the willingness to go through that, on the Chrome side of things.",
          "createdAt": "2020-08-19T15:19:18Z",
          "updatedAt": "2020-08-19T15:26:34Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The entire header doesn't parse as specced, though, not just some subset of it.\r\n\r\nThat's the pedantic point of view (which I happen to like). But one could argue that failure to parse parameters does not require to throw away the disposition type.\r\n",
          "createdAt": "2020-08-19T15:24:16Z",
          "updatedAt": "2020-08-19T15:24:16Z"
        },
        {
          "author": "MattMenke2",
          "authorAssociation": "NONE",
          "body": "> That's the pedantic point of view (which I happen to like). But one could argue that failure to parse parameters does not require to throw away the disposition type.\r\n\r\nBut that necessarily require us to at least partially parse the invalid content, so we then actually need to specify how and when invalid parts of a header should be parsed.",
          "createdAt": "2020-08-19T15:28:38Z",
          "updatedAt": "2020-08-19T15:28:38Z"
        }
      ]
    },
    {
      "number": 1260,
      "id": "MDU6SXNzdWU2OTU5NDI0Nzg=",
      "title": "Buffering PRIORITY_UPDATES and early responses",
      "url": "https://github.com/httpwg/http-extensions/issues/1260",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "I think it might be better to say \"SHOULD be buffered and be applied once the stream is opened.\"\r\n\r\nThe problem with current text is that it does deal with servers sending responses _while_ they receive requests (i.e. early response).\r\n\r\n_Originally posted by @kazuho in https://github.com/httpwg/http-extensions/pull/1167#r484963926_",
      "createdAt": "2020-09-08T14:52:48Z",
      "updatedAt": "2020-09-11T10:56:31Z",
      "closedAt": "2020-09-11T10:56:31Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's interesting that serving early response with appropriate priority is not a use case anyone came up with in defence of PRIORITY_UPDATE frames. \r\n\r\nI think we can support an early response case but we need to make sure the language is precise. For example, the document says\r\n\r\n> The signal carried by a PRIORITY_UPDATE frame overrides that carried by the\r\nheader field, even when the frame was received before the request headers.\r\n\r\nWhat we're asking implementers to do with Kazuho's suggestion to ignore any Priority header that might be in the request if they choose to process headers after they started serving a response. I'd like implementers to confirm that they think this is a reasonable thing to do.",
          "createdAt": "2020-09-08T20:35:38Z",
          "updatedAt": "2020-09-08T20:35:38Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In general, an early response is because the *headers* are sufficient to generate a response without processing the body of the request.  (POST somewhere that requires authentication you don't have, for example.)  Talking about an early response before you've processed the headers seems kind of nonsensical, unless *maybe* you're talking about a 404 once you've seen the URL.  Even then, I suspect most servers would simplify their processing by waiting until they see the end of the header section.",
          "createdAt": "2020-09-08T21:02:27Z",
          "updatedAt": "2020-09-08T21:02:27Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Apologies. This issue would have been improved if GitHub included the text that Kazuho was speaking to. So here it is\r\n\r\n> Request-stream variant PRIORITY_UPDATE frames (type=0xF0700) received before the\r\nrequest or response has started SHOULD be buffered until the stream is opened\r\nand applied immediately after the request message has been processed.\r\n\r\nKazuho was suggesting that we change this to\r\n\r\n> Request-stream variant PRIORITY_UPDATE frames (type=0xF0700) received before the\r\nrequest or response has started SHOULD be buffered and applied once the stream is opened.\r\n",
          "createdAt": "2020-09-08T21:22:16Z",
          "updatedAt": "2020-09-08T21:22:36Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we want to be precise, I think the best way would be to change the model that we assume in the document.\r\n\r\nThe document (including the changes proposed in #1167, which I think we should merge and then try to adjust) assumes that the priority is carried by the priority header field, with PRIORITY_UPDATE frame updating the information. That's correct on the client-side, but on the server-side, as we know, PRIORITY_UPDATE frame can arrive before the stream is being created or before the request headers are received. And in theory, a server might start sending response before it receives the priority request header field (though that's rare as @MikeBishop points out).\r\n\r\nWe could instead say that from server's viewpoint, the PRIORITY_UPDATE frame always carries the up-to-date signal, whereas the value of priority request header field is adopted only when a PRIORITY_UPDATE frame has not (yet) been received for that request.",
          "createdAt": "2020-09-08T23:23:01Z",
          "updatedAt": "2020-09-08T23:23:57Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that's a reasonable way to frame it.  It is equivalent, of course, to simply state that the PRIORITY_UPDATE frame is an update which might race the initial value.  If the server knows it's an update, it can ignore the older message when it sees it.",
          "createdAt": "2020-09-09T18:39:11Z",
          "updatedAt": "2020-09-09T18:39:11Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that we can go either directions, being precise, or concisely stating that it is an update that replaces the value sent in the header field (if any).",
          "createdAt": "2020-09-09T19:08:12Z",
          "updatedAt": "2020-09-09T19:08:12Z"
        }
      ]
    },
    {
      "number": 1261,
      "id": "MDU6SXNzdWU2OTcwMDQ1NTY=",
      "title": "\"Within the stream limit\" in HTTP/2?",
      "url": "https://github.com/httpwg/http-extensions/issues/1261",
      "state": "OPEN",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "What does \"within the stream limit\" mean in this case?  HTTP/2 specifies a maximum number of concurrently active streams, with streams which are either \"open\" or \"half-open\" counting toward the limit regardless of the ID.  I think what you're saying here is that you're modifying the definition of the limit to also include \"idle\" streams where priority information has been received.  However, you're not explicitly calling this out as a modification to the 7540 concurrency logic.\r\n\r\n_Originally posted by @MikeBishop in https://github.com/httpwg/http-extensions/pull/1167#discussion_r485149756_",
      "createdAt": "2020-09-09T17:16:24Z",
      "updatedAt": "2020-09-10T14:23:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PR #1262 moves some of the text around but the issue here still remains. In [review of PR #1262](https://github.com/httpwg/http-extensions/pull/1262/files#r485975868) Kazuho said \r\n\r\n> I think we should RECOMMEND servers to buffer the most recent PRIORITY_UPDATE frames it receives for all the unopened streams, provided that the stream ID being specified by the frame is within the concurrency window.\r\n\r\n> Otherwise, the server will fail to prioritize the responses correctly when a client issues many requests at once (e.g., when finding lots of tags in a HTML document).",
          "createdAt": "2020-09-10T14:23:46Z",
          "updatedAt": "2020-09-10T14:23:46Z"
        }
      ]
    },
    {
      "number": 1267,
      "id": "MDU6SXNzdWU3MDU1OTM5MjM=",
      "title": "State that priority parameters cannot be split across PRIORITY_UPDATE frames",
      "url": "https://github.com/httpwg/http-extensions/issues/1267",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "Because priority parameters are an sf-dictionary, they can be split across header lines.  This is not the case for priority updates carried in _PRIORITY_UPDATE_ frames.\r\n\r\nWhile this restriction can be inferred from a couple of sentences in the draft, stating it explicitly -- priority parameters cannot be split across _PRIORITY_UPDATE_ frames -- would make the draft clearer.",
      "createdAt": "2020-09-21T13:22:03Z",
      "updatedAt": "2020-09-28T10:53:24Z",
      "closedAt": "2020-09-28T10:53:24Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I hadn't thought much about this. https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-19#section-3.2 says \r\n\r\n>  Note that Dictionaries can have their members split across multiple\r\n>    lines inside a header or trailer section; for example, the following\r\n>    are equivalent:\r\n> \r\n>    Example-Hdr: foo=1, bar=2\r\n> \r\n>    and\r\n> \r\n>    Example-Hdr: foo=1\r\n>    Example-Hdr: bar=2\r\n> \r\n>    However, individual members of a Dictionary cannot be safely split\r\n>    between lines; see Section 4.2 for details.\r\n\r\nA client could send urgency and incremental parameters in separate PRIORITY_UPDATE frames. However, that risks the server processing each as if the other parameter was omitted, which is probably surprising and not the intention. Is that what you mean by \"cannot be split\"?\r\n\r\n@kazuho WDYT about us adding text making this situation clearer? ",
          "createdAt": "2020-09-23T23:58:02Z",
          "updatedAt": "2020-09-23T23:58:02Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am fine with stating that each PRIORITY_UPDATE frame is distinct and complete, rather than a conveyer of the difference.\r\n\r\nThe pros of that approach is that the server can ignore the value of the priority request header field if it has already received a PRIORITY_UPDATE frame. If we are to say that the frame carries the delta, the server will be required to parse the value of the request header field then apply the value that have been sent by using (possibly multiple of) PRIORITY_UPDATE frames.\r\n\r\nI'm a bit disappointed that we would not have alignment with how the priority response header is being handled (it is considered as a delta that corrects the client-provided values), but I think the point explained above is more important.",
          "createdAt": "2020-09-24T03:35:59Z",
          "updatedAt": "2020-09-24T03:35:59Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the difference is OK.  I would not expect the header field to be updated by a partial trailer field, for instance.  All of the individual field lines in a header combine into a single value by the end of the header.  The frame doesn't get to provide multiple lines, so it has to be complete.\r\n\r\nThat is, unless I'm misreading the example in the structured fields draft.  I'll open an issue...",
          "createdAt": "2020-09-24T04:15:22Z",
          "updatedAt": "2020-09-24T04:15:22Z"
        }
      ]
    },
    {
      "number": 1268,
      "id": "MDU6SXNzdWU3MDc1NzY5MzI=",
      "title": "What happens if PRIORITY_UPDATE's PFV is not a valid SF?",
      "url": "https://github.com/httpwg/http-extensions/issues/1268",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "The `Priority` field's field value and the Priority Field Value carried in _PRIORITY_UPDATE_ frame may not be a well-structured Structured Field (i.e. it may fail to parse).  While ignoring unexpected parameters and values is discussed in the draft, handling unparseable Structured Fields is not.",
      "createdAt": "2020-09-23T18:15:48Z",
      "updatedAt": "2020-09-28T10:53:24Z",
      "closedAt": "2020-09-28T10:53:24Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good question.\r\n\r\nI don't believe that Structured Fields spec has any guidance other than to fail parsing. I'm open to ideas on what to suggest. \r\n\r\nFail closed seems quite harsh. My gut feeling is to suggest the treating as though default values were received.",
          "createdAt": "2020-09-23T19:50:18Z",
          "updatedAt": "2020-09-23T19:50:18Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": "That may become an optimization: send invalid Dictionary to send default values.\r\n\r\nUnlike HTTP Fields, the contents of the _PRIORITY_UPDATE_ frame are not expected to come directly from the user of the protocol.  We should at least ignore such frames.",
          "createdAt": "2020-09-23T21:24:46Z",
          "updatedAt": "2020-09-23T21:24:46Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Omitting the parameters implies defaults, so omitting the header or sending a frame with empty value would work just as well as sending a malformed value.\r\n\r\nTake for example Chrome which sends initial priority in PRIORITY_UPDATE. If that is malformed and it's ignored, how would a server prioritise things?",
          "createdAt": "2020-09-23T21:56:49Z",
          "updatedAt": "2020-09-23T21:56:49Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to using defaults. IMO, implementations can sent an Warning response header field if they want to be helpful, but I do not think we need to state that (as we do not make such statement in each of the HTTP-related specifications).",
          "createdAt": "2020-09-23T22:51:57Z",
          "updatedAt": "2020-09-23T22:51:57Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wouldn't ignore a badly formed frame, I would generate a connection error.  Otherwise you are burying an error.\r\n\r\nI'd be opposed to mandating that garbage be ignored.  I'm OK if people decide to ignore junk, but have a slight preference if they don't.  Ignoring junk has negative consequences for other protocol users.",
          "createdAt": "2020-09-24T04:12:49Z",
          "updatedAt": "2020-09-24T04:12:49Z"
        }
      ]
    },
    {
      "number": 1269,
      "id": "MDU6SXNzdWU3MDc4NDI0MTU=",
      "title": "Combined value across headers and footers",
      "url": "https://github.com/httpwg/http-extensions/issues/1269",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "The structured field definition of dictionaries [says](https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-19#section-3.2):\r\n\r\n> Note that Dictionaries can have their members split across multiple\r\n   lines inside a header or trailer section;\r\n\r\nThe priority work is debating updates to priorities, which can be piecemeal.  I could read this two ways:\r\n\r\n1. The value of a field can be split within a field section.\r\n2. The value of a field can be split across multiple field sections.\r\n\r\nThough the \"or\" implies that it is more of the former than the latter.\r\n\r\nThe core spec says this of trailers:\r\n\r\n> Trailer fields ought to be processed and stored separately from the fields in the header section to avoid contradicting message semantics known at the time the header section was complete. \r\n\r\nWhich reinforces that view.\r\n\r\nA simple fix might be to s/inside a header or trailer section/of the same header or trailer section/.\r\n\r\nHowever, I couldn't find anything in the core spec about combining field lines.  It is a common practice that might be worth documenting/defining somehow.",
      "createdAt": "2020-09-24T04:25:29Z",
      "updatedAt": "2020-10-13T02:14:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Agreed WRT the suggestion. See [here](https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#field-order) in the core spec for what you're looking for.",
          "createdAt": "2020-10-05T05:49:49Z",
          "updatedAt": "2020-10-05T05:49:49Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "agreed.",
          "createdAt": "2020-10-05T06:16:40Z",
          "updatedAt": "2020-10-05T06:16:40Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "This has been discussed on list and there hasn't been any pushback, so proceeding with an instruction to the RPC in AUTH48.",
          "createdAt": "2020-10-13T02:14:07Z",
          "updatedAt": "2020-10-13T02:14:07Z"
        }
      ]
    },
    {
      "number": 1270,
      "id": "MDU6SXNzdWU3MDgxOTA0OTA=",
      "title": "When to apply pre-request PRIORITY_UPDATE frames",
      "url": "https://github.com/httpwg/http-extensions/issues/1270",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "The priorities draft states:\r\n\r\n> Request-stream variant PRIORITY_UPDATE frames (type=0xF0700) received before the request or response has started SHOULD be buffered until the stream is opened and applied immediately after the request message has been processed.\r\n\r\nBecause server may reply with a `Priority` field of its own based on priority information, it is better to apply the pre-request _PRIORITY_UPDATE_ frame **before** the server begins to process the request.",
      "createdAt": "2020-09-24T13:50:43Z",
      "updatedAt": "2020-09-24T15:47:46Z",
      "closedAt": "2020-09-24T15:47:45Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure how that helps because my view is that the priority only matters when there are response bytes to send.\r\n\r\nAn intermediary that receives a PRIORITY_UPDATE as an initial priority signal might chose to add that information to the request it sends on to the server. It can make that decision while processing the request. ",
          "createdAt": "2020-09-24T14:03:21Z",
          "updatedAt": "2020-09-24T14:03:21Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": "> I'm not sure how that helps because my view is that the priority only matters when there are response bytes to send.\r\n\r\nEven if that's true (which is a different topic!), how do you know that the server does not have bytes to send as soon as it's processed the request?  If it has stale priority information (due to a yet-unprocessed _PRIORITY_FRAME_), it may issue an incorrect `Priority` response.\r\n\r\nAn intermediary complicates the picture.  The original issue is just about the client - server exchange.",
          "createdAt": "2020-09-24T14:15:00Z",
          "updatedAt": "2020-09-24T14:15:00Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If a server **has** a fresh PRIORITY_UPDATE in a buffer, and it's processing the request that it applies to, then not using the PRIORITY_UPDATE seems like a poor implementation choice. So is the problem that a server-local priority decision would benefit from having client-signalled priority **while** processing the request?",
          "createdAt": "2020-09-24T14:40:10Z",
          "updatedAt": "2020-09-24T14:40:10Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": "Our conversation has devolved to the point where we go in circles.  This is likely because we mean different things by what \"the request message has been processed\" means.\r\n\r\nMy understanding of this is that the user code (sitting one level higher than the HTTP code) has processed the request.  In that case, the point I am making is that applying priority update afterward is suboptimal.  Note that the user code does not have direct access to the incoming _PRIORITY_UPDATE_ frames -- at least not directly.  This is why changing the request's \"urgency\" and \"incremental\" properties should occur before the user code starts handling the request.\r\n\r\nMy mental model is based on [lsquic](https://github.com/litespeedtech/lsquic), so it the above is natural to me.  What kind of model do you have?",
          "createdAt": "2020-09-24T15:02:17Z",
          "updatedAt": "2020-09-24T15:02:17Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@dtikhonov I aplogize because I think you've hit an issue where the Editor's copy does not reflect the most up-to-date markdown. This is partly my source of confusion in the dicussion. I don't know why this has happened. @mnot or @martinthomson might be able to provide insight.\r\n\r\nI beleive we have already merged text that tackles your issue, please see https://github.com/httpwg/http-extensions/commit/8b665dce1fdd65105adb7a7d85c9bedd7ea2dbd8#diff-fa11e89c5392765dabb3b9a9047381abR342 which was done to resolve https://github.com/httpwg/http-extensions/issues/1260\r\n\r\n",
          "createdAt": "2020-09-24T15:22:05Z",
          "updatedAt": "2020-09-24T15:22:05Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "NONE",
          "body": "Oh yeah: the web page is a stale version of the draft! I will now reference a git-cloned copy. Thanks.\r\n\r\nYes: the new text addresses my concern.  I will close this bug.",
          "createdAt": "2020-09-24T15:47:45Z",
          "updatedAt": "2020-09-24T15:47:45Z"
        }
      ]
    },
    {
      "number": 1272,
      "id": "MDU6SXNzdWU3MDk2MzA4ODM=",
      "title": "Unbalanced parentheses",
      "url": "https://github.com/httpwg/http-extensions/issues/1272",
      "state": "OPEN",
      "author": "triple-underscore",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "client-hints",
        "editorial"
      ],
      "body": "The following sentence in [HTTP Client Hints, section 4.1](https://httpwg.org/http-extensions/draft-ietf-httpbis-client-hints.html#information-exposure) has parentheses unbalanced, making it somewhat confusing.\r\n\r\n> The header-based opt-in means that removal of passive fingerprinting vectors is possible, such as the User-Agent string (enabling active access to that information through User-Agent Client Hints ([UA-CH]) or otherwise expose information already available through script (e.g., the Save-Data Client Hint), without increasing the passive fingerprinting surface.",
      "createdAt": "2020-09-26T23:26:33Z",
      "updatedAt": "2020-10-06T04:05:19Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1273,
      "id": "MDU6SXNzdWU3MDk3NzM2OTI=",
      "title": "bnf for dict-member",
      "url": "https://github.com/httpwg/http-extensions/issues/1273",
      "state": "CLOSED",
      "author": "Jxck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "according to the current spec, `dict-member` is defined as\r\n\r\n```bnf\r\ndict-member = member-name [ \"=\" member-value ]\r\n```\r\n\r\nbut current test includes case like below as valid. [link to test](https://github.com/httpwg/structured-field-tests/blob/master/dictionary.json#L114-L117)\r\n\r\n```json\r\n    {\r\n        \"name\": \"missing value with params dictionary\",\r\n        \"raw\": [\"a=1, b;foo=9, c=3\"],\r\n        \"header_type\": \"dictionary\",\r\n        \"expected\": [[\"a\", [1, []]], [\"b\", [true, [[\"foo\", 9]]]], [\"c\", [3, []]]]\r\n    }\r\n```\r\n\r\n`b` 's member-value's are omitted, so `b` is implicitly `true` and it **has parameters** `foo=9` too.\r\n\r\nin my understand from BNF,  if `=` doesn't appear next to member-name, member name section are omitted.\r\n\r\nso if its should valid, BNF should be seems like this.\r\n\r\n```bnf\r\ndict-member = member-name [ ( \"=\" member-value) / parameters ]\r\n```\r\n",
      "createdAt": "2020-09-27T16:47:08Z",
      "updatedAt": "2020-10-14T20:30:35Z",
      "closedAt": "2020-10-13T22:52:33Z",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Heh, when that test was added I logged #1007 for essentially the same reason. The prose text and the algorithm were updated in fa0d3b0ea2412154747b63736ad041b9177b2b50 but I guess the ABNF was overlooked.\r\n\r\n@mnot this report seems right, but it's very late in the day and the ABNF is a second class citizen in this spec. Should it be fixed?",
          "createdAt": "2020-09-29T01:58:22Z",
          "updatedAt": "2020-09-29T01:58:22Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "I hope it should be fixed, because it can be cause an interim problem who implements based on ABNF.",
          "createdAt": "2020-09-29T02:36:42Z",
          "updatedAt": "2020-09-29T02:36:42Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This indeed looks like an oversight, and yes, the ABNF needs to be fixed.",
          "createdAt": "2020-09-29T12:36:12Z",
          "updatedAt": "2020-09-29T12:36:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Oh, that's very annoying; I remember seeing this, but I thought it was fixed.\r\n\r\nPeople should not implemented based upon the ABNF, but yes, it should be fixed.\r\n\r\nI think the right approach is:\r\n\r\n~~~ abnf\r\ndict-member    = member-name ( \"=\" member-value ) / parameters\r\n~~~",
          "createdAt": "2020-10-05T05:56:19Z",
          "updatedAt": "2020-10-05T05:56:19Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "ooh, Github knows ABNF, @reschke!",
          "createdAt": "2020-10-05T05:57:01Z",
          "updatedAt": "2020-10-05T05:57:01Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agree to @mnots ABNF.\r\n\r\nOn a first quick reading it might give people the wrong idea, that parameters are only possible without a value, but the text (and the rest of the ABNF) clarifies that well.",
          "createdAt": "2020-10-05T06:24:45Z",
          "updatedAt": "2020-10-05T06:24:45Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "@mnot just a question\r\n> People should not implemented based upon the ABNF\r\n\r\nWhy should not ? What should I implement based upon ?",
          "createdAt": "2020-10-05T09:17:00Z",
          "updatedAt": "2020-10-05T09:17:34Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "@mnot \r\n> \r\n> I think the right approach is:\r\n> \r\n> ```abnf\r\n> dict-member    = member-name ( \"=\" member-value ) / parameters\r\n> ```\r\n\r\nDo you mean:\r\n\r\n```abnf\r\ndict-member    = member-name ( \"=\" member-value / parameters ) \r\n```\r\n\r\n? ",
          "createdAt": "2020-10-05T21:17:34Z",
          "updatedAt": "2020-10-05T21:18:34Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "@Jxck \r\n> \r\n> Why should not ? What should I implement based upon ?\r\n\r\nThe algorithms. See Section 1.2: \"When parsing from HTTP fields, implementations MUST have behavior that is indistinguishable from following the algorithms. If there is disagreement between the parsing algorithms and ABNF, the specified algorithms take precedence.\" Etc. ",
          "createdAt": "2020-10-05T21:22:59Z",
          "updatedAt": "2020-10-05T21:22:59Z"
        },
        {
          "author": "dtikhonov",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Implementations MUST have behavior that is indistinguishable from following the algorithms.\r\n\r\nOne way to parse it is that one can use ABNF as long as it produces the right answer...",
          "createdAt": "2020-10-05T21:28:14Z",
          "updatedAt": "2020-10-05T21:28:14Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> \r\n> \r\n> > Implementations MUST have behavior that is indistinguishable from following the algorithms.\r\n> \r\n> One way to parse it is that one can use ABNF as long as it produces the right answer...\r\n\r\nSure, if the ABNF is correct. Which it, apparently, isn't (currently).",
          "createdAt": "2020-10-05T23:01:51Z",
          "updatedAt": "2020-10-05T23:01:51Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@phluid61 no. RFC5234 s 3.5 recommends that grouping be used when an alternative consists of multiple rules or literals.",
          "createdAt": "2020-10-06T03:12:55Z",
          "updatedAt": "2020-10-06T03:12:55Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is an area in which parentheses are critical.  In ABNF, concatenation (\" \") has higher precedence than alternation (\"/\"), so @phluid61 is correct to say that...\r\n\r\n```abnf\r\ndict-member    = member-name ( \"=\" member-value / parameters ) \r\n```\r\n\r\n... matches the tests.  This is what the other means:\r\n\r\n```abnf\r\ndict-member    = ( member-name \"=\" member-value ) / parameters\r\n```\r\n\r\nOf course, the original suggestion was probably even better in that it was more explicit.  Even though `[]` is unnecessary given that `parameters` can be empty.",
          "createdAt": "2020-10-06T03:44:25Z",
          "updatedAt": "2020-10-06T03:44:25Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "[RFC5234 s 3.10](https://tools.ietf.org/html/rfc5234#section-3.10), directly below the text that describes operator precedence:\r\n\r\n~~~\r\n   Use of the alternative operator, freely mixed with concatenations,\r\n   can be confusing.\r\n\r\n      Again, it is recommended that the grouping operator be used to\r\n      make explicit concatenation groups.\r\n~~~",
          "createdAt": "2020-10-06T03:47:54Z",
          "updatedAt": "2020-10-06T03:48:22Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "> \"When parsing from HTTP fields, implementations MUST have behavior that is indistinguishable from following the algorithms. If there is disagreement between the parsing algorithms and ABNF, the specified algorithms take precedence.\"\r\n\r\nOh I missed this section. but I think spec should have correct ABNF which is equivalent with algorithms and implementer could implement parser automatically from ABNF instead of saying \"should not implement depend upon the ABNF\".",
          "createdAt": "2020-10-06T04:19:31Z",
          "updatedAt": "2020-10-06T04:19:31Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> \r\n> \r\n> @phluid61 no. RFC5234 s 3.5 recommends that grouping be used when an alternative consists of multiple rules or literals.\r\n\r\nOh, right, sorry I forgot that in ABNF concatenation has higher precedence than alternation. Ignore me.",
          "createdAt": "2020-10-06T05:38:56Z",
          "updatedAt": "2020-10-07T03:25:48Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is the ABNF for production or consumption?  Because...\r\n\r\n>  Note that this requirement is only on serialisation; parsers are still required to correctly handle the true Boolean value when it appears in Dictionary values. \r\n\r\nWould suggest that the grammar a parser uses might be:\r\n\r\n```abnf\r\ndict-member    = member-name ( [ \"=\" sf-boolean ] parameters /  \"=\" member-value )\r\n```\r\n\r\nWhereas it appears that serialization needs to use the simpler:\r\n\r\n```abnf\r\ndict-member    = member-name ( parameters /  \"=\" member-value )\r\n```\r\n",
          "createdAt": "2020-10-06T05:51:35Z",
          "updatedAt": "2020-10-06T05:51:35Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah I'm confused again now. [RFC 5234, Section 3.5](https://tools.ietf.org/html/rfc5234#section-3.5) says:\r\n\r\n~~~text\r\n         elem (foo / bar) blat\r\n\r\n   matches (elem foo blat) or (elem bar blat), and\r\n\r\n         elem foo / bar blat\r\n\r\n   matches (elem foo) or (bar blat).\r\n~~~\r\n\r\nWhich means that\r\n\r\n~~~abnf\r\ndict-member = member-name ( \"=\" member-value ) / parameters\r\n~~~\r\n\r\nis equivalent to\r\n\r\n~~~abnf\r\ndict-member = ( member-name \"=\" member-value ) / parameters\r\n~~~\r\n\r\nWhich is how I read it originally, and how I'm pretty sure every other ABNF I've seen does it. (Even RFC 7230's definition of `quoted-pair`)",
          "createdAt": "2020-10-06T07:18:50Z",
          "updatedAt": "2020-10-06T07:18:50Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That is a correct reading.  Hence my suggestion above (and the different ordering).",
          "createdAt": "2020-10-07T00:16:17Z",
          "updatedAt": "2020-10-07T00:16:17Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Or if you really, really want the grouping operator for the concatenation group:\r\n\r\n```abnf\r\ndict-member    = member-name ( ( \"=\" member-value ) / parameters )\r\n; OR\r\ndict-member    = member-name ( parameters / ( \"=\" member-value ) )\r\n```",
          "createdAt": "2020-10-10T22:26:20Z",
          "updatedAt": "2020-10-10T22:26:20Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "To @martinthomson's question above:\r\n\r\n> This document uses... the Augmented Backus-Naur Form (ABNF) notation of [RFC5234] to illustrate expected syntax in HTTP header fields.\r\n\r\n> When parsing from HTTP fields, implementations MUST have behavior\r\n   that is indistinguishable from following the algorithms.  If there is\r\n   disagreement between the parsing algorithms and ABNF, the specified\r\n   algorithms take precedence.\r\n\r\n> For serialization to HTTP fields, the ABNF illustrates their expected\r\n   wire representations, and the algorithms define the recommended way\r\n   to produce them.  Implementations MAY vary from the specified\r\n   behavior so long as the output is still correctly handled by the\r\n   parsing algorithm.\r\n\r\n Regarding grouping: my reading of 5234 is that concatenated groups be explicitly delimited not for correctness, but to avoid likely reader confusion (since some people will assume precedence in a different order).\r\n\r\nSo, I think that leaves us with:\r\n\r\n~~~ abnf\r\ndict-member    = member-name ( parameters /  ( \"=\" member-value ) )\r\n~~~\r\n\r\nThe small price of a bit more visual noise is well worth the clarity, IMO.\r\n\r\nComments? We're now in AUTH48, so I'd like to come to a decision.",
          "createdAt": "2020-10-13T03:11:08Z",
          "updatedAt": "2020-10-13T03:11:08Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that is right and good.  And yes, 5234 recommends parentheses for exactly this reason.  (You can drop the extra space I added after the '/'.)",
          "createdAt": "2020-10-13T03:28:14Z",
          "updatedAt": "2020-10-13T03:28:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@phluid61 @bsdphk @Jxck anybody else?",
          "createdAt": "2020-10-13T04:40:47Z",
          "updatedAt": "2020-10-13T04:40:47Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK with me",
          "createdAt": "2020-10-13T10:41:43Z",
          "updatedAt": "2020-10-13T10:41:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "AUTH48 request made.",
          "createdAt": "2020-10-13T22:52:33Z",
          "updatedAt": "2020-10-13T22:52:33Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "@mnot \r\nthat doesn't works fine for me.\r\n\r\nas parameters definition covers anything because of it's optional itself.\r\n\r\n```abnf\r\ndict-member    = member-name ( parameters /  ( \"=\" member-value ) )\r\nparameters     =  *( \";\" *SP parameter )\r\n```\r\n\r\nit matches `a=b` as \"`a` with no parameters and rest of `=b`\"\r\n\r\nso It works better as defined below.\r\n\r\n```abnf\r\ndict-member    = member-name ( ( \"=\" member-value ) / parameters )\r\n```\r\n\r\nalmost same with my first proposal and it **already running in my code**.\r\n- https://github.com/Jxck/structured-field-values/blob/master/index.js#L507",
          "createdAt": "2020-10-14T09:00:04Z",
          "updatedAt": "2020-10-14T09:41:45Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@jxck I'm confused. What's the practical difference between them? Ordering of alternatives isn't significant.",
          "createdAt": "2020-10-14T09:14:46Z",
          "updatedAt": "2020-10-14T09:14:46Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "@mnot ah, reasonable. in that case, both are matched then How to determine which are intended ?\r\n\r\n```\r\na=b\r\n=> result: {member-name: a, parameters: {}} , rest: \"=b\"\r\n=> result: {member-name: a, member-value: b, parameters: {}}, rest: \"\"\r\n``` \r\n\r\n\r\n",
          "createdAt": "2020-10-14T09:34:34Z",
          "updatedAt": "2020-10-14T09:35:03Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "If \"parameters optional itself\" could be fix.\r\nthen something like below works fine for here.\r\n(but it required widely change...)\r\n\r\n```abnf\r\ndict-member    = member-name ( (\";\" parameters) /  ( \"=\" member-value ) )\r\n```",
          "createdAt": "2020-10-14T09:40:46Z",
          "updatedAt": "2020-10-14T09:41:25Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@Jxck it sounds like you want unique particle attribution, which was never promised. The second interpretation, where there is no remainder, is what the algorithm produces.",
          "createdAt": "2020-10-14T20:30:35Z",
          "updatedAt": "2020-10-14T20:30:35Z"
        }
      ]
    },
    {
      "number": 1274,
      "id": "MDU6SXNzdWU3MDk4MTMxMjE=",
      "title": "Need a way to tell if server supports priority",
      "url": "https://github.com/httpwg/http-extensions/issues/1274",
      "state": "CLOSED",
      "author": "guoye-zhang",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "Extensible priority scheme is an extension which server might not choose to implement. However, [Low-Latency HTTP Live Streaming](https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-07) depends on current HTTP/2 dependencies and weights, and if it is to switch to the new scheme, client needs to tell if the server supports priority. In case priority isn't supported, client would disable low-latency features and fallback to regular HLS.",
      "createdAt": "2020-09-27T20:46:49Z",
      "updatedAt": "2020-10-17T00:08:51Z",
      "closedAt": "2020-10-17T00:08:51Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe this is already covered under section 2.1  https://tools.ietf.org/html/draft-ietf-httpbis-priority-01#section-2. An HTTP/2 server that implement the extension MUST send the setting.",
          "createdAt": "2020-09-27T21:04:16Z",
          "updatedAt": "2020-09-27T21:04:16Z"
        },
        {
          "author": "guoye-zhang",
          "authorAssociation": "NONE",
          "body": "@LPardue This is not exactly about detecting old or new priority scheme in HTTP/2. We also want to know if an HTTP/3 server supports priority. And when HTTP/2 dependency is removed from the next version of RFC, there could HTTP/2 servers that don't support either scheme.",
          "createdAt": "2020-09-27T22:14:57Z",
          "updatedAt": "2020-09-27T22:14:57Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, it sounds like a slightly different requirement. \r\n\r\nAn explicit \"I support extensible priorities\" signal would likely want to future proof itself for some other scheme or signal. This is a slippery slope of complexity. I have an unpushed branch for draft-lassey-priority-setting that explored advertising multiple priority schemes and agreeing on one. This got gnarly pretty quick, and seemed to me way more complicated than needed for the problem the design team set out to solve.\r\n\r\nLooking at LLHLS, it says\r\n\r\n> Efficient delivery requires HTTP/2 priority control (dependencies  and weights) \r\n\r\nThis requirement is IMO at odds with the premise of priorities, even the H2 scheme we have today. RFC 7540 says:\r\n\r\n> An endpoint cannot force a peer to process concurrent streams in a particular order using priority.\r\n\r\nGiven that LLHLS seems to be a specialisation of HTTP/2, I wonder if it would be better served by an ability for a server to advertise if it supports LLHLS or not, rather than building up the picture from protocol foundations or extensions.\r\n",
          "createdAt": "2020-09-27T23:02:04Z",
          "updatedAt": "2020-09-27T23:02:04Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And while exploring this tangent, I wonder how JavaScript-based HAS players using Fetch or XHR would approach connection-based HTTP feature detection. Maybe @wilaw could share some insight about how this can or can't be done.",
          "createdAt": "2020-09-27T23:11:23Z",
          "updatedAt": "2020-09-27T23:11:23Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "@LPardue the Apple LL-HLS client will fall back to regular latency if the server does not support a required set of functionality because the algorithms will behave improperly otherwise. This includes request multiplexing within a single connection, the ability to strictly order pipelined requests for a single flavor of media , and the ability to prioritize simultaneous requests for certain flavors (bit rates, metadata) above others. \r\n\r\nThis does not require a negotiation of prioritization schemes, the direction it seems you went in your \"slippery slope of complexity\" tangent. It only requires that the service positively indicate the current generation of scheme that it supports.",
          "createdAt": "2020-09-27T23:26:51Z",
          "updatedAt": "2020-09-27T23:26:51Z"
        },
        {
          "author": "guoye-zhang",
          "authorAssociation": "NONE",
          "body": "One of the goals of HLS is that it can be served by any HTTP server and takes advantage of existing CDN infrastructure, so we want to avoid a dedicated signal for LLHLS if possible.",
          "createdAt": "2020-09-27T23:31:49Z",
          "updatedAt": "2020-09-27T23:31:49Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The use case is quite focused. The general the problem I see is that if you have both endpoints stating they support future multiple schemes, how do the endpoints agree to on which scheme to use? If you don't agree on one, then you'll end up having to send them all, and they might not even be compatible. That's not a very nice situation.\r\n\r\nOne problem today is _all_ HTTP/2 servers support the tree-based scheme. But they might not respect the prioritization requirements that you have. If we had a means to state extensible priority support, I wouldn't be surprised if some servers also didn't live up to the requirements. That's why I question the value of such a signal.\r\n\r\n",
          "createdAt": "2020-09-27T23:54:16Z",
          "updatedAt": "2020-09-27T23:54:38Z"
        },
        {
          "author": "guoye-zhang",
          "authorAssociation": "NONE",
          "body": "The hope is that this priority scheme is general enough for LLHLS use case. Inventing another prioritization scheme which achieves largely the same thing would not be ideal. Nor if server is forced to interpret this priority scheme in a more specific way to support LLHLS.\r\n\r\nI wonder if it's possible to add feature detection for HTTP extensions in general. It would also be useful for, for example, resumable upload support.",
          "createdAt": "2020-09-28T07:40:40Z",
          "updatedAt": "2020-09-28T07:40:40Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The hope is that this priority scheme is general enough for LLHLS use case. Inventing another prioritization scheme which achieves largely the same thing would not be ideal. Nor if server is forced to interpret this priority scheme in a more specific way to support LLHLS.\r\n\r\nThen I'm confused. The issue appears to state that a client needs to know if the server provides \"strictly order pipelined requests for a single flavor of media , and the ability to prioritize simultaneous requests for certain flavors (bit rates, metadata) above others.\". Since extensible priorities does not mandate server behaviour, advertising it's being used isn't a strong enough contract for you.\r\n",
          "createdAt": "2020-09-28T10:01:27Z",
          "updatedAt": "2020-09-28T10:01:27Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can see the desire to use different prioritization signals based on what the server claims to do. But I think I agree with @LPardue that, in general, it is dangerous to assume that the two properties are equal: if a server implements a prioritization scheme, and if a client can exploit certain capabilities of that prioritization scheme.\r\n\r\nTo give an example, consider the case where a H2 terminator sits in front of a H1 server, the number of concurrent requests from the H2 terminator to the H1 server is limited to 5 per each H2 connection, the stream-level concurrency of the H2 connection would be 100. This as a reasonable configuration; it provides enough concurrency for the H2 hop to hide the latency, avoids excessive use of the application server (doing H1). But a client cannot utilize the capability of receiving 100 incremental responses concurrently.",
          "createdAt": "2020-09-28T10:41:21Z",
          "updatedAt": "2020-09-28T10:41:21Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "I'm confused about your apparent desire to not signal prioritization capability. How is a client to use any sort of prioritization scheme if the supported scheme(s) are not signaled?",
          "createdAt": "2020-09-28T15:17:57Z",
          "updatedAt": "2020-09-28T15:17:57Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sending the signals causes no interoperability problems if the target server does not support the prioritization scheme. This is part of the strength of extensible priorities, that it can be extended without the requirement of upfront coordination. Adding a signal for supporting extensible priorities could soon degrade to needing to enumerate all supported priority parameters. \r\n\r\n",
          "createdAt": "2020-09-28T15:43:43Z",
          "updatedAt": "2020-09-28T15:43:43Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "NONE",
          "body": "Quoting from this [source](https://developers.google.com/web/fundamentals/performance/http2) and repeating a point made by Lucas earlier about RFC 7540 \"_Stream dependencies and weights express a transport preference, not a requirement, and as such do not guarantee a particular processing or transmission order. That is, the client cannot force the server to process the stream in a particular order using stream prioritization. While this may seem counterintuitive, it is in fact the desired behavior. We do not want to block the server from making progress on a lower priority resource if a higher priority resource is blocked_.\".\r\n\r\nSo it would seem that any LL-HLS client cannot depend upon prioritization taking place in a H2 conformant server. The client may ask for prioritization but it will not receive an explicit signal that this has been implemented by the server. It will receive an implicit signal however, which is the turn-around time and throughput it receives on its playlist and part requests. Its algorithm should be robust at interpreting and handling these signals. The performance a client receives over a poor last mile network talking to a server implementing prioritization may well be indistinguishable from the performance it receives from a good last mile network talking to a non-prioritizing server. It needs to work under either scenario. It may need to back off on its target latency based on these signals for example. ",
          "createdAt": "2020-09-28T15:46:37Z",
          "updatedAt": "2020-09-28T15:46:37Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "@LPardue so your recommendation to clients is that they just start playing whack-a-mole with the server, sending it a variety of prioritization signals, until they find one that it responds to?",
          "createdAt": "2020-09-28T16:42:12Z",
          "updatedAt": "2020-09-28T16:42:12Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since there is no way to validate that a server behaves in any particular way that a client wants, then they are already playing whack-a-mole. HTTP/2 prioritization signal parsing is mandatory to implement but acting on that is not. And that leads to varying quality of implementation; see https://github.com/andydavies/http2-prioritization-issues where a significant portion of tested services report failure for a certain type of test.\r\n\r\nFurthermore, servers can take any signals into account when making prioritization decisions. That could be signals outside this scheme, which may interfere with your prioritization requirements.\r\n\r\nWould you really be happy with a setting that says \"I support parsing the Priority header\"? We don't tend to have such signals for other HTTP headers, it seems like an anti-pattern.\r\n\r\nIf a LL-HLS client wants a server to assert that it support LL-HLS, it seems more natural to have a setting that advertises just that. Then you can apply more stringent prioritization/ multiplexing requirements and performance goals on that server.",
          "createdAt": "2020-09-28T18:01:40Z",
          "updatedAt": "2020-09-28T18:02:11Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "To use an optional feature you need a signal that says \"I support a particular set of semantics.\" You have to consider it from the POV of a client who wants to use the feature:\r\nCLIENT: Hey server, there's this feature I want to use. Do you support it?\r\nSERVER: Well, I support its syntax\r\nCLIENT: So you support it?\r\nSERVER: Maybe! Your feature uses it and was defined in 2020. A couple other features use the same syntax, one was defined in 2021 and another in 2023\r\nCLIENT: Hey, the 2023 feature uses the same bit to do something different that would kill my performance!\r\nSERVER: Oooh, you're right\r\nCLIENT: So can I burn a few RTTs with a test to see how you treat that bit?\r\nSERVER: Possibly. But your feature is best-effort so you'll need to do it a bunch of times to get confidence\r\nCLIENT: I guess I can't use this feature after all. Who designed this, anyway?\r\n\r\nLet's look at IP protocols with optional features that have been well-adopted. TCP and TLS both do optional features right: they provide positive signals of support. They have achieved broad adoption with a minimum of drama.\r\n\r\nThen there are counter-examples of features that are unsignaled and implicit. HTTP 1.1 pipelining and Range requests come to mind. They are both disastrous (for their intended use) when used against servers that don't  support them, and their adoption has suffered as a result. It was bad protocol design then and it's bad protocol design now.",
          "createdAt": "2020-09-29T15:59:16Z",
          "updatedAt": "2020-09-29T15:59:16Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is a strong case of you ain't gonna need it. I don't anticipate someone defining another prioritization scheme. But if they do, and we don't know what it is, then designing a negotiation mechanism to help select different schemes now has a risk of failure.\r\n\r\nAs I said earlier, extensible priorities is an extension that itself is extensible. If you want absolute cast-iron guarantees from endpoints about what they do, then you have to run the task to completion. \r\n\r\nI'm not familiar with other HTTP extensions that have this upfront server advert requirement. If there are then I'd appreciate references to them. Otherwise their absence is telling that HTTP feature detection is a problem that is not solved trivially. \r\n\r\nLikewise, if you have proposals that would satisfy your request them please write them up and share them as a PR. Because I suspect people are finding it hard to talk around a solution when little is written down.",
          "createdAt": "2020-09-29T16:18:22Z",
          "updatedAt": "2020-09-29T16:18:55Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@roger-on-github \r\n\r\n> Then there are counter-examples of features that are unsignaled and implicit. HTTP 1.1 pipelining and Range requests come to mind. \r\n\r\nPipelining is not an optional feature. Yes, there's breakage, but it's not an example of extensibility gone wrong.\r\n\r\nRange requests/responses IMHO have all the signalling that is needed, so it would be nice if you could be more specific.",
          "createdAt": "2020-09-29T16:29:31Z",
          "updatedAt": "2020-09-29T16:29:31Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "@reschke a client that issues a Range request for the middle 140 bytes of a 3GB file to a server that does not handle Range requests will receive a 200 and 3GB of data. For a client that was trying to use Range requests to limit itself to an operationally required amount of data, getting 3GB instead is a terrible outcome.",
          "createdAt": "2020-09-29T17:32:36Z",
          "updatedAt": "2020-09-29T17:32:36Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "It's not a strong case of you ain't gonna need it, it's more like a strong case of \"nobody's going to use it because the outcome is undefined and might actually be worse than using it.\" Not anticipating someone defining another prioritization scheme is a poor excuse not to plan for it. \r\n\r\nAt this point I've moved beyond the specifics of LL-HLS, to criticizing the overall plan to provide optional, extensible, unsignaled prioritization capability in H3 (or H2), on behalf of any client that might want to use it for anything.\r\n\r\nAt the very least, to make it adoptable and future-proof you would need to do the following:\r\n- Restrict the request syntax in a way that is uniquely bound to a particular capability set so that a client making the request is assured that it cannot be interpreted as any other semantic. Maybe by reserving a frame type for it, maybe with an IANA-managed capability selector and a version number, or something else.\r\n- Provide a positive indicator if the responding server could not support the requested capability. In the case of a prioritization request to a server that does not support that prioritization method, for example, this might take the form of a mandatory \"Prioritization-Exception\" HTTP response header that indicated that the server does not support that method. That would allow the client to react appropriately, such as by changing its request pattern or by trying a different prioritization method.",
          "createdAt": "2020-09-29T17:53:34Z",
          "updatedAt": "2020-09-29T17:53:34Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Not anticipating someone defining another prioritization scheme is a poor excuse not to plan for it.\r\n\r\nI did the thought experiment and wrote a candidate design. I didn't like the complexity this added to the protocol. Please present a design that you believe will address your requirements and the WG can assess it.\r\n\r\n> Restrict the request syntax in a way that is uniquely bound to a particular capability set so that a client making the request is assured that it cannot be interpreted as any other semantic. Maybe by reserving a frame type for it, maybe with an IANA-managed capability selector and a version number, or something else.\r\n\r\nThe syntax is a Structured Headers dictionary, carried in a header or a frame. We've had the headers vs frames debate in the WG, the outcome was to provide both. Revisiting this would need WG chair intervention.\r\n\r\n> Provide a positive indicator if the responding server could not support the requested capability. In the case of a prioritization request to a server that does not support that prioritization method, for example, this might take the form of a mandatory \"Prioritization-Exception\" HTTP response header that indicated that the server does not support that method. That would allow the client to react appropriately, such as by changing its request pattern or by trying a different prioritization method.\r\n\r\nThis is cannot be done with Structured Headers dictionary, see https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-17#section-3.2\r\n\r\n>   Typically, a field specification will define the semantics of\r\n   Dictionaries by specifying the allowed type(s) for individual member\r\n   names, as well as whether their presence is required or optional.\r\n   Recipients MUST ignore names that are undefined or unknown, unless\r\n   the field's specification specifically disallows them.\r\n\r\nThe proposal here requires design changes to the protocol. There'd need to be WG support for making such changes.",
          "createdAt": "2020-09-29T18:07:08Z",
          "updatedAt": "2020-09-29T18:07:21Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@roger-on-github \r\n\r\n...it could do a HEAD request first and check for Accept-Ranges.",
          "createdAt": "2020-09-29T18:35:05Z",
          "updatedAt": "2020-09-29T18:35:05Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue \r\n>> Not anticipating someone defining another prioritization scheme is a poor excuse not to plan for it.\r\n> \r\n> I did the thought experiment and wrote a candidate design. I didn't like the complexity this added to the protocol.\r\n\r\nI think that there is a distinction between having a signal and having a plan.\r\n\r\nWhile it is true that we do not have a signal to indicate support for extensible priorities, it does not mean that the new scheme is unextensible or replaceable. If there becomes a necessity, people can define new parameters to extend the scheme, or define new set of header fields / frames that would supersede the extensible priorities.\r\n\r\nRegarding if it would be a good idea to define a signal indicating support for extensible priorities _now_, under the premise that it would be used by the client to change it's behavior, I would reiterate what others (including me) have pointed out. Don't do that, because recognizing the prioritization signal does not mean that the server would (can) obey to those signals sent by the client.\r\n\r\nThe hard lesson we learned from HTTP/2 is that many servers do not (correctly) implement the prioritization scheme. We have seen poor performance due to that. That's why we are introducing a new scheme that is conservative, that would not lead to unnecessarily bad performance even when there are issues within the endpoints.",
          "createdAt": "2020-09-30T12:26:57Z",
          "updatedAt": "2020-10-01T07:59:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@roger-on-github have you considered putting a signal inside the manifest?",
          "createdAt": "2020-10-07T06:35:10Z",
          "updatedAt": "2020-10-07T06:35:10Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "Responding collectively:\r\n\r\nI agree with @LPardue that it's difficult to have this discussion without a concrete proposal. So I've created a PR with a proposed design here: https://github.com/httpwg/http-extensions/pull/1283\r\n\r\nTo address the concern raised by @kazuho , my proposal does not require a promise of priority support, only an acknowledgment that a requested prioritization was applied to a particular response.\r\n\r\n@mnot : asking intermediaries to change their delivery behavior based on deep inspection of the response is not something I considered, no. Is that a recommended pattern for HTTP delivery these days? Do you know of any examples that have achieved wide adoption (i.e. by a broad range of CDNs)? It seems like a layer violation to me.",
          "createdAt": "2020-10-07T18:22:22Z",
          "updatedAt": "2020-10-07T18:22:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the proposal @roger-on-github .\r\n\r\nIn a nutshell it defines a new parameter `ap` that is mandatory and attests to the server having applied something.\r\n\r\nThe problem I have with that design it that, as an implementer of an HTTP/3 stack, I depend on the QUIC transport to manage bandwidth allocation. My server is dependent on both the behaviour of the local stack, the client's flow control (stream and connection) and retransmission logic. All of those things affect how the client could perceive bandwidth usage over some time period, and they are things that happen somewhere that is not exposed to my serving application at the time I emit the response header.\r\n\r\nIt is unfair to say that this server has not applied the priority signal. It will most likely do what the client asked for. If the client is going to measure bandwidth allocation and make informed decisions for future requests, I'm not sure the value of this parameter.\r\n\r\nThis new parameter also introduces a downside. Currently the response header is defined as `A server uses it to inform the client that the priority was overwritten`. So in the conventional case where a server follows the client signal, we would not need to generate a response header at all. The new parameter would require the header to be sent if the priority was applied.",
          "createdAt": "2020-10-07T18:34:16Z",
          "updatedAt": "2020-10-07T18:37:42Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "The applied parameter does not attest anything more than the application of the requested prioritization to the scheduling logic at the HTTP level. It is understood that in exceptional cases the vagaries of the underlying transport can change the effective outcome. That does not negate the value of the server scheduling, nor the client's decision to ask for it.\r\n\r\nI agree that always adding the response header adds a minor cost. If the consensus here is that this cost significant, my proposal could be modified to add a second (request) parameter that requests this acknowledgment (or a SETTING that requests that behavior).",
          "createdAt": "2020-10-07T18:47:30Z",
          "updatedAt": "2020-10-07T18:50:06Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I disagree that this is an exceptional case. I delegate stream scheduling to the QUIC transport layer implementation, which abstracts how it works. I will feed the transport as fast as I can. I don't know what claim my HTTP layer can make. ",
          "createdAt": "2020-10-07T18:55:21Z",
          "updatedAt": "2020-10-07T18:55:21Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "How does your implementation behave when two files are requested, both are immediately available, and a priority of incremental=0 is requested for both?",
          "createdAt": "2020-10-07T18:57:35Z",
          "updatedAt": "2020-10-07T18:57:35Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's worth highlighting that H3 differs from H2 in that *stream-based* payload is subject to flow control and retransmission. And so to keep the transport simple, all stream contents are equally prioritised. H2 typically focused on DATA frames, which correlate to response payload only.\r\n\r\nSo taking 2 requests with urgency=3 and incremental=0. The transport offers a larger urgency space for non-response streams. Extensible priority urgency fits in the middle of that space.\r\n\r\nFor the given example, the transport will:\r\n\r\nAlways prioritise trying to send on H3 control streams.\r\nThen attempt to send response data on streams in the order they were generated.\r\n\r\nThe H3 layer can only write as much data to a stream as there is flow control. So if, for example, the client stopped reading the response on stream 0, the stream would become application blocked. The transport would then move onto stream 4 in order to keep the pipe occupied.\r\n\r\nEven if the client wasn't behaving weird. It is possible that packets that carry Window updates from client to server get lost. And so the server is quite dependent on its view of window size at any instant. ",
          "createdAt": "2020-10-07T19:33:42Z",
          "updatedAt": "2020-10-07T19:33:42Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The proposed `ap` parameter can also only apply to the mandatory parameters (because unknown extensions are ignored). So its usefulness is quite restricted.\r\n\r\nBut I'm also concerned about how it would interplay with extensions. For instance, I have a candidate, non-published, response extension parameter that would allow refining how a server sends chunks. Do I tell the client I am not applying things precisely as asked nd risk it taking the wrong action? It seems I'd have an incentive to mask the details.",
          "createdAt": "2020-10-07T19:48:38Z",
          "updatedAt": "2020-10-07T19:48:38Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "Regarding H3: flow control is managed (or at least influenced) by the client. So it is possible that a sufficiently advanced client with a knowledge of the expected (approximate) size of the payloads could arrange things so that substantially all of the segment1 bytes were put onto the wire before any segment2 bytes, and (statistically) the client will receive all the segment1 bytes first.\r\n\r\n(And in fact if that is not possible, then it is likely that H3 is not a suitable protocol for this kind of application, or any application where performance depends on strict delivery ordering.)\r\n\r\nRegarding extensibility: would you prefer a design where the client simply requests explicit acknowledgement of the applied priority, whatever it ends up being? In other words, a request parameter that triggers a mandatory attachment of a priority header to the response.",
          "createdAt": "2020-10-07T20:05:26Z",
          "updatedAt": "2020-10-07T20:05:26Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A H2 client is also in control of stream receive windows, so it could employ such a strategy too. Think of H2 like a meta-transport in this respect. You'd probably be best served by conservative initial stream windows (which are common across all streams in H2 and H3 ) and then aggressive window growing for the stream of upmost importance. Knowledge of the resource size could help but might not even be necessary. The tradeoff is that you block the other streams and potentially starve the pipe if the first request is not available for some reason. But I totally get that video streaming has different demands for resource loading compared to the web. HoL avoidance features might mess you up, while they really help other HTTP-poweted workloads.\r\n\r\nIn my experience, one problem we have is that H2 and H3 settings are made quite generically. A browser that tried to adopt the above strategies might suffer regressions. However, they can adopt different strategies for managing the pipe; for example being clever with request ordering and batching (e.g not making all requests concurrently).\r\n\r\n",
          "createdAt": "2020-10-07T20:37:20Z",
          "updatedAt": "2020-10-07T20:37:20Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@roger-on-github Thank you for the concrete proposal.\r\n\r\n> @mnot : asking intermediaries to change their delivery behavior based on deep inspection of the response is not something I considered, no. Is that a recommended pattern for HTTP delivery these days? Do you know of any examples that have achieved wide adoption (i.e. by a broad range of CDNs)? It seems like a layer violation to me.\r\n\r\nWould that concern evaporate if we use a dedicated URI (i.e. something like `/.well-known/llhls`; cf. [RFC 5785])(https://tools.ietf.org/html/rfc5785)) to communicate the server capabilities?\r\n\r\nI am not fully sure if using an end-to-end signal (a HTTP response) is the best solution, as each hop might have different capabilities, but I think that using a dedicated resource is no worse than using a HTTP response header as proposed in #1283. In fact, as prioritization is about choosing what to send when multiple responses compete on _one_ connection, having one signal per connection is better IMO.",
          "createdAt": "2020-10-07T23:29:05Z",
          "updatedAt": "2020-10-07T23:29:05Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And/or you could put it in the DNS",
          "createdAt": "2020-10-07T23:39:31Z",
          "updatedAt": "2020-10-07T23:39:31Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "I don't think that using a well-known URI scales very well. Content providers often offer the same content to both old and new clients, via both HTTP 1.1 and H2 (and maybe some day H3) using the same directory structure but different protocol implementations. It's probably not reasonable to ask a CDN to support extensible priorities on all three, or to perform directory magic to insert a dummy path element against protocols that support a feature. And if you add more than one such feature the complexity scales geometrically. That sounds much worse than an HTTP response header to me, from the point of view of someone trying to implement the whole system.\r\n\r\nThere are a few problems with \"one signal per connection.\" First, it's more complex, because that signal has to encapsulate the entire priority tree for all active requests. Second, it would require new terminology not currently defined. And third, it would need to be refreshed each time a new request became active or an old request finished to remain accurate.\r\n\r\nI will write up an alternate design based on the earlier feedback from @LPardue and share it soon.",
          "createdAt": "2020-10-08T00:07:59Z",
          "updatedAt": "2020-10-08T00:07:59Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there might be some cross talk between concepts of \r\n\r\n1. \"does the server support the priority scheme and some optional extension parameters, and is willing to be subjected to some additional scrutiny by clients\"\r\n\r\n2. Is the server doing exactly what the client asked it.\r\n\r\nConcept 1) suits a .well-known or HTTPSVC still service, because it decorates the HTTP connection\r\n\r\nConcept 2) requires a server to give up information about itself, with unclear ramifications. Active probing like this has problems. And a design that depends on HTTP request/response, seems to be incompatible with endpoints that wish to only implement frame-based prioritisation. So it causes a problem for this I-D that needs to support both.",
          "createdAt": "2020-10-08T00:22:08Z",
          "updatedAt": "2020-10-08T00:22:40Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think I like how @LPardue describes the difference between the two concepts.\r\n\r\nAnd if the client is going to issue requests differently based on how server behaves, I think that it is better to provide server administrators the knob for opting in/out. Because, then, the server administrators can use that knob to choose the client policy that works best.\r\n\r\nAs @LPardue points out, it is hard to make a good decision based on if the server recognizes the priority request header field, because how the servers actually prioritize the responses depend on many many factors.\r\n\r\n@roger-on-github I think how well a well-known URI would scale depends on how you would design that metadata. To give an example, if we think that the server administrator might opt in to using LLHLS only for HTTP/3, then the well-known URI could be defined to contain a JSON array of ALPNs for which LLHLS should be used.",
          "createdAt": "2020-10-08T00:50:18Z",
          "updatedAt": "2020-10-08T00:50:18Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "@kazuho the server administrators generally do not have enough knowledge of the client behavior (which itself tends to change over time and between clients) to choose a \"best\" policy.\r\n\r\nAnd to be clear: I don't anticipate defining a specific signal for LL-HLS. That would be a classic error of defining something in terms of what it's for instead of how it must work. At most, if I were to add prioritization rules to the LL-HLS spec I expect that I would add a provision that \"servers using H3 MUST support extensible priorities with the following (possibly non-standard) extensions...\" Extensible priorities are apparently what we've got for H3, so my intention is to build on that.",
          "createdAt": "2020-10-08T01:02:16Z",
          "updatedAt": "2020-10-08T01:02:16Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "Okay, I've written up an alternative proposal (which we can call A2): https://github.com/httpwg/http-extensions/compare/master...roger-on-github:add-ack\r\n\r\nEssentially it replaces the applied response parameter with an 'acknowledge' request parameter, which mandates a response header containing whatever prioritization was applied (or none).\r\n\r\nIt addresses the following concerns:\r\n- it mitigates the cost of the applied parameter by making reporting opt-in by the client\r\n- it addresses the question of extensions by allowing the server to populate the response header with whatever it knows about",
          "createdAt": "2020-10-08T01:11:12Z",
          "updatedAt": "2020-10-08T01:11:12Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@roger-on-github \r\n> the server administrators generally do not have enough knowledge of the client behavior (which itself tends to change over time and between clients) to choose a \"best\" policy.\r\n\r\nI understand the sentiment, but I tend to think that it might be a more reliable signal for changing the request policy than using a signal indicating acknowledgement of a signal.\r\n\r\nPS. Thank you for clarifying the intended use-case.",
          "createdAt": "2020-10-08T01:14:48Z",
          "updatedAt": "2020-10-08T01:16:33Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that writing the requirement \"MUST support priorities\" is part of the problem. It clashes with the design principles of prioritisation and nature of HTTP (which we're stuck with good and bad).\r\n\r\nTo elaborate, adding a MUST requirement for a feature that is, by definition, optional for a server to implement is odd. It's made worse by the client having very limited ability to detect this condition is held true. A javascript client in a browser is not going to be aware of how requests map to connections, so any bandwidth allocation measurements are going to be tricky.\r\n\r\nA different way to write this would be to say something like (forgive my lack of details): an llhls server MUST provide the A,B,C multiplexing and bandwidth allocation characteristics because X,Y,Z. A client that detects these characteristics are unmet MUST/MAY leave/fallback etc. It is RECOMMENDED that the Extensible priority scheme is used together with parameters Foo, Bar. H2 connections MAY use the tree-based scheme. An HTTP server that is aware it is llhls enabled but unable to satisfy these conditions for any reason can respond with a header field \"llhls: sorry\".\r\n\r\nI think that makes it clear for a server operator what the expectations are, and they can make the judgement call about whether their stack can be molded to fit them.",
          "createdAt": "2020-10-08T01:36:05Z",
          "updatedAt": "2020-10-08T01:36:05Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "@LPardue I get the limitations around MUST. I really do. it might be a good idea to define some kind of means test, with a hypothetical server model and perhaps an open-source test suite that can be run when qualifying or debugging the server/CDN, so that failure to perform is readily identified and the server can be flagged. Maybe that means test makes it into the spec.\r\n\r\nBut to return to the subject of this thread: at some level of optimization, a client needs to know whether a tool is available in order to employ that tool. Let's take the example from https://github.com/httpwg/http-extensions/pull/1283: response ordering. In a normally multiplexed environment like H3, there are optimizations that a client can do if it can trigger pipelined responses to be delivered serially, at least to an extent that is generally effective. But if it cannot then it has to avoid that request pattern, because the performance cost of the result would be actually worse than the prospective gain of the optimization. ",
          "createdAt": "2020-10-08T16:26:57Z",
          "updatedAt": "2020-10-08T16:26:57Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In a normally multiplexed environment like H3, there are optimizations that a client can do if it can trigger pipelined responses to be delivered serially\r\n\r\nTo be pedantic, QUIC offers no ordering guarantees across streams. A server cannot guarantee that you'll receive stream data in the order that it was sent. Even if it was all delivered in the exact order, then it's quite likely that the QUIC transport layer will not present that information to the application.\r\n\r\nIf you really need strict serialization or synchronization across streams then you'll have to build that capability. For instance, QPACK is stateful and requires synchronization across control streams, request streams and response streams. That is some heavily lifting but the gains for compression have been deemed worth the complexity.\r\n\r\nAlternatively you can run the client very conservatively, running requests serially or using flow control. But if you can't control how connections are used across purposes, then it is hard to tailor each to its needs. A purpose-built client can do that, a browser-based application cannot.\r\n\r\nBut the approach of the client advertising a \"wide-open connection\" and demanding that a general purpose HTTP/2 or HTTP/3 server acts a particular way is not realistically achievable. Servers have a duty of care to their operators, who have a different set of requirement from clients. There's a power balance and a client with too much can easily cause serious problems. This isn't theoretical, Jonathan Looney at Netflix [found a bunch of problems last year](https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md) and the community worked hard to get these fixed. I'll quote them here because they relate to this discussion:\r\n\r\n> - CVE-2019-9511 \u201cData Dribble\u201d: The attacker requests a large amount of data from a specified resource over multiple streams. They manipulate window size and stream priority to force the server to queue the data in 1-byte chunks. Depending on how efficiently this data is queued, this can consume excess CPU, memory, or both, potentially leading to a denial of service.\r\n> - CVE-2019-9512 \u201cPing Flood\u201d: The attacker sends continual pings to an HTTP/2 peer, causing the peer to build an internal queue of responses. Depending on how efficiently this data is queued, this can consume excess CPU, memory, or both, potentially leading to a denial of service.\r\n> - CVE-2019-9513 \u201cResource Loop\u201d: The attacker creates multiple request streams and continually shuffles the priority of the streams in a way that causes substantial churn to the priority tree. This can consume excess CPU, potentially leading to a denial of service.\r\n> - CVE-2019-9514 \u201cReset Flood\u201d: The attacker opens a number of streams and sends an invalid request over each stream that should solicit a stream of RST_STREAM frames from the peer. Depending on how the peer queues the RST_STREAM frames, this can consume excess memory, CPU, or both, potentially leading to a denial of service.\r\n> - CVE-2019-9515 \u201cSettings Flood\u201d: The attacker sends a stream of SETTINGS frames to the peer. Since the RFC requires that the peer reply with one acknowledgement per SETTINGS frame, an empty SETTINGS frame is almost equivalent in behavior to a ping. Depending on how efficiently this data is queued, this can consume excess CPU, memory, or both, potentially leading to a denial of service.\r\n> - CVE-2019-9516 \u201c0-Length Headers Leak\u201d: The attacker sends a stream of headers with a 0-length header name and 0-length header value, optionally Huffman encoded into 1-byte or greater headers. Some implementations allocate memory for these headers and keep the allocation alive until the session dies. This can consume excess memory, potentially leading to a denial of service.\r\n> - CVE-2019-9517 \u201cInternal Data Buffering\u201d: The attacker opens the HTTP/2 window so the peer can send without constraint; however, they leave the TCP window closed so the peer cannot actually write (many of) the bytes on the wire. The attacker then sends a stream of requests for a large response object. Depending on how the servers queue the responses, this can consume excess memory, CPU, or both, potentially leading to a denial of service.\r\n> - CVE-2019-9518 \u201cEmpty Frames Flood\u201d: The attacker sends a stream of frames with an empty payload and without the end-of-stream flag. These frames can be DATA, HEADERS, CONTINUATION and/or PUSH_PROMISE. The peer spends time processing each frame disproportionate to attack bandwidth. This can consume excess CPU, potentially leading to a denial of service. (Discovered by Piotr Sikora of Google)\r\n\r\nI can't speak for all HTTP/2 server implementations. But the ones I am familiar with go to great efforts to protect their operators, often without their knowledge. Asking an L7 web server application to promise something it cannot is defective.",
          "createdAt": "2020-10-08T17:46:22Z",
          "updatedAt": "2020-10-08T17:46:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd also like to present another parallel situation with relation to video.\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType\r\n\r\n```\r\ncanPlayType() reports how likely it is that the current browser will be able to play media of a given MIME type.\r\n\r\nReturns DOMString\r\n\r\nprobably\r\n    Media of the type indicated by the mediaType parameter is probably playable on this device.\r\nmaybe\r\n    Not enough information is available to determine for sure whether or not the media will play until playback is actually attempted.\r\n\"\" (empty string)\r\n    Media of the given type definitely can't be played on the current device. \r\n```\r\nIf the local system can't even assure itself of capability, then I'm pessimistic about how remote endpoints would treat signals about priority.",
          "createdAt": "2020-10-08T19:05:48Z",
          "updatedAt": "2020-10-08T19:05:48Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "NONE",
          "body": "@LPardue  - canPlayType is actually a counter-argument to the importance of trusted signals. The vagueness of its replies means that modern MSE development is moving in the direction of utilizing https://developer.mozilla.org/en-US/docs/Web/API/Media_Capabilities_API as a replacement. This API returns explicit boolean responses as to whether a given MIME type can be decoded, whether it can be done smoothly and done in a power efficient manner. These clear signals help players make the correct decision about content selection. \r\n",
          "createdAt": "2020-10-08T20:09:40Z",
          "updatedAt": "2020-10-08T20:09:40Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thats a good point Will, thanks. I'm not disputing that a certain kind of client would find a trusted signal useful. I do think that it is practically very difficult for an HTTP server to say anything but probably or maybe. It can't even decisively say no for some types of priority signal.\r\n\r\n@wilaw do you think there is interest and a path to something like a \"Transport_Capabilities_API\" that might rely on something like .well-known mentioned above?",
          "createdAt": "2020-10-08T20:29:46Z",
          "updatedAt": "2020-10-08T20:29:46Z"
        },
        {
          "author": "wilaw",
          "authorAssociation": "NONE",
          "body": "@LPardue  - a hypothetical Transport_Capabilities_API is moving the problem to the browser, which is currently in no better position to deterministically confirm whether a server will support a prioritization request. The HTTP message from a client to a server is syntactically a 'request' and not a 'command'. Retro-fitting conformance via /.well-known/ or header schemes seems awkward. \r\n\r\nI love that fact that I can serve HLS to millions of people using the same H1, H2, H3 protocols that deliver other binary blobs for other applications. At the same time I am very sympathetic to what Roger is asking for on this thread. I think the solution may lie in the near-term next-gen protocols, of which WebTransport (QuicTransport and Http3Transport) is the most exciting.  Since both are actively being developed at IETF, there is perhaps still time to add to the core design the concept of prioritization confirmation or prioritization enforcement? ",
          "createdAt": "2020-10-08T21:40:19Z",
          "updatedAt": "2020-10-08T21:40:19Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the perspective.\r\n\r\nI too am sympathetic.\r\n\r\nBut QUIC itself has been submitted to the IESG, and says very little about prioritisation. That ship has sailed. HTTP/3 has delegated its prioritisation to this draft, which after healthy discussion has pulled up anchor and is getting ready to depart. \r\n\r\nWhat's being asked is for a late stage reconsideration of an ethos that builds on years of experience with H2; that signals are a hint and a client can't expect the server to act in any particularly strict way. For the ~2 years we've been discussing binning the H2 tree, the one thing that people seemed happy to keep is that ethos. \r\n\r\nAs an implementer of a QUIC stack and H3 extensible priorities I don't have confidence that I can state with 100% truth that I will follow the clients instruction. So I'm best off saying yes I did and let the client deal with the outcome. Which to me seems no better than sailing nothing and letting the client deal with the outcome.",
          "createdAt": "2020-10-08T21:56:08Z",
          "updatedAt": "2020-10-08T21:56:08Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can't speak for what WebTransport will do. I suspect they may have similar challenges when it comes to signalling priorities and scheduling but perhaps the green field lets them design how they wish. The downside of course is that its not conventional HTTP. We've seen some of this with using WebSockets to decorate or assist HAS: it's possible but doesn't benefit from huge scaling afforded by HTTP.",
          "createdAt": "2020-10-08T22:01:06Z",
          "updatedAt": "2020-10-08T22:01:06Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "Given the weak (or non-existent) guarantees provided by Extensible Priorities, there's a fallback approach that is worth considering. LL-HLS could mandate the use of Extensible Priorities, for H3 connections and H2 connections with H2 priorities disabled, with a static prioritization on resources to be imposed by the server and a defined prioritization process (or outcome) on the server and intermediaries. \r\n\r\nThe defined prioritization could be something along the lines of:\r\n- All Playlist responses must have an urgency of 1\r\n- All Segment responses must have incremental=0\r\n- All Segment responses must have an urgency > 2, ordered by highest bitrate tier, with lower tiers having greater urgency\r\n- When delivering LL-HLS (directly) to a client, servers/intermediaries must:\r\n o Supply the Priority HTTP Header in responses\r\n o Within a given urgency level, write incremental=0 responses in request order, subject to limitations x,y,z...\r\n o Write greater urgency responses ahead of lesser, subject to limitations a,b,c...\r\n o If necessary, apply further constraints on QUIC (TBD) to make ordering somewhat reliable\r\n\r\nYou've made it clear that EP cannot impose those server \"musts.\" But the LL-HLS spec can. It would be difficult for clients to validate them, but the HLS stream validator tool could include a set of \"must-pass\" tests.\r\n\r\nOne difficulty is that the namespace of urgency defined by EP (0-7) is too small to effectively support static prioritization. LL-HLS could address this by defining a supplemental-urgency (0 to 1000) where urgency is capped at 6, and a rule that for any simultaneous set of responses with urgency=6, supplemental-urgency be applied.\r\n\r\nPros of this approach:\r\n- No change required to the Extensible Priorities specification\r\n- Clients can easily check first-level spec compliance by examining the Priority HTTP Header\r\n- All clients (even JavaScript) get reasonable prioritization behavior automatically\r\n- Keeps LL-HLS specific knowledge in the origin. Intermediaries would only need fairly generic EP implementations that satisfy the LL-HLS prioritization outcome.\r\n- We've got time. There is no hurry to admit H3 into the LL-HLS Server Configuration profile.\r\n\r\nCons:\r\n- Difficult to evolve prioritization behavior once it is defined. Could be mitigated by signaling a version.\r\n- Restricts innovation on the client. (But not much more than EP does inherently.)\r\n\r\nIt's not my first choice. But it might be good enough.",
          "createdAt": "2020-10-09T16:33:48Z",
          "updatedAt": "2020-10-09T16:33:48Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@roger-on-github thank for detailing this fallback thoroughly. \r\n\r\nAs you rightly point out, Extensible Priorities is generic but you are free to profile at the application as you have done and apply more restrictive scheduling targets. This allows you complete control over client application behaviour.\r\n\r\n> All Playlist responses must have an urgency of 1\r\nAll Segment responses must have incremental=0\r\nAll Segment responses must have an urgency > 2, ordered by highest bitrate tier, with lower tiers having greater urgency\r\n\r\nOne way to interpret this is that LLHLS is an additional server-side signal. E.g. the server applies prioritization according to static configuration such as content-type. I don't know if that's your intention but by taking that approach you provide clear guidance to servers about how to do things, and empower them to do it regardless of the client support for extensible priorities. Cloudflare has previously blogged that employing such a strategy for Microsoft Edge (pre chromium) improved important web page loading metrics. Alternatively, this could be guidance recommending that content origins present this information to a proxy/CDN in the form of an Extensible Priorities signal. That seems like an easier requirement to levy on LLHLS deployments, but I am not an expert.\r\n\r\nAs a further iteration you might want to add some words about handling client reprioritization signals.\r\n\r\n> One difficulty is that the namespace of urgency defined by EP (0-7) is too small to effectively support static prioritization. LL-HLS could address this by defining a supplemental-urgency (0 to 1000) where urgency is capped at 6, and a rule that for any simultaneous set of responses with urgency=6, supplemental-urgency be applied.\r\n\r\nThis is a limitation and there has been some past discussion on the merits of more vs. less. I think the current count strikes the middle-ground. In the past we've said if people need more, then additional parameters can be used. You're effectively extending the range here which seems like a good approach, another way would be to add another dimension.\r\n\r\nAs mentioned before, I'm sympathetic to your use case. It sucks to say \"your problem, you fix it\" but I think on-balance that the complexity or additional requirements to do anything else may make the topic of this issue too big for HTTP implementers to solve. I of course cannot talk for all implementers.\r\n\r\n@roger-on-github In the interest of making forward progress, is the fallback something you're happy to run with, or would you like this discussion to carry on? We have an [HTTP WG Interim meeting scheduled on October 20 2020](https://github.com/httpwg/wg-materials/blob/gh-pages/interim-20-10/agenda.md) with 15 minutes agenda time for HTTP Priorities - is that a good target for coming to a resolution?",
          "createdAt": "2020-10-09T19:24:17Z",
          "updatedAt": "2020-10-09T19:26:13Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "@LPardue regarding client reprioritization, good point. Probably good to have something along the lines of \"a server MAY override the static prioritization in response to explicit prioritization requests from the client.\"\r\n\r\nAs far as the next stage of discussion goes, I'll do a round of comment-seeking from the HLS community and the networking folks at Apple and see what turns up.",
          "createdAt": "2020-10-12T16:35:26Z",
          "updatedAt": "2020-10-12T16:35:26Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "I surveyed various groups and received no objections to the general idea of static server-generated prioritization for LL-HLS over H3. \r\n\r\nSo next, at some point, I'll need to:\r\n- Formally define a new supplemental-priority parameter somewhere, probably an I-D\r\n- Write down the exact prioritization requirements on servers and intermediates serving LL-HLS over H3. Maybe structure that as a profile of Extensible Priorities in another I-D.\r\n- Build an end-to-end implementation to make sure it works\r\n- Build a test suite that can be run to validate server compliance\r\n\r\nOnce that's done the LL-HLS spec can be updated to add H3 support, referencing the appropriate I-Ds.",
          "createdAt": "2020-10-16T23:37:55Z",
          "updatedAt": "2020-10-16T23:37:55Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @roger-on-github, thanks for the update!\r\n\r\nIt seems like we have a resolution to the original issue raised against the Extensible Priorities specification and that we can close with no action here. Does that sound ok?\r\n\r\nThe work you describe has some touchpoints with the HTTP community beyond this spec. I'd be happy to engage where I can to improve the general state of things.\r\n\r\nWe've so far benefitted from @rmarx's qlog and qvis combination to record and analyse how stream multiplexing actually works in real connections. That could be a good starting point for your validation testing plans. I think there would be community interest in enhancements to this aspect of QUIC and H3.",
          "createdAt": "2020-10-16T23:57:27Z",
          "updatedAt": "2020-10-16T23:57:46Z"
        },
        {
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "body": "Yes, I'm ok with closing this issue. Thanks for the pointers on qlog and qvis; I'll keep them in mind.",
          "createdAt": "2020-10-17T00:02:37Z",
          "updatedAt": "2020-10-17T00:02:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since we have an alternative that folks can live with, closing this issue with no action.",
          "createdAt": "2020-10-17T00:08:51Z",
          "updatedAt": "2020-10-17T00:08:51Z"
        }
      ]
    },
    {
      "number": 1277,
      "id": "MDU6SXNzdWU3MTIxNDk4NTE=",
      "title": "The priorities I-D draft refers to non-existent FRAME_ENCODING_ERROR",
      "url": "https://github.com/httpwg/http-extensions/issues/1277",
      "state": "CLOSED",
      "author": "dtikhonov",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "The latest version of the draft states:\r\n\r\n> Failure to parse the Priority Field Value MUST be treated as a connection error of type FRAME_ENCODING_ERROR.\r\n\r\nThere is no such error either in [the HTTP/3 draft](https://tools.ietf.org/html/draft-ietf-quic-http-31#section-11.2.3) or in [RFC7540](https://tools.ietf.org/html/rfc7540#section-7).\r\n\r\nPerhaps HTTP/3's _H3_FRAME_ERROR_ was meant?",
      "createdAt": "2020-09-30T17:49:19Z",
      "updatedAt": "2020-10-01T11:00:17Z",
      "closedAt": "2020-10-01T11:00:17Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Dang, I worked from memory and should've spent 2 minutes for checking. I'll get this fixed up thanks.",
          "createdAt": "2020-09-30T17:59:50Z",
          "updatedAt": "2020-09-30T17:59:50Z"
        }
      ]
    },
    {
      "number": 1288,
      "id": "MDU6SXNzdWU3MjAyMjA2MDM=",
      "title": "\"Site for cookies\" handling for service workers",
      "url": "https://github.com/httpwg/http-extensions/issues/1288",
      "state": "OPEN",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'm a bit surprised by https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-06#section-5.2.2.2.\r\n\r\nAs I understand it the SameSite definition cookies use has a recursive parent check to prevent A2 in A1->B->A2 from getting cookies that A1 does get, as B might try to trick it. However, if A2 is entirely generated by a service worker, the above rules would mean it would still get spoofed.\r\n\r\ncc @krgovind @jkarlin ",
      "createdAt": "2020-10-13T13:01:01Z",
      "updatedAt": "2020-10-15T08:21:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jkarlin",
          "authorAssociation": "NONE",
          "body": "@mikewest ",
          "createdAt": "2020-10-13T14:35:47Z",
          "updatedAt": "2020-10-13T14:35:47Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The recursiveness check is useful for CSRF defenses, but I agree Service Workers (as usual...) kinda mess it up. @jkarlin, this reminds me of the conversations around partitioning schemes (double- vs triple-keying) for storage partitioning.\r\n\r\nIf we could align the partitioning rules with the recursive check, that would be great for XS-Search attacks and the HTTP cache, and would probably solve the Service Worker problem automatically. But the recursive check doesn't naturally lend itself to a partition key. The other direction would be to add some extra things to fetch requests so the document-side decision is preserved through SW, which also sounds messy.",
          "createdAt": "2020-10-13T15:56:33Z",
          "updatedAt": "2020-10-13T15:56:33Z"
        },
        {
          "author": "jkarlin",
          "authorAssociation": "NONE",
          "body": "Short of including the full chain in the partitioning key, I think we'd need to do something like consider the partition to be opaque if the current frame site matches the top frame site but there is a separate site inbetween. I don't know how often this happens in practice, though it's something we could measure.",
          "createdAt": "2020-10-13T17:05:41Z",
          "updatedAt": "2020-10-13T17:05:41Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It occurs to me that simply using SameSite-consistent partitioning rules probably wouldn't work anyway. For top-level requests, there are variations in SameSite behavior:\r\n\r\n* SameSite=Lax blocks the cookie on cross-site top-level POST but allows it on cross-site top-level GET\r\n* SameSite=Strict blocks the cookie on cross-site top-level navigations of both methods.\r\n* Funny LaxPlusPOST behavior of the default thing.\r\n\r\nI dunno if SW/Fetch currently captures that behavior. If not, we should fix that too. If so, we can maybe mirror the solution for that. And then the question of whether we can harden XS-Search defenses with an ancestor-aware partitioning scheme can maybe be separate?",
          "createdAt": "2020-10-13T19:35:18Z",
          "updatedAt": "2020-10-13T19:35:18Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Currently cookie behavior is largely defined in https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis though I would prefer it if more of the logic moved into Fetch.\r\n\r\nhttps://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-06#section-5.5 seems to capture what you state though it talks about safe methods instead. However, in this specific case that's probably equivalent as navigation can only ever use GET or POST.\r\n\r\nHowever, I'm not entirely persuaded that all this complexity is worth it for documents that allow themselves to be framed across the origin boundary as these are not the only attack vectors.\r\n\r\n(Also, service workers are a very different case from the HTTP cache, they're in the same boat as `localStorage`.)",
          "createdAt": "2020-10-14T11:22:43Z",
          "updatedAt": "2020-10-14T11:22:43Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, safe method is the correct criteria. I used GET vs. POST as examples just to simplify things. My point is that SameSite already has different behaviors depending on value, which means we won't find a single Service Worker partitioning scheme that fits them all. That suggests instead we need to make the behaviors pass through SW correctly.\r\n\r\nAs for why those cases, cross-site top-level POSTs are the classic CSRF attack vector, so any CSRF story had better cover those. On the ancestor chaining case, whether the document allows itself to be framed cross-origin isn't the point. By the time the document has sent X-Frame-Options/frame-ancestors, the cookied request has already been sent and the site needs to worry about CSRF. Any CSRF story needs to kick in at the request. (Imagine if origin A embeds origin B, which tries to attack A by embedding some URL on A.)\r\n\r\nEither way, SameSite=Lax and SameSite=Strict have existing semantics and are shipped across browsers already. Loosening their semantics now could introduce security problems in sites that were designed against those semantics.",
          "createdAt": "2020-10-14T20:05:03Z",
          "updatedAt": "2020-10-14T20:05:46Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Those sites would also introduce security problems by adopting service workers. You make a good point regarding CSRF, sites would want https://github.com/w3c/webappsec-fetch-metadata/issues/56.\r\n\r\n(As for \"safe method\", I generally don't think that's a good primitive as its meaning changes over time. This is somewhat problematic for APIs that allow arbitrary methods. But again, it's not a problem here as navigation doesn't do that.)",
          "createdAt": "2020-10-15T08:21:26Z",
          "updatedAt": "2020-10-15T08:21:26Z"
        }
      ]
    },
    {
      "number": 1289,
      "id": "MDU6SXNzdWU3MjE4MDM2NzM=",
      "title": "6265bis doesn't have an opinion on localhost cookies",
      "url": "https://github.com/httpwg/http-extensions/issues/1289",
      "state": "OPEN",
      "author": "sbingler",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Sparked from: https://github.com/web-platform-tests/wpt/issues/26123\r\n\r\n[6265bis-06](https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-06) doesn't seem to have any instructions on how to handle cookies set on/by localhost. More specifically for this issue: how the Domain attribute should be handled.\r\n\r\nChrome disallows this action, which makes sense to me, but this seems ripe for implementation specific behavior.\r\n\r\nShould 6265bis take a stance here?",
      "createdAt": "2020-10-14T21:25:25Z",
      "updatedAt": "2020-10-15T20:45:42Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DCtheTall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "CC @mikewest ",
          "createdAt": "2020-10-15T13:42:40Z",
          "updatedAt": "2020-10-15T13:42:40Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Does Chrome disallow it by way of special-casing localhost, or is it because localhost is treated as an eTLD and eTLDs can't set domain attributes? I assumed it was the latter. The domain attribute seems to work just fine on http://foo1.bar.localhost and http://foo2.bar.localhost in testing.",
          "createdAt": "2020-10-15T14:50:17Z",
          "updatedAt": "2020-10-15T14:50:17Z"
        },
        {
          "author": "DCtheTall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "An important clarification is that including `Domain=localhost` in the Set-Cookie header in Chrome on localhost works, but the leading-dot `Domain=.localhost` would be disallowed in Chrome unless the request URL is a subdomain of localhost.",
          "createdAt": "2020-10-15T15:36:49Z",
          "updatedAt": "2020-10-15T20:45:42Z"
        }
      ]
    },
    {
      "number": 1290,
      "id": "MDU6SXNzdWU3MjMxNzQzMjE=",
      "title": "BCP56bis: Consider expanding scope of H2/H3 stream multiplexing discussion",
      "url": "https://github.com/httpwg/http-extensions/issues/1290",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "The document makes 2 brief mentions of HTTP/2 multiplexing. \r\n\r\nI think there is tacit knowledge about how stream multiplexing works in practice. We have experience from years of HTTP/2 deployments and interop. HTTP/3 changes things with it's removal of guaranteed ordering across streams. We also can't ignore the role that prioritization plays with multiplexing.\r\n\r\nPeople wanting to use HTTP might not be with the above aspects of stream multiplexing. Through the course of discussion in https://github.com/httpwg/http-extensions/issues/1274 it appeared to me that the designers of LL-HLS have a model for stream multiplexing usage to deliver video that may not be easily achievable with the protocol mechanics of H2 or H3, or the practical constraints that HTTP server operators apply to mitigate DoS etc. There could be emergent problems that damage their use case goals. I doubt that this is an isolated example.\r\n\r\nSo this ticket asks the question, is there benefit to the community to capture something about multiplexing in BCP56bis? Personally I think so.\r\n",
      "createdAt": "2020-10-16T12:28:12Z",
      "updatedAt": "2020-10-16T12:28:12Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1296,
      "id": "MDU6SXNzdWU3MjQxMjI0NzQ=",
      "title": "ios 14 beta",
      "url": "https://github.com/httpwg/http-extensions/issues/1296",
      "state": "CLOSED",
      "author": "pes2020kk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-18T21:16:08Z",
      "updatedAt": "2020-10-18T21:59:36Z",
      "closedAt": "2020-10-18T21:59:36Z",
      "comments": [
        {
          "author": "pes2020kk",
          "authorAssociation": "NONE",
          "body": "> \n\n",
          "createdAt": "2020-10-18T21:21:41Z",
          "updatedAt": "2020-10-18T21:21:41Z"
        }
      ]
    },
    {
      "number": 1300,
      "id": "MDU6SXNzdWU3MjY1NjYxMTc=",
      "title": "Default incremental value in the new http priority scheme",
      "url": "https://github.com/httpwg/http-extensions/issues/1300",
      "state": "CLOSED",
      "author": "yangchi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Reading https://tools.ietf.org/html/draft-ietf-httpbis-priority-02, it has the following on defaults:\r\n\r\n> When receiving an HTTP request that does not carry these priority parameters, a server SHOULD act as if their default values were specified.\r\n\r\n> The default value of the incremental parameter is false (\"0\").\r\n\r\nThis creates a problem to services that's already running a different resourse allocation scheme, when adopting the new proposal. Suppose one has production traffic where streams in the same connections have been behaving equivalent to incremental = 1. Adopting this new http priority proposal means we need to add a priority header to every request our clients send, to let it specify incremental=1 explicitly. Worse, for older clients, this is impossible to fix.\r\n\r\nCan the default incremental value be left for implementation to decide? To remove the ambiguity when there is no clear default, client can use a SETTING frame to communicate the default incremental it desires. Server can also use a SETTING frame to communicate the default Incremental it would use when it receives a request that don't have the priority header.",
      "createdAt": "2020-10-21T14:50:22Z",
      "updatedAt": "2020-10-21T15:15:03Z",
      "closedAt": "2020-10-21T15:15:03Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There's no single correct answer here, hence the recommendation is SHOULD.\r\n\r\nSome work to date has shown that for typical web workloads, serving resources as FIFO is a sensible choice hence why incremental is default to false. If you have a server that thinks it better to apply a default of true, then there's nothing stopping you implementing it that way. \r\n\r\nDefining no default introduces too many unknowns. And adding a dependency on SETTINGS complicates this specification. I'm not conviced that either is needed.",
          "createdAt": "2020-10-21T15:08:30Z",
          "updatedAt": "2020-10-21T15:08:30Z"
        },
        {
          "author": "yangchi",
          "authorAssociation": "NONE",
          "body": "That's fair. I guess I didn't pay enough attention to this being a \"SHOULD\". Then this is fine.",
          "createdAt": "2020-10-21T15:15:03Z",
          "updatedAt": "2020-10-21T15:15:03Z"
        }
      ]
    },
    {
      "number": 1301,
      "id": "MDU6SXNzdWU3Mjc0ODUxODg=",
      "title": "rfc6265bis: be consistent about \"header field\"",
      "url": "https://github.com/httpwg/http-extensions/issues/1301",
      "state": "OPEN",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-10-22T15:17:05Z",
      "updatedAt": "2020-10-22T15:17:05Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1302,
      "id": "MDU6SXNzdWU3Mjc0ODU3MjU=",
      "title": "rfc6265bis: ABNF should just define field *values* (not the whole field line)",
      "url": "https://github.com/httpwg/http-extensions/issues/1302",
      "state": "OPEN",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-10-22T15:17:43Z",
      "updatedAt": "2020-10-22T15:17:43Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 1303,
      "id": "MDU6SXNzdWU3Mjg0OTcyMjk=",
      "title": "signatures: asterisk preceding some content identifiers",
      "url": "https://github.com/httpwg/http-extensions/issues/1303",
      "state": "OPEN",
      "author": "llorllale",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The draft lacks normative text on the meaning of the asterisk preceding certain content identifiers in the `headers` signature parameter. Seems like they are meant to indicate pesudo-HTTP header fields, but that still leaves two categories in need of discrimination: HTTP headers and the request line. Suggest we remove this asterisk and instead rely on the registry (section 5.2.2) and the definition of each item (sections 2 and 4.1).",
      "createdAt": "2020-10-23T20:12:36Z",
      "updatedAt": "2020-10-31T18:19:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "llorllale",
          "authorAssociation": "NONE",
          "body": "PR #1297 is substituting parenthesis for a preceding asterisk: https://github.com/httpwg/http-extensions/pull/1297#discussion_r508296903",
          "createdAt": "2020-10-23T20:40:22Z",
          "updatedAt": "2020-10-23T21:19:51Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@llorllale if the preceding asterisk works for you, can you please close?\r\n\r\nOtherwise, could you update the issue title and description to be in line with the current version?\r\n\r\nThanks \ud83d\ude0a",
          "createdAt": "2020-10-24T16:38:20Z",
          "updatedAt": "2020-10-24T16:38:20Z"
        },
        {
          "author": "llorllale",
          "authorAssociation": "NONE",
          "body": "@ioggstream \r\n\r\n> @llorllale if the preceding asterisk works for you, can you please close?\r\n> \r\n> Otherwise, could you update the issue title and description to be in line with the current version?\r\n> \r\n> Thanks blush\r\n\r\nUpdated title and description.\r\n\r\nI'd first appreciate some clarity around the use of the asterisk. Like I said in the opening comment: I strongly suspect they're there to identify pseudo HTTP headers. I just can't flat out say so because there is no normative text explaining the use of the asterisks!\r\n\r\nMy question is: why are we marking pseudo-headers? For example, are we to differentiate between pseudo-header `*created` and an actual HTTP header `Created`? If so, we need normative text describing the expected behaviour. I would assume a new section is required just to explain the use of the asterisk when preceding tokens inside the `sig*` dictionary entry.",
          "createdAt": "2020-10-24T21:08:55Z",
          "updatedAt": "2020-10-24T21:08:55Z"
        },
        {
          "author": "llorllale",
          "authorAssociation": "NONE",
          "body": "This question is linked to #1304. ",
          "createdAt": "2020-10-24T21:13:04Z",
          "updatedAt": "2020-10-24T21:13:04Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@llorllale thanks for updating.\r\n\r\n1- `*` does not identify [pseudo-headers](https://tools.ietf.org/html/rfc7540#section-8.1.2.1) which are something related to a specific version of HTTP; instead, they distinguish between signature parameters and http fields. IIUC `*created` is the actual name of the signature parameter.\r\n2- imho this spec should not rely on specific MESSAGING behavior and should build instead on [SEMANTICS](https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html) only\r\n\r\nFor the rest, feel free to propose a PR with the text you expect to see here! It could trigger a faster discussion :)\r\n\r\n-- EDIT\r\n\r\nre-reading the spec I think they would be clear having a clear distinction b/w content-identifiers  and signature-metadata.\r\n\r\nThis doesn't necessarily have to change the implementation, but only the narrative of the specs, eg:\r\n\r\n> To create the Signature Input, the signer concatenates:\r\n> - each identifier in the Signature Metadata prefixed with a `*`\r\n> - each identifier in the Coverd  Content ...\r\n",
          "createdAt": "2020-10-24T21:46:15Z",
          "updatedAt": "2020-10-25T00:09:35Z"
        },
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "> 1- * does not identify pseudo-headers which are something related to a specific version of HTTP; instead, they distinguish between signature parameters and http fields. IIUC *created is the actual name of the signature parameter.\r\n\r\nErr, hold up -- \"(request-line)\" was intended to refer to a pseudo-header and other non-header values... I'm now seeing that we have something new in the spec with the addition of asterisk for signature parameters? Are we sure we want to do that? Anyone have the background on why this addition was made? Or are we switching everything over to asterisk-led stuff now?",
          "createdAt": "2020-10-27T02:42:30Z",
          "updatedAt": "2020-10-27T02:42:30Z"
        },
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "Hmm, so I guess this change is being made because of the adoption of the Dictionary Structured Header Fields stuff... and because those require the outermost characters to be parenthesis in a set? Have we put any thought into what is going to happen w/ existing implementations? I guess they'd barf, which is an ok thing to do... as long as they will always barf.",
          "createdAt": "2020-10-27T02:46:44Z",
          "updatedAt": "2020-10-27T02:46:44Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "this is fairly incomprehensible.... some implementations refer to pseudo headers, but I can't find a defintion for them anywhere... what is the correct way to structure the authorization header...starting with:\r\n\r\n```\r\nSignature keyId=\"${verificationMethod}\",algorithm=\"hs2019\",headers=\"(key-id) (created) (expires) (request-target) host content-type digest\",signature=\"${signature}\",created=\"${created}\",expires=\"${expires}\"\r\n```\r\n\r\nhttps://tools.ietf.org/html/rfc7540#section-8.1.2.3\r\n\r\n^ are we doing this or not?",
          "createdAt": "2020-10-31T17:05:19Z",
          "updatedAt": "2020-10-31T17:05:19Z"
        },
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "> some implementations refer to pseudo headers, but I can't find a defintion for them anywhere\r\n\r\nThe whole format has changed due to the proposed adoption of Structured Headers... there are now TWO headers you need to care about `Signature-Input` and `Signature` ... and I can't tell if everything has changed over to this new asterisk format, or if pseudo-headers are still wrapped in parens, and signature input params use asterisks. I'm guessing that everything that is either a pseudo-header OR a signature input parameter are prepended by asterisks now. Waiting on confirmation on that.",
          "createdAt": "2020-10-31T17:34:38Z",
          "updatedAt": "2020-10-31T17:34:38Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "examples / test-vectors would help.... given the state of the spec, its not possible for me to divine any... a reference implementation is desperately needed.",
          "createdAt": "2020-10-31T17:56:55Z",
          "updatedAt": "2020-10-31T17:56:55Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@OR13 this spec is going to change a lot... a reference implementation won't be stable in a short period iiuc, but I think we should have it. There are [ ~40 issues to be worked out](https://github.com/httpwg/http-extensions/labels/signatures).\r\n\r\n@msporny let me try to clarify the terminology, as I am a bit confused.\r\n\r\n## avoid using the pseudo-headers term\r\n\r\n- the `pseudo-header` term is  defined in http/2;\r\n- in draft-cavage, pseudo-headers are only mentioned in constructing the `(request-target)` special header: I'd avoid even in that spec a reference to http/2 \r\n- imho the term `pseudo-headers` should not be used explicitly neither in this I-D, nor in draft-cavage\r\n\r\n## referencing the signature input fields\r\n\r\n- In draft-cavage-http-signatures-12 the signature input is referenced as \"signature parameters\" or \"special header\".\r\niiuc this thread is related to \"signature parameters and special headers\" (draft-cavage terminology);\r\n- while it's still a I-D and every change can be reverted, I am not that negative on splitting the stuff in two headers, because it simplifies the processing steps;  \r\n\r\nMy 2\u00a2 and have a nice day, R.",
          "createdAt": "2020-10-31T18:19:40Z",
          "updatedAt": "2020-10-31T18:19:40Z"
        }
      ]
    },
    {
      "number": 1304,
      "id": "MDU6SXNzdWU3Mjg0OTc4MTU=",
      "title": "signatures: expected behaviour on unrecognized signature header parameters",
      "url": "https://github.com/httpwg/http-extensions/issues/1304",
      "state": "OPEN",
      "author": "llorllale",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The draft has no normative text on expected behaviour when an unrecognized signature header parameter is encountered. Suggest adding normative text indicating implementations MUST produce an error when an unrecognized parameter is encountered (ie. they are not in the registry: https://tools.ietf.org/html/draft-ietf-httpbis-message-signatures-00#section-5.2.2).",
      "createdAt": "2020-10-23T20:13:44Z",
      "updatedAt": "2020-10-23T23:10:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "richanna",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The Structured Fields draft discourages field specifications from declaring the presence of unknown parameters to be an error condition, as this hurts forward compatibility with future extensions. This might be best left to profiling specifications.",
          "createdAt": "2020-10-23T22:35:41Z",
          "updatedAt": "2020-10-23T22:35:41Z"
        },
        {
          "author": "llorllale",
          "authorAssociation": "NONE",
          "body": "I wasn't aware of PR #1297 before I opened this issue.\r\n\r\nThat said, we might have to revisit the Structured Fields draft's guidelines on ignoring unknown parameters if we are to factor in `Signature-Input` in the computation of the `Signature`. We'd have to specify a canonicalization algorithm on `Signature-Input`.",
          "createdAt": "2020-10-23T22:46:32Z",
          "updatedAt": "2020-10-23T22:46:32Z"
        },
        {
          "author": "richanna",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We do have to fill in any ambiguities in the Structured Fields serialization algorithms, but unknown parameters shouldn't really affect that. The verifier can parse and serialize the parameters, even if it doesn't know what they mean. It's only when interpreting the field value that it should ignore them.",
          "createdAt": "2020-10-23T23:10:12Z",
          "updatedAt": "2020-10-23T23:10:12Z"
        }
      ]
    },
    {
      "number": 1305,
      "id": "MDU6SXNzdWU3Mjg0OTkxNTU=",
      "title": "signatures: datatypes of (created) and (expires)",
      "url": "https://github.com/httpwg/http-extensions/issues/1305",
      "state": "OPEN",
      "author": "llorllale",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The draft defines an odd asymmetry between the data types of `(created)` and `(expires)` (respectively: integer string and decimal string). The non-normative examples all show `(expires)` as an integer string. Suggest we have them both as integer strings as:\r\n\r\n* it simplifies implementations\r\n* if omission of nanoseconds is OK on `(created)` (yes, imo), then it should be OK as well for `(expires)` imo",
      "createdAt": "2020-10-23T20:16:24Z",
      "updatedAt": "2020-10-27T02:18:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "richanna",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If you are signing a request being sent over a high throughput link between systems with good clock synchronization, 1000ms is way more lifetime than necessary. That said, I'm hard pressed to think of a scenario that would be mitigated by an expiration time of +200ms but not by an expiration time of +1000ms.",
          "createdAt": "2020-10-23T22:16:13Z",
          "updatedAt": "2020-10-23T22:16:13Z"
        },
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "Agree, created/expires should be an integer representing time from epoch with 1000ms resolution.",
          "createdAt": "2020-10-27T02:18:55Z",
          "updatedAt": "2020-10-27T02:18:55Z"
        }
      ]
    },
    {
      "number": 1306,
      "id": "MDU6SXNzdWU3Mjg0OTk0ODc=",
      "title": "signatures: HTTP header line folding",
      "url": "https://github.com/httpwg/http-extensions/issues/1306",
      "state": "OPEN",
      "author": "llorllale",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The HTTP Header canonicalization algorithm does not account for line folding even though the non-normative example shows one such header. Although deprecated, we should continue supporting line folding due to the significant userbase of HTTP/1.1 in the wild.",
      "createdAt": "2020-10-23T20:17:02Z",
      "updatedAt": "2020-10-27T02:24:30Z",
      "closedAt": null,
      "comments": [
        {
          "author": "richanna",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My impression was that this is already handled by the language in [Section 3.2.4 of RFC7230](https://tools.ietf.org/html/rfc7230#section-3.2.4), but it won't hurt to make this explicit here. \ud83d\udc4d",
          "createdAt": "2020-10-23T22:43:32Z",
          "updatedAt": "2020-10-23T22:43:32Z"
        },
        {
          "author": "llorllale",
          "authorAssociation": "NONE",
          "body": "@richanna you're right - I initially misread and got confused.\r\n\r\nOn a second reading of RFC7230 3.2.4 I notice this (emphasis mine):\r\n\r\n>    A server that receives an obs-fold in a request message that is not\r\n   within a message/http container MUST either reject the message by\r\n   sending a 400 (Bad Request), preferably with a representation\r\n   explaining that obsolete line folding is unacceptable, or **replace\r\n   each received obs-fold with one or more SP octets prior to\r\n   interpreting the field value** or forwarding the message downstream.\r\n\r\nDo we need to specify the number of SP octets for replacements such that implementations can reliably produce the correct signature input?\r\n\r\nFYI, a quick test in golang shows that `obs-fold` is not being replaced:\r\n\r\n```go\r\nfunc Test(t *testing.T) {\r\n\trequest, err := http.NewRequest(http.MethodGet, \"http://example.org/foo\", nil)\r\n\trequire.NoError(t, err)\r\n\trequest.Header.Set(\"X-Example\", `Example header\r\n                     with some whitespace.`)\r\n\texpected := \"Example header with some whitespace.\"\r\n\tactual := request.Header.Get(\"X-EXAMPLE\")\r\n\trequire.Equal(t, expected, actual)\r\n}\r\n```\r\n\r\nResult:\r\n\r\n```\r\n        \tError:      \tNot equal: \r\n        \t            \texpected: \"Example header with some whitespace.\"\r\n        \t            \tactual  : \"Example header\\n                     with some whitespace.\"\r\n        \t            \t\r\n        \t            \tDiff:\r\n        \t            \t--- Expected\r\n        \t            \t+++ Actual\r\n        \t            \t@@ -1 +1,2 @@\r\n        \t            \t-Example header with some whitespace.\r\n        \t            \t+Example header\r\n        \t            \t+                     with some whitespace.\r\n```\r\n\r\nI suppose a more complete test can be carried out by spooling two test servers and sending requests/responses between them and see what happens.",
          "createdAt": "2020-10-23T23:17:02Z",
          "updatedAt": "2020-10-23T23:17:02Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Altering the content of the signed headers is something that may be tricky to address and, in a certain way, breaks the signature goals tying this spec to a specific version of HTTP Messaging (eg. HTTP/1.1) .\r\n\r\nimho we should only rely on HTTP Semantics (eg. RFC7231) and avoid any tie with MESSAGING (RFC7231) , HTTP/2 or QUIC.\r\n\r\nI think that the \"field value canonicalization\" issue should be addressed within a specific issue. This topic can benefit from the experience of current implementations.",
          "createdAt": "2020-10-24T14:02:45Z",
          "updatedAt": "2020-10-24T14:02:45Z"
        },
        {
          "author": "llorllale",
          "authorAssociation": "NONE",
          "body": "@ioggstream \r\n\r\n> Altering the content of the signed headers is something that may be tricky to address\r\n\r\nAgreed.\r\n\r\n> breaks the signature goals tying this spec to a specific version of HTTP Messaging (eg. HTTP/1.1)\r\n\r\nSure does. \r\n\r\n> current implementations\r\n\r\nTwo levels - language support and then httpsig library support:\r\n\r\n**Language support:**\r\n\r\n* Golang: allows setting header values spanning multiple lines. Does not substitute `obs-fold` with SP.\r\n* Javascript/Node: allows setting header values spanning multiple lines. Does not substitute `obs-fold` with SP.\r\n* [Default implementation of Java 11+ `HttpRequest.Builder`](https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpRequest.Builder.html): does **not** allow header values with line breaks[1]\r\n\r\n**Library support:**\r\n\r\nNone of the httpsig implementations I've so far tested work with folded headers... here are a couple:\r\n\r\n<details><summary>digitalbazaar/http-signature-header</summary>\r\n\r\nTest Case:\r\n\r\n```javascript\r\n    it('properly encodes a folded header value', () => {\r\n      const date = new Date().toUTCString();\r\n      const multiLine = `Example header\r\n                spanning multiple lines.`;\r\n      const requestOptions = {\r\n        headers: {date, multiLine},\r\n        method: 'GET',\r\n        url: 'https://example.com:18443/1/2/3',\r\n      };\r\n      const stringToSign = httpSignatureHeader.createSignatureString(\r\n        {includeHeaders: ['host', 'date', 'multiLine'], requestOptions});\r\n      stringToSign.should.equal(\r\n        `host: example.com:18443\\ndate: ${date}\\nmultiLine: Example header spanning multiple lines.`);\r\n    });\r\n```\r\n\r\nResult:\r\n\r\n```\r\n  1) http-signature\r\n       createSignatureString API\r\n         properly encodes a folded header value:\r\n\r\n      AssertionError: expected 'host: example.com:18443\\ndate: Sat, 24 Oct 2020 15:11:18 GMT\\nmultiline: Example header\\n                spanning multiple lines.' to equal 'host: example.com:18443\\ndate: Sat, 24 Oct 2020 15:11:18 GMT\\nmultiLine: Example header spanning multiple lines.'\r\n      + expected - actual\r\n\r\n       host: example.com:18443\r\n       date: Sat, 24 Oct 2020 15:11:18 GMT\r\n      -multiline: Example header\r\n      -                spanning multiple lines.\r\n      +multiLine: Example header spanning multiple lines.\r\n```\r\n</details>\r\n\r\n<details><summary>igor-pavlenko/httpsignatures-go</summary>\r\n\r\nTest Case (added to TestHSBuildSignatureString):\r\n```go\r\n\t\t{\r\n\t\t\tname: \"Folded HTTP header\",\r\n\t\t\targs: args{\r\n\t\t\t\tph: Headers{\r\n\t\t\t\t\theaders: []string{\"X-EXAMPLE-FOLDED\"},\r\n\t\t\t\t},\r\n\t\t\t\tr: (func() *http.Request {\r\n\t\t\t\t\tr := httptest.NewRequest(http.MethodGet, \"http://example.org/foo\", nil)\r\n\t\t\t\t\tr.Header.Set(\"X-EXAMPLE-FOLDED\", `Example folded header\r\n                             spanning multiple lines.`)\r\n\t\t\t\t\treturn r\r\n\t\t\t\t})(),\r\n\t\t\t},\r\n\t\t\twant: []byte(\"x-example-folded: Example folded header spanning multiple lines.\"),\r\n\t\t},\r\n```\r\n\r\nResult (modified printed output in lib_test.go slightly):\r\n```\r\n        \tMessages:   \tgot [x-example-folded: Example folded header\r\n        \t            \t                             spanning multiple lines.]\r\n        \t            \twant [x-example-folded: Example folded header spanning multiple lines.]\r\n```\r\n</details>\r\n\r\n----\r\n\r\n[1] HttpRequest.Builder.header():\r\n\r\n<details><summary>Test Case</summary>\r\n\r\n```java\r\n  @Test\r\n  public void test() {\r\n    final var request = HttpRequest.newBuilder()\r\n      .header(\"X-EXAMPLE-FOLD\", String.format(\"Example header%n        spanning multiple lines.\"))\r\n      .build();\r\n    MatcherAssert.assertThat(\r\n      request.headers().firstValue(\"X-EXAMPLE-FOLD\").get(),\r\n      new IsEqual<>(\"Example header spanning multiple lines.\")\r\n    );\r\n  }\r\n```\r\n\r\nResult:\r\n\r\n```\r\njava.lang.IllegalArgumentException: invalid header value: \"Example header\r\n        spanning multiple lines.\"\r\n```\r\n\r\n</details>",
          "createdAt": "2020-10-24T20:28:01Z",
          "updatedAt": "2020-10-24T20:32:10Z"
        },
        {
          "author": "llorllale",
          "authorAssociation": "NONE",
          "body": "The biggest issue here is support at the language level.\r\n\r\nPreliminary thought: forget folding, just take the HTTP header's value as-is.\r\n\r\nFurther testing: integration test between a language that supports multi-line header values vs a language that does not (Java).",
          "createdAt": "2020-10-24T20:30:28Z",
          "updatedAt": "2020-10-24T20:30:28Z"
        },
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "> Preliminary thought: forget folding, just take the HTTP header's value as-is.\r\n\r\nWe tried this as a general design rule for the first seven or so years of this spec (depended on whatever the HTTP libraries in each language gave us back, which tended to be the same) and it seemed to work well.\r\n\r\nThat said, if all the languages support a specific type of transformation, we should consider it noting that there are many more implementations out there that won't do the transformation.\r\n\r\nWhat we really need is a test suite to run each implementation against. :)",
          "createdAt": "2020-10-27T02:24:30Z",
          "updatedAt": "2020-10-27T02:24:30Z"
        }
      ]
    },
    {
      "number": 1307,
      "id": "MDU6SXNzdWU3Mjg1MDMzNDI=",
      "title": "signatures: which parameters are tokens and which are quoted strings?",
      "url": "https://github.com/httpwg/http-extensions/issues/1307",
      "state": "OPEN",
      "author": "llorllale",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "The signature header parameters are missing normative text on whether they are tokens or quoted strings. Suggest including normative text in each parameter's definition in section 4.1 clearly indicating whether they are a quoted-string or a token.\r\n\r\nRelated: in agreement with the topic in appendix B.1.2, the definition for `keyId` should at minimum define illegal characters that would present obstacles to reasonable parsing algorithms. Suggest adding normative text that this parameter MUST NOT include commas (\",\"), at minimum.",
      "createdAt": "2020-10-23T20:24:51Z",
      "updatedAt": "2020-10-27T02:28:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "The original intent was that keyId is supposed to be a quoted string, because it could contain a URL, like a DID, or other random http URL.. Everything else that wasn't a number was supposed to be a quoted string as well. Agree that we should update the spec with this language making it more clear.",
          "createdAt": "2020-10-27T02:28:09Z",
          "updatedAt": "2020-10-27T02:28:09Z"
        }
      ]
    },
    {
      "number": 1308,
      "id": "MDU6SXNzdWU3Mjg1MDU1MTU=",
      "title": "signatures: clarify letter case for content identifiers",
      "url": "https://github.com/httpwg/http-extensions/issues/1308",
      "state": "OPEN",
      "author": "llorllale",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "This line in the definition of `headers` is hard to understand, unless one assumes the \"header fields\" refers to HTTP headers:\r\n\r\n> If specified, identifiers for header fields SHOULD be lowercased and all others MUST be lowercased.\r\n\r\nSuggest clarification on what header fields are being referred to here. Or, in agreement with the suggestion in B.1.15, we could just force implementations to lowercase all content identifiers.",
      "createdAt": "2020-10-23T20:29:09Z",
      "updatedAt": "2020-10-27T14:53:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "richanna",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm very in favor of simply mandating lowercase for all content identifiers.",
          "createdAt": "2020-10-23T22:45:02Z",
          "updatedAt": "2020-10-23T22:45:02Z"
        },
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "The reason the spec didn't do this originally was because implementers complained about a mandatory lowercase for all identifiers because it didn't matter. They'd lowercase anyway when doing c14n. The pseudo-headers were always lower-cased because they weren't real headers and we could more easily suggest that implementers do this. That said, there's really no strong argument that I know of where they should be lowercased.\r\n\r\nFundamentally, I get the theoretical purity here and don't have a super strong opinion on this. Implementers got it wrong and developers got it wrong, and it caused implementations to throw errors that were annoying to developers: \"If a computer can lowercase it for me deterministically, why are you asking me to do it?!\".\r\n\r\nWhat's the reasoning for mandating lowercase?",
          "createdAt": "2020-10-27T02:33:05Z",
          "updatedAt": "2020-10-27T02:33:05Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> What's the reasoning for mandating lowercase?\r\n\r\nInteroperability.",
          "createdAt": "2020-10-27T09:33:09Z",
          "updatedAt": "2020-10-27T09:33:09Z"
        },
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "> Interoperability.\r\n\r\nHow does mandating lowercase increase interoperability? \r\n\r\nThere are two ways to get there... 1) mandate lowercase, causing developers to have to take on that mental effort (which is usually a bad way to go -- they're human for now, so fallible), or 2) implementations lowercase everything (make the machines do the heavy lifting, because they have to check for lowercase anyway).",
          "createdAt": "2020-10-27T12:28:29Z",
          "updatedAt": "2020-10-27T12:28:29Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I usually like something that breaks early and avoid troubleshooting at runtime. Recently we suggested using lowecase for digest-algorithms.\r\n\r\nBut I'm open to other, interview-based or data-drive-based positions.",
          "createdAt": "2020-10-27T14:09:42Z",
          "updatedAt": "2020-10-27T14:09:42Z"
        },
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "> I usually like something that breaks early and avoid troubleshooting at runtime. Recently we suggested using lowercase for digest-algorithms.\r\n\r\n\"suggest\" or \"mandate\"? The former makes sense. I'm struggling to understand how the latter makes sense if implementations MUST call lowercase() on certain input parameters?\r\n\r\n> But I'm open to other, interview-based or data-drive-based positions.\r\n\r\nWhat sort of data would be convincing to you? I ask, because this seems to be an instance where gathering the data for/against is going to be very difficult, but reasoning about is fairly trivial. For example:\r\n\r\n1. Require implementations to lowercase certain input parameters (e.g., all left hand values being c14n'd and any argument that could end up being c14n'd -- specifically, don't lowercase right hand values being c14n'd) to the c14n function.\r\n\r\nIf we do this, how does the algorithm break wrt. case sensitivity?",
          "createdAt": "2020-10-27T14:24:10Z",
          "updatedAt": "2020-10-27T14:24:10Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> \"suggest\" or \"mandate\"? The former makes sense.\r\n\r\nhttpbis-digest-headers is a refresh of RFC3230, so we could not `MUST lowercase`: if it was a new spec, we'd `MUST lowecase`.\r\n\r\n> What sort of data would be convincing to you?\r\n\r\nI don't need to be convinced :) I'm really open to feedback, and I'll leave this kind of decision to the http-wg.",
          "createdAt": "2020-10-27T14:48:56Z",
          "updatedAt": "2020-10-27T14:48:56Z"
        },
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "@ioggstream wrote:\r\n> httpbis-digest-headers is a refresh of RFC3230, so we could not MUST lowercase: if it was a new spec, we'd MUST lowecase.\r\n\r\nNow I'm confused. :)\r\n\r\nWe're talking about the HTTP Message Signatures spec, right? Not the httpbis-digest-headers spec? HTTP Message Signatures is a new spec, so we can mandate MUST lowercase... the question is where... 1) in the c14n algorithm, or 2) as guidance for input into the algorithm?\r\n\r\n@richanna wrote:\r\n> I'm very in favor of simply mandating lowercase for all content identifiers.\r\n\r\nPerhaps @richanna can provide some input on what exactly would be mandated via specific spec text changes?",
          "createdAt": "2020-10-27T14:53:23Z",
          "updatedAt": "2020-10-27T14:53:23Z"
        }
      ]
    },
    {
      "number": 1311,
      "id": "MDU6SXNzdWU3Mjg4OTU4MjA=",
      "title": "remove redundant definitions after transitioning to structured fields",
      "url": "https://github.com/httpwg/http-extensions/issues/1311",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "## I expect\r\n\r\n- [ ] to reference sf-decimal and sf-integer. It is probably more readable to define the params first, and then reference them in the content-identifier section\r\n- [ ] use SF reference, use Unixtime reference #1313 ",
      "createdAt": "2020-10-24T23:04:34Z",
      "updatedAt": "2020-10-27T09:27:30Z",
      "closedAt": null,
      "comments": [
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "+1, agree that we should refer to sf-integer. Where would we refer to sf-decimal in the spec?",
          "createdAt": "2020-10-27T02:34:58Z",
          "updatedAt": "2020-10-27T02:34:58Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> +1, agree that we should refer to sf-integer. Where would we refer to sf-decimal in the spec?\r\n\r\nhttps://github.com/httpwg/http-extensions/pull/1312/files#diff-1d57bca6223a0fee3ef29148c2550c0f862e72f67a56cc7f57b5a72fbd8320e3R262",
          "createdAt": "2020-10-27T09:27:30Z",
          "updatedAt": "2020-10-27T09:27:30Z"
        }
      ]
    },
    {
      "number": 1315,
      "id": "MDU6SXNzdWU3Mjg5MDgxOTY=",
      "title": "Removing subheaders content identifiers",
      "url": "https://github.com/httpwg/http-extensions/issues/1315",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "## Discussion\r\n\r\nAt the last http-wg interim meeting we discussed the opportunity to have sub-headers content identifiers, and it was noted that they are subject to a variety of problems.\r\n\r\nI suggest to:\r\n\r\n- remove them in the current draft\r\n- eventually refining the proposal in a new PR with the support of the ML\r\n\r\nI would be great to get more information about the use cases of this features and share some thoughts with the wg.",
      "createdAt": "2020-10-25T00:33:35Z",
      "updatedAt": "2020-10-27T09:45:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "msporny",
          "authorAssociation": "NONE",
          "body": "Can you please explain what happened in the HTTP WG interim meeting for those of us that could not attend? Exactly what is the problem and could you provide a concrete example of the problem?",
          "createdAt": "2020-10-27T02:37:01Z",
          "updatedAt": "2020-10-27T02:37:01Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @msporny, hope you're fine :)\r\n\r\nHere are the [interim minutes](https://httpwg.org/wg-materials/interim-20-10/minutes.html). I don't know if there are some recordings.\r\n\r\nOne of the problem is the following: \r\n\r\n1- if Signature references a sub-header, the verifier must know the syntax of the header\r\n2- the header will thus be parsed before validating the signature\r\n3- it does not require to send a valid signature to force the verifier to parse (split, token, indexing, ...) whatever header\r\n4- the verifier might not know the header syntax: at this point it can either guess or fail\r\n5- if they guess, the sender can steer the way the signature is processed\r\n\r\n@martinthomson  explained better than me a generalization of this issue.",
          "createdAt": "2020-10-27T09:45:06Z",
          "updatedAt": "2020-10-27T09:45:06Z"
        }
      ]
    },
    {
      "number": 1318,
      "id": "MDU6SXNzdWU3MzAwNDIzMjc=",
      "title": "HTTP Message Signatures - expired draft, please refresh",
      "url": "https://github.com/httpwg/http-extensions/issues/1318",
      "state": "CLOSED",
      "author": "msporny",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'm getting a large volume of private emails asking why the HTTP Message Signatures has been allowed to expire in an active WG.\r\n\r\nhttps://tools.ietf.org/html/draft-ietf-httpbis-message-signatures-00\r\n\r\nI'm trying to reassure those people that the spec is still very much alive. When can we expect a new publication of the spec?",
      "createdAt": "2020-10-27T02:17:02Z",
      "updatedAt": "2020-10-27T22:20:22Z",
      "closedAt": "2020-10-27T22:20:21Z",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@richanna @jricher could you please create a -01? It's about\r\n\r\n- git tag\r\n- git push\r\n- check your email\r\n",
          "createdAt": "2020-10-27T09:37:59Z",
          "updatedAt": "2020-10-27T09:37:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Please use e-mail to the authors to ask about things like this.",
          "createdAt": "2020-10-27T22:20:21Z",
          "updatedAt": "2020-10-27T22:20:21Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg0Mzk4OTU=",
      "title": "Using h2 instead of http2 for ALPN labels",
      "url": "https://github.com/httpwg/http-extensions/pull/10",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "I added a reference to the first mention as well, just to keep things shiny.\n",
      "createdAt": "2014-07-15T22:39:38Z",
      "updatedAt": "2014-08-15T18:19:34Z",
      "closedAt": "2014-08-15T18:19:34Z",
      "mergedAt": "2014-08-15T18:19:34Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ab805ccd0db2a224f16717eb46440bfbe04c07e1",
      "headRepository": "martinthomson/http-extensions",
      "headRefName": "h2",
      "headRefOid": "881e99d4284a28c816503c3a7ef3137d4a93dfd0",
      "mergeCommit": {
        "oid": "521103fd30b8a667b7332e76398040433fb3f67c"
      }
    },
    {
      "number": 14,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1ODM1ODE=",
      "title": "Update tunnel-protocol spec",
      "url": "https://github.com/httpwg/http-extensions/pull/14",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "As discussed; a quick pass to trim down RTCweb stuff, etc.\n",
      "createdAt": "2014-08-11T05:38:58Z",
      "updatedAt": "2014-08-13T19:29:21Z",
      "closedAt": "2014-08-13T19:29:21Z",
      "mergedAt": "2014-08-13T19:29:21Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks ok to me, @andyhutton, @juberti, does this look OK ?\n",
          "createdAt": "2014-08-11T05:54:01Z",
          "updatedAt": "2014-08-11T05:54:01Z"
        },
        {
          "author": "juberti",
          "authorAssociation": "NONE",
          "body": "Content looks good to me.\n\nOn Sun, Aug 10, 2014 at 10:54 PM, Martin Thomson notifications@github.com\nwrote:\n\n> This looks ok to me, @andyhutton https://github.com/andyhutton, @juberti\n> https://github.com/juberti, does this look OK ?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/httpwg/http-extensions/pull/14#issuecomment-51744209.\n",
          "createdAt": "2014-08-11T06:07:25Z",
          "updatedAt": "2014-08-11T06:07:25Z"
        },
        {
          "author": "andyhutton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also looks good to me.\n\nShould I now merge the pull request and submit the draft?\n",
          "createdAt": "2014-08-13T15:34:36Z",
          "updatedAt": "2014-08-13T15:34:36Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "cd7e9f5549152ec5c22aacfe5718fd4dbd5b3b2c",
      "headRepository": null,
      "headRefName": "trim-tunnel",
      "headRefOid": "624d8f43ed7f501e65e44addba38a7c57caf580b",
      "mergeCommit": null
    },
    {
      "number": 15,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4MjY3MDI=",
      "title": "Talk about multiple alternative services",
      "url": "https://github.com/httpwg/http-extensions/pull/15",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "For httpwg/http-extensions#8.\n",
      "createdAt": "2014-08-15T02:18:54Z",
      "updatedAt": "2014-08-17T23:44:13Z",
      "closedAt": "2014-08-15T18:17:50Z",
      "mergedAt": "2014-08-15T18:17:50Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "790ba147ebb1bc77c153fe4c59b89393a70c1dc8",
      "headRepository": null,
      "headRefName": "mult-alt-svc",
      "headRefOid": "c0425c93f0f63461799b30cc51ea455be81cfd8e",
      "mergeCommit": {
        "oid": "18acce984812eee71803e9e599525fb98c3b58fa"
      }
    },
    {
      "number": 20,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk5MDIwMjg=",
      "title": "Alt svc edit",
      "url": "https://github.com/httpwg/http-extensions/pull/20",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Editorial suggestions for alt-svc; please double-check.\n",
      "createdAt": "2014-08-18T07:01:28Z",
      "updatedAt": "2014-10-25T16:04:16Z",
      "closedAt": "2014-10-25T16:04:16Z",
      "mergedAt": "2014-10-25T16:04:16Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a498e59ea4f09fdc1b2a190969690d9632d66ea9",
      "headRepository": null,
      "headRefName": "alt-svc-edit",
      "headRefOid": "092d0854f101b9a0b65d8b069011cf8dad3ed0c3",
      "mergeCommit": {
        "oid": "47ef78b9986ae9a4554518dfcb555065d0bc779c"
      }
    },
    {
      "number": 23,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk5NTQ4NTM=",
      "title": "fix minor typos in tunnel protocol",
      "url": "https://github.com/httpwg/http-extensions/pull/23",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2014-08-19T01:02:20Z",
      "updatedAt": "2016-07-07T03:06:32Z",
      "closedAt": "2014-08-19T17:42:42Z",
      "mergedAt": "2014-08-19T17:42:42Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a498e59ea4f09fdc1b2a190969690d9632d66ea9",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "20140819-tunnel-minor-typos",
      "headRefOid": "cff3db07db049f89b20549f04104492bcd8fc1dd",
      "mergeCommit": {
        "oid": "b42302a5ba9d879fe38006249d61ca6c41c79cd2"
      }
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk5NTYxODc=",
      "title": "Opp sec edit",
      "url": "https://github.com/httpwg/http-extensions/pull/24",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Editorial suggestions for opp-sec; please review carefully.\n",
      "createdAt": "2014-08-19T01:53:45Z",
      "updatedAt": "2014-08-19T18:13:04Z",
      "closedAt": "2014-08-19T18:13:04Z",
      "mergedAt": "2014-08-19T18:13:04Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a498e59ea4f09fdc1b2a190969690d9632d66ea9",
      "headRepository": null,
      "headRefName": "opp-sec-edit",
      "headRefOid": "69e2de9a950dfdcf91781356057853a5c7d3e0e8",
      "mergeCommit": null
    },
    {
      "number": 29,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk5OTYyMjk=",
      "title": "Remove tracking note",
      "url": "https://github.com/httpwg/http-extensions/pull/29",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Mark moved this note in his edits, but I think that we don't need it any more at all.  The security considerations will suffice.\n",
      "createdAt": "2014-08-19T17:38:19Z",
      "updatedAt": "2014-10-25T16:13:35Z",
      "closedAt": "2014-10-25T16:13:35Z",
      "mergedAt": "2014-10-25T16:13:35Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a498e59ea4f09fdc1b2a190969690d9632d66ea9",
      "headRepository": "martinthomson/http-extensions",
      "headRefName": "asutrack",
      "headRefOid": "a381948f095c4c3ebaa7033f52cf9eb4be3dab4a",
      "mergeCommit": {
        "oid": "c7364235769978b87aafdc848a5ae941fad83d4c"
      }
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk5OTg1NDA=",
      "title": "Multiple values for tunnel protocol",
      "url": "https://github.com/httpwg/http-extensions/pull/31",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "tunnel-proto"
      ],
      "body": "This changes the grammar and text to permit multiple ALPN tokens in the header.  This is necessary for HTTP tunnels (\"http/1.1\" and \"h2\") as well as some WebRTC cases. \n\nI made some editorial changes at the same time.  I'll split those out if we don't accept this.\n",
      "createdAt": "2014-08-19T18:14:53Z",
      "updatedAt": "2015-05-20T18:21:02Z",
      "closedAt": "2014-12-03T06:17:53Z",
      "mergedAt": "2014-12-03T06:17:53Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "2bf353e7497a4980d093d321f042c9ace0476267",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "multiple",
      "headRefOid": "0f84c56674c0dac8983d4d96bfe8c8f416ce3e2e",
      "mergeCommit": {
        "oid": "acb73d0cc595d5bca1685121edb834a582127067"
      }
    },
    {
      "number": 39,
      "id": "MDExOlB1bGxSZXF1ZXN0MjczODAxMDg=",
      "title": "Add Origin to ALTSVC HTTP/2 frame.",
      "url": "https://github.com/httpwg/http-extensions/pull/39",
      "state": "CLOSED",
      "author": "bencebeky",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "A possible implementation of http://lists.w3.org/Archives/Public/ietf-http-wg/2015JanMar/0062.html.\n",
      "createdAt": "2015-01-14T20:21:32Z",
      "updatedAt": "2015-01-29T16:16:24Z",
      "closedAt": "2015-01-29T16:16:24Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the proposal; will use a variant using 16 bits.\n",
          "createdAt": "2015-01-29T16:16:24Z",
          "updatedAt": "2015-01-29T16:16:24Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5d2951600b49c66584274db5b6d60828bf89d7ab",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "91762a9f959f28663c535e1a435377aac6ecf71d",
      "mergeCommit": null
    },
    {
      "number": 40,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc3ODY1OTY=",
      "title": "normative language, links, refs, abbreviations",
      "url": "https://github.com/httpwg/http-extensions/pull/40",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-01-21T19:19:03Z",
      "updatedAt": "2015-01-21T19:25:37Z",
      "closedAt": "2015-01-21T19:25:37Z",
      "mergedAt": "2015-01-21T19:25:37Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "276c9e2f03e0f4c174e4d2538974c8d139df6d3e",
      "headRepository": "reschke/http-extensions",
      "headRefName": "master",
      "headRefOid": "340d3022e73bf453faece5a33e5c24068b6a3977",
      "mergeCommit": {
        "oid": "b7fcd612a663f62efabe93e030a4f572b2e62a0b"
      }
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg1NTgxODU=",
      "title": "Changes remaining MUST for Alt-Used.",
      "url": "https://github.com/httpwg/http-extensions/pull/41",
      "state": "MERGED",
      "author": "hruellan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-02-03T14:56:08Z",
      "updatedAt": "2015-02-03T15:14:26Z",
      "closedAt": "2015-02-03T15:14:26Z",
      "mergedAt": "2015-02-03T15:14:26Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7bfc4abcdad0dd2840846e768b358b7371b1e7d9",
      "headRepository": "hruellan/http-extensions",
      "headRefName": "alt-used",
      "headRefOid": "b53940c64d7b9eb90fa544b2c65b4f3be98eb49c",
      "mergeCommit": {
        "oid": "90c541e73f9f63df633399ff662ff5820188ff38"
      }
    },
    {
      "number": 42,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg1NjkwMTI=",
      "title": "Alt-Used improvements",
      "url": "https://github.com/httpwg/http-extensions/pull/42",
      "state": "MERGED",
      "author": "hruellan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-02-03T16:57:30Z",
      "updatedAt": "2015-02-03T17:04:32Z",
      "closedAt": "2015-02-03T17:04:32Z",
      "mergedAt": "2015-02-03T17:04:32Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3ec017f8af4413f2f6b256c03143bbb998d8e3b6",
      "headRepository": "hruellan/http-extensions",
      "headRefName": "alt-used",
      "headRefOid": "63c3d391ec5b92b342cde3faf2a38e5cb3c1a827",
      "mergeCommit": {
        "oid": "53fe6bea6906fc4db7fd5ffe396137d901b8e0a2"
      }
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1MTkxNzI=",
      "title": "Typos.",
      "url": "https://github.com/httpwg/http-extensions/pull/46",
      "state": "MERGED",
      "author": "hruellan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-02-18T11:46:18Z",
      "updatedAt": "2015-02-18T12:10:45Z",
      "closedAt": "2015-02-18T12:01:02Z",
      "mergedAt": "2015-02-18T12:01:02Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8f91ed11a6c5c007444bbac3a3330838aac99793",
      "headRepository": "hruellan/http-extensions",
      "headRefName": "auth-info",
      "headRefOid": "8904ce7f7ffd5d45385a9327201a7b1d242107a0",
      "mergeCommit": {
        "oid": "b6616dc93a34c162c5edab6937ad9ec106b582af"
      }
    },
    {
      "number": 47,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1MjE4NjY=",
      "title": "Proposal for header purpose.",
      "url": "https://github.com/httpwg/http-extensions/pull/47",
      "state": "MERGED",
      "author": "hruellan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-02-18T12:37:13Z",
      "updatedAt": "2015-02-19T09:16:46Z",
      "closedAt": "2015-02-18T12:53:33Z",
      "mergedAt": "2015-02-18T12:53:33Z",
      "mergedBy": "reschke",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Herve, could you please open an issue for this, so that we can assure that we track the underlying issue? It's OK to merge the proposal if the editor feels that it's helpful, but we need to make sure the WG gets consensus here.\n\nThanks,\n",
          "createdAt": "2015-02-19T03:07:37Z",
          "updatedAt": "2015-02-19T03:07:37Z"
        },
        {
          "author": "hruellan",
          "authorAssociation": "NONE",
          "body": "Linked to issue #49.\n",
          "createdAt": "2015-02-19T09:16:46Z",
          "updatedAt": "2015-02-19T09:16:46Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ea144aa147e00a3272b1932da60f59136dac157f",
      "headRepository": "hruellan/http-extensions",
      "headRefName": "auth-info",
      "headRefOid": "849702e4f7f6476b09a8e7777941dac21a848e00",
      "mergeCommit": {
        "oid": "8909511c212ada9d682d2f2a9c1ae20ca3338ae9"
      }
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1Mjc0MDc=",
      "title": "fix \"contributing\" link in readme",
      "url": "https://github.com/httpwg/http-extensions/pull/48",
      "state": "MERGED",
      "author": "jomo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "> It is not necessary to notify the mailing list for editorial issues.\n\n:sunglasses: \n",
      "createdAt": "2015-02-18T14:06:42Z",
      "updatedAt": "2015-02-19T08:41:57Z",
      "closedAt": "2015-02-19T08:41:57Z",
      "mergedAt": "2015-02-19T08:41:57Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "84c7cb88bc740d4b5229849d891526020419155e",
      "headRepository": "jomo/http-extensions",
      "headRefName": "patch-1",
      "headRefOid": "c79ce1cccda6759c6390da56e73175c0a81b48b0",
      "mergeCommit": null
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEzODE4NzI=",
      "title": "Falsification",
      "url": "https://github.com/httpwg/http-extensions/pull/54",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "tunnel-proto"
      ],
      "body": "This adds a section regarding falsification of Tunnel-Protocol.  I didn't expand this to note that WebRTC won't suffer from this problem because the application won't be able to set the header field.  That seemed like too much detail.\n",
      "createdAt": "2015-03-17T21:53:15Z",
      "updatedAt": "2015-03-25T01:02:57Z",
      "closedAt": "2015-03-24T18:50:04Z",
      "mergedAt": "2015-03-24T18:50:04Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5d1d5854d392c14ddc73761c6ff5796f5cbb940b",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "falsification",
      "headRefOid": "c1e253ac12b7b980857a31881c98837d9c2e536a",
      "mergeCommit": {
        "oid": "792cac7522445a5012875705d7e582553f42261d"
      }
    },
    {
      "number": 55,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE4NTYxOTY=",
      "title": "Editorial changes",
      "url": "https://github.com/httpwg/http-extensions/pull/55",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "for encryption.\n\nI had these in my local repo.  They weren't pushed, but I wanted to make sure that they are OK before merging them.\n",
      "createdAt": "2015-03-24T18:28:51Z",
      "updatedAt": "2015-05-20T18:20:04Z",
      "closedAt": "2015-05-20T18:20:01Z",
      "mergedAt": "2015-05-20T18:20:01Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6f105f1bd355697492ed3548c6ae50b2d6dc1d7f",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "editorial",
      "headRefOid": "2645ecc531f0dd6b99619a24e1363ecb94dbe321",
      "mergeCommit": null
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE4NzUxNTk=",
      "title": "Precise signification of http/1.1 ALPN token.",
      "url": "https://github.com/httpwg/http-extensions/pull/56",
      "state": "CLOSED",
      "author": "hruellan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The `http/1.1` ALPN token identifies HTTP/1.1 over TLS.\n",
      "createdAt": "2015-03-24T22:06:35Z",
      "updatedAt": "2015-07-20T13:02:53Z",
      "closedAt": "2015-07-20T13:02:53Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6f105f1bd355697492ed3548c6ae50b2d6dc1d7f",
      "headRepository": "hruellan/http-extensions",
      "headRefName": "alpn-identifiers",
      "headRefOid": "26a5cf0b3ccab12466e25c069f6ff55a6f0b3310",
      "mergeCommit": null
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIzMzgxNDk=",
      "title": "Use only one alternative service.",
      "url": "https://github.com/httpwg/http-extensions/pull/59",
      "state": "MERGED",
      "author": "hruellan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Solves #58 \n",
      "createdAt": "2015-03-31T16:09:37Z",
      "updatedAt": "2015-05-30T10:51:42Z",
      "closedAt": "2015-05-30T10:51:42Z",
      "mergedAt": "2015-05-30T10:51:42Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b6a0053bef5078e90754d2771ba8ccd0a36c5bcc",
      "headRepository": "hruellan/http-extensions",
      "headRefName": "alt-svc-only-one",
      "headRefOid": "b80566b71a752d04e5bc271f6f9b503004a150c4",
      "mergeCommit": null
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIzMzgxOTI=",
      "title": "Corrects typo.",
      "url": "https://github.com/httpwg/http-extensions/pull/60",
      "state": "MERGED",
      "author": "hruellan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "",
      "createdAt": "2015-03-31T16:10:08Z",
      "updatedAt": "2015-05-01T13:01:03Z",
      "closedAt": "2015-05-01T13:01:03Z",
      "mergedAt": "2015-05-01T13:01:03Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b6a0053bef5078e90754d2771ba8ccd0a36c5bcc",
      "headRepository": "hruellan/http-extensions",
      "headRefName": "alt-svc-typo",
      "headRefOid": "b1c56d72b0ea699ef98655e8c2d08e14665bffcd",
      "mergeCommit": null
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIzMzgzNjI=",
      "title": "Alt svc tracking",
      "url": "https://github.com/httpwg/http-extensions/pull/61",
      "state": "CLOSED",
      "author": "hruellan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Extends alt-svc information removal to any app.\n",
      "createdAt": "2015-03-31T16:11:43Z",
      "updatedAt": "2015-05-04T08:56:19Z",
      "closedAt": "2015-05-04T08:56:19Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(see above)\n",
          "createdAt": "2015-05-04T08:56:19Z",
          "updatedAt": "2015-05-04T08:56:19Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b6a0053bef5078e90754d2771ba8ccd0a36c5bcc",
      "headRepository": "hruellan/http-extensions",
      "headRefName": "alt-svc-tracking",
      "headRefOid": "348ee5688528f4858c6969cd013dbd2ed791b54b",
      "mergeCommit": null
    },
    {
      "number": 63,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM0MDc0Mzc=",
      "title": "Renaming to ALPN",
      "url": "https://github.com/httpwg/http-extensions/pull/63",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Last call discussion identified this as a solution to the confusion that exists around the intent of the header field.\n\nCloses #57.\n",
      "createdAt": "2015-04-15T23:46:23Z",
      "updatedAt": "2015-05-20T18:21:01Z",
      "closedAt": "2015-04-27T16:12:16Z",
      "mergedAt": "2015-04-27T16:12:16Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5e91bb4353fd7436a1c2ffe39fa4e692f39bd722",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "alpn",
      "headRefOid": "df82c6b2b7c4b9a356944934d5f324fd87815707",
      "mergeCommit": {
        "oid": "e67a4f89d0733b72caec4da64c247c4ee76cb1cf"
      }
    },
    {
      "number": 66,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxMTYzNzA=",
      "title": "Avoid ambiguity with \"may not\" and a \"MAY\" requirement",
      "url": "https://github.com/httpwg/http-extensions/pull/66",
      "state": "CLOSED",
      "author": "aprescott",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "451"
      ],
      "body": "RFC 2119 defines \"MAY\" as a keyword, which may cause confusion with \"may not\", even though the latter is not uppercased.\n\nThis hopefully better clarifies that the server in question may or may not be an origin server, as opposed to implying that origin servers are prevented from returning a 451 response status.\n",
      "createdAt": "2015-04-26T01:53:11Z",
      "updatedAt": "2016-02-17T20:40:34Z",
      "closedAt": "2015-12-30T00:20:41Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "aprescott",
          "authorAssociation": "NONE",
          "body": "I re-wrapped the content to 80 characters after making this change, although I'm happy to undo that if the diff noise is unwelcome.\n\nI also would be glad to go with a different choice of wording if there's something more preferable.\n",
          "createdAt": "2015-04-26T01:54:14Z",
          "updatedAt": "2015-04-26T01:54:14Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good to me.\n",
          "createdAt": "2015-08-14T15:52:16Z",
          "updatedAt": "2015-08-14T15:52:16Z"
        },
        {
          "author": "aprescott",
          "authorAssociation": "NONE",
          "body": "Out of curiosity, why this was closed?\n",
          "createdAt": "2015-12-30T02:08:35Z",
          "updatedAt": "2015-12-30T02:08:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "because the RFC has been published.\n",
          "createdAt": "2016-01-04T05:30:03Z",
          "updatedAt": "2016-01-04T05:30:03Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually, it has been approved but not published, and this is a change that could be done during AUTH48 (a minimal change would be \"may\" -> \"might\").\n",
          "createdAt": "2016-01-04T06:37:55Z",
          "updatedAt": "2016-01-04T06:37:55Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@timbray, thoughts? I think this is editors' discretion (although historically we do try to avoid using RFC2119 keywords in this manner).\n",
          "createdAt": "2016-01-04T06:48:07Z",
          "updatedAt": "2016-01-04T06:48:07Z"
        },
        {
          "author": "aprescott",
          "authorAssociation": "NONE",
          "body": "Happy to resubmit a PR with the change, unless @timbray or someone else would just make that small modification.\n",
          "createdAt": "2016-01-07T15:36:37Z",
          "updatedAt": "2016-01-07T15:36:37Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this can be considered to be resolved due to the changes in f36fb4af.\n",
          "createdAt": "2016-02-17T20:40:34Z",
          "updatedAt": "2016-02-17T20:40:34Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "67a4b3a6a22854f325c387bfb5ec5c39025f68f4",
      "headRepository": "aprescott/http-extensions",
      "headRefName": "may-not-ambiguity",
      "headRefOid": "d811fafc29acdc705a9aa001baa52d4b767df061",
      "mergeCommit": null
    },
    {
      "number": 68,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ0ODA5MTY=",
      "title": "Fix typo.",
      "url": "https://github.com/httpwg/http-extensions/pull/68",
      "state": "MERGED",
      "author": "bencebeky",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-04-30T17:12:49Z",
      "updatedAt": "2015-05-01T12:56:04Z",
      "closedAt": "2015-05-01T12:56:04Z",
      "mergedAt": "2015-05-01T12:56:04Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4c0e439daee9bd977730cf0765a613f7b8eda90f",
      "headRepository": null,
      "headRefName": "typo",
      "headRefOid": "d25e42ebb189bfe0bd4ff38ee1f29c18b2821434",
      "mergeCommit": null
    },
    {
      "number": 70,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYyNzUwOTA=",
      "title": "Cice edits",
      "url": "https://github.com/httpwg/http-extensions/pull/70",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "cice"
      ],
      "body": "Mostly editorial.\n",
      "createdAt": "2015-05-27T07:13:39Z",
      "updatedAt": "2017-02-01T05:00:59Z",
      "closedAt": "2015-07-20T12:53:20Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4f5adebe800b9f0b06c945f7bc7b378cb7d4e987",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "cice-edits",
      "headRefOid": "d4933da77a526321da35b209a588754178d4da82",
      "mergeCommit": null
    },
    {
      "number": 77,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0NjI1MjE=",
      "title": "Going down for maintenance?",
      "url": "https://github.com/httpwg/http-extensions/pull/77",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Spec commends the use of Alt-Svc when a server is \"going down for maintenance.\"  But new clients will always be trying to contact the origin server, and existing clients may always fall back to it for various reasons.  Alt-Svc isn't a redundancy strategy for the origin, and I don't think we should present it as one here.  Servers will still need to cluster, anycast, etc. or shed load by changing DNS.\n",
      "createdAt": "2015-05-28T23:51:04Z",
      "updatedAt": "2015-08-14T15:31:32Z",
      "closedAt": "2015-08-14T15:31:32Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep.\n",
          "createdAt": "2015-05-28T23:54:07Z",
          "updatedAt": "2015-05-28T23:54:07Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See https://github.com/httpwg/http-extensions/commit/0b847c05be2dca2280007c84f87ed6fb2ec1a5d1\n",
          "createdAt": "2015-08-14T15:31:32Z",
          "updatedAt": "2015-08-14T15:31:32Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "85b0e60079c726e8538737ff2aca0c18a4685974",
      "headRepository": "MikeBishop/http-extensions",
      "headRefName": "patch-1",
      "headRefOid": "1b8e468f17bec4d43b688ac7794813f83073dbf5",
      "mergeCommit": null
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY0NjQ2MTg=",
      "title": "Alt-Svc Editorial Nits",
      "url": "https://github.com/httpwg/http-extensions/pull/78",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Assorted:\n- Alt-Svc doesn't introduce 421, just points to RFC 7540\n- Missing \"the\" in overview\n- Requests != connections in HTTP/2; presuming you mean connections throughout\n- Non-normative \"can\" mismatch with normative SHOULD later in the document\n- Clients who wish to avoid tracking are also permitted to just drop Alt-Used; turned to normative MAY to match earlier text\n- Word order in scheme confusion text\n",
      "createdAt": "2015-05-29T00:34:05Z",
      "updatedAt": "2015-08-14T15:20:01Z",
      "closedAt": "2015-08-14T15:20:01Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(see code comments; cherry-picked everything else in https://github.com/httpwg/http-extensions/commit/65ffed008a9eb9d06762217cfd6e03401fef640f)\n",
          "createdAt": "2015-08-14T15:19:53Z",
          "updatedAt": "2015-08-14T15:19:53Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "85b0e60079c726e8538737ff2aca0c18a4685974",
      "headRepository": "MikeBishop/http-extensions",
      "headRefName": "patch-2",
      "headRefOid": "68366900371da5678a39d73af7c5e714157d93db",
      "mergeCommit": null
    },
    {
      "number": 85,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc3NTY4NDk=",
      "title": "editorial changes",
      "url": "https://github.com/httpwg/http-extensions/pull/85",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- consistent use of `http` instead of \"http\"\n- make S1.1, P3 a bit more readable\n",
      "createdAt": "2015-06-16T03:31:30Z",
      "updatedAt": "2016-07-07T03:06:29Z",
      "closedAt": "2015-06-16T03:45:55Z",
      "mergedAt": "2015-06-16T03:45:55Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3fb72e957ea1cb9d692a36fb2f49a9c6ee47e1e2",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "20150615-encryption-editorial",
      "headRefOid": "18a30fa1fb9babde70107dd8bd19335a44d6d555",
      "mergeCommit": null
    },
    {
      "number": 86,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzMzM2OTA=",
      "title": "no need to update RFC 2616",
      "url": "https://github.com/httpwg/http-extensions/pull/86",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-07-20T09:08:28Z",
      "updatedAt": "2017-02-01T05:00:02Z",
      "closedAt": "2015-08-14T13:57:15Z",
      "mergedAt": "2015-08-14T13:57:15Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ea96c6ec97343cec5dc59792316e91c2ed9c9747",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-1",
      "headRefOid": "1a29d55db5e93abdebacb24ed0a8347e8549c875",
      "mergeCommit": null
    },
    {
      "number": 88,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzNDk0MzI=",
      "title": "Adds text on ALPN identifiers.",
      "url": "https://github.com/httpwg/http-extensions/pull/88",
      "state": "CLOSED",
      "author": "hruellan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "For solving #43.\n",
      "createdAt": "2015-07-20T13:05:28Z",
      "updatedAt": "2015-08-20T08:08:59Z",
      "closedAt": "2015-08-20T08:08:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Included slightly modified in https://github.com/httpwg/http-extensions/commit/ee453d2f9205a5ea8e6115e899baa421c6245a38\n",
          "createdAt": "2015-08-14T16:34:17Z",
          "updatedAt": "2015-08-14T16:34:17Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5b793656bcf9c69e05d95cc0e70d2f3ca9ac773e",
      "headRepository": "hruellan/http-extensions",
      "headRefName": "alpn-identifiers",
      "headRefOid": "601987c66d8b7b7c766734b304f2876515eddcd2",
      "mergeCommit": null
    },
    {
      "number": 90,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA0NjA1NTQ=",
      "title": "Allow empty list of alternative services.",
      "url": "https://github.com/httpwg/http-extensions/pull/90",
      "state": "CLOSED",
      "author": "bencebeky",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Allow empty list of alternative services both in header field value and in\nframe.  See\nhttps://github.com/httpwg/http-extensions/issues/16#issuecomment-123273055.\n",
      "createdAt": "2015-07-21T14:05:20Z",
      "updatedAt": "2015-08-26T18:49:05Z",
      "closedAt": "2015-08-26T18:49:05Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Addressed by introducing the \"clear\" keyword (see https://github.com/httpwg/http-extensions/commit/68970e3555ba77cd56418c036e601af520b17711)\n",
          "createdAt": "2015-08-26T18:49:05Z",
          "updatedAt": "2015-08-26T18:49:05Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1f192ced8a16066e09b92a98385c3bf82bbeb563",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "fbb84a5cafa51d7e14c8273f9319a111ded5cbce",
      "mergeCommit": null
    },
    {
      "number": 93,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM4Mzg4OTg=",
      "title": "Flatten Section 5",
      "url": "https://github.com/httpwg/http-extensions/pull/93",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "451"
      ],
      "body": "",
      "createdAt": "2015-09-01T05:35:29Z",
      "updatedAt": "2016-09-28T06:59:04Z",
      "closedAt": "2015-12-30T00:20:26Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "68970e3555ba77cd56418c036e601af520b17711",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "un5.1",
      "headRefOid": "fb97e083cf9c6e425d9f3d6aff048d3be5f51dd1",
      "mergeCommit": null
    },
    {
      "number": 97,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5MzUwMDE=",
      "title": "Issue 73:  Text for port-privilege change",
      "url": "https://github.com/httpwg/http-extensions/pull/97",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Proposes additional text in security considerations around changing from privileged to non-privileged ports; addresses #73.\n",
      "createdAt": "2015-10-06T17:50:19Z",
      "updatedAt": "2015-10-06T18:13:53Z",
      "closedAt": "2015-10-06T18:13:53Z",
      "mergedAt": "2015-10-06T18:13:53Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4cc3af22ffd2e7f6c3f33dd2e91b84ff2e92e8d5",
      "headRepository": "MikeBishop/http-extensions",
      "headRefName": "issue73",
      "headRefOid": "3a2680dd6fd7f86aa427f4435eab76b368d69777",
      "mergeCommit": null
    },
    {
      "number": 98,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5MzY4MjQ=",
      "title": "Security for spoofed certs",
      "url": "https://github.com/httpwg/http-extensions/pull/98",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Text giving recommendations for guarding against spoofed certs.\n",
      "createdAt": "2015-10-06T18:05:18Z",
      "updatedAt": "2015-11-04T15:03:13Z",
      "closedAt": "2015-11-04T15:03:12Z",
      "mergedAt": "2015-11-04T15:03:12Z",
      "mergedBy": "reschke",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The text on pinning is fine.  If the intent is expand on the authentication requirements for alternatives, the first sentence would suffice.\n\nI'm concerned that the \"additional requirements\" you describe here might lead to interoperability problems.  If these aren't specified, we are left to guess what the validation requirements are for any given client.  I recognize that failure to authenticate an alternative doesn't necessarily translate into a fatal error - the alternative is just not used.  However, I'm wondering what the motivation for the change is.\n",
          "createdAt": "2015-10-07T04:33:05Z",
          "updatedAt": "2015-10-07T04:33:05Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is from #76, which I should have tagged.  You argued against the spec requiring an identical cert, and I agree that synchronization and security of the cert could certainly be an issue.  However, the client might already have some data about the certs used by the origin and could reasonably expect some similarity between them.\n\nAs I said in the issue, I think cautious implementations will probably do _something_ here, and I'd prefer the possibility to be mentioned in the spec so it's something operators will be aware of.\n",
          "createdAt": "2015-10-07T16:00:54Z",
          "updatedAt": "2015-10-07T16:00:54Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson are you ok with this proposal?\n",
          "createdAt": "2015-11-04T09:11:21Z",
          "updatedAt": "2015-11-04T09:11:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, it is what we discussed in the meeting.\n",
          "createdAt": "2015-11-04T14:31:11Z",
          "updatedAt": "2015-11-04T14:31:11Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4cc3af22ffd2e7f6c3f33dd2e91b84ff2e92e8d5",
      "headRepository": "MikeBishop/http-extensions",
      "headRefName": "issue76",
      "headRefOid": "92451691a65b16974be7c34ede62da7503d2c813",
      "mergeCommit": null
    },
    {
      "number": 99,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5MzgxMDQ=",
      "title": "Issue 74:  Alternates are authoritative",
      "url": "https://github.com/httpwg/http-extensions/pull/99",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "An alternate can send an Alt-Svc field that overrides that sent by the origin and is cached on an equal basis.\n",
      "createdAt": "2015-10-06T18:16:06Z",
      "updatedAt": "2015-10-06T19:38:39Z",
      "closedAt": "2015-10-06T19:38:39Z",
      "mergedAt": "2015-10-06T19:38:39Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d5547250ff37ea6e60b8ad02dbfdc2a49475c1b4",
      "headRepository": "MikeBishop/http-extensions",
      "headRefName": "issue74",
      "headRefOid": "7deef94477f5033ef9dab10d6a85967c04550039",
      "mergeCommit": null
    },
    {
      "number": 100,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5Mzg5MzU=",
      "title": "Wrong protocol is connection failure",
      "url": "https://github.com/httpwg/http-extensions/pull/100",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Simple enough, as agreed previously.  Issue #72. \n",
      "createdAt": "2015-10-06T18:23:30Z",
      "updatedAt": "2015-10-07T06:35:20Z",
      "closedAt": "2015-10-07T06:35:20Z",
      "mergedAt": "2015-10-07T06:35:20Z",
      "mergedBy": "reschke",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM\n",
          "createdAt": "2015-10-07T04:52:45Z",
          "updatedAt": "2015-10-07T04:52:45Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d5547250ff37ea6e60b8ad02dbfdc2a49475c1b4",
      "headRepository": "MikeBishop/http-extensions",
      "headRefName": "issue72",
      "headRefOid": "a81204940562af4dcba8a45dbd81ff4f2f0688ad",
      "mergeCommit": null
    },
    {
      "number": 101,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5NDA1NTE=",
      "title": "Reconciling MAY/can vs. SHOULD",
      "url": "https://github.com/httpwg/http-extensions/pull/101",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Client MAY (2.2) vs. SHOULD (2.4) use alternatives they're aware of; clients \"can\" (2.4) vs. SHOULD (5) include the Alt-Used header. Reconciling these both to SHOULDs.\n",
      "createdAt": "2015-10-06T18:36:47Z",
      "updatedAt": "2016-02-04T01:27:29Z",
      "closedAt": "2016-02-04T01:27:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM\n",
          "createdAt": "2015-10-07T04:53:09Z",
          "updatedAt": "2015-10-07T04:53:09Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussed in Yokohama; this pull request seems reasonable.\n",
          "createdAt": "2015-11-02T04:32:32Z",
          "updatedAt": "2015-11-02T05:55:03Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There are unfortunately 2 change request here, one of which I partly agree with, the other I disagree with.\n\nThe first one is caused by having normative language spread over 2.2 and 2.4; I tried to address this in https://github.com/httpwg/http-extensions/commit/acc3ae3c4290323069501d55ea8cdb5bacdbc6e8.\n\nThe second one is about adding a duplicate requirement; I continue to believe we shouldn't do that. We can mention requirements multiple times, but only one place should have the magic keyword (otherwise we risk ending up with exactly the kind of inconsistencies this pull request is about).\n\n@MikeBishop are you ok with the change?\n",
          "createdAt": "2015-11-04T12:51:26Z",
          "updatedAt": "2015-11-04T12:51:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think this is resolved, but if you disagree, please open a new issue ASAP.\n",
          "createdAt": "2016-02-04T01:27:29Z",
          "updatedAt": "2016-02-04T01:27:29Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d5547250ff37ea6e60b8ad02dbfdc2a49475c1b4",
      "headRepository": "MikeBishop/http-extensions",
      "headRefName": "should-may",
      "headRefOid": "e70e63e381a04f61703cb2c7988934d167f74907",
      "mergeCommit": null
    },
    {
      "number": 124,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI2OTQ1Njk=",
      "title": "AltSvc WGLC Comments",
      "url": "https://github.com/httpwg/http-extensions/pull/124",
      "state": "CLOSED",
      "author": "hruellan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "alt-svc"
      ],
      "body": "Various editorial proposal for AltSVC\n",
      "createdAt": "2015-12-04T17:03:48Z",
      "updatedAt": "2015-12-30T00:20:15Z",
      "closedAt": "2015-12-30T00:20:15Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7eace35f73f611e1fe4212d98550d7a4329cae59",
      "headRepository": "hruellan/http-extensions",
      "headRefName": "alt-svc-wglc",
      "headRefOid": "101fd08d494cf2590d1cca629569e3ee252b98ca",
      "mergeCommit": null
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ0MDQwNDg=",
      "title": "Remove extraneous comma",
      "url": "https://github.com/httpwg/http-extensions/pull/127",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Even a pull request feels heavy-weight for this....\n",
      "createdAt": "2015-12-22T19:11:36Z",
      "updatedAt": "2015-12-23T06:36:13Z",
      "closedAt": "2015-12-23T06:36:13Z",
      "mergedAt": "2015-12-23T06:36:13Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "485bd6913284d02b205d4c3aaa937bc1d02c8344",
      "headRepository": "MikeBishop/http-extensions",
      "headRefName": "patch-3",
      "headRefOid": "b5b2a74e7cc4d852f8a25f7f3789a32a0d740533",
      "mergeCommit": {
        "oid": "b22811a5024e057193c0816e70553f4e19570ae4"
      }
    },
    {
      "number": 128,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ0NDIwMjg=",
      "title": "Merge encryption",
      "url": "https://github.com/httpwg/http-extensions/pull/128",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Need to check that this is OK first.\n",
      "createdAt": "2015-12-23T05:52:13Z",
      "updatedAt": "2016-09-28T06:59:04Z",
      "closedAt": "2015-12-30T05:47:03Z",
      "mergedAt": "2015-12-30T05:47:03Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "485bd6913284d02b205d4c3aaa937bc1d02c8344",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "merge_encryption",
      "headRefOid": "47d00a621d58437818dbf360ee34d0acc7e65a76",
      "mergeCommit": null
    },
    {
      "number": 129,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ1Mjg0ODE=",
      "title": "Initial draft of doc shepherd write-up",
      "url": "https://github.com/httpwg/http-extensions/pull/129",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2015-12-24T05:44:44Z",
      "updatedAt": "2015-12-30T00:19:52Z",
      "closedAt": "2015-12-30T00:19:52Z",
      "mergedAt": "2015-12-30T00:19:52Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6793d40e503bf5838e099031002a26a25ea3ad0e",
      "headRepository": "MikeBishop/http-extensions",
      "headRefName": "master",
      "headRefOid": "34be77ef9b0fa9b52ea0305038d451173d15c9ec",
      "mergeCommit": {
        "oid": "8de4af378ed7cbe5abf4ddb3826244bc53f115e3"
      }
    },
    {
      "number": 134,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY2OTg2NzA=",
      "title": "Altsvc samehost",
      "url": "https://github.com/httpwg/http-extensions/pull/134",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2016-01-21T02:46:55Z",
      "updatedAt": "2017-02-01T05:00:04Z",
      "closedAt": "2016-02-04T00:45:18Z",
      "mergedAt": "2016-02-04T00:45:18Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closes #139.\n",
          "createdAt": "2016-02-04T00:45:22Z",
          "updatedAt": "2016-02-04T00:45:22Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "434fe00dcbe790549f19a1b5ac737c09badb1865",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "altsvc-samehost",
      "headRefOid": "7c247c598035dd78c1aab8531b4e3ffeae66facb",
      "mergeCommit": {
        "oid": "dc26e2de11f80e4c8c9b3c57bb8df1d2f02bd358"
      }
    },
    {
      "number": 136,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc0OTU4MTc=",
      "title": "Use two octets to indicate record padding length in httpbis-encryption-encoding",
      "url": "https://github.com/httpwg/http-extensions/pull/136",
      "state": "MERGED",
      "author": "beverloo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "encryption"
      ],
      "body": "This is a proposal to address issue #135\n\n/cc @martinthomson \n",
      "createdAt": "2016-01-28T12:33:54Z",
      "updatedAt": "2016-02-14T03:57:58Z",
      "closedAt": "2016-02-14T03:57:58Z",
      "mergedAt": "2016-02-14T03:57:58Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "beverloo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've updated the graph in section 2 to note the new range. PTAL.\n",
          "createdAt": "2016-02-12T19:20:15Z",
          "updatedAt": "2016-02-12T19:20:15Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "98c1c756e853a7c5121e2989399a24ae6120973a",
      "headRepository": "beverloo/http-extensions",
      "headRefName": "two-byte-padding",
      "headRefOid": "6ef50140a6f0abe4177df7e19ce4f490ae4b243b",
      "mergeCommit": null
    },
    {
      "number": 137,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc1MTQxMzQ=",
      "title": "Rename aesgcm128 to aesgcm to provide an update path",
      "url": "https://github.com/httpwg/http-extensions/pull/137",
      "state": "MERGED",
      "author": "beverloo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "encryption"
      ],
      "body": "In order to allow existing applications to update from one octet of\npadding per record to two (PR #136, Issue #135), this PR renames\n\"aesgcm128\" to \"aesgcm\" as the value for the Content-Encoding header,\nas well as the parameter name in the Crypto-Key header.\n\nThis also affects the context used for deriving the nonce and the\ncontent encryption key. Examples have been updated.\n\nWhat I did not update is the JWE mapping (currently \"A128GCM\"). Do\nwe wish to change that to \"AGCM\", which may be less descriptive?\n",
      "createdAt": "2016-01-28T15:05:38Z",
      "updatedAt": "2016-02-14T03:59:09Z",
      "closedAt": "2016-02-14T03:58:15Z",
      "mergedAt": "2016-02-14T03:58:15Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "beverloo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson - for your consideration\n\nI updated the hashes, but would like you to verify those when you've got a moment (they include the uint8 -> uint16 change). I wasn't able to reproduce the output of the explicit example using the current spec.\n",
          "createdAt": "2016-01-28T15:06:43Z",
          "updatedAt": "2016-01-28T19:30:25Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Awesome.  I'm still awaiting the return of my implementation (I'm annoyed that I put it on a boat), but I will verify when able.  It's entirely possible that one (or more) of the examples are in error.\n",
          "createdAt": "2016-01-28T22:27:56Z",
          "updatedAt": "2016-01-28T22:27:56Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I still need to double-check the examples, but I won't be able to do that for a while now.  Stupid travel.  Might as well make progress at least.\n\nThanks for putting this all together @beverloo.\n",
          "createdAt": "2016-02-14T03:59:09Z",
          "updatedAt": "2016-02-14T03:59:09Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "98c1c756e853a7c5121e2989399a24ae6120973a",
      "headRepository": "beverloo/http-extensions",
      "headRefName": "aesgcm-without-128",
      "headRefOid": "b920f58b1f0058218c8a55a106f19aa8509e5c09",
      "mergeCommit": null
    },
    {
      "number": 142,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgzMDAwNzY=",
      "title": "type the artwork",
      "url": "https://github.com/httpwg/http-extensions/pull/142",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2016-02-04T15:14:48Z",
      "updatedAt": "2017-02-01T05:00:05Z",
      "closedAt": "2016-02-04T23:31:53Z",
      "mergedAt": "2016-02-04T23:31:53Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1dac3433d70c7257e19abd2ee1372fade3a97782",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "type-artwork",
      "headRefOid": "1aaad4a3e9014174dc88ee2b25c7d6957f7abe47",
      "mergeCommit": {
        "oid": "5b58038458afd8c8a9aa4bd17e87248a9e6dd3ac"
      }
    },
    {
      "number": 143,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg0ODcyMDQ=",
      "title": "type the artwork",
      "url": "https://github.com/httpwg/http-extensions/pull/143",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2016-02-05T21:31:29Z",
      "updatedAt": "2017-02-01T05:00:41Z",
      "closedAt": "2016-02-06T01:34:32Z",
      "mergedAt": "2016-02-06T01:34:32Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "44f1fad3fd4a85bec7cd713012dc8d3f3d36badb",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-2",
      "headRefOid": "0572159d86eb4f85a8698a95fbbda237a517bbd7",
      "mergeCommit": {
        "oid": "b3982e3376f0281666bf9e01e4bb092dcd57eba1"
      }
    },
    {
      "number": 146,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg1MTcxNDM=",
      "title": "type the artwork",
      "url": "https://github.com/httpwg/http-extensions/pull/146",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2016-02-06T10:15:19Z",
      "updatedAt": "2016-04-02T06:09:26Z",
      "closedAt": "2016-02-07T00:03:20Z",
      "mergedAt": "2016-02-07T00:03:20Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d532bf10ab226ce893d6b3575102517367d32ac8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-3",
      "headRefOid": "b3f4e1214e81cb942a2d7479fec57f19819222c9",
      "mergeCommit": {
        "oid": "6e2059219e8927d401dcf4de3768606bc7b4f75d"
      }
    },
    {
      "number": 147,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg1NDQ5OTU=",
      "title": "type the artwork",
      "url": "https://github.com/httpwg/http-extensions/pull/147",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2016-02-07T12:01:47Z",
      "updatedAt": "2016-04-02T06:09:22Z",
      "closedAt": "2016-02-07T20:56:51Z",
      "mergedAt": "2016-02-07T20:56:51Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "df0589cffe854dba2bc9cca212ef53d34568b001",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-4",
      "headRefOid": "99c1497cb3b1d1c409237389a77b6afe9f954c7b",
      "mergeCommit": null
    },
    {
      "number": 149,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA2MzMwMzI=",
      "title": "harmonize boilerplate",
      "url": "https://github.com/httpwg/http-extensions/pull/149",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2016-02-25T06:43:51Z",
      "updatedAt": "2016-04-02T06:09:20Z",
      "closedAt": "2016-03-01T10:23:11Z",
      "mergedAt": "2016-03-01T10:23:11Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e3e1ff6868e8eef86e0d529a8dd2f97a18daa870",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-6",
      "headRefOid": "b63ae2a8f02a6e60f994c2853c04547ca5ce5c2b",
      "mergeCommit": null
    },
    {
      "number": 150,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA2MzMwNTk=",
      "title": "harmonize boilerplate",
      "url": "https://github.com/httpwg/http-extensions/pull/150",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2016-02-25T06:44:16Z",
      "updatedAt": "2016-04-02T06:09:22Z",
      "closedAt": "2016-03-01T10:23:00Z",
      "mergedAt": "2016-03-01T10:23:00Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e3e1ff6868e8eef86e0d529a8dd2f97a18daa870",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-5",
      "headRefOid": "fc1b47c5247253510bbd27a9ec799549f6f8d06b",
      "mergeCommit": null
    },
    {
      "number": 151,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIwMjEzMDE=",
      "title": "Adding `commit` member to JSON",
      "url": "https://github.com/httpwg/http-extensions/pull/151",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2016-03-08T03:54:26Z",
      "updatedAt": "2016-03-11T03:32:47Z",
      "closedAt": "2016-03-11T03:32:37Z",
      "mergedAt": "2016-03-11T03:32:37Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And lo, relativism became ascendant.\n",
          "createdAt": "2016-03-08T05:44:15Z",
          "updatedAt": "2016-03-08T05:44:15Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "85f3b3231e177e7f52398144c1f02095ee2cf31f",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "http-tls-json",
      "headRefOid": "e28ac256450be09894ae3f355b8338c679ea2cb2",
      "mergeCommit": null
    },
    {
      "number": 152,
      "id": "MDExOlB1bGxSZXF1ZXN0NjIwMjE0MTk=",
      "title": "Wrap at 100",
      "url": "https://github.com/httpwg/http-extensions/pull/152",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2016-03-08T03:56:03Z",
      "updatedAt": "2016-03-17T00:54:24Z",
      "closedAt": "2016-03-17T00:54:22Z",
      "mergedAt": "2016-03-17T00:54:22Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3ac08cd35dc3000968cd3c0209e65a9258caecde",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "wrap",
      "headRefOid": "8746f505d24f6d1995dd278f398721fc6d23d3fb",
      "mergeCommit": null
    },
    {
      "number": 157,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI1MDMzNzM=",
      "title": "Refining the framing of the commitment",
      "url": "https://github.com/httpwg/http-extensions/pull/157",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Second round on this one, small tweaks and a small amount of restructuring.\n",
      "createdAt": "2016-03-11T06:35:47Z",
      "updatedAt": "2016-09-28T06:59:15Z",
      "closedAt": "2016-03-13T23:42:48Z",
      "mergedAt": "2016-03-13T23:42:48Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "LGTM, made a few smallish comments \n",
          "createdAt": "2016-03-11T07:00:23Z",
          "updatedAt": "2016-03-11T07:00:23Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ec90aa602a9d83142328427340cd4297093a009b",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "optional_commit",
      "headRefOid": "1c7ad691ba6e59884cd956ccf9738df25dadf35d",
      "mergeCommit": null
    },
    {
      "number": 158,
      "id": "MDExOlB1bGxSZXF1ZXN0NjI2OTkyMzI=",
      "title": "Updated encryption examples",
      "url": "https://github.com/httpwg/http-extensions/pull/158",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Thanks to @beverloo for identifying the bug in my code that caused this to take so long.\n",
      "createdAt": "2016-03-14T04:25:46Z",
      "updatedAt": "2016-09-28T06:59:13Z",
      "closedAt": "2016-03-17T00:57:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merged manually\n",
          "createdAt": "2016-03-17T00:57:12Z",
          "updatedAt": "2016-03-17T00:57:12Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "140756390ae9147fb016446ba31ca9122e14baaa",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "encex2",
      "headRefOid": "e0ca24ba8013f19dd7723ea19b7f350393e6a78d",
      "mergeCommit": null
    },
    {
      "number": 163,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ1NjEyOTE=",
      "title": "WIP: addressing CH feedback",
      "url": "https://github.com/httpwg/http-extensions/pull/163",
      "state": "MERGED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://lists.w3.org/Archives/Public/ietf-http-wg/2016JanMar/0519.html\n\nOutstanding issues:\n- [x] reference User-Agent header field definition\n- [x] reference cookie spec\n- [x] make \"proactive content negotiation [RFC7231]\" reference more specific\n- [ ] most of the \"this document uses...\" references do not seem to be used; cleanup.\n- [x]  drop \"common syntax\" leftover from previous drafts.\n- [x] make \"Vary\" reference more specific\n- [x] reference HTML spec\n- [x] include a reference to \"CSS px\"\n- [x] include a reference to \"layout viewport\"\n- [ ] clarify whether this is for user agents or all clients \n",
      "createdAt": "2016-03-30T01:58:03Z",
      "updatedAt": "2017-02-01T05:00:43Z",
      "closedAt": "2016-04-05T16:49:18Z",
      "mergedAt": "2016-04-05T16:49:18Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@reschke @mnot most of the remaining issues are references. Any tips or examples for how to reference W3C docs? Similarly, for Vary, how do I deeplink into the spec?\n",
          "createdAt": "2016-04-01T17:15:36Z",
          "updatedAt": "2016-04-01T17:15:36Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "W3C: try something like:\n\n informative:\n-  W3C.REC-html5-20141028:\n\nFor deep linking, I believe kramdown can't help. Just say \"Section xyz of [RFC....]\".\n",
          "createdAt": "2016-04-01T17:54:35Z",
          "updatedAt": "2016-04-01T17:54:35Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@reschke thanks, please review. I think I got most of the things fixed.\n",
          "createdAt": "2016-04-01T19:14:42Z",
          "updatedAt": "2016-04-01T19:14:42Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@mnot @reschke squashed. Please review and feel free to merge if it looks good.\n",
          "createdAt": "2016-04-04T16:53:33Z",
          "updatedAt": "2016-04-04T16:53:33Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looked at it; I think it improves many things so we can merge it (should I?); but there maybe a few more things to do (but we can do that as separate changes).\n",
          "createdAt": "2016-04-05T14:30:27Z",
          "updatedAt": "2016-04-05T14:30:27Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "+1 to merge and iterate, as it unblocks other work on this end.\n",
          "createdAt": "2016-04-05T16:48:50Z",
          "updatedAt": "2016-04-05T16:48:50Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d390fe0a872ccd08977d91f5bea88b0bd06a6d53",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ch-reschke",
      "headRefOid": "eff353b355354c8ba6573e2b50b521bc8198d308",
      "mergeCommit": {
        "oid": "f9f6c2f080af5f017fb26f8a862a3ff1104cdea3"
      }
    },
    {
      "number": 164,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ3MTk0MDU=",
      "title": "Julian's review",
      "url": "https://github.com/httpwg/http-extensions/pull/164",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think that I caught everything in the first round of discussion.  There aren't any substantial changes here, but it's a PR so that others can confirm.\n",
      "createdAt": "2016-03-31T00:41:33Z",
      "updatedAt": "2016-09-28T06:59:16Z",
      "closedAt": "2016-03-31T06:16:02Z",
      "mergedAt": "2016-03-31T06:16:02Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a1f0946b55c1924ac5afa4eb59a0fd600ea06980",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "julian_review",
      "headRefOid": "bae5514ee22f62150722c2f2ebc6c3419d0e974e",
      "mergeCommit": {
        "oid": "d354e60dfa0c80cbfe6cd1530eb0596e617cd744"
      }
    },
    {
      "number": 173,
      "id": "MDExOlB1bGxSZXF1ZXN0NjcxNzk5MjI=",
      "title": "fixing typo",
      "url": "https://github.com/httpwg/http-extensions/pull/173",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2016-04-20T12:44:55Z",
      "updatedAt": "2016-04-21T15:59:07Z",
      "closedAt": "2016-04-20T14:04:11Z",
      "mergedAt": "2016-04-20T14:04:11Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3d23813632c7e323507690a6d5a5fd38aadbf97a",
      "headRepository": "dret/http-extensions",
      "headRefName": "patch-1",
      "headRefOid": "442149362eee425cc4b261042d60c7469b8cad1c",
      "mergeCommit": {
        "oid": "4f50d26ce86809fcb479bccff9a11f9f4770677f"
      }
    },
    {
      "number": 175,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk0NTIxMzg=",
      "title": "Fix formatting",
      "url": "https://github.com/httpwg/http-extensions/pull/175",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "origin-frame"
      ],
      "body": "Putting the meat of the document in Section 1.2 was a bit odd.  Also, the fields descriptions were glommed together.\n",
      "createdAt": "2016-05-10T05:52:54Z",
      "updatedAt": "2016-05-10T06:55:52Z",
      "closedAt": "2016-05-10T06:01:40Z",
      "mergedAt": "2016-05-10T06:01:40Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Weird; didn't happen on local copies.\n",
          "createdAt": "2016-05-10T06:01:37Z",
          "updatedAt": "2016-05-10T06:01:37Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "cb8a0af5f9e88131f901601f601954dc8e8e98c0",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "resection_origin",
      "headRefOid": "e02d3433184e3b132a88b28501e8c29cdf55aea3",
      "mergeCommit": {
        "oid": "a4829e29d7b8e4caacfb384e4c14e39c9c5d61ec"
      }
    },
    {
      "number": 176,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk2NzA3OTE=",
      "title": "ORIGIN Frame Minor edits",
      "url": "https://github.com/httpwg/http-extensions/pull/176",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Some rather minor edits to the ORIGIN frame spec\n",
      "createdAt": "2016-05-11T13:22:05Z",
      "updatedAt": "2016-05-12T00:16:42Z",
      "closedAt": "2016-05-12T00:16:38Z",
      "mergedAt": "2016-05-12T00:16:38Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!\n",
          "createdAt": "2016-05-12T00:16:42Z",
          "updatedAt": "2016-05-12T00:16:42Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a9ce5e369ead68851b47ef4d98d0e6888a0e54f5",
      "headRepository": "LPardue/http-extensions",
      "headRefName": "minor-edits",
      "headRefOid": "799fdcb6e4439f3f9719f9c85c27def7facde69f",
      "mergeCommit": {
        "oid": "44bb967c45897866ebad18d844b9e748ec94853e"
      }
    },
    {
      "number": 179,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE0NzQ5NjA=",
      "title": "make Save-Data extensible",
      "url": "https://github.com/httpwg/http-extensions/pull/179",
      "state": "MERGED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "- only one \"on\" value is recognized today\n- allow parameters on token\n\nDiscussion: https://github.com/httpwg/http-extensions/issues/168\n\n@mnot @reschke can you please do a quick sanity check?\n",
      "createdAt": "2016-05-25T22:42:58Z",
      "updatedAt": "2017-02-01T05:00:44Z",
      "closedAt": "2016-05-31T14:27:16Z",
      "mergedAt": "2016-05-31T14:27:15Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@mnot thanks, updated! getting warmer? \n",
          "createdAt": "2016-05-26T04:29:22Z",
          "updatedAt": "2016-05-26T04:29:22Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Think so. @reschke is the Keeper of the ABNF, though.\n",
          "createdAt": "2016-05-26T04:39:15Z",
          "updatedAt": "2016-05-26T04:39:15Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@reschke @mnot thanks. Updated, do you want to do a last sanity check before I merge?     \n",
          "createdAt": "2016-05-27T15:46:56Z",
          "updatedAt": "2016-05-27T15:46:56Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me.\n",
          "createdAt": "2016-05-31T10:25:49Z",
          "updatedAt": "2016-05-31T10:25:49Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a7503aa6d9366654d561c49d989663ff75ff327a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "save-data-extensibility",
      "headRefOid": "ff50b829504738af5cf797e4e74a8c55744e588e",
      "mergeCommit": {
        "oid": "014b13c4952afc178d05527325b6586b0fe2d048"
      }
    },
    {
      "number": 180,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE5NTU0Njc=",
      "title": "Mike Bishop and Stefan Eissing need acknowledgment.",
      "url": "https://github.com/httpwg/http-extensions/pull/180",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "'specially Mike.\n",
      "createdAt": "2016-05-31T03:55:08Z",
      "updatedAt": "2016-09-28T06:59:18Z",
      "closedAt": "2016-05-31T04:04:54Z",
      "mergedAt": "2016-05-31T04:04:53Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5ac99d5ac8b002d84fb4e4c647c0378425f4c65d",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ackmike",
      "headRefOid": "cb7e090a7830ca9f75603ac14781f530aa90e130",
      "mergeCommit": {
        "oid": "47be7c298fdb7af1559677f81818cacfe51d3746"
      }
    },
    {
      "number": 181,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE5NTU3NjA=",
      "title": "Commitment might exceed the freshness lifetime",
      "url": "https://github.com/httpwg/http-extensions/pull/181",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "We make this decision explicitly, and we don't want to imply that just because you don't have a fresh \"http-opportunistic\" resource, any commitment is shortened as a result (which is a reasonable interpretation based on the current text).\n",
      "createdAt": "2016-05-31T04:01:13Z",
      "updatedAt": "2016-09-28T06:59:19Z",
      "closedAt": "2016-05-31T04:04:22Z",
      "mergedAt": "2016-05-31T04:04:22Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5ac99d5ac8b002d84fb4e4c647c0378425f4c65d",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "expires_and_opsec",
      "headRefOid": "54a349b4686d0c1dc8637f265bff29c44ab0f9c8",
      "mergeCommit": {
        "oid": "e9329ca6ac220472454ec935312b2959ad0a6f85"
      }
    },
    {
      "number": 183,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE5NTU5Mjg=",
      "title": "Use monospace for span.tt",
      "url": "https://github.com/httpwg/http-extensions/pull/183",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #182.  Maybe.\n",
      "createdAt": "2016-05-31T04:04:23Z",
      "updatedAt": "2016-09-28T06:59:21Z",
      "closedAt": "2016-06-30T01:39:36Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e9329ca6ac220472454ec935312b2959ad0a6f85",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "spantt",
      "headRefOid": "7e7737a9e10d515ba9982fdb385bd5dd7730ff1f",
      "mergeCommit": null
    },
    {
      "number": 190,
      "id": "MDExOlB1bGxSZXF1ZXN0NzIyNTM3OTU=",
      "title": "Address feedback on client-hints-01 draft",
      "url": "https://github.com/httpwg/http-extensions/pull/190",
      "state": "MERGED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "WIP.\n",
      "createdAt": "2016-06-01T21:17:05Z",
      "updatedAt": "2017-02-01T05:00:44Z",
      "closedAt": "2016-06-07T16:54:24Z",
      "mergedAt": "2016-06-07T16:54:24Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@mnot @reschke quick once over before I merge?\n",
          "createdAt": "2016-06-07T15:37:06Z",
          "updatedAt": "2016-06-07T15:37:06Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@reschke thanks, updated, squashed.. merging.\n",
          "createdAt": "2016-06-07T16:53:54Z",
          "updatedAt": "2016-06-07T16:53:54Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d9b55616e100f6043d1f959f6a48f5c8810a3616",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ch-feedback",
      "headRefOid": "075fd54c4c180110973306a0d172e36ee7b18880",
      "mergeCommit": {
        "oid": "a92837f7764df4e54dc10ed4e0ffe6da42f41001"
      }
    },
    {
      "number": 193,
      "id": "MDExOlB1bGxSZXF1ZXN0NzI0NTEzNzY=",
      "title": "A commitment, once made, requires both reasonable assurances and stro\u2026",
      "url": "https://github.com/httpwg/http-extensions/pull/193",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026ng authentication\n\nCloses #191 if Erik is cool with it.\n",
      "createdAt": "2016-06-03T04:07:06Z",
      "updatedAt": "2016-09-28T06:59:22Z",
      "closedAt": "2016-06-21T02:31:51Z",
      "mergedAt": "2016-06-21T02:31:50Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@enygren?\n",
          "createdAt": "2016-06-07T03:21:27Z",
          "updatedAt": "2016-06-07T03:21:27Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "ETIMEDOUT\n\n@enygren, if you object please reopen.\n",
          "createdAt": "2016-06-21T02:30:51Z",
          "updatedAt": "2016-06-21T02:30:51Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "def47ada8377032e314c75533df578818e3943b4",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "strong_auth_commit",
      "headRefOid": "6da54e5b1559efef213141b41e97d4ad13d0bd2d",
      "mergeCommit": {
        "oid": "6e343b3ed058c3400f841480b9c40282364db768"
      }
    },
    {
      "number": 196,
      "id": "MDExOlB1bGxSZXF1ZXN0NzI5Nzk0MzY=",
      "title": "PHK's keyid changes",
      "url": "https://github.com/httpwg/http-extensions/pull/196",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A few improvements, I hope.\n",
      "createdAt": "2016-06-08T02:51:04Z",
      "updatedAt": "2016-06-22T06:30:41Z",
      "closedAt": "2016-06-22T06:30:40Z",
      "mergedAt": "2016-06-22T06:30:40Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a92837f7764df4e54dc10ed4e0ffe6da42f41001",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "phk_keyid",
      "headRefOid": "d6c77f440a97f80f827a61ba28fc38344486e24f",
      "mergeCommit": {
        "oid": "ec46d20bf7991657092e3cbf5969683adbef7428"
      }
    },
    {
      "number": 197,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMwMTQwNzc=",
      "title": "Adding OWS",
      "url": "https://github.com/httpwg/http-extensions/pull/197",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #194\n",
      "createdAt": "2016-06-08T09:32:54Z",
      "updatedAt": "2016-06-22T06:28:42Z",
      "closedAt": "2016-06-22T06:28:40Z",
      "mergedAt": "2016-06-22T06:28:40Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d38d10dceec3889a7b61676fa4a30f1a61ad6296",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ows_ftl",
      "headRefOid": "581f9da3b97d171cc2a1929687332810929f7885",
      "mergeCommit": {
        "oid": "fa70f67b7b0c76c3dc6e6f8df3824df836bc501c"
      }
    },
    {
      "number": 198,
      "id": "MDExOlB1bGxSZXF1ZXN0NzMwMTQyODY=",
      "title": "Oops in the intro paragraph.",
      "url": "https://github.com/httpwg/http-extensions/pull/198",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #195\n",
      "createdAt": "2016-06-08T09:34:10Z",
      "updatedAt": "2016-06-22T06:28:20Z",
      "closedAt": "2016-06-22T03:47:32Z",
      "mergedAt": "2016-06-22T03:47:32Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d38d10dceec3889a7b61676fa4a30f1a61ad6296",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "aesgcm_registration",
      "headRefOid": "54eaef674550faab05dc28734845b23b44d24754",
      "mergeCommit": {
        "oid": "f648829ff5c53d87d08d2764cd46fffd6838356b"
      }
    },
    {
      "number": 202,
      "id": "MDExOlB1bGxSZXF1ZXN0NzQ3MjAxODE=",
      "title": "Magnus review encryption",
      "url": "https://github.com/httpwg/http-extensions/pull/202",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Updates based on Magnus Westerlund's review.\n",
      "createdAt": "2016-06-22T03:46:41Z",
      "updatedAt": "2016-06-27T06:44:36Z",
      "closedAt": "2016-06-27T06:44:33Z",
      "mergedAt": "2016-06-27T06:44:33Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "263db30abb6f0f0b5a0cc3c2c3424108b3c171bc",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "magnus_review_encryption",
      "headRefOid": "f1a20672e6c31003dd79500cdd7698c077df595c",
      "mergeCommit": {
        "oid": "103edc3517b5a15547f1cfea78920a82ebd4c290"
      }
    },
    {
      "number": 203,
      "id": "MDExOlB1bGxSZXF1ZXN0NzUyMzQ3Njk=",
      "title": "typo fix",
      "url": "https://github.com/httpwg/http-extensions/pull/203",
      "state": "MERGED",
      "author": "ePaul",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\"The record starts and ends on multiples of the record size\" sounds like a tautology.\n",
      "createdAt": "2016-06-26T17:01:45Z",
      "updatedAt": "2016-06-27T02:07:25Z",
      "closedAt": "2016-06-27T02:07:25Z",
      "mergedAt": "2016-06-27T02:07:25Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "09a90f9d8c3bc90fd70340927a3c809a2ef8e365",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "2f99d3d6fbca72b1032b60703a780893cf19f9dd",
      "mergeCommit": {
        "oid": "f654dd7ac1f2cb64f5ade96cf56553617416b6e8"
      }
    },
    {
      "number": 205,
      "id": "MDExOlB1bGxSZXF1ZXN0NzU3NDY4MTY=",
      "title": "Provide rules for handling duplicate keys",
      "url": "https://github.com/httpwg/http-extensions/pull/205",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "Raised on list by Kari Hurtta.  Option 6.\n",
      "createdAt": "2016-06-30T01:16:43Z",
      "updatedAt": "2017-02-01T05:00:33Z",
      "closedAt": "2016-11-21T02:13:28Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This has been OBE.",
          "createdAt": "2016-11-21T02:13:28Z",
          "updatedAt": "2016-11-21T02:13:28Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "103edc3517b5a15547f1cfea78920a82ebd4c290",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "duplicate_keys",
      "headRefOid": "4cfbeba2412caceb5e12e32c1ed61dde884f4d35",
      "mergeCommit": null
    },
    {
      "number": 206,
      "id": "MDExOlB1bGxSZXF1ZXN0NzU3NDY4Nzk=",
      "title": "Edits for Kari",
      "url": "https://github.com/httpwg/http-extensions/pull/206",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "Kari raised several concerns on-list.  They seem like editorial things.\n",
      "createdAt": "2016-06-30T01:17:39Z",
      "updatedAt": "2017-02-01T05:00:32Z",
      "closedAt": "2016-10-11T06:22:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Overtaken by...\n",
          "createdAt": "2016-10-11T06:22:29Z",
          "updatedAt": "2016-10-11T06:22:29Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "103edc3517b5a15547f1cfea78920a82ebd4c290",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "kari",
      "headRefOid": "ebcacaae58c7c5b7d17a5f1af309dbb283c23d0c",
      "mergeCommit": null
    },
    {
      "number": 207,
      "id": "MDExOlB1bGxSZXF1ZXN0NzU3NDc0MzE=",
      "title": "Making tls-commit and tls-ports mutually exclusive",
      "url": "https://github.com/httpwg/http-extensions/pull/207",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "This probably isn't the end of this issue though.  We require that an opportunistic upgrade uses the same hostname.  The text I added here lifts the requirement regarding port numbers, but should it also say that the hostname needs to remain the same?\n\nI've left this open here, but I think that we probably should leave the hostname requirement in place.  That way, we still retain some of the aspects of http:// authority.\n",
      "createdAt": "2016-06-30T01:25:48Z",
      "updatedAt": "2016-09-28T07:06:55Z",
      "closedAt": "2016-09-28T06:50:14Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I disagree.  As soon as you're fully authenticating the TLS certificate, you're doing vanilla Alt-Svc and this draft could be totally out of the picture.  The only thing you're gaining from the http-opportunistic resource is a commitment that the TLS Alt-Svc will remain available and a suggestion that the client refuse to fall back to the plain-text origin.  I don't see that same-host plays into that.\n\nAlternately phrased -- what about the alternative being on a different host implies the origin should _not_ be able to make a commitment that it will remain available?\n",
          "createdAt": "2016-07-01T22:53:14Z",
          "updatedAt": "2016-07-01T22:53:14Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry about being so slow, but @MikeBishop, if I understand what you are implying, you are suggesting that we should remove the host restriction if the certificate fits.  I was thinking about a client using the process we outline in the draft to arrive at such a host, which isn't really possible.  \n\nHowever, I guess we have to accept that a client might learn of this resource from an HTTPS connection to some other host (maybe because of connection coalescing).  In which case, then I find that I agree.  Some more careful words needed, I guess.\n",
          "createdAt": "2016-07-11T07:12:24Z",
          "updatedAt": "2016-07-11T07:12:24Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that this has been OBE.\n",
          "createdAt": "2016-09-28T06:50:14Z",
          "updatedAt": "2016-09-28T06:50:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Ah, sorry - forgot to look at the pulls.\n",
          "createdAt": "2016-09-28T07:06:55Z",
          "updatedAt": "2016-09-28T07:06:55Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "103edc3517b5a15547f1cfea78920a82ebd4c290",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "commit_ports",
      "headRefOid": "6ba3961ff8ee862a473bbd92070502c5ad9b5843",
      "mergeCommit": null
    },
    {
      "number": 209,
      "id": "MDExOlB1bGxSZXF1ZXN0NzYwNDUxNzY=",
      "title": "Subject-verb agreement",
      "url": "https://github.com/httpwg/http-extensions/pull/209",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The key phrase is \"Serving ... requires\", not \"URIs require\".\n",
      "createdAt": "2016-07-01T22:43:05Z",
      "updatedAt": "2016-07-06T09:40:48Z",
      "closedAt": "2016-07-06T09:40:48Z",
      "mergedAt": "2016-07-06T09:40:48Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "103edc3517b5a15547f1cfea78920a82ebd4c290",
      "headRepository": "MikeBishop/http-extensions",
      "headRefName": "patch-4",
      "headRefOid": "d4fe9e2072dff83700d5a277c7ea49e529668e32",
      "mergeCommit": {
        "oid": "ba55e437d6538c23b409a8a48945c4519f0c24a4"
      }
    },
    {
      "number": 210,
      "id": "MDExOlB1bGxSZXF1ZXN0NzYzMDU1MjA=",
      "title": "feat: Add an example of a composite Crypto-Key header",
      "url": "https://github.com/httpwg/http-extensions/pull/210",
      "state": "CLOSED",
      "author": "jrconlin",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "encryption"
      ],
      "body": "Crypto-Key is a composite data field. Curretly both draft ECE and draft\nVAPID use Crypto-Key to store information. This has lead to some\nconfusion regarding how data should be stored and accessed.\n",
      "createdAt": "2016-07-05T16:41:44Z",
      "updatedAt": "2016-12-22T03:35:09Z",
      "closedAt": "2016-12-22T03:35:09Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Redundant with the removal of said header.",
          "createdAt": "2016-12-22T03:35:09Z",
          "updatedAt": "2016-12-22T03:35:09Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "103edc3517b5a15547f1cfea78920a82ebd4c290",
      "headRepository": "jrconlin/http-extensions",
      "headRefName": "feat/example",
      "headRefOid": "ba0663263b1e31b91fd5479b0f1d749a099838a6",
      "mergeCommit": null
    },
    {
      "number": 211,
      "id": "MDExOlB1bGxSZXF1ZXN0NzY3OTIyNzI=",
      "title": "Opp-Sec Shepherd Write-up",
      "url": "https://github.com/httpwg/http-extensions/pull/211",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "After much dancing to avoid sending you tens of \"merging httpwg/master\" commits....\n",
      "createdAt": "2016-07-08T18:14:30Z",
      "updatedAt": "2016-07-08T22:42:52Z",
      "closedAt": "2016-07-08T22:42:16Z",
      "mergedAt": "2016-07-08T22:42:16Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!\n",
          "createdAt": "2016-07-08T22:42:52Z",
          "updatedAt": "2016-07-08T22:42:52Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "99cce0cc28c24d70f58b692eaf45dd24e95d3bf4",
      "headRepository": "MikeBishop/http-extensions",
      "headRefName": "master",
      "headRefOid": "40d8cd877d862dbeec51213dcc5c95a4144440ed",
      "mergeCommit": {
        "oid": "6a05e2c4ad403ff90c69420c413ad8ee229e04c7"
      }
    },
    {
      "number": 218,
      "id": "MDExOlB1bGxSZXF1ZXN0ODAwMDY2MTM=",
      "title": "Remove DH",
      "url": "https://github.com/httpwg/http-extensions/pull/218",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "encryption"
      ],
      "body": "This is only really needed by webpush and that spec can take the necessary pieces.  This is a LOT simpler as a result of this change.\n\n[Preview the changes](http://httpwg.org/http-extensions/simple_base/draft-ietf-httpbis-encryption-encoding.html).\n",
      "createdAt": "2016-08-04T01:45:15Z",
      "updatedAt": "2016-09-28T06:58:45Z",
      "closedAt": "2016-09-28T06:58:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Manually rebased and merged.\n",
          "createdAt": "2016-09-28T06:58:34Z",
          "updatedAt": "2016-09-28T06:58:34Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5733c371c31af0dbaabf5377d768280253122cd3",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "simple_base",
      "headRefOid": "128e946d1f09da08ab6fffcd2ac3c84ac16081ce",
      "mergeCommit": null
    },
    {
      "number": 221,
      "id": "MDExOlB1bGxSZXF1ZXN0ODA2NTI5Nzk=",
      "title": "Explicitly note case-sensitivity of prefix",
      "url": "https://github.com/httpwg/http-extensions/pull/221",
      "state": "CLOSED",
      "author": "ericlaw1979",
      "authorAssociation": "NONE",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "As cookie attributes are case-insensitive, I think it makes sense to explicitly call out case-sensitivity of prefixes.\n",
      "createdAt": "2016-08-09T16:33:59Z",
      "updatedAt": "2017-05-05T12:37:35Z",
      "closedAt": "2017-05-05T12:37:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I pulled this into https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-01#section-5.3 (steps 13 and 14). Thanks!",
          "createdAt": "2017-05-05T12:37:35Z",
          "updatedAt": "2017-05-05T12:37:35Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5733c371c31af0dbaabf5377d768280253122cd3",
      "headRepository": "ericlaw1979/http-extensions",
      "headRefName": "patch-1",
      "headRefOid": "d3918736714eff90aab80e474eabac06eed0cc63",
      "mergeCommit": null
    },
    {
      "number": 237,
      "id": "MDExOlB1bGxSZXF1ZXN0ODY5MjY2Mzg=",
      "title": "type the artwork",
      "url": "https://github.com/httpwg/http-extensions/pull/237",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2016-09-27T13:11:32Z",
      "updatedAt": "2016-09-28T06:23:10Z",
      "closedAt": "2016-09-28T06:23:08Z",
      "mergedAt": "2016-09-28T06:23:08Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ede46f9203e06b607692852fb1685f2d4453684d",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "artwork-typing",
      "headRefOid": "6d00eb8e199e498e5b1a9418da74990abd76ad2d",
      "mergeCommit": {
        "oid": "6e059e1ff75e808b20f06baa2f82f3846ad37373"
      }
    },
    {
      "number": 239,
      "id": "MDExOlB1bGxSZXF1ZXN0ODg0MjI2NzY=",
      "title": "update reference to CR-css-values-3",
      "url": "https://github.com/httpwg/http-extensions/pull/239",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "",
      "createdAt": "2016-10-07T11:32:37Z",
      "updatedAt": "2017-02-01T05:00:46Z",
      "closedAt": "2016-12-02T18:05:15Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "If memory serves, we froze older version due to build errors.. and it appears that this is still the case based on Travis results.\n",
          "createdAt": "2016-10-07T18:38:52Z",
          "updatedAt": "2016-10-07T18:38:52Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@reschke I'm inclined to close this as wontfix.. since this breaks the build and I'm not sure how to work around it.",
          "createdAt": "2016-11-23T18:30:43Z",
          "updatedAt": "2016-11-23T18:30:43Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5ec7eed4fa2c941a34e868117ef2fb634d8d506e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "css-values-reference",
      "headRefOid": "21a86d852bd041ec535c207f3428662f118f8974",
      "mergeCommit": null
    },
    {
      "number": 240,
      "id": "MDExOlB1bGxSZXF1ZXN0ODg0MjI4NTk=",
      "title": "netinfo isn't a dated document, so do not pretend it is",
      "url": "https://github.com/httpwg/http-extensions/pull/240",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2016-10-07T11:34:13Z",
      "updatedAt": "2017-02-01T05:00:47Z",
      "closedAt": "2016-10-07T15:07:23Z",
      "mergedAt": "2016-10-07T15:07:23Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Thanks @reschke!\n",
          "createdAt": "2016-10-07T15:07:33Z",
          "updatedAt": "2016-10-07T15:07:33Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5ec7eed4fa2c941a34e868117ef2fb634d8d506e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "netinfo-date",
      "headRefOid": "2e8b673934bb519b662d86ad88a24942b33c7f10",
      "mergeCommit": {
        "oid": "7f14eeb1301e959bfa2e2f1285e9b867dba6160c"
      }
    },
    {
      "number": 241,
      "id": "MDExOlB1bGxSZXF1ZXN0ODg0MjUxNzE=",
      "title": "consistency in IANA considerations",
      "url": "https://github.com/httpwg/http-extensions/pull/241",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "",
      "createdAt": "2016-10-07T11:54:15Z",
      "updatedAt": "2017-02-01T05:00:48Z",
      "closedAt": "2016-11-23T18:29:50Z",
      "mergedAt": "2016-11-23T18:29:50Z",
      "mergedBy": "igrigorik",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5ec7eed4fa2c941a34e868117ef2fb634d8d506e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "consistency-IANA",
      "headRefOid": "68dcb16ea6ee13b93763fc6aa62c2d5bb42b287c",
      "mergeCommit": {
        "oid": "d7aa5f8346ce2bdec8528b457be8f0c197fda629"
      }
    },
    {
      "number": 242,
      "id": "MDExOlB1bGxSZXF1ZXN0ODg2MTMzMTc=",
      "title": "The \"mixed-scheme\" field is probably needed when you make any request\u2026",
      "url": "https://github.com/httpwg/http-extensions/pull/242",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "\u2026 over a connection that might be used for \"https\" resources.  After all, ordering of request in \"h2\" is\nsomewhat nebulous.\n\nAs discussed on-list.\n",
      "createdAt": "2016-10-10T06:09:24Z",
      "updatedAt": "2017-02-01T05:00:31Z",
      "closedAt": "2016-11-21T02:11:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This one has been OBE.",
          "createdAt": "2016-11-21T02:11:31Z",
          "updatedAt": "2016-11-21T02:11:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0Nzc0Ng==",
          "commit": {
            "abbreviatedOid": "f98d9d6"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2016-10-10T06:18:12Z",
          "updatedAt": "2016-10-10T06:18:51Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "... MUST NOT `http`?\n",
              "createdAt": "2016-10-10T06:18:12Z",
              "updatedAt": "2016-10-12T00:37:53Z"
            },
            {
              "originalPosition": 7,
              "body": "\"would ordinarily be used\" is really wooly...\n",
              "createdAt": "2016-10-10T06:18:42Z",
              "updatedAt": "2016-10-12T00:37:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MTU4Ng==",
          "commit": {
            "abbreviatedOid": "f98d9d6"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2016-10-12T00:38:09Z",
          "updatedAt": "2016-10-12T00:38:09Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I will try again, hopefully with less ineptitude.\n",
              "createdAt": "2016-10-12T00:38:09Z",
              "updatedAt": "2016-10-12T00:38:09Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7f14eeb1301e959bfa2e2f1285e9b867dba6160c",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reuse_mixed_scheme",
      "headRefOid": "f085c6c2b02bd8d11b710330dc8771b32ff937f2",
      "mergeCommit": null
    },
    {
      "number": 244,
      "id": "MDExOlB1bGxSZXF1ZXN0ODg3OTk5NzY=",
      "title": "incorrect IPR",
      "url": "https://github.com/httpwg/http-extensions/pull/244",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "we can't change the IPR clause from RFC 6265\n",
      "createdAt": "2016-10-11T09:34:46Z",
      "updatedAt": "2017-12-13T07:17:17Z",
      "closedAt": "2017-02-07T05:29:26Z",
      "mergedAt": "2017-02-07T05:29:26Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "48917f5fe152ddaba4bb4aeab29d946bf7fc1cc5",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "rfc6265-ipr",
      "headRefOid": "a7a54098dbe5d02db5da4caf51db9c95ad2a505a",
      "mergeCommit": {
        "oid": "2006f7d446acc7a03100bb90244aed30a0d9f56d"
      }
    },
    {
      "number": 249,
      "id": "MDExOlB1bGxSZXF1ZXN0ODk5Mzk0MjU=",
      "title": "Julian ec review",
      "url": "https://github.com/httpwg/http-extensions/pull/249",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "encryption"
      ],
      "body": "I think that these are all editorial.\n",
      "createdAt": "2016-10-19T04:12:16Z",
      "updatedAt": "2016-11-01T05:48:45Z",
      "closedAt": "2016-11-01T05:46:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merged manually.\n",
          "createdAt": "2016-11-01T05:46:30Z",
          "updatedAt": "2016-11-01T05:46:30Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5c805c8fd66bb4c22fa4f86d4424cbfc50378f6c",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "julian_ec_review",
      "headRefOid": "67b65dfdc7877f819463af89c8203a41cbc1d67c",
      "mergeCommit": null
    },
    {
      "number": 250,
      "id": "MDExOlB1bGxSZXF1ZXN0OTAxMDUxMDk=",
      "title": "clarify Accept-CH",
      "url": "https://github.com/httpwg/http-extensions/pull/250",
      "state": "MERGED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "See\nhttps://lists.w3.org/Archives/Public/ietf-http-wg/2016OctDec/0146.html\n\n@reschke ptal. \n",
      "createdAt": "2016-10-19T22:48:48Z",
      "updatedAt": "2017-02-01T05:00:49Z",
      "closedAt": "2016-10-20T06:17:36Z",
      "mergedAt": "2016-10-20T06:17:36Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good to me.\n",
          "createdAt": "2016-10-20T05:56:19Z",
          "updatedAt": "2016-10-20T05:56:19Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Thanks!\n",
          "createdAt": "2016-10-20T06:17:43Z",
          "updatedAt": "2016-10-20T06:17:43Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5c805c8fd66bb4c22fa4f86d4424cbfc50378f6c",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "clarify-accept-ch",
      "headRefOid": "dd86b55e6d2d522a2779f67b487b270ffbba4ec0",
      "mergeCommit": {
        "oid": "dea2f2c57e72ab8b4eba85a8f6894a61d011ebbd"
      }
    },
    {
      "number": 252,
      "id": "MDExOlB1bGxSZXF1ZXN0OTE0ODYxODg=",
      "title": "Remove Encryption header field",
      "url": "https://github.com/httpwg/http-extensions/pull/252",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "encryption"
      ],
      "body": "This moves the values that were in the Encryption header field to\nthe start of the payload.  This provides a meagre efficiency gain\nas well as removing the need to have two correlated header fields.\n\nThis should go most of the way to address WGLC comments.\n",
      "createdAt": "2016-10-29T11:12:23Z",
      "updatedAt": "2016-11-01T05:44:57Z",
      "closedAt": "2016-11-01T05:44:53Z",
      "mergedAt": "2016-11-01T05:44:53Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me in general.\n\nThat said; this removes the parsing weirdness for \"Encryption\" (good), but not for \"Crypto-Key\", right?\n",
          "createdAt": "2016-10-30T07:54:21Z",
          "updatedAt": "2016-10-30T10:31:19Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke happy to correct any parsing weirdness, but need to know precisely what it is first.\n",
          "createdAt": "2016-10-30T23:55:12Z",
          "updatedAt": "2016-10-30T23:55:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjM2MTQ1Ng==",
          "commit": {
            "abbreviatedOid": "3e35d46"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2016-10-30T10:29:33Z",
          "updatedAt": "2016-10-30T10:29:34Z",
          "comments": [
            {
              "originalPosition": 244,
              "body": "\"header field\" -> \"header block\"?\n",
              "createdAt": "2016-10-30T10:29:33Z",
              "updatedAt": "2016-10-30T23:54:00Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f2b5026cab0054d5ff2ad776e37002ffd4e9e36c",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "flatten_enc",
      "headRefOid": "00091e7b7b75a9feffe6b8dc76c65a79834cfa1f",
      "mergeCommit": {
        "oid": "0b0a56e56b395ffc92c07681f1df88aba9451847"
      }
    },
    {
      "number": 254,
      "id": "MDExOlB1bGxSZXF1ZXN0OTE1NDQ2NTU=",
      "title": "Simplify opportunistic encryption",
      "url": "https://github.com/httpwg/http-extensions/pull/254",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "We've been circling an answer to this for a while.  The entire gamut of possible solutions is broad, and we haven't had much luck in reaching clarity here.\n\nOne the one end of the scale, it should be perfectly OK to send a request for an `http` origin over an authenticated TLS connection.  But we still have the (entirely legitimate) concern there is that some servers might get themselves confused by this.\n\nThe other end of the scale is the bells and whistles JSON stuff.  @mcmanus seemed OK with this based on his implementation experience, but it is a little complicated.  We found too many corner cases for me to be happy that it implementations wouldn't end up busted.  And now that we insist on authentication for the server, many of the features didn't make sense.\n\nWe've also considered an HTTP/2 setting.  That's appealing, but it does limit the applicability a little.\n## This proposal\n\nThis change aims more to the conservative end of that scale.  It keeps the `/.well-known/` resource, but simplifies it, reducing it to a flat list of origins.  The client only needs to acquire this from the authenticated server.\n\nThis doesn't defend against Alt-Svc attacks mounted by attackers with the ability to both send header fields and run an authenticated server, but we're in a very strange place if this is the sort of capabilities we ascribe to our attackers in our threat models.\n## Other changes\n\nI've explicitly added `http/1.1` here.  I believe that's reflective of consensus, but that part is easy to revert.\n\nThe text about client certificates is now clearer.\n",
      "createdAt": "2016-10-31T01:00:24Z",
      "updatedAt": "2016-11-01T05:44:32Z",
      "closedAt": "2016-11-01T05:44:29Z",
      "mergedAt": "2016-11-01T05:44:29Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4a819685d7afcdb7930e69f8198a9bdb1e3c3c6b",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "opsec_simple",
      "headRefOid": "63988a353d93e0e6b6932c66d28e53da5184a2c8",
      "mergeCommit": {
        "oid": "80ce7618e857bc43819bdddf06ae984390f1f070"
      }
    },
    {
      "number": 257,
      "id": "MDExOlB1bGxSZXF1ZXN0OTE3MzUzMDQ=",
      "title": "Try to explain and justify the use of the absolute form in HTTP/1.1",
      "url": "https://github.com/httpwg/http-extensions/pull/257",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "Based on the discussion on-list, the requirement to use the absolute form is a little hard.  This tries to justify it on the basis that the secure server is acting as a proxy.  Maybe that's dishonest, but I think that it's accurate.  I would rather finagle this than have an experimental document update a standards-track one.",
      "createdAt": "2016-11-01T05:52:24Z",
      "updatedAt": "2017-02-01T05:00:24Z",
      "closedAt": "2016-11-03T04:12:42Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc2MjkzMA==",
          "commit": {
            "abbreviatedOid": "5c60483"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2016-11-02T07:57:00Z",
          "updatedAt": "2016-11-02T07:57:00Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I don't think this is going to pass the sniff test unless we update 7230. \n\nHow will this transit a proxy -- aren't you requiring reverse proxies et al to change their behaviour? \n\nIt's also not at all clear that this information will be made available to applications.\n",
              "createdAt": "2016-11-02T07:57:00Z",
              "updatedAt": "2016-11-02T07:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyNzgxNQ==",
          "commit": {
            "abbreviatedOid": "5c60483"
          },
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2016-11-02T14:41:48Z",
          "updatedAt": "2016-11-02T14:41:49Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I really do think its fine to abandon h1 for this. The core difference between h1 and h2 is at the transport level and this is a transport level feature.\n",
              "createdAt": "2016-11-02T14:41:49Z",
              "updatedAt": "2016-11-02T14:41:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk0ODQ1OQ==",
          "commit": {
            "abbreviatedOid": "5c60483"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2016-11-03T03:55:17Z",
          "updatedAt": "2016-11-03T03:55:17Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "OK, I tried :)  So what is our rationale for excluding h1?  That it doesn't carry an explicit scheme?\n",
              "createdAt": "2016-11-03T03:55:17Z",
              "updatedAt": "2016-11-03T03:55:17Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "0b0a56e56b395ffc92c07681f1df88aba9451847",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "violate_7230",
      "headRefOid": "5c604831c8dc203c763a78d13d68ab62715ea1eb",
      "mergeCommit": null
    },
    {
      "number": 258,
      "id": "MDExOlB1bGxSZXF1ZXN0OTE3NjE1MjM=",
      "title": "remove bogus \"!\"",
      "url": "https://github.com/httpwg/http-extensions/pull/258",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "it leads to kramdown warnings (\"overwriting RFC....\").",
      "createdAt": "2016-11-01T10:31:39Z",
      "updatedAt": "2017-02-01T05:01:07Z",
      "closedAt": "2016-11-01T12:24:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "might not be a warning after all...\n",
          "createdAt": "2016-11-01T12:24:34Z",
          "updatedAt": "2016-11-01T12:24:34Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke, there are two ways to add references in the kramdown variant of markdown.  Adding \"x\" to the appropriate references block and then using `{{x}}`, OR using `{{?x}}` (informative) or `{{!x}}` (normative).\n\nThe warning comes about because the references block already contains \"x\", or because the reference is being used inconsistently (mixing styles is bad).\n",
          "createdAt": "2016-11-02T03:25:19Z",
          "updatedAt": "2016-11-02T03:25:19Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3c624387f6c94ba1f1acd1432cb85e54a2a9e7e8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "kramdown-warning",
      "headRefOid": "b3efc6c43e0529dde55816c476df7c0db2f593f9",
      "mergeCommit": null
    },
    {
      "number": 259,
      "id": "MDExOlB1bGxSZXF1ZXN0OTE4OTM2ODc=",
      "title": "Fix examples",
      "url": "https://github.com/httpwg/http-extensions/pull/259",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "encryption"
      ],
      "body": "Somehow I managed to mess up the examples royally.  They were kinda valid, but the rs and id fields didn't match the rest of the example.",
      "createdAt": "2016-11-02T01:13:44Z",
      "updatedAt": "2016-11-15T05:20:37Z",
      "closedAt": "2016-11-15T04:45:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Works for me (see https://gist.github.com/reschke/46659c912b426dffeac41d9a21421c95)\n",
          "createdAt": "2016-11-02T13:47:56Z",
          "updatedAt": "2016-11-02T13:47:56Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Superceded by other changes.\n",
          "createdAt": "2016-11-15T04:45:31Z",
          "updatedAt": "2016-11-15T04:45:31Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3c624387f6c94ba1f1acd1432cb85e54a2a9e7e8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "fix_example",
      "headRefOid": "4cd62c9fb0b6a99adeac72afc006fec7df833075",
      "mergeCommit": null
    },
    {
      "number": 261,
      "id": "MDExOlB1bGxSZXF1ZXN0OTE5OTQ3MjA=",
      "title": "https origins are no longer relevant for http-opportunistic resources",
      "url": "https://github.com/httpwg/http-extensions/pull/261",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "",
      "createdAt": "2016-11-02T15:36:08Z",
      "updatedAt": "2016-11-21T02:10:56Z",
      "closedAt": "2016-11-21T02:10:54Z",
      "mergedAt": "2016-11-21T02:10:54Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e67b5b8ac2cc5ccc0ff78dd67a5f7ba6c414fad6",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "https_nonsense",
      "headRefOid": "dc24113b22b545ba112ebbc707b38ef3396c9f8a",
      "mergeCommit": {
        "oid": "a44bea940c746d8a75d4a51ff915bc32ec9cae00"
      }
    },
    {
      "number": 262,
      "id": "MDExOlB1bGxSZXF1ZXN0OTIwOTU0NDA=",
      "title": "Exclude HTTP/1.1",
      "url": "https://github.com/httpwg/http-extensions/pull/262",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "I tried to make this work, but @mcmanus is right: this is entirely a transport decision and given that our best option was to violate a MUST in RFC 7230, that's too hard.  This just says that HTTP/1.1 is no good because we can't include the scheme (because RFC 7230 says we can't).  I almost made this h2-specific, but then remembered that there might be another protocol that has favourable properties.",
      "createdAt": "2016-11-03T04:28:33Z",
      "updatedAt": "2016-11-21T02:10:34Z",
      "closedAt": "2016-11-21T02:10:32Z",
      "mergedAt": "2016-11-21T02:10:32Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It's official - MT says \"HTTP/1.1 is no good.\"\n",
          "createdAt": "2016-11-03T05:15:42Z",
          "updatedAt": "2016-11-03T05:15:42Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "66bdfd51a13cef8176896e7a0edeb80268c97e9b",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "remove_http11",
      "headRefOid": "7669702701e798858824786a4dafc14e32cb4928",
      "mergeCommit": {
        "oid": "699ae291145189d6dd70cba15dc5dc24f9e3bda4"
      }
    },
    {
      "number": 270,
      "id": "MDExOlB1bGxSZXF1ZXN0OTQ1NDUzNzQ=",
      "title": "Don't allow clients to send http and https requests coalesced.",
      "url": "https://github.com/httpwg/http-extensions/pull/270",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "opp-sec"
      ],
      "body": "This is kinda silly, but it seems like adding support for coalescing is\r\nsomething we could fix later.\r\n\r\nCloses #269 with the nuclear option.",
      "createdAt": "2016-11-21T02:23:20Z",
      "updatedAt": "2016-12-22T03:36:13Z",
      "closedAt": "2016-12-22T03:36:09Z",
      "mergedAt": "2016-12-22T03:36:09Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the pull request is fine by me. I do wonder if we shouldn't make the json a tad more complicated to allow for a reasonable mixed definition in the future. But an unreasonable one is obviously possible :)",
          "createdAt": "2016-11-21T22:04:10Z",
          "updatedAt": "2016-11-21T22:04:10Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a44bea940c746d8a75d4a51ff915bc32ec9cae00",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "dont_cross_the_streams",
      "headRefOid": "68891a45fcdcaeecfed28089a2e564afe7aa30f7",
      "mergeCommit": {
        "oid": "68891a45fcdcaeecfed28089a2e564afe7aa30f7"
      }
    },
    {
      "number": 272,
      "id": "MDExOlB1bGxSZXF1ZXN0OTQ1NTA5NzU=",
      "title": "Advice on padding strategy",
      "url": "https://github.com/httpwg/http-extensions/pull/272",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "encryption"
      ],
      "body": "Closes #260 ",
      "createdAt": "2016-11-21T03:55:22Z",
      "updatedAt": "2016-12-22T03:34:27Z",
      "closedAt": "2016-12-22T03:34:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merged manually.",
          "createdAt": "2016-12-22T03:34:21Z",
          "updatedAt": "2016-12-22T03:34:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAxOTgwNjU=",
          "commit": {
            "abbreviatedOid": "7d57011"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2016-11-25T19:40:11Z",
          "updatedAt": "2016-11-25T19:40:46Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I am guessing \"good \" is not the word you want here. Perhaps \"true\"?",
              "createdAt": "2016-11-25T19:40:11Z",
              "updatedAt": "2016-11-25T19:40:46Z"
            },
            {
              "originalPosition": 10,
              "body": "Perhaps something slightly stronger like \"should\" or \"MAY WISH TO\" ",
              "createdAt": "2016-11-25T19:40:39Z",
              "updatedAt": "2016-11-25T19:40:46Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7875d366f4c634b91162c4ae919f294ca1fcca79",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "pad_advice",
      "headRefOid": "7d570115a5740ddb42393da7024290d751ae5f5a",
      "mergeCommit": null
    },
    {
      "number": 273,
      "id": "MDExOlB1bGxSZXF1ZXN0OTQ1NTE2NDE=",
      "title": "Remove Crypto-Key header field",
      "url": "https://github.com/httpwg/http-extensions/pull/273",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #265, #210.",
      "createdAt": "2016-11-21T04:05:54Z",
      "updatedAt": "2017-02-13T22:43:45Z",
      "closedAt": "2016-12-22T03:31:38Z",
      "mergedAt": "2016-12-22T03:31:38Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "This looks OK, except for whatever build error you have",
          "createdAt": "2016-11-25T19:39:34Z",
          "updatedAt": "2016-11-25T19:39:34Z"
        },
        {
          "author": null,
          "authorAssociation": "NONE",
          "body": "@martinthomson Late to the party, but...for Web Push, am I understanding correctly that this is now included in the ECE header (idlen = 65, keyid = sender public key)?",
          "createdAt": "2017-02-13T20:57:57Z",
          "updatedAt": "2017-02-13T20:57:57Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kitcambridge yep, that's it.",
          "createdAt": "2017-02-13T22:43:45Z",
          "updatedAt": "2017-02-13T22:43:45Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7875d366f4c634b91162c4ae919f294ca1fcca79",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "remove_crypto_key",
      "headRefOid": "31d78384ee237cf86023c73f3e74674fc896097c",
      "mergeCommit": {
        "oid": "2712de01a00aa3bc51cb371a07bc13aaeba411fb"
      }
    },
    {
      "number": 275,
      "id": "MDExOlB1bGxSZXF1ZXN0OTcxODc1MDM=",
      "title": "spell Golomb correctly",
      "url": "https://github.com/httpwg/http-extensions/pull/275",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2016-12-08T19:45:12Z",
      "updatedAt": "2017-02-07T05:29:07Z",
      "closedAt": "2017-02-07T05:29:07Z",
      "mergedAt": "2017-02-07T05:29:07Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "70a7c47a0c1183291957b72dae571255b7ad1c3e",
      "headRepository": null,
      "headRefName": "spell",
      "headRefOid": "a8d2195a85aafcf1272b72c477d45ec3fb9d197c",
      "mergeCommit": {
        "oid": "e2fd250613eb6709bbf913770bf56c5aa9f3a39c"
      }
    },
    {
      "number": 276,
      "id": "MDExOlB1bGxSZXF1ZXN0OTcxOTE2MzA=",
      "title": "fix typo bit -> be",
      "url": "https://github.com/httpwg/http-extensions/pull/276",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think this is correct, since it doesn't quite seem to make sense otherwise.",
      "createdAt": "2016-12-08T20:09:12Z",
      "updatedAt": "2017-02-07T05:27:31Z",
      "closedAt": "2017-02-07T05:27:31Z",
      "mergedAt": "2017-02-07T05:27:31Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "70a7c47a0c1183291957b72dae571255b7ad1c3e",
      "headRepository": null,
      "headRefName": "bit",
      "headRefOid": "e4bbc857e30f1cf211d44ff415381e36ee7357e9",
      "mergeCommit": {
        "oid": "e103b9e272c461259ed920b2b70c5b4e292fd959"
      }
    },
    {
      "number": 277,
      "id": "MDExOlB1bGxSZXF1ZXN0OTcyNjkxMDU=",
      "title": "make title consistent with WG terminology",
      "url": "https://github.com/httpwg/http-extensions/pull/277",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "",
      "createdAt": "2016-12-09T08:30:39Z",
      "updatedAt": "2017-12-13T07:15:38Z",
      "closedAt": "2017-12-13T06:18:51Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have struggled with the naming from the start, and am open to any suggestions on that, with the single caveat that making the name too long is probably not a good idea without at good acronym.",
          "createdAt": "2017-02-01T13:04:11Z",
          "updatedAt": "2017-02-01T13:04:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OBE",
          "createdAt": "2017-12-13T06:18:51Z",
          "updatedAt": "2017-12-13T06:18:51Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e273a041db62a459e778c90f21d2467fc56a8847",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-3",
      "headRefOid": "35cf27c5800a0ca6cd09b3bb63ae19d795ec149a",
      "mergeCommit": null
    },
    {
      "number": 278,
      "id": "MDExOlB1bGxSZXF1ZXN0OTc0NTM0NDg=",
      "title": "prune boilerplate",
      "url": "https://github.com/httpwg/http-extensions/pull/278",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2016-12-11T09:31:54Z",
      "updatedAt": "2016-12-22T03:38:52Z",
      "closedAt": "2016-12-22T03:38:49Z",
      "mergedAt": "2016-12-22T03:38:49Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f02e163e0a24dacac21e4f6d6026686c54d2c442",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-5",
      "headRefOid": "4e80a5bd8b6df447112ca53a9a6acbc5d837984e",
      "mergeCommit": {
        "oid": "d1f33b833881174b0d438dc49260b7af8c777049"
      }
    },
    {
      "number": 279,
      "id": "MDExOlB1bGxSZXF1ZXN0OTk4OTgzMzQ=",
      "title": "More clarification on authenticated opportunistic responses",
      "url": "https://github.com/httpwg/http-extensions/pull/279",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "",
      "createdAt": "2017-01-02T23:24:56Z",
      "updatedAt": "2017-02-01T04:59:55Z",
      "closedAt": "2017-02-01T04:57:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Manually merged.",
          "createdAt": "2017-02-01T04:57:27Z",
          "updatedAt": "2017-02-01T04:57:27Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5102472cdb788fa61e622ae335acdceea8aa144d",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "authenticate_opportunistic_response",
      "headRefOid": "35609f8d621a3156031a93a5b118d53a5696f396",
      "mergeCommit": null
    },
    {
      "number": 280,
      "id": "MDExOlB1bGxSZXF1ZXN0OTk5MDEwODQ=",
      "title": "Clarify paragraph on requirements for alt-svc",
      "url": "https://github.com/httpwg/http-extensions/pull/280",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "opp-sec"
      ],
      "body": "This was getting unwieldy.  Change it so that there are two musts and two supporting statements.",
      "createdAt": "2017-01-03T00:46:58Z",
      "updatedAt": "2017-02-01T04:59:55Z",
      "closedAt": "2017-02-01T04:59:46Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merged manually.",
          "createdAt": "2017-02-01T04:59:46Z",
          "updatedAt": "2017-02-01T04:59:46Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5102472cdb788fa61e622ae335acdceea8aa144d",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "long_sentence",
      "headRefOid": "21ff4e285dce0a2895b9b20057a6615e1b55e8a7",
      "mergeCommit": null
    },
    {
      "number": 283,
      "id": "MDExOlB1bGxSZXF1ZXN0MTAzNjc5MDE3",
      "title": "Move to using padding that is more like TLS",
      "url": "https://github.com/httpwg/http-extensions/pull/283",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "encryption"
      ],
      "body": "Following the discussion on the list.",
      "createdAt": "2017-01-30T04:51:27Z",
      "updatedAt": "2017-02-12T23:31:45Z",
      "closedAt": "2017-02-12T23:31:42Z",
      "mergedAt": "2017-02-12T23:31:42Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "manger",
          "authorAssociation": "NONE",
          "body": "Need to change the language about the size of the last record: from MUST be shorter, to CAN be shorter (in text and diagram).",
          "createdAt": "2017-01-30T06:08:44Z",
          "updatedAt": "2017-01-30T06:08:44Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "215f0707c7c2a1770b2b0772ffca14c62cd92afe",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "tls_padding",
      "headRefOid": "0f3ff05b3679f9ead35c1be800723e73915b6aaf",
      "mergeCommit": {
        "oid": "b9059bb5e40cdcba05f29300ed716f4681506c22"
      }
    },
    {
      "number": 285,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA0MDgyODE4",
      "title": "DNS relaxation, smaller initial Origin Set",
      "url": "https://github.com/httpwg/http-extensions/pull/285",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "- Relax DNS requirements when ORIGIN is received\r\n- Change the initial origin set to just SNI",
      "createdAt": "2017-02-01T06:40:41Z",
      "updatedAt": "2017-02-13T05:25:28Z",
      "closedAt": "2017-02-13T05:25:23Z",
      "mergedAt": "2017-02-13T05:25:23Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Mon, Feb 6, 2017 at 9:15 PM, Mark Nottingham <notifications@github.com>\nwrote:\n\n> I'm inclined to think that if you want to host an alternative service and\n> send ORIGIN, you need to explicitly list the alternative in ORIGIN. The\n> client *could* make some assumptions, but that doesn't seem great.\n> Thoughts?\n>\n\nwait - no. You wouldn't send the alternative in the ORIGIN frame, you would\nsend the origin that you are the alternative for, right? that would make\nsense - if you want to use an alternative you can't rely on the SNI default.\n",
          "createdAt": "2017-02-07T17:55:36Z",
          "updatedAt": "2017-02-07T17:55:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk0OTQ2NTU=",
          "commit": {
            "abbreviatedOid": "ac5a5e4"
          },
          "author": "cabo",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-01T07:40:37Z",
          "updatedAt": "2017-02-01T07:40:37Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "an empty what?",
              "createdAt": "2017-02-01T07:40:37Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk0OTYwNDY=",
          "commit": {
            "abbreviatedOid": "ac5a5e4"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-01T07:54:48Z",
          "updatedAt": "2017-02-01T07:54:48Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Fixed in 241ce50, thanks",
              "createdAt": "2017-02-01T07:54:48Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1MTQyNTA=",
          "commit": {
            "abbreviatedOid": "241ce50"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This all assumes use of `https`.  That's probably an error because for `http` you have just provided a perfect hijacking mechanism.  We already have enough of those for cleartext HTTP thanks very much :)\r\n\r\nI would strongly recommend explicitly limiting this feature to `https` based on the current changes.",
          "createdAt": "2017-02-01T10:00:38Z",
          "updatedAt": "2017-02-01T10:05:51Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "This is a retroactive change to h2.  It says that you can't coalesce.  It also says that you can't *use* a connection if you didn't use SNI.  I think that you need to include some weasel-words about how this doesn't really apply until the first ORIGIN frame is sent or received.",
              "createdAt": "2017-02-01T10:00:38Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            },
            {
              "originalPosition": 88,
              "body": "Rather than simple removal, I would add:\r\n\r\n> Though this document removes the requirement on clients to ensure that the DNS refers to the same IP address, it does not remove the requirement for certificate-based authentication.  A client MUST validate a server IP address.",
              "createdAt": "2017-02-01T10:03:15Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk5Mjk1NDc=",
          "commit": {
            "abbreviatedOid": "8afa09b"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This is looking good.",
          "createdAt": "2017-02-03T00:56:47Z",
          "updatedAt": "2017-02-03T00:56:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwMjc0NTU=",
          "commit": {
            "abbreviatedOid": "8afa09b"
          },
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "this is indeed looking good",
          "createdAt": "2017-02-03T14:54:08Z",
          "updatedAt": "2017-02-03T16:09:55Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "nit extra newline",
              "createdAt": "2017-02-03T14:54:08Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            },
            {
              "originalPosition": 63,
              "body": "this is a whole new, albeit interesting!, way of versioning. is this the place to break that ground?",
              "createdAt": "2017-02-03T14:57:32Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            },
            {
              "originalPosition": 69,
              "body": "clarifying suggestion: The ORIGIN frame describes a property of the connection, and therefore  is processed hop-by-hop.",
              "createdAt": "2017-02-03T15:14:24Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            },
            {
              "originalPosition": 82,
              "body": "hmm. how does this interact with Alt-Svc? Seems that you could be connected to a port number different than the origin port number (thanks to Alt-Svc) and still want to use origin frames.",
              "createdAt": "2017-02-03T15:16:58Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            },
            {
              "originalPosition": 103,
              "body": "alt-svc concern applies here too wrt port",
              "createdAt": "2017-02-03T15:28:14Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            },
            {
              "originalPosition": 4,
              "body": "in discussions on this there are a couple of other motivators that may (or may not!) be worth including as introductory text.. one is simply that it can save a dns lookup by effectively inlining the result and the other is that dns is often a privacy leak that can be avoided by not making the lookup",
              "createdAt": "2017-02-03T16:02:35Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwODU5ODA=",
          "commit": {
            "abbreviatedOid": "8afa09b"
          },
          "author": "deweerdt",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "minor nits",
          "createdAt": "2017-02-03T19:29:56Z",
          "updatedAt": "2017-02-03T19:33:29Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Should this mention network ordering?",
              "createdAt": "2017-02-03T19:29:56Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            },
            {
              "originalPosition": 207,
              "body": "typo: s/sNSName/DNSName/",
              "createdAt": "2017-02-03T19:33:11Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            },
            {
              "originalPosition": 213,
              "body": "s/to indicate what for origins/to indicate for which origins/",
              "createdAt": "2017-02-03T19:33:13Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzE3NTI=",
          "commit": {
            "abbreviatedOid": "8afa09b"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-04T00:25:44Z",
          "updatedAt": "2017-02-04T00:25:44Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Well, it has to be somewhere. I did it here because there seem to be some cases that require a breaking change (e.g., if we want to include a DELETE or CLEAR flag down the road), and some that don't (e.g., wildcard support).\r\n\r\nHappy to take it out (there are always more ways to do it), but it seemed mostly harmless to try it out here.",
              "createdAt": "2017-02-04T00:25:44Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzE4ODk=",
          "commit": {
            "abbreviatedOid": "8afa09b"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-04T00:27:13Z",
          "updatedAt": "2017-02-04T00:27:13Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Convention is not to in new frame types, since H2 defines it.",
              "createdAt": "2017-02-04T00:27:13Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzIyMjA=",
          "commit": {
            "abbreviatedOid": "8afa09b"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-04T00:30:37Z",
          "updatedAt": "2017-02-04T00:30:37Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "already fixed",
              "createdAt": "2017-02-04T00:30:37Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzI0NDg=",
          "commit": {
            "abbreviatedOid": "8afa09b"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-04T00:33:09Z",
          "updatedAt": "2017-02-04T00:33:09Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "Is correct; see https://tools.ietf.org/html/rfc5280#section-4.2.1.6 (but will add a ref)",
              "createdAt": "2017-02-04T00:33:09Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzI3MTI=",
          "commit": {
            "abbreviatedOid": "8afa09b"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-04T00:36:17Z",
          "updatedAt": "2017-02-04T00:36:17Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done",
              "createdAt": "2017-02-04T00:36:17Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzM3MTI=",
          "commit": {
            "abbreviatedOid": "8afa09b"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-04T00:48:18Z",
          "updatedAt": "2017-02-04T00:48:18Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Yeah. need to think about how to best specify that.",
              "createdAt": "2017-02-04T00:48:18Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDc4NTQ=",
          "commit": {
            "abbreviatedOid": "8afa09b"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-07T00:52:48Z",
          "updatedAt": "2017-02-07T00:52:48Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "@mcmanus see latest commit; I defer the cert checks until use of the origin, and I think that takes care of the concerns here. ",
              "createdAt": "2017-02-07T00:52:48Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MTY5NzQ=",
          "commit": {
            "abbreviatedOid": "8afa09b"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-07T02:15:16Z",
          "updatedAt": "2017-02-07T02:15:16Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "I'm inclined to think that if you want to host an alternative service and send ORIGIN, you need to explicitly list the alternative in ORIGIN. The client *could* make some assumptions, but that doesn't seem great. Thoughts?",
              "createdAt": "2017-02-07T02:15:16Z",
              "updatedAt": "2017-02-13T05:20:20Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e273a041db62a459e778c90f21d2467fc56a8847",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "origin-mnot",
      "headRefOid": "e2083ad3938f7f335ef4051ce5edfb03259fdcd7",
      "mergeCommit": {
        "oid": "b4e8c08c900b9a9a8a2d8d8f4e33bcca03156f51"
      }
    },
    {
      "number": 287,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA0NDY0MDQw",
      "title": "Immutable editorial",
      "url": "https://github.com/httpwg/http-extensions/pull/287",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "immutable"
      ],
      "body": "Editorial stuff, mostly line wrapping and adjusting terminology. Happy to chat through it if you like.",
      "createdAt": "2017-02-03T02:13:38Z",
      "updatedAt": "2017-03-13T16:32:00Z",
      "closedAt": "2017-03-13T16:31:46Z",
      "mergedAt": "2017-03-13T16:31:46Z",
      "mergedBy": "mcmanus",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks for this",
          "createdAt": "2017-03-13T16:26:32Z",
          "updatedAt": "2017-03-13T16:26:32Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c9b88d9fc9326bb81bc1978a07c0d6b81c6964c7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "immutable-editorial",
      "headRefOid": "1c2966821a2c2bfd6319dad90e61fc1fb662f074",
      "mergeCommit": {
        "oid": "9e568824a8563eb27fa9be9af9ada986b97d2fbd"
      }
    },
    {
      "number": 292,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA0OTk0MDUz",
      "title": "Cite a recent HTML spec",
      "url": "https://github.com/httpwg/http-extensions/pull/292",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "estark37"
      ],
      "labels": [
        "expect-ct"
      ],
      "body": "",
      "createdAt": "2017-02-07T12:21:35Z",
      "updatedAt": "2017-10-05T05:22:38Z",
      "closedAt": "2017-10-05T05:22:28Z",
      "mergedAt": "2017-10-05T05:22:28Z",
      "mergedBy": "estark37",
      "comments": [
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks!",
          "createdAt": "2017-10-05T05:22:33Z",
          "updatedAt": "2017-10-05T05:22:33Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "32d9b943ae4a188cddb7a1a9bed9395d9c429429",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "html-citation",
      "headRefOid": "1db4060ad7ace30b59be512e67e2680049845f06",
      "mergeCommit": {
        "oid": "1e638f8cb5f638c648c9bc4c2230a57728ff1b4e"
      }
    },
    {
      "number": 293,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA1Mjk4MDM0",
      "title": "don't cite RFC 2616, it's obsolete",
      "url": "https://github.com/httpwg/http-extensions/pull/293",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-02-08T20:27:53Z",
      "updatedAt": "2017-12-13T07:17:33Z",
      "closedAt": "2017-02-08T20:38:15Z",
      "mergedAt": "2017-02-08T20:38:15Z",
      "mergedBy": "estark37",
      "comments": [
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks!",
          "createdAt": "2017-02-08T20:38:19Z",
          "updatedAt": "2017-02-08T20:38:19Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9ab4cb50fe879a2a5833bdcbe53bb39f9debbe23",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "no2616",
      "headRefOid": "348de1d7325a9392cffbce0e027a89fba4843948",
      "mergeCommit": {
        "oid": "64b39bfd53a44dae738fc11e831950de4f582fe9"
      }
    },
    {
      "number": 296,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA1OTA3NTcy",
      "title": "incorrect content length in example",
      "url": "https://github.com/httpwg/http-extensions/pull/296",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "header = 16 +4 + 1 +2 = 23\r\ntwo records of 25 bytes = 50\r\n\r\nsum is 73",
      "createdAt": "2017-02-13T14:49:04Z",
      "updatedAt": "2017-02-13T22:44:14Z",
      "closedAt": "2017-02-13T22:44:11Z",
      "mergedAt": "2017-02-13T22:44:11Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "dbcff09bf1ae22d5da822c9ef9e4bd8b09647780",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "examplecontentlength",
      "headRefOid": "5f46cda266281263daaa398742aecf9e4ee76704",
      "mergeCommit": {
        "oid": "0361ff6b659f794ef294d4d97652f94696f8f233"
      }
    },
    {
      "number": 297,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA2NDIzMjkx",
      "title": "Updated Opp-Sec writeup",
      "url": "https://github.com/httpwg/http-extensions/pull/297",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "For git tracking purposes, even though I'm uploading directly to Datatracker as well.",
      "createdAt": "2017-02-15T23:29:41Z",
      "updatedAt": "2017-04-28T01:34:43Z",
      "closedAt": "2017-04-28T01:34:43Z",
      "mergedAt": "2017-04-28T01:34:43Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjIxNDUwNDQ=",
          "commit": {
            "abbreviatedOid": "bb90029"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-16T00:11:35Z",
          "updatedAt": "2017-02-16T00:11:35Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "You might also note the added prohibition on \"coalescing\".",
              "createdAt": "2017-02-16T00:11:35Z",
              "updatedAt": "2017-02-16T00:11:35Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "0361ff6b659f794ef294d4d97652f94696f8f233",
      "headRepository": "MikeBishop/http-extensions",
      "headRefName": "oppsec_writeup_v2",
      "headRefOid": "bb900290a24dba9b533cd680eea4a7e0e212c5a5",
      "mergeCommit": {
        "oid": "a591ef7fe842de5dc66dd58548fe924d97eb0d1b"
      }
    },
    {
      "number": 298,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA2OTEwNDg3",
      "title": "align the descriptions",
      "url": "https://github.com/httpwg/http-extensions/pull/298",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-02-19T18:17:34Z",
      "updatedAt": "2017-02-19T22:35:56Z",
      "closedAt": "2017-02-19T22:35:53Z",
      "mergedAt": "2017-02-19T22:35:53Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7702e397fa1c9d4a91b6854a20efe1b4c6100ee8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ee-align-desc",
      "headRefOid": "e8fcfefccb6615ed3adcf8bcaa66778e7c9e44a2",
      "mergeCommit": {
        "oid": "e4e079370810459f685e6d883bbbf62c75879740"
      }
    },
    {
      "number": 299,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA2OTExMDc0",
      "title": "update FIPS180-4 reference",
      "url": "https://github.com/httpwg/http-extensions/pull/299",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-02-19T18:33:45Z",
      "updatedAt": "2017-02-20T05:30:32Z",
      "closedAt": "2017-02-19T22:36:13Z",
      "mergedAt": "2017-02-19T22:36:13Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7702e397fa1c9d4a91b6854a20efe1b4c6100ee8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "fips-ref",
      "headRefOid": "1b2ee7ca6f50dad3f50c014f046c5d0664f6f77a",
      "mergeCommit": {
        "oid": "64e276f87577f91878b2976bcfcded6c2e317281"
      }
    },
    {
      "number": 300,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA2OTExNTQw",
      "title": "fix series info for XMLENC",
      "url": "https://github.com/httpwg/http-extensions/pull/300",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-02-19T18:46:39Z",
      "updatedAt": "2017-12-13T07:17:50Z",
      "closedAt": "2017-02-19T22:36:52Z",
      "mergedAt": "2017-02-19T22:36:52Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7702e397fa1c9d4a91b6854a20efe1b4c6100ee8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "xmlenc-seriesinfo",
      "headRefOid": "3e79b3d145e20ee77eea5a9395b1ec3a8f23ad9c",
      "mergeCommit": {
        "oid": "51aeba0398f3afc13794e20ddd6ef856802e51f5"
      }
    },
    {
      "number": 301,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA3MDk3OTI4",
      "title": "Make the intro to http2-encryption clearer about the scope",
      "url": "https://github.com/httpwg/http-extensions/pull/301",
      "state": "MERGED",
      "author": "paulehoffman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-02-21T00:55:32Z",
      "updatedAt": "2017-02-21T02:42:50Z",
      "closedAt": "2017-02-21T02:42:50Z",
      "mergedAt": "2017-02-21T02:42:50Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson thoughts?",
          "createdAt": "2017-02-21T01:00:10Z",
          "updatedAt": "2017-02-21T01:00:10Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Seems fine, with the edits Mark suggested.  I'll merge and make those changes unless Paul gets to it first.",
          "createdAt": "2017-02-21T01:20:26Z",
          "updatedAt": "2017-02-21T01:20:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4NTk5Mjg=",
          "commit": {
            "abbreviatedOid": "9e5a214"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Looks pretty good to me, some tweaks here.",
          "createdAt": "2017-02-21T00:57:09Z",
          "updatedAt": "2017-02-21T00:59:29Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I think this would read more clearly if it were just \"...URIs, because it is vulnerable...\"",
              "createdAt": "2017-02-21T00:57:09Z",
              "updatedAt": "2017-02-21T00:59:29Z"
            },
            {
              "originalPosition": 26,
              "body": "describe**d**",
              "createdAt": "2017-02-21T00:57:24Z",
              "updatedAt": "2017-02-21T00:59:30Z"
            },
            {
              "originalPosition": 20,
              "body": "This is worded oddly. Suggest \"It allows a `http` URI to be accessed using HTTP/2 {{RFC7230}} and Transport Layer...\"",
              "createdAt": "2017-02-21T00:58:50Z",
              "updatedAt": "2017-02-21T00:59:30Z"
            },
            {
              "originalPosition": 5,
              "body": "in -> and",
              "createdAt": "2017-02-21T00:59:04Z",
              "updatedAt": "2017-02-21T00:59:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4NjAyMjY=",
          "commit": {
            "abbreviatedOid": "9e5a214"
          },
          "author": "paulehoffman",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-21T01:01:04Z",
          "updatedAt": "2017-02-21T01:01:04Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "WFM",
              "createdAt": "2017-02-21T01:01:04Z",
              "updatedAt": "2017-02-21T01:01:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4NjA4MDE=",
          "commit": {
            "abbreviatedOid": "9e5a214"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-21T01:08:29Z",
          "updatedAt": "2017-02-21T01:09:27Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "\"a\" or \"an\" for \"http\"?",
              "createdAt": "2017-02-21T01:08:29Z",
              "updatedAt": "2017-02-21T01:09:27Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8e4976a8ebc4628346e55536d145223b0e940365",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "9e5a2143cb5a2d688b3d2238467e92dd6b0e45cf",
      "mergeCommit": {
        "oid": "9e5a2143cb5a2d688b3d2238467e92dd6b0e45cf"
      }
    },
    {
      "number": 305,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA3ODc0ODA5",
      "title": "Incorporate feedback on httpbis-client-hints-03",
      "url": "https://github.com/httpwg/http-extensions/pull/305",
      "state": "MERGED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Related discussions:\r\n- https://lists.w3.org/Archives/Public/ietf-http-wg/2017JanMar/thread.html#msg143\r\n- https://github.com/httpwg/http-extensions/issues/284",
      "createdAt": "2017-02-24T17:37:59Z",
      "updatedAt": "2017-02-27T06:01:55Z",
      "closedAt": "2017-02-27T05:48:30Z",
      "mergedAt": "2017-02-27T05:48:30Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@mnot thanks for the review, updated.. ptal.",
          "createdAt": "2017-02-27T05:41:39Z",
          "updatedAt": "2017-02-27T05:41:39Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2017-02-27T05:48:38Z",
          "updatedAt": "2017-02-27T05:48:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM4ODA4NzA=",
          "commit": {
            "abbreviatedOid": "a2bb641"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2017-02-26T12:44:38Z",
          "updatedAt": "2017-02-26T12:44:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MTM0NDU=",
          "commit": {
            "abbreviatedOid": "a2bb641"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2017-02-27T05:03:00Z",
          "updatedAt": "2017-02-27T05:04:42Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "\"should\" is a special word in the IETF -- do you mean SHOULD (i.e., an RFC2119 requirement)? If not, \"can\" is better. \r\n\r\nSHOULD is a bit problematic here, because typically when you use it, you should define the circumstances when the requirement can be violated.",
              "createdAt": "2017-02-27T05:03:00Z",
              "updatedAt": "2017-02-27T05:41:21Z"
            },
            {
              "originalPosition": 51,
              "body": "\"Clients control which Client Hint headers and their respective header fields are communicated\" -- this wording is odd. Suggest:\r\n\r\n\"Clients control which Client Hints are sent in requests, based...\"",
              "createdAt": "2017-02-27T05:03:53Z",
              "updatedAt": "2017-02-27T05:41:21Z"
            },
            {
              "originalPosition": 69,
              "body": "I don't think defining the semantics in a \"For example\" is going to fly here. ",
              "createdAt": "2017-02-27T05:04:31Z",
              "updatedAt": "2017-02-27T05:41:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5MTU5NzY=",
          "commit": {
            "abbreviatedOid": "1e0c2d2"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-02-27T05:45:32Z",
          "updatedAt": "2017-02-27T05:45:32Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "98c81fd12b4f78f0a9fb05024e9f8db3d361a7da",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ch-cleanup",
      "headRefOid": "1e0c2d272dd5c4829aa6502a8a0e22411b2f0eec",
      "mergeCommit": {
        "oid": "8d70210ad894186886b33f1891a5616d2e8d1d3a"
      }
    },
    {
      "number": 309,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA5MDg1OTU1",
      "title": "Editorial cleanup and improvements",
      "url": "https://github.com/httpwg/http-extensions/pull/309",
      "state": "MERGED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Closes https://github.com/httpwg/http-extensions/issues/308.",
      "createdAt": "2017-03-04T01:20:22Z",
      "updatedAt": "2017-03-17T21:23:26Z",
      "closedAt": "2017-03-14T08:03:05Z",
      "mergedAt": "2017-03-14T08:03:05Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@mnot thanks, updated -- ptal.",
          "createdAt": "2017-03-06T12:42:55Z",
          "updatedAt": "2017-03-06T12:42:55Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2017-03-14T07:07:44Z",
          "updatedAt": "2017-03-14T07:07:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjUxNjQ2ODQ=",
          "commit": {
            "abbreviatedOid": "f5f3f8a"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM; see answers to first two questions on original issue.",
          "createdAt": "2017-03-06T01:45:27Z",
          "updatedAt": "2017-03-06T01:45:27Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "60b9a7fb26ddb901b56ba3e4fd9f8ffb14271c5f",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ch-editorial-nits",
      "headRefOid": "49a1f278e79a1457c89ff49381f1ca7ff7f09d04",
      "mergeCommit": {
        "oid": "bf46a5aef4aeaaaa10b3328acf1c79c02ef79789"
      }
    },
    {
      "number": 311,
      "id": "MDExOlB1bGxSZXF1ZXN0MTEwNDg0MDc5",
      "title": "immutable: fix typo",
      "url": "https://github.com/httpwg/http-extensions/pull/311",
      "state": "MERGED",
      "author": "vfaronov",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-03-13T19:51:24Z",
      "updatedAt": "2017-03-13T20:00:25Z",
      "closedAt": "2017-03-13T20:00:23Z",
      "mergedAt": "2017-03-13T20:00:23Z",
      "mergedBy": "mcmanus",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ty",
          "createdAt": "2017-03-13T20:00:25Z",
          "updatedAt": "2017-03-13T20:00:25Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9e568824a8563eb27fa9be9af9ada986b97d2fbd",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "5f4341993d96b4e4c9321b9403d836e8d2d334ff",
      "mergeCommit": {
        "oid": "a92686217e271843a2374d0090850ea7f38a758a"
      }
    },
    {
      "number": 313,
      "id": "MDExOlB1bGxSZXF1ZXN0MTExMzc3Mjcy",
      "title": "define Accept-CH-Lifetime",
      "url": "https://github.com/httpwg/http-extensions/pull/313",
      "state": "MERGED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #307 and #306.",
      "createdAt": "2017-03-17T22:28:03Z",
      "updatedAt": "2018-04-03T17:52:54Z",
      "closedAt": "2017-03-26T17:31:00Z",
      "mergedAt": "2017-03-26T17:31:00Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Looks good overall. \r\n\r\n`Accept-CH-Lifetime` changes the semantics of `Accept-CH`. Not only does it effectively put `Accept-CH` on subsequent responses from the same origin for the given lifetime, it **also** suggests that Client Hints should be added to requests _to_ that origin, no matter where the requesting page has come from.\r\n\r\nNot a problem, but right now it's conveyed almost as an aside. This needs to be clearly specified so it isn't missed / misunderstood.\r\n",
          "createdAt": "2017-03-22T01:24:41Z",
          "updatedAt": "2017-03-22T01:24:41Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@mnot updated, PTAL. ",
          "createdAt": "2017-03-23T18:42:59Z",
          "updatedAt": "2017-03-23T18:42:59Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Thanks Mark!",
          "createdAt": "2017-03-26T17:30:47Z",
          "updatedAt": "2017-03-26T17:30:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNzQ0ODU=",
          "commit": {
            "abbreviatedOid": "937227c"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "This is better.",
          "createdAt": "2017-03-26T17:11:12Z",
          "updatedAt": "2017-03-26T17:11:12Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "81a850e04491a8bd1961fbccacebdadfd5ad2779",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "accept-ch-lifetime",
      "headRefOid": "937227cca3bccdece4cccc05f330b261c91be2ea",
      "mergeCommit": {
        "oid": "8486ed58924dd1bf2fd881d5d626751f6e55ec3f"
      }
    },
    {
      "number": 323,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE1MjIxODIx",
      "title": "change frame type of origin to 0xc to avoid conflict",
      "url": "https://github.com/httpwg/http-extensions/pull/323",
      "state": "MERGED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While testing firefox's implementation of this draft Vlad determined that some versions of Chrome throw PROTOCOL_ERROR and close the connection if it receives a type 0xB frame with a non zero length on stream 0.\r\n\r\nOther frame type numbers, such as 0xC do not seem to have that problem.\r\n\r\ntesting indicates this is fixed in version 59 and is a problem previous to that. (57 is in release as I write this).\r\n\r\npresumably this is related to historical code around BLOCKED which was proposed to use 0xB.\r\n\r\nPrudence says to just use a different code point for the moment.",
      "createdAt": "2017-04-11T01:05:05Z",
      "updatedAt": "2017-04-18T08:39:48Z",
      "closedAt": "2017-04-11T04:09:40Z",
      "mergedAt": "2017-04-11T04:09:40Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Question for @mcmanus and @mnot, should we somehow reserve 0xb to avoid this problem?",
          "createdAt": "2017-04-18T07:21:30Z",
          "updatedAt": "2017-04-18T07:21:30Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If this is fixed in Chrome 59, why bother? Actually, I'd also revert this change.",
          "createdAt": "2017-04-18T07:30:53Z",
          "updatedAt": "2017-04-18T07:30:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Neither. There are still old Chrome versions deployed (some people lag, for various reasons), so it's not safe to use now, but it should be in the not-to-distant future; we just need to wait a while to use it (presumably for another extension).\r\n\r\nReserving it for all time would be a bad precedent.",
          "createdAt": "2017-04-18T08:39:48Z",
          "updatedAt": "2017-04-18T08:39:48Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8c31395609cdd2d1a91059fcbaa5a33fda622525",
      "headRepository": "mcmanus/http-extensions",
      "headRefName": "origin-code-c",
      "headRefOid": "75225e028f01078c71a54a078cd636cf1cb49428",
      "mergeCommit": {
        "oid": "597ed3854315bf54a453af0cdc593dc65627f11e"
      }
    },
    {
      "number": 326,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE2Mjg5NDgz",
      "title": "Use stand_alone for markdown",
      "url": "https://github.com/httpwg/http-extensions/pull/326",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This includes a common set of processing instructions for the markdown files.  The results should be more consistent with other drafts in the repo.  \r\n\r\nThis is partly selfish.  I found that this is necessary on my machine because java is flaky and kramdown-rfc2629 creates entity references that it can't handle. ",
      "createdAt": "2017-04-18T09:46:59Z",
      "updatedAt": "2018-04-03T17:52:56Z",
      "closedAt": "2017-09-29T06:08:23Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would recommend to remove all PIs (unless there is one that you think has an actual effect)",
          "createdAt": "2017-04-18T10:00:41Z",
          "updatedAt": "2017-04-18T10:00:41Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OBE.",
          "createdAt": "2017-09-29T06:08:23Z",
          "updatedAt": "2017-09-29T06:08:23Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9033b99c55bbe7845c66dc29f990a1d33aafd36a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "stand_alone",
      "headRefOid": "d1cd741112c52291f67c7cd6ef57f05acd39a8ad",
      "mergeCommit": null
    },
    {
      "number": 327,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE2Mzc5NzY1",
      "title": "Update Expect-CT syntax to match convention",
      "url": "https://github.com/httpwg/http-extensions/pull/327",
      "state": "MERGED",
      "author": "estark37",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This changes Expect-CT to be a comma-separated list of directives (which may be\r\nname=value pairs), and adds some examples.\r\n\r\nAlso allows the server to send multiple header fields so that they can be\r\ncombined, as per\r\nhttps://github.com/httpwg/http-extensions/issues/318#issuecomment-294369176\r\n\r\nFixes issue #318, #321 ",
      "createdAt": "2017-04-18T17:28:32Z",
      "updatedAt": "2018-04-03T17:52:57Z",
      "closedAt": "2017-04-19T19:51:24Z",
      "mergedAt": "2017-04-19T19:51:24Z",
      "mergedBy": "estark37",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzMjQ4NjE=",
          "commit": {
            "abbreviatedOid": "09d261c"
          },
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-04-18T19:15:41Z",
          "updatedAt": "2017-04-18T19:15:42Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "For variation, I suggest adding a single space after the commas for this middle example just to remind readers that spaces here are ignored.",
              "createdAt": "2017-04-18T19:15:41Z",
              "updatedAt": "2017-04-18T23:32:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzNzMzNDQ=",
          "commit": {
            "abbreviatedOid": "09d261c"
          },
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-04-18T23:08:54Z",
          "updatedAt": "2017-04-18T23:08:54Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Done",
              "createdAt": "2017-04-18T23:08:54Z",
              "updatedAt": "2017-04-18T23:32:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzNzYwMjk=",
          "commit": {
            "abbreviatedOid": "9b6bc1b"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-04-18T23:30:12Z",
          "updatedAt": "2017-04-18T23:30:15Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I would put a blank line between each example, lest this be confused for a single header block.\r\n\r\nAlso, use foo.example, not foo.test.",
              "createdAt": "2017-04-18T23:30:12Z",
              "updatedAt": "2017-04-18T23:32:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzNzYzNTQ=",
          "commit": {
            "abbreviatedOid": "9b6bc1b"
          },
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-04-18T23:32:55Z",
          "updatedAt": "2017-04-18T23:32:55Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Done and done",
              "createdAt": "2017-04-18T23:32:55Z",
              "updatedAt": "2017-04-18T23:32:55Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9033b99c55bbe7845c66dc29f990a1d33aafd36a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "expect-ct-definition",
      "headRefOid": "24c59fa033ad57a9cedbbd3ad823c8e12cc64450",
      "mergeCommit": {
        "oid": "3e7865d4bece35f70fc34c8f7551462f509f1de1"
      }
    },
    {
      "number": 328,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE2NDU3Nzgx",
      "title": "Editorial suggestions",
      "url": "https://github.com/httpwg/http-extensions/pull/328",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [
        "kazuho"
      ],
      "labels": [
        "early-hints"
      ],
      "body": "... for your consideration; feel free to take, discard, or do whatever else you like :)\r\n",
      "createdAt": "2017-04-19T02:26:42Z",
      "updatedAt": "2017-12-13T20:31:01Z",
      "closedAt": "2017-05-16T02:20:42Z",
      "mergedAt": "2017-05-16T02:20:42Z",
      "mergedBy": "kazuho",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you so much for the improvements. This PR is a tremendous opportunity for me to improve my skills (both in terms of writing a specification and in terms of English).",
          "createdAt": "2017-05-16T02:20:45Z",
          "updatedAt": "2017-05-16T02:20:45Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "2722a39ec17936b8b1fc1dda5661b6bf933cf983",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "early-editorial",
      "headRefOid": "0c55d1ef27b3175c3c61044021a236d5cf4127b9",
      "mergeCommit": {
        "oid": "6cbe340c8b7a15a126fcdf89e5f1b316c04cba12"
      }
    },
    {
      "number": 329,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE2Nzc1Nzg2",
      "title": "Two editorial nits.",
      "url": "https://github.com/httpwg/http-extensions/pull/329",
      "state": "MERGED",
      "author": "bencebeky",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "1. Fix one typo.\r\n2. Technically, a set is always a subset of itself.  Therefore current wording implies that if two connections have identical Origin Sets, then neither should be used for new requests, and both should be closed.  Fix this by saying \"proper subset\" instead of \"subset\".",
      "createdAt": "2017-04-20T13:50:17Z",
      "updatedAt": "2017-04-21T00:23:26Z",
      "closedAt": "2017-04-21T00:23:21Z",
      "mergedAt": "2017-04-21T00:23:21Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2017-04-21T00:23:26Z",
          "updatedAt": "2017-04-21T00:23:26Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b4c3e248a0ed7f3ac780fb78b21cc433d36880ee",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "87bc0fbbfa7b0b25a620e88f21a8efc352b1252a",
      "mergeCommit": {
        "oid": "5a886852c7506489ab34dc707498f37640042aab"
      }
    },
    {
      "number": 332,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE3MDc2MDk0",
      "title": "fix \"is is\" typo",
      "url": "https://github.com/httpwg/http-extensions/pull/332",
      "state": "MERGED",
      "author": "enygren",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-04-21T22:09:00Z",
      "updatedAt": "2017-04-24T01:22:34Z",
      "closedAt": "2017-04-24T01:22:33Z",
      "mergedAt": "2017-04-24T01:22:33Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5a886852c7506489ab34dc707498f37640042aab",
      "headRepository": "enygren/http-extensions",
      "headRefName": "master",
      "headRefOid": "ae4421e2470d03d95fbb9ed40a6f1f0cd74d3e48",
      "mergeCommit": {
        "oid": "212835147ef3b36bccfb0dad797409aaaf86d742"
      }
    },
    {
      "number": 334,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE3NzE1NDk3",
      "title": "Fix abstract wrt what this document obsoletes",
      "url": "https://github.com/httpwg/http-extensions/pull/334",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "",
      "createdAt": "2017-04-26T13:33:15Z",
      "updatedAt": "2017-12-13T07:15:53Z",
      "closedAt": "2017-05-05T12:31:37Z",
      "mergedAt": "2017-05-05T12:31:36Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2017-05-05T12:31:33Z",
          "updatedAt": "2017-05-05T12:31:33Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a691d8570a20400faf278b465cbed154d1f7a719",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-1",
      "headRefOid": "f66df3871d921c77e706090f6b4facbc85c86bdb",
      "mergeCommit": {
        "oid": "d88adb56761d009c6546cf78b5f7e9fdf7bfa933"
      }
    },
    {
      "number": 335,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE3NzE3MDc1",
      "title": "fix USASCII reference",
      "url": "https://github.com/httpwg/http-extensions/pull/335",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "",
      "createdAt": "2017-04-26T13:40:27Z",
      "updatedAt": "2017-05-05T12:34:56Z",
      "closedAt": "2017-05-05T12:31:57Z",
      "mergedAt": "2017-05-05T12:31:57Z",
      "mergedBy": "mikewest",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a691d8570a20400faf278b465cbed154d1f7a719",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-5",
      "headRefOid": "3719282c9d620a9b15f4a799aa829164be1908f9",
      "mergeCommit": {
        "oid": "6c017310bc3966dbb40d699726a22a1a0b559511"
      }
    },
    {
      "number": 336,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE3NzE3MjY2",
      "title": "remove historic status text",
      "url": "https://github.com/httpwg/http-extensions/pull/336",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "...about the changes in rfc6265",
      "createdAt": "2017-04-26T13:41:15Z",
      "updatedAt": "2017-05-05T12:34:54Z",
      "closedAt": "2017-05-05T12:32:12Z",
      "mergedAt": "2017-05-05T12:32:11Z",
      "mergedBy": "mikewest",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a691d8570a20400faf278b465cbed154d1f7a719",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-2",
      "headRefOid": "c44538e3fad0b3eee0b1bb9d507d91a862f528e4",
      "mergeCommit": {
        "oid": "d1686c48b705a12ad2af681fce704bd776c33f4c"
      }
    },
    {
      "number": 337,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE3NzE5MTY5",
      "title": "fix ID citations",
      "url": "https://github.com/httpwg/http-extensions/pull/337",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "",
      "createdAt": "2017-04-26T13:49:09Z",
      "updatedAt": "2017-12-13T07:15:50Z",
      "closedAt": "2017-05-05T12:32:40Z",
      "mergedAt": "2017-05-05T12:32:40Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I knew there had to be a way to do this. :) Thanks!",
          "createdAt": "2017-05-05T12:32:35Z",
          "updatedAt": "2017-05-05T12:32:35Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a691d8570a20400faf278b465cbed154d1f7a719",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-6",
      "headRefOid": "f9f85632a52a62df6ec6c380908e5acd308bd533",
      "mergeCommit": {
        "oid": "328a71941ab120d358e9c1f4f70bb685b19c18f9"
      }
    },
    {
      "number": 338,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE3OTMxODE3",
      "title": "make internal references dynamic",
      "url": "https://github.com/httpwg/http-extensions/pull/338",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "addresses #333",
      "createdAt": "2017-04-27T12:55:42Z",
      "updatedAt": "2017-05-05T12:34:51Z",
      "closedAt": "2017-05-05T12:34:45Z",
      "mergedAt": "2017-05-05T12:34:45Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "This is very cool. I didn't see this kind of linking mechanism in the kramdown-rfc2629 docs... is there a list of the supported syntatical sugar somewhere I should skim through?",
          "createdAt": "2017-05-05T12:34:39Z",
          "updatedAt": "2017-05-05T12:34:39Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a691d8570a20400faf278b465cbed154d1f7a719",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-7",
      "headRefOid": "ec3014a281f25ea09cbacdf302d28fa5dd9a75e4",
      "mergeCommit": {
        "oid": "47248974294ab0a689cb794deada62c0e461e074"
      }
    },
    {
      "number": 340,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE4MDg4MDQ0",
      "title": "settings parameter to indicate support for CACHE_DIGEST",
      "url": "https://github.com/httpwg/http-extensions/pull/340",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "The PR introduces a new SETTINGS parameter that can be used by a server to notify if (and how) it makes use of the CACHE_DIGEST frames.\r\n\r\nYou might find the discussion about how to use the parameter interesting. The text of the PR, under the assumption that the underlying transport will be TLS 1.3, suggests the client:\r\n* to wait for `SETTING_CACHE_DIGEST` SETTINGS parameter when doing a full handshake\r\n* retain the value of the parameter in the TLS session cache\r\n* and reuse the cached settings parameter value when doing 0-RTT resumption\r\n\r\nResolves #229.\r\n\r\n",
      "createdAt": "2017-04-28T06:28:58Z",
      "updatedAt": "2017-05-25T07:29:58Z",
      "closedAt": "2017-05-25T07:29:58Z",
      "mergedAt": "2017-05-25T07:29:58Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MzEwMDg=",
          "commit": {
            "abbreviatedOid": "0ac82a5"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Looks good to me, delta the one comment I made.",
          "createdAt": "2017-05-01T01:11:37Z",
          "updatedAt": "2017-05-01T01:11:57Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "\"... found in previous connections to that origin {{RFC6454}} to make ... \"?",
              "createdAt": "2017-05-01T01:11:37Z",
              "updatedAt": "2017-05-25T07:25:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MzczNzU=",
          "commit": {
            "abbreviatedOid": "0ac82a5"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-01T03:52:56Z",
          "updatedAt": "2017-05-01T03:52:56Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Thank you for the suggestion. Applied in the commit below. That makes the sentence clearer.",
              "createdAt": "2017-05-01T03:52:56Z",
              "updatedAt": "2017-05-25T07:25:40Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a2ff3ce9da5b042d14842bc90b30ea13fbe69847",
      "headRepository": "kazuho/http-extensions",
      "headRefName": "kazuho/settings-cache-digest",
      "headRefOid": "11cab73c16a46bfd941c72a0079baac003dbd604",
      "mergeCommit": {
        "oid": "bd2385872244105fae8d818238809c0bc29e0407"
      }
    },
    {
      "number": 341,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE4MjY4NTc2",
      "title": "define `cache-digest` header in appendix",
      "url": "https://github.com/httpwg/http-extensions/pull/341",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "#256.\r\n\r\nSince I wasn't sure if we can make normative references from an appendix, RFC5234 (ABNF) and RFC4648 (Base64) has been added as informative references.",
      "createdAt": "2017-04-29T09:18:35Z",
      "updatedAt": "2017-05-29T00:55:05Z",
      "closedAt": "2017-05-25T06:37:10Z",
      "mergedAt": "2017-05-25T06:37:10Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot Thank you for your review. I believe that I have addressed all four issues in the commit above.",
          "createdAt": "2017-05-01T05:20:31Z",
          "updatedAt": "2017-05-01T05:20:46Z"
        },
        {
          "author": "sebdeckers",
          "authorAssociation": "NONE",
          "body": "@kazuho Would it make sense to also describe the cookie-based method in this spec?",
          "createdAt": "2017-05-27T13:36:27Z",
          "updatedAt": "2017-05-27T13:36:27Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While we could do that, I am kind of negative against it.\r\n\r\nWe need a specification for Cache-digest using HTTP/2 frames or HTTP/1 headers, since it needs to be defined as an interaction between a server and a client (that has the knowledge of what is being cached).\r\n\r\nOTOH, we do not need a specification for a Cache-Digest cookie, since it is totally controlled by the server. So it is entirely up to each server implementation to use whatever format it wants. Also, it is not easy to find out the right way to implement a cookie-based Cache-Digest that would work on all web browsers, since the timing the browser consumes the cookies sent from the server depend on the timing of the response.\r\n\r\nTo summarize, the relatively low necessity and the technical difficulty makes me hesitate in pursuing the idea.",
          "createdAt": "2017-05-29T00:55:04Z",
          "updatedAt": "2017-05-29T00:55:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MzE0ODY=",
          "commit": {
            "abbreviatedOid": "bab4e9d"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-01T01:24:36Z",
          "updatedAt": "2017-05-01T01:27:00Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Isn't the motivation simply that browsers currently don't send CACHE_DIGEST, so you have to fake it with Fetch?",
              "createdAt": "2017-05-01T01:24:36Z",
              "updatedAt": "2017-05-01T05:17:17Z"
            },
            {
              "originalPosition": 46,
              "body": "Need to register the header field in IANA Considerations, as per RFC3864.",
              "createdAt": "2017-05-01T01:25:18Z",
              "updatedAt": "2017-05-01T05:17:17Z"
            },
            {
              "originalPosition": 27,
              "body": "It would be good to mention other limitations -- e.g., since the header is end-to-end, there might be confusion about what cache generated the header field.",
              "createdAt": "2017-05-01T01:26:02Z",
              "updatedAt": "2017-05-01T05:17:17Z"
            },
            {
              "originalPosition": 24,
              "body": "It might be worth spelling out why they need to be sent on every request (since different requests might be routed differently; there is no connection affinity).",
              "createdAt": "2017-05-01T01:26:45Z",
              "updatedAt": "2017-05-01T05:17:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NDA0ODU=",
          "commit": {
            "abbreviatedOid": "bab4e9d"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-01T05:18:52Z",
          "updatedAt": "2017-05-01T05:18:52Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I have adjusted the text so that it discusses specifically about Service Workers.\r\n\r\nIt is Service Workers (that provides a Cache _and_ the Fetch API) that we use to emulate Cache-Digests.",
              "createdAt": "2017-05-01T05:18:52Z",
              "updatedAt": "2017-05-01T05:18:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0ODQ5Mzg=",
          "commit": {
            "abbreviatedOid": "fdb3b0b"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-11T05:17:45Z",
          "updatedAt": "2017-05-11T05:17:45Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I'm afraid this isn't adequate; if an RFC -- even an experimental one -- defines a header, it really needs to register it. I can do a separate PR if you like.",
              "createdAt": "2017-05-11T05:17:45Z",
              "updatedAt": "2017-05-11T05:17:45Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a591ef7fe842de5dc66dd58548fe924d97eb0d1b",
      "headRepository": "kazuho/http-extensions",
      "headRefName": "kazuho/cache-digest-header",
      "headRefOid": "fdb3b0bb2ce79733dd581d5c664c6cebaf5154fa",
      "mergeCommit": {
        "oid": "3853ae2a5a5a2e98601affe38e8bc353bf3318b5"
      }
    },
    {
      "number": 344,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIxMDE5NTQ5",
      "title": "augment downref to RFC 3490 with explanation (see #343)",
      "url": "https://github.com/httpwg/http-extensions/pull/344",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "(taken from 6265)\r\n\r\nNote this requires kramdown-rfc2629 version 1.2.2 or newer  - please make sure to use this when generating submissions",
      "createdAt": "2017-05-17T10:06:59Z",
      "updatedAt": "2017-05-26T12:26:38Z",
      "closedAt": "2017-05-26T12:26:35Z",
      "mergedAt": "2017-05-26T12:26:35Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Thanks (and thanks for the note about Kramdown)",
          "createdAt": "2017-05-26T12:26:31Z",
          "updatedAt": "2017-05-26T12:26:31Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9852a212bda7f9906b09b0f8fd5a7f8ba8ee34fe",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-7",
      "headRefOid": "ea6d64d33939b8399f18346511ce4af44161dbcc",
      "mergeCommit": {
        "oid": "d5f7cb8c000f7a5c6d3545827883efe1a90eac99"
      }
    },
    {
      "number": 345,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIxMDE5Nzky",
      "title": "update UTS46 reference",
      "url": "https://github.com/httpwg/http-extensions/pull/345",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "",
      "createdAt": "2017-05-17T10:08:18Z",
      "updatedAt": "2017-05-26T12:26:56Z",
      "closedAt": "2017-05-26T12:26:46Z",
      "mergedAt": "2017-05-26T12:26:46Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": ":+1: ",
          "createdAt": "2017-05-26T12:26:54Z",
          "updatedAt": "2017-05-26T12:26:54Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9852a212bda7f9906b09b0f8fd5a7f8ba8ee34fe",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-2",
      "headRefOid": "690c9a4ec31dc79f29aa76143887970e4639466b",
      "mergeCommit": {
        "oid": "fb581ef4eac4006df4390a0eb0edf4247fd24a8d"
      }
    },
    {
      "number": 346,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIxMDIwMTIw",
      "title": "prune boilerplate",
      "url": "https://github.com/httpwg/http-extensions/pull/346",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bsdphk"
      ],
      "labels": [
        "header-structure"
      ],
      "body": "",
      "createdAt": "2017-05-17T10:09:56Z",
      "updatedAt": "2017-12-13T07:15:36Z",
      "closedAt": "2017-11-28T01:38:18Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OBE",
          "createdAt": "2017-11-28T01:38:18Z",
          "updatedAt": "2017-11-28T01:38:18Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9852a212bda7f9906b09b0f8fd5a7f8ba8ee34fe",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-4",
      "headRefOid": "d2d68a28e1909fe0579460a153f14f71e06a8ad0",
      "mergeCommit": null
    },
    {
      "number": 347,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIxMDIwMjcx",
      "title": "augment CSRF citation",
      "url": "https://github.com/httpwg/http-extensions/pull/347",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "",
      "createdAt": "2017-05-17T10:10:39Z",
      "updatedAt": "2017-05-26T12:26:02Z",
      "closedAt": "2017-05-26T12:25:55Z",
      "mergedAt": "2017-05-26T12:25:55Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2017-05-26T12:25:59Z",
          "updatedAt": "2017-05-26T12:25:59Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9852a212bda7f9906b09b0f8fd5a7f8ba8ee34fe",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-5",
      "headRefOid": "d0e062ad2858d71426850668f20ba20503e12fac",
      "mergeCommit": {
        "oid": "c4f010122e0e41d37b054a92cf8f47fad50ab143"
      }
    },
    {
      "number": 348,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIxOTEzOTc5",
      "title": "Explain interactions with Alt-Svc",
      "url": "https://github.com/httpwg/http-extensions/pull/348",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "origin-frame"
      ],
      "body": "The consequences for ORIGIN + Alt-Svc with a port change aren't awesome, but this should at least remove any confusion.",
      "createdAt": "2017-05-23T05:00:29Z",
      "updatedAt": "2017-07-31T06:44:17Z",
      "closedAt": "2017-07-31T06:43:14Z",
      "mergedAt": "2017-07-31T06:43:14Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Are you going to take another go at this?",
          "createdAt": "2017-07-31T04:36:48Z",
          "updatedAt": "2017-07-31T04:36:48Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, I let this one drop because I missed your suggestion, which is good.",
          "createdAt": "2017-07-31T04:54:54Z",
          "updatedAt": "2017-07-31T04:56:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2017-07-31T06:43:21Z",
          "updatedAt": "2017-07-31T06:43:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDk1MzU=",
          "commit": {
            "abbreviatedOid": "526f8a8"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2017-05-23T06:09:55Z",
          "updatedAt": "2017-05-23T06:10:41Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "ORIGIN doesn't specify how to remove a member of the origin set.",
              "createdAt": "2017-05-23T06:09:55Z",
              "updatedAt": "2017-07-31T05:29:14Z"
            },
            {
              "originalPosition": 26,
              "body": "I'm not sure this is helping; what are you trying to accomplish?",
              "createdAt": "2017-05-23T06:10:32Z",
              "updatedAt": "2017-07-31T05:29:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NzAyMTg=",
          "commit": {
            "abbreviatedOid": "526f8a8"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-23T08:09:49Z",
          "updatedAt": "2017-05-23T08:09:49Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "It doesn't remove it from the origin set, that's unfortunate phrasing.  It does invalidate the connection for use with the origin.",
              "createdAt": "2017-05-23T08:09:49Z",
              "updatedAt": "2017-07-31T05:29:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NzA4NDI=",
          "commit": {
            "abbreviatedOid": "526f8a8"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-23T08:12:50Z",
          "updatedAt": "2017-05-23T08:12:50Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I thought that the example was illustrative: if you Alt-Svc with a different port, then send ORIGIN you get in a bind unless you include the original origin in the ORIGIN frame because the implicitly-included origin uses the alternative service port.\r\n\r\nI've been trying to find a word for a. the origin that is seed for the origin set, and b. the origin that the client is chasing with alternative services.  I don't think that \"original origin\" is very helpful.",
              "createdAt": "2017-05-23T08:12:50Z",
              "updatedAt": "2017-07-31T05:29:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMDE4MTY=",
          "commit": {
            "abbreviatedOid": "23edbf8"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-25T03:39:36Z",
          "updatedAt": "2017-05-25T03:39:37Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Maybe define a new term \"initial origin\"?",
              "createdAt": "2017-05-25T03:39:36Z",
              "updatedAt": "2017-07-31T05:29:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMDIxNTI=",
          "commit": {
            "abbreviatedOid": "526f8a8"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-25T03:44:00Z",
          "updatedAt": "2017-05-25T03:44:00Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "That's not quite it, it's the default (alternative) service for the origin that matters here.  The origin doesn't change when talking to an alternative.",
              "createdAt": "2017-05-25T03:44:00Z",
              "updatedAt": "2017-07-31T05:29:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMDc1NDk=",
          "commit": {
            "abbreviatedOid": "526f8a8"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-25T04:54:05Z",
          "updatedAt": "2017-05-25T04:54:05Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "More noodling on this one... \"initial origin\" works, but that's not the hard one.  Does \"original service\" work for the service that is not an alternative?",
              "createdAt": "2017-05-25T04:54:05Z",
              "updatedAt": "2017-07-31T05:29:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NjE0NTc=",
          "commit": {
            "abbreviatedOid": "69ce241"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-30T06:35:26Z",
          "updatedAt": "2017-05-30T06:35:26Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "I think you want to say something like this:\r\n\r\n> Servers used as an alternative service {{?RFC7838}} will need to explicitly send the origin(s) that are available when sending ORIGIN frames, because the initial origin set (see {{ref}}) does not contain any alternative services. Because the origin includes the port number, this includes alternative services that are on the same host as the origin.\r\n\r\nI.e., this is about more than just ports.",
              "createdAt": "2017-05-30T06:35:26Z",
              "updatedAt": "2017-07-31T05:29:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzOTg5ODM=",
          "commit": {
            "abbreviatedOid": "69ce241"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-01T01:36:10Z",
          "updatedAt": "2017-06-01T01:36:10Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "That doesn't ring true either.  I realize that there are cases where the alternative has its own independent identity (e.g., example.com might use alt.example.net as an alternative, but that server might also want to serve resources for alt.example.net), but I wanted to avoid dragging that into this.\r\n\r\nThe port thing is a trap because the initial origin is primed based on the port that was *used*.  At least with the SNI, the original origin (example.com) is sent, so there is no confusion.  If the port number is the same for origin and alternative, the initial origin covers the resources that caused the client to use this alternative.  Send an empty ORIGIN frame and you still have a usable alternative.  Change the port number and that is no longer true.",
              "createdAt": "2017-06-01T01:36:10Z",
              "updatedAt": "2017-07-31T05:29:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMDU3MjM=",
          "commit": {
            "abbreviatedOid": "69ce241"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-20T00:10:58Z",
          "updatedAt": "2017-06-20T00:10:58Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "> When sending an ORIGIN frame to a connection that is initialised as an Alternative Service {{?RFC7838}}, the initial origin set {{ref}} will contain an origin with the appropriate scheme and hostname (since Alternative Services specifies that the origin's hostname be sent in SNI). However, it is possible that the port will be different than that of the intended origin, since the initial origin set is calculated using the actual port in use, which can be different for the alternative service. In this case, the intended origin ought to be sent in the ORIGIN frame explicitly.",
              "createdAt": "2017-06-20T00:10:58Z",
              "updatedAt": "2017-07-31T05:29:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxMjgzMDE=",
          "commit": {
            "abbreviatedOid": "b6c50a9"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-07-31T05:17:10Z",
          "updatedAt": "2017-07-31T05:17:10Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "connections's?",
              "createdAt": "2017-07-31T05:17:10Z",
              "updatedAt": "2017-07-31T05:29:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxMjkyNTk=",
          "commit": {
            "abbreviatedOid": "b6c50a9"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-07-31T05:28:28Z",
          "updatedAt": "2017-07-31T05:28:28Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Your text, not mine, but I'll fix it.",
              "createdAt": "2017-07-31T05:28:28Z",
              "updatedAt": "2017-07-31T05:29:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxMjkzNDg=",
          "commit": {
            "abbreviatedOid": "b6c50a9"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-07-31T05:29:28Z",
          "updatedAt": "2017-07-31T05:29:28Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "OK, it's mine apparently",
              "createdAt": "2017-07-31T05:29:28Z",
              "updatedAt": "2017-07-31T05:29:28Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "31b4e577c1fc445f95c4bd8bb18003c969f31b5d",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "origin-alt-port",
      "headRefOid": "73c9519656ce52643878de6d3e240fb299edb943",
      "mergeCommit": {
        "oid": "85f58fa3025eebfed79400089d7fa3995c9a1694"
      }
    },
    {
      "number": 352,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIyMzgyMDU3",
      "title": "Register header, frame type with IANA",
      "url": "https://github.com/httpwg/http-extensions/pull/352",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "The header needs to be registered if it's going to appear in an RFC.\r\n\r\nLooking at 7540, I think the frame type needs to be registered as well, since \"Experimental Use\" is private / local only.",
      "createdAt": "2017-05-25T06:50:27Z",
      "updatedAt": "2017-12-13T20:33:25Z",
      "closedAt": "2017-05-25T07:02:53Z",
      "mergedAt": "2017-05-25T07:02:53Z",
      "mergedBy": "kazuho",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you very much!",
          "createdAt": "2017-05-25T07:03:13Z",
          "updatedAt": "2017-05-25T07:03:13Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3853ae2a5a5a2e98601affe38e8bc353bf3318b5",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "cache-digest-iana-patch",
      "headRefOid": "0ee448d652e5114c87ced9e54bbae8a21c6da463",
      "mergeCommit": {
        "oid": "a2ff3ce9da5b042d14842bc90b30ea13fbe69847"
      }
    },
    {
      "number": 353,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIyNTMzNzQ4",
      "title": "adjust the explanation why it is difficult to generate the header block of a final response immediately",
      "url": "https://github.com/httpwg/http-extensions/pull/353",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "early-hints"
      ],
      "body": "based on the suggestion in https://lists.w3.org/Archives/Public/ietf-http-wg/2017AprJun/0147.html",
      "createdAt": "2017-05-25T21:50:18Z",
      "updatedAt": "2017-05-30T01:38:25Z",
      "closedAt": "2017-05-30T01:38:25Z",
      "mergedAt": "2017-05-30T01:38:25Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "339ac0fff9524f04e80dfc48db4f3ba3eb8963f6",
      "headRepository": "kazuho/http-extensions",
      "headRefName": "kazuho/intro",
      "headRefOid": "1fde8fc80296e68d9934a2dd6ea45e1027213b90",
      "mergeCommit": {
        "oid": "3efc639b142da8a480f72e0fcfdb2a04dfac24e2"
      }
    },
    {
      "number": 354,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIyNTU2MTQ5",
      "title": "add example",
      "url": "https://github.com/httpwg/http-extensions/pull/354",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "early-hints"
      ],
      "body": "Adds an example showing how 103 can be used.",
      "createdAt": "2017-05-26T01:16:05Z",
      "updatedAt": "2017-05-30T01:34:16Z",
      "closedAt": "2017-05-30T01:34:16Z",
      "mergedAt": "2017-05-30T01:34:16Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "339ac0fff9524f04e80dfc48db4f3ba3eb8963f6",
      "headRepository": "kazuho/http-extensions",
      "headRefName": "kazuho/early-hints/add-example",
      "headRefOid": "277c3303ddd9395cda751f7013299a5f5bdb03fa",
      "mergeCommit": {
        "oid": "a6090ca5555c9de82604beb9dc66c16398d580fb"
      }
    },
    {
      "number": 357,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI0NjM2NzIw",
      "title": "improve the wording: \"client MUST NOT process\" ",
      "url": "https://github.com/httpwg/http-extensions/pull/357",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "early-hints"
      ],
      "body": "This is a PR that essentially rebases the change proposed in #319.\r\n\r\nTo me the change proposed by @royfielding is a clear improvement. I believe that we should merge this.",
      "createdAt": "2017-06-08T12:20:58Z",
      "updatedAt": "2017-06-13T09:25:24Z",
      "closedAt": "2017-06-13T09:25:24Z",
      "mergedAt": "2017-06-13T09:25:24Z",
      "mergedBy": "kazuho",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c802542acc841e1f62e23184b96d0906e55c639f",
      "headRepository": "kazuho/http-extensions",
      "headRefName": "kazuho/revive-319",
      "headRefOid": "59f8b1ae784057cb646bdafa8c601a425dc81560",
      "mergeCommit": {
        "oid": "d83ec365fb144426678a073b897183c3a3d77f46"
      }
    },
    {
      "number": 361,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI3NTYxOTMz",
      "title": "Address client-hints-04 feedback",
      "url": "https://github.com/httpwg/http-extensions/pull/361",
      "state": "MERGED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "See https://github.com/httpwg/http-extensions/issues/359, https://github.com/httpwg/http-extensions/issues/360.",
      "createdAt": "2017-06-26T20:57:14Z",
      "updatedAt": "2018-04-03T17:52:58Z",
      "closedAt": "2017-07-21T15:04:21Z",
      "mergedAt": "2017-07-21T15:04:21Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Oh, one thing -- you removed Downlink. It'd be good to mention that in the change notes, and on list, so people are aware.",
          "createdAt": "2017-06-27T04:21:50Z",
          "updatedAt": "2017-06-27T04:21:50Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Thanks guys, pushed a few more updates. \r\n\r\n@reschke everything else looks good? If so I'll squash+push a new draft.",
          "createdAt": "2017-06-27T07:44:27Z",
          "updatedAt": "2017-06-27T07:44:27Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@reschke can you take another pass, please? Want to make sure we caught all of your feedback here.",
          "createdAt": "2017-07-02T07:54:14Z",
          "updatedAt": "2017-07-02T07:54:14Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@reschke merging. If you have any followup feedback, we can open a new issue.",
          "createdAt": "2017-07-21T15:04:58Z",
          "updatedAt": "2017-07-21T15:04:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MjUxMjI=",
          "commit": {
            "abbreviatedOid": "78a0a61"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM. I suspect you might have people bring up further nits about the boilerplate, etc. in IETF LC, but let's let them raise them (gives people something to do :)\r\n\r\nGo ahead and ship a new draft and we'll kick it down the road.",
          "createdAt": "2017-06-27T01:30:48Z",
          "updatedAt": "2017-06-27T01:30:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NTM5NTQ=",
          "commit": {
            "abbreviatedOid": "d7c6aa3"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-27T06:33:23Z",
          "updatedAt": "2017-06-27T06:33:24Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This doesn't seem to be consistent with https://tools.ietf.org/html/rfc8174#section-2",
              "createdAt": "2017-06-27T06:33:24Z",
              "updatedAt": "2017-07-21T14:55:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjYwNzk=",
          "commit": {
            "abbreviatedOid": "d7c6aa3"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-27T07:42:47Z",
          "updatedAt": "2017-06-27T07:42:48Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Good catch, looks like I took the text from outdated draft.",
              "createdAt": "2017-06-27T07:42:48Z",
              "updatedAt": "2017-07-21T14:55:57Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1971ad142550190423608a45ba4213d1a59508dc",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ch-feedback",
      "headRefOid": "b742630a1f109146b4bab553dadb7ae63b1e34ce",
      "mergeCommit": {
        "oid": "110d0cbb199d27b9ea27f294222e002979ca5981"
      }
    },
    {
      "number": 362,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI3NjAwMjIz",
      "title": "Contributing",
      "url": "https://github.com/httpwg/http-extensions/pull/362",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "meta"
      ],
      "body": "Revise contributing.md to reflect our working practices more closely.\r\n\r\nSpecifically, editors can make proposals in the drafts that close issues, as long as they remember to label them `proposal`.\r\n\r\nThis is more aligned with the quicwg process; it's different (they use `has-consensus`) because we have a large number of existing issues with consensus.",
      "createdAt": "2017-06-27T02:23:20Z",
      "updatedAt": "2017-10-13T02:23:07Z",
      "closedAt": "2017-10-13T02:23:05Z",
      "mergedAt": "2017-10-13T02:23:05Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@mcmanus I changed this to just be like the QUIC process, where we flag things with `has-consensus` after the issue is confirmed on-list, just like QUIC. I think that will cause less confusion (esp. since I see Martin starting to adopt `has-consensus` in his WGs), and we don't **have** to flag everything with consensus as such, especially for non-controversial drafts. WDYT?",
          "createdAt": "2017-09-29T06:20:36Z",
          "updatedAt": "2017-09-29T06:20:36Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "whoami to stand in the way of github progress? merge it!",
          "createdAt": "2017-09-29T13:31:59Z",
          "updatedAt": "2017-09-29T13:31:59Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "I'm seeing a few (but very few) occurrences of the word \"we\" which plays a bit against \"you\" and may make newcomers feel a bit of resistance (ie: we decide, you abide). I think it's important to keep in mind to use \"the group\" or something like this instead to avoid newcomers thinking that decisions are taken by a few people as is often the case in opensource projects for example, and make them realize that by participating they become part of this group.",
          "createdAt": "2017-09-30T05:02:38Z",
          "updatedAt": "2017-09-30T05:02:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hm. I read 'we' as being inclusive -- literally, \"the reader along with others.\" \r\n\r\nFurther up (in existing text) is:\r\n\r\n> To be active in the Working Group, you can participate in any of these places. Most activity takes place on the mailing list, but if you just want to comment on and raise issues, that's fine too.\r\n\r\nI'm happy to expand that to make it clear that \"we\" is \"all participants\" -- would that help?",
          "createdAt": "2017-09-30T05:30:39Z",
          "updatedAt": "2017-09-30T05:30:39Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "Semantically I agree with your view and share it as well, but keep in mind we're talking to people completely external to this group and thinking whether or not they're going to join by reading this file serving as a rule. Maybe indeed adding a line after the one you quoted saying 'Anyone participating to a discussion or an issue automatically becomes part of the Working Group, sometimes referred to as \"we\" in this document'. But in general I think that \"we\" should be avoided as it rarely includes \"you\", especially when there are probably 2 or 3 occurrences only.\r\n",
          "createdAt": "2017-09-30T05:40:33Z",
          "updatedAt": "2017-09-30T05:40:33Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK. I added an explicit statement about \"membership\" at the top -- that should clarify things. I don't think that with that context \"we\" is harmful or misleading.",
          "createdAt": "2017-10-01T15:29:35Z",
          "updatedAt": "2017-10-01T15:29:35Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "OK fine, thanks.",
          "createdAt": "2017-10-01T16:06:00Z",
          "updatedAt": "2017-10-01T16:06:00Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "382669c2d16d3a02e81b42edb20bac8220782df7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "contributing",
      "headRefOid": "4a3bcb809b2cb702ade8062f7874f1cd4fbc9e94",
      "mergeCommit": {
        "oid": "c33218f7698e6d0e30c127d8908bfbef16b10644"
      }
    },
    {
      "number": 363,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI3NjA2MjAy",
      "title": "fix contradictory definintions with HTTP/1.1",
      "url": "https://github.com/httpwg/http-extensions/pull/363",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "early-hints"
      ],
      "body": "* removes statements that are either redundant or contradicts with RFC 7230, 7231\r\n* clarifies how a server is expected to do when generating a response",
      "createdAt": "2017-06-27T03:38:25Z",
      "updatedAt": "2017-07-11T06:04:31Z",
      "closedAt": "2017-07-11T05:59:42Z",
      "mergedAt": "2017-07-11T05:59:42Z",
      "mergedBy": "kazuho",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While it is not required to specify how an intermediary might behave, doing so might be beneficial as suggested in https://github.com/httpwg/http-extensions/pull/363#discussion_r124179796.\r\n\r\nWe could possibly have something like the following below the example.\r\n\r\n> As is the case with any informational response, a server might emit more than one 103 (Early Hints) responses prior to sending a final response. This can happen for example when a caching intermediary generates a 103 (Early Hints) response based on the header fields of a stale-cached response, then forwards a 103 (Early Hints) response and a final response that were sent from the origin in response to a revalidation request.\r\n",
          "createdAt": "2017-06-27T07:54:24Z",
          "updatedAt": "2017-06-27T07:55:46Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "works for me.\n\n",
          "createdAt": "2017-06-27T08:10:27Z",
          "updatedAt": "2017-06-27T08:10:27Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@wtarreau Thank you for the answer. Adopted the text (with nits) in d0903d6.",
          "createdAt": "2017-07-07T03:30:15Z",
          "updatedAt": "2017-07-07T03:30:15Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot Thank you for the review!",
          "createdAt": "2017-07-11T06:04:31Z",
          "updatedAt": "2017-07-11T06:04:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MzgzNDM=",
          "commit": {
            "abbreviatedOid": "8550922"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-27T03:47:34Z",
          "updatedAt": "2017-06-27T03:49:01Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "All intermediaries, including proxies, or just gateways? Having proxies generate this might surprise some.",
              "createdAt": "2017-06-27T03:47:34Z",
              "updatedAt": "2017-07-07T03:29:24Z"
            },
            {
              "originalPosition": 23,
              "body": "What's the intent here -- to require headers in the 103 to be repeated in the final response? Editorial issue aside, that seems like it might always work; e.g., when the 103 headers are speculative.",
              "createdAt": "2017-06-27T03:48:47Z",
              "updatedAt": "2017-07-07T03:29:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0Mzk0MzM=",
          "commit": {
            "abbreviatedOid": "8550922"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-27T04:00:43Z",
          "updatedAt": "2017-06-27T04:00:44Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "> to require headers in the 103 to be repeated in the final response?\r\n\r\nCorrect.\r\n\r\nEven though the current version of the draft states that evaluation of the header fields included in a 103 response is speculative, it does not provide a guidance in how a server is expected to generate a response.\r\n\r\nThe issue was pointed out by @reschke  (please refer to the last paragraph on https://lists.w3.org/Archives/Public/ietf-http-wg/2017AprJun/0220.html), and I think that it would be beneficial for us to specify it.",
              "createdAt": "2017-06-27T04:00:43Z",
              "updatedAt": "2017-07-07T03:29:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0Mzk2NzA=",
          "commit": {
            "abbreviatedOid": "8550922"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-27T04:03:36Z",
          "updatedAt": "2017-06-27T04:03:36Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I had proxies in mind as well.\r\n\r\nIf people are going to find such action to be taken by a proxy as a surprise, I am not against removing the paragraph as a whole (since IMO a gateway could do that regardless of what the specification states (or not)).",
              "createdAt": "2017-06-27T04:03:36Z",
              "updatedAt": "2017-07-07T03:29:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDA5Mjc=",
          "commit": {
            "abbreviatedOid": "8550922"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-27T04:20:17Z",
          "updatedAt": "2017-06-27T04:20:17Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Hm. I can imagine cases where the origin wants to \"target\" the hints at an intermediary, but not have them replayed from cache. Is it necessary to use a MUST NOT here, or do we just need to give guidance? ",
              "createdAt": "2017-06-27T04:20:17Z",
              "updatedAt": "2017-07-07T03:29:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDA5NjA=",
          "commit": {
            "abbreviatedOid": "8550922"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-27T04:20:48Z",
          "updatedAt": "2017-06-27T04:20:48Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I think it would be best to leave it unspecified, personally.",
              "createdAt": "2017-06-27T04:20:48Z",
              "updatedAt": "2017-07-07T03:29:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDIwNTE=",
          "commit": {
            "abbreviatedOid": "8550922"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-27T04:34:18Z",
          "updatedAt": "2017-06-27T04:34:18Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Do you think changing this to `SHOULD NOT` would be sufficient? Your suggestion makes sense.\r\n\r\nThe other scenario that I can think of would be a caching intermediary sending 103 based on a stale-cached response, while contacting the origin for revalidation. Changing this to SHOULD NOT will give us more room to perform these kind of operations. If this was a MUST NOT, an intermediary cannot do that without risking the possibility of breaking the specification.",
              "createdAt": "2017-06-27T04:34:18Z",
              "updatedAt": "2017-07-07T03:29:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDI2ODk=",
          "commit": {
            "abbreviatedOid": "8550922"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-27T04:41:33Z",
          "updatedAt": "2017-06-27T04:41:33Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I was thinking more of making it advisory text only (requirements affect conformance, and this really is a judgement call). E.g.,\r\n\r\n> Typically, servers will include the headers sent in 103 (Early Hints) in the final response as well. However, there might be cases when this is not desirable, such as when the server learns that they are not correct before the final response is sent, or the server does not wish them to be cached.",
              "createdAt": "2017-06-27T04:41:33Z",
              "updatedAt": "2017-07-07T03:29:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDQ4NjQ=",
          "commit": {
            "abbreviatedOid": "8550922"
          },
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-27T05:08:23Z",
          "updatedAt": "2017-06-27T05:08:23Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "@mnot: I like your proposed text. It emphasizes the speculative nature of what is presented in 103. Also I noticed that \"speculative\" is exactly the term that's missing in the document to explain the logics behind early hints and why the final value may slightly differ.",
              "createdAt": "2017-06-27T05:08:23Z",
              "updatedAt": "2017-07-07T03:29:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDU1NTQ=",
          "commit": {
            "abbreviatedOid": "8550922"
          },
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-27T05:16:52Z",
          "updatedAt": "2017-06-27T05:16:52Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I'd leave it with any intermediary. A good end-to-end example would involve a client not aware of 103, a caching proxy aware of 103, a gateway (reverse proxy) sending some links in 103 roughly based on the URL and a server knowing perfectly what to prefetch. When the gateway receives the request, it would immediately emit a 103 with 2-3 links which are generic to the site (eg: css, logo) and passes the request to the server. The server knows based on the URL that some JS is needed as well and could send an extra 103 with 2-3 more links while processing. The proxy receiving these 103 can start to prefetch these objects and populate its cache, then send some push promises to the client with these objects. That way the limitations of pushed resources (not cacheable, limited to connection etc) are significantly outcome as the client-side caching proxy can provide them very quickly again.",
              "createdAt": "2017-06-27T05:16:52Z",
              "updatedAt": "2017-07-07T03:29:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjgxMTk=",
          "commit": {
            "abbreviatedOid": "8550922"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-27T07:51:49Z",
          "updatedAt": "2017-06-27T07:51:50Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "@mnot Thank you for the text.\r\n\r\nI have adopted it in dc88612 with slight modifications. I've removed \"or the server does not wish them to be cached\" since IMO it might sound as an advice that 103 can be used a way to send signal to one client (that receives the informational response). Please let me know what you think.\r\n\r\n@wtarreau I agree that it makes sense to use the word \"speculative\" somewhere. The problem is where we should :-)",
              "createdAt": "2017-06-27T07:51:49Z",
              "updatedAt": "2017-07-07T03:29:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjgyNTQ=",
          "commit": {
            "abbreviatedOid": "8550922"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-27T07:52:28Z",
          "updatedAt": "2017-06-27T07:52:28Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "The text has been removed in 0154cce.",
              "createdAt": "2017-06-27T07:52:28Z",
              "updatedAt": "2017-07-07T03:29:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwODg4MTg=",
          "commit": {
            "abbreviatedOid": "d0903d6"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Looks good to me!",
          "createdAt": "2017-07-11T04:15:24Z",
          "updatedAt": "2017-07-11T04:15:24Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5dc0e0a5b47ae52545c554f34793d3d83b6cc5f5",
      "headRepository": "kazuho/http-extensions",
      "headRefName": "kazuho/early-hints/wglc",
      "headRefOid": "d0903d61c8e591c800ca22534dd3e46b761737ec",
      "mergeCommit": {
        "oid": "aa43c89e38ab982ba0e405e8dedd8fd2486b5682"
      }
    },
    {
      "number": 366,
      "id": "MDExOlB1bGxSZXF1ZXN0MTMwNzQ5MzM5",
      "title": "ORIGIN frame typos",
      "url": "https://github.com/httpwg/http-extensions/pull/366",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Make optionallity more like ALTSVC, make test less Gollum-like",
      "createdAt": "2017-07-16T12:19:36Z",
      "updatedAt": "2017-07-16T12:46:40Z",
      "closedAt": "2017-07-16T12:33:21Z",
      "mergedAt": "2017-07-16T12:33:20Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "thx",
          "createdAt": "2017-07-16T12:33:24Z",
          "updatedAt": "2017-07-16T12:33:24Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e1833b1e9a319f3a53c8c057daaa939122b4617d",
      "headRepository": "LPardue/http-extensions",
      "headRefName": "patch-2",
      "headRefOid": "a70ef5e14ee27a97584b9820c31cd662830ab3f1",
      "mergeCommit": {
        "oid": "7398075de66b376c8275e5e7dba73a6bfce96ec0"
      }
    },
    {
      "number": 367,
      "id": "MDExOlB1bGxSZXF1ZXN0MTMwNzU2NjY1",
      "title": "simplify reference anchors",
      "url": "https://github.com/httpwg/http-extensions/pull/367",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-07-16T16:14:50Z",
      "updatedAt": "2017-12-13T07:18:44Z",
      "closedAt": "2017-07-17T20:38:10Z",
      "mergedAt": "2017-07-17T20:38:10Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Thanks Julian!",
          "createdAt": "2017-07-17T20:38:05Z",
          "updatedAt": "2017-07-17T20:38:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0NDAxNDE=",
          "commit": {
            "abbreviatedOid": "f238bb0"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-07-17T20:37:51Z",
          "updatedAt": "2017-07-17T20:37:51Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7398075de66b376c8275e5e7dba73a6bfce96ec0",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ref-anchors",
      "headRefOid": "f238bb0358323ccbd90bf8ed21566f458576bf9d",
      "mergeCommit": {
        "oid": "1971ad142550190423608a45ba4213d1a59508dc"
      }
    },
    {
      "number": 373,
      "id": "MDExOlB1bGxSZXF1ZXN0MTMxODEyMTg3",
      "title": "Scope Accept-CH opt-in to same origin",
      "url": "https://github.com/httpwg/http-extensions/pull/373",
      "state": "MERGED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "WIP, based on discussion in #372.",
      "createdAt": "2017-07-21T16:30:26Z",
      "updatedAt": "2019-06-05T20:17:54Z",
      "closedAt": "2017-10-27T18:47:47Z",
      "mergedAt": "2017-10-27T18:47:47Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@arturjanc thanks for the review. Took another run, with a few large updates:\r\n\r\n- Accept-CH and Accept-CH-Lifetime should be processed for responses originating from potentially trustworthy origins (i.e. HTTPS-only)\r\n- Accept-CH-Lifetime preference should be double-keyed, per discussion in #372.\r\n- Consolidated security guidance in one section + tried to rewrite that in light of above updates.\r\n\r\nI couldn't find any good existing spec examples on double-keying, so would appreciate any guidance on how to explain it here well. \r\n\r\n@mnot ptal as well, as this is a substantive update.\r\n\r\n/cc @tarunban @yoavweiss",
          "createdAt": "2017-07-28T18:38:49Z",
          "updatedAt": "2017-07-28T18:38:49Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson @mnot thanks for the feedback! Updated, ptal.",
          "createdAt": "2017-10-06T18:51:10Z",
          "updatedAt": "2017-10-06T18:51:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Looks better.",
          "createdAt": "2017-10-10T00:19:04Z",
          "updatedAt": "2017-10-10T00:19:04Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@martinthomson thanks for the thorough review (and patience :)), again! Updated, ptal.",
          "createdAt": "2017-10-13T21:28:45Z",
          "updatedAt": "2017-10-13T21:28:45Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> the opt-ins are limited to secure transport, but the actual hints are not. Is that correct? If so, should we change it?\r\n\r\nI don't think that's necessary. This is implicit due to requirement for opt-in over secure transport \u2014 i.e. only secure origins can opt-in to receive hints and HTTPS-only is the new default policy for all hints.",
          "createdAt": "2017-10-27T18:22:21Z",
          "updatedAt": "2017-10-27T18:22:21Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "> @mnot I think it'd be good to see #373 in situ; from what I see in the patch, I think it's strictly better. No guarantees that there aren't other issues, or that this isn't completely covered, but personally I think it's better. - https://github.com/httpwg/http-extensions/issues/372#issuecomment-339513412\r\n\r\nSquashed & merged. @martinthomson thanks for your help here and let me know if there is anything else I should address (in a separate PR :)). ",
          "createdAt": "2017-10-27T18:50:09Z",
          "updatedAt": "2017-10-27T18:50:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MjQ1NTM=",
          "commit": {
            "abbreviatedOid": "a80ad96"
          },
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-07-22T15:11:11Z",
          "updatedAt": "2017-07-22T15:17:05Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I'm worried about this being a little vague. It seems that there would be a benefit to specifying the \"policies and mechanisms\" mentioned in this para because they might be crucial to ensuring the privacy properties of a given implementation.",
              "createdAt": "2017-07-22T15:11:11Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 35,
              "body": "I would make this stronger:\r\n1. Hints shouldn't provide information that isn't available via the usual channels.\r\n2. Hints sent for subresource requests shouldn't carry information not available to the provider of the subresource unless the first-party opts into sending hints (note that this, combined with the same-origin restriction, would likely suggest some form of double-keying)",
              "createdAt": "2017-07-22T15:16:37Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5OTU5OTc=",
          "commit": {
            "abbreviatedOid": "4e0f1d6"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "A few things I saw. Overall I think this approach looks good. Still need to see the whole spec after changes before doing a final review; need to see it in situ (and I suspect others will too).",
          "createdAt": "2017-08-03T05:19:26Z",
          "updatedAt": "2017-08-03T05:23:47Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Is the intent of including 'intermediary proxy' to include CDNs, or to also include forward proxies? If it's just CDN/reverse proxies, I'd remove it; it's widely understood that they're acting as a server. 'intermediary proxy' means \"forward proxy\" and I don't think you want that.",
              "createdAt": "2017-08-03T05:19:26Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 25,
              "body": "This reads as if you can either have a secure origin OR include the HTML meta tag to get Accept-CH processed; is that the intent?",
              "createdAt": "2017-08-03T05:21:02Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 40,
              "body": "Age in relation to what?",
              "createdAt": "2017-08-03T05:22:07Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwMDkxODU=",
          "commit": {
            "abbreviatedOid": "4e0f1d6"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-03T07:08:30Z",
          "updatedAt": "2017-08-03T07:28:46Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "The addition of the reference to SECURE-CONTEXTS is new here, and unnecessary.  The requirement here is not that the context is secure (that's a notion that belongs to the web, not HTTP generally), but that the `Accept-CH` is both authentic and integrity protected.  You should limit the use of `Accept-CH` to HTTPS.",
              "createdAt": "2017-08-03T07:08:30Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 50,
              "body": "\"double-keyed\" is a new concept for the protocol here, and one that (again) really only makes sense on the web.  The property that you are looking for is that the persisted state is bound to the origin.  You should allow it to be more narrowly bound, but the point is to constrain its maximum scope.  Choosing a narrower scope is a discretionary thing that might be done by web browsers.\r\n\r\nAlso, I find the phrasing of this last bit cumbersome and hard to follow.  The point is that permission to persist might be scope (see above).",
              "createdAt": "2017-08-03T07:12:18Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 71,
              "body": "The term you are looking for here is \"linkability\" or \"linkable\".  The more information that a request contains, the more likely an adversary is to be able to correctly identify two requests as belonging to the same user agent (i.e., link the two).\r\n\r\nThe claim here (reducing the accuracy of field values) isn't generically true.  I believe that it is true for the hints defined in this document, but the structure of this document is such that it might be taken as a universal truth.  For something like the proposed Geolocation header field, which is a continuous-valued field, this claim would be false (read [Section 13.5 of RFC 6772](https://tools.ietf.org/html/rfc6772#section-13.5) for background).",
              "createdAt": "2017-08-03T07:19:57Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 77,
              "body": "should is not sufficient here: information that is persisted for an origin MUST be reset when any action that is designed to break linkability is executed (clearing cookies is one such action)",
              "createdAt": "2017-08-03T07:21:56Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 78,
              "body": "MAY is extremely weak and \"may\" is even weaker.  It seems like these are generally fixed values, akin to User-Agent, but others thus far proposed (see again Geolocation) aren't.  It seems like the advice here is intended to be generic, so what are the criteria an implementation might use to decide to send or suppress these fields if cookies are not being sent?",
              "createdAt": "2017-08-03T07:25:41Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 80,
              "body": "You don't want to make this claim.  It's fairly easy to show it as false.  If your claim is that the incremental increase in linkability (over not sending hints) is reduced significantly, that might be true, but I doubt that also.  This is making a trade-off - if the information is basically already available via User-Agent or script, then this isn't a big increase, but in other cases it could be a big change.",
              "createdAt": "2017-08-03T07:28:16Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NDM1MzY=",
          "commit": {
            "abbreviatedOid": "4e0f1d6"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-10-06T17:40:23Z",
          "updatedAt": "2017-10-06T17:40:23Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Ack, removed.",
              "createdAt": "2017-10-06T17:40:23Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NDY3MTQ=",
          "commit": {
            "abbreviatedOid": "4e0f1d6"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-10-06T17:52:15Z",
          "updatedAt": "2017-10-06T17:52:15Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Ack, updated.",
              "createdAt": "2017-10-06T17:52:15Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NTQ3Nzg=",
          "commit": {
            "abbreviatedOid": "4e0f1d6"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-10-06T18:23:11Z",
          "updatedAt": "2017-10-06T18:23:12Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Ack, took a run at rewriting this.",
              "createdAt": "2017-10-06T18:23:11Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NTU0MzA=",
          "commit": {
            "abbreviatedOid": "4e0f1d6"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-10-06T18:25:40Z",
          "updatedAt": "2017-10-06T18:25:40Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Ack, updated.",
              "createdAt": "2017-10-06T18:25:40Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NTYwMDU=",
          "commit": {
            "abbreviatedOid": "4e0f1d6"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-10-06T18:27:43Z",
          "updatedAt": "2017-10-06T18:27:43Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Ack, updated.",
              "createdAt": "2017-10-06T18:27:43Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NTg2MDI=",
          "commit": {
            "abbreviatedOid": "4e0f1d6"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-10-06T18:37:54Z",
          "updatedAt": "2017-10-06T18:37:54Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Ack, dropped.",
              "createdAt": "2017-10-06T18:37:54Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3NTg2MTg=",
          "commit": {
            "abbreviatedOid": "4e0f1d6"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-10-06T18:37:58Z",
          "updatedAt": "2017-10-06T18:37:58Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "This is a tricky one. Took an attempt at rewriting it -- ptal.",
              "createdAt": "2017-10-06T18:37:58Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgxNDMwNTY=",
          "commit": {
            "abbreviatedOid": "4f04666"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-10-10T00:35:34Z",
          "updatedAt": "2017-10-10T04:08:06Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "This sentence needs to be split up for readability.  I think that you have many clauses here.  Client hints can be carried in HTTP headers.  The client will only send client hints if the origin explicitly indicates that it supports them.  The server indicates support using the Accept-CH header field.  Support can be indicated using Accept-CH that is carried in meta-equivalent tags in HTML.  The client will only send client hints for requests with an https scheme.",
              "createdAt": "2017-10-10T00:35:34Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 35,
              "body": "\"sent Accept-CH preference\" is an odd grammatical construct.  How about simply \"the set of client hints that the server supports (or prefers)\"?",
              "createdAt": "2017-10-10T03:47:31Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 42,
              "body": "Same sentence structure as before.  Easier to read this time, but why not just come right out and say it?  A server's preferences regarding client hints MUST NOT be persisted for an origin that isn't HTTPS.",
              "createdAt": "2017-10-10T03:49:13Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 51,
              "body": "Use origins rather than names.  Also, foo.com is a real name and you should use foo.example.com instead.",
              "createdAt": "2017-10-10T03:49:49Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 60,
              "body": "I don't think that the word \"proactive\" is correct.  \"Proactive content negotiation\" would involve the server taking extra action (like ringing your high school music teacher) to find out what you might prefer.  For example, \"proactive\" might be used to describe what the advertising industry does to ensure that you are provided with relevant advertising.",
              "createdAt": "2017-10-10T03:51:25Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 63,
              "body": "SHOULD NOT?  Also \"via other means, such as using HTML, CSS, or JavaScript\"",
              "createdAt": "2017-10-10T03:51:39Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 69,
              "body": "The cache clearing thing appears here as an aside.  I think that you want a complete paragraph on this.  (And a MUST).",
              "createdAt": "2017-10-10T03:54:04Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 69,
              "body": "Again with the \", delivered over secure transport,\".",
              "createdAt": "2017-10-10T03:54:31Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 69,
              "body": "The server opt-in isn't really a security mechanism.  The adversary here is the server.  I would remove this item from the list.",
              "createdAt": "2017-10-10T03:55:01Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 70,
              "body": "This doesn't really work.  We don't regulate the use of cookies, so it is trivial for your adversary (the server) to construct a cookie if that causes the client hints to be sent to it.\r\n\r\nIf we scratch this and the second item, that reduces the entire set of protections to \"ask the user\", which isn't very satisfying.  Maybe there is something here that could be extracted, but this text doesn't do it.\r\n\r\nTake one sort of coincidental signal that the user might generate: they actively choose to send a password to the server.  This might be argued to indicate that further identification is acceptable to that user.  But passwords are - if the user follows good practices - origin-specific, and so the act of sending a password does not inherently create linkability.\r\n\r\nWhat you want to look for is a signal that the user is OK to link their activity here with activity elsewhere.  That's a whole lot harder, especially since we try really hard to avoid creating inadvertent or secondary signals like that.",
              "createdAt": "2017-10-10T03:59:55Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            },
            {
              "originalPosition": 63,
              "body": "This is better, but it fails to recognize that some information can leak, even when attempts are made to obscure it.  I would add a note saying something like \"Reducing the set of values that can be expressed in client hints can improve privacy by ensuring that the same value is sent by multiple users, but this can be insufficient for some types of data, especially data that can change over time.\"  That would address my concern regarding the possibility of a Geolocation header field that is a client hint.  (I would retain a host of other concerns about such a proposal, but you can't be expected to address all of those here.)",
              "createdAt": "2017-10-10T04:07:58Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkzNDgyMTg=",
          "commit": {
            "abbreviatedOid": "4f04666"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-10-13T20:54:35Z",
          "updatedAt": "2017-10-13T20:54:35Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "I believe we use \"proactive\" and \"server-driven\" interchangeably, so current language is OK. That said, I'll defer to @mnot and @mcmanus. ",
              "createdAt": "2017-10-13T20:54:35Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkzNDg0Njk=",
          "commit": {
            "abbreviatedOid": "4f04666"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-10-13T20:55:41Z",
          "updatedAt": "2017-10-13T20:55:41Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "ack",
              "createdAt": "2017-10-13T20:55:41Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkzNDk5OTQ=",
          "commit": {
            "abbreviatedOid": "4f04666"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-10-13T21:02:52Z",
          "updatedAt": "2017-10-13T21:02:52Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Thanks good suggestions, tried to rewrite and work this into current text.",
              "createdAt": "2017-10-13T21:02:52Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkzNTExMTc=",
          "commit": {
            "abbreviatedOid": "4f04666"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-10-13T21:08:11Z",
          "updatedAt": "2017-10-13T21:08:11Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Good call, mixing may/must's here.. Moved it into a separate section.",
              "createdAt": "2017-10-13T21:08:11Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkzNTQ4Njc=",
          "commit": {
            "abbreviatedOid": "4f04666"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-10-13T21:27:39Z",
          "updatedAt": "2017-10-13T21:27:39Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "The HTTPS requirement we're adding in this update helps scope down our list of adversaries: before we were also considering passive observers, now we're scoped to the response server.  With that in mind, good point on regulating cookies: with server as adversary it's not a meaningful protection.\r\n\r\nThat said, I think the broader \"may avoid transmitting some or all of CH header fields\" can be a valid recommendation. I'll drop the cookies and referrer text.",
              "createdAt": "2017-10-13T21:27:39Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIwODg5NTg=",
          "commit": {
            "abbreviatedOid": "b4ef4d0"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Overall looks good. IIUC, the opt-ins are limited to secure transport, but the actual hints are not. Is that correct? If so, should we change it?",
          "createdAt": "2017-10-26T06:29:57Z",
          "updatedAt": "2017-10-26T06:39:00Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Nit: s/be be/be/",
              "createdAt": "2017-10-26T06:29:57Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1ODg2MTc=",
          "commit": {
            "abbreviatedOid": "b4ef4d0"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-10-27T18:15:54Z",
          "updatedAt": "2017-10-27T18:15:54Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Ack. Good catch.",
              "createdAt": "2017-10-27T18:15:54Z",
              "updatedAt": "2017-10-27T18:31:24Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1e638f8cb5f638c648c9bc4c2230a57728ff1b4e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ch-same-origin",
      "headRefOid": "0caa65480bc3011b5c44f46ebd0b60223d72f22a",
      "mergeCommit": {
        "oid": "d85cc9d8e49cff59cf97e30fe140d3155618c6c7"
      }
    },
    {
      "number": 375,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM0MDg1NjE4",
      "title": "better clarify the differences between H2 server push",
      "url": "https://github.com/httpwg/http-extensions/pull/375",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "following the discussion on [this thread](https://lists.w3.org/Archives/Public/ietf-http-wg/2017JulSep/0164.html)",
      "createdAt": "2017-08-04T03:46:45Z",
      "updatedAt": "2017-08-07T05:24:00Z",
      "closedAt": "2017-08-07T05:24:00Z",
      "mergedAt": "2017-08-07T05:23:59Z",
      "mergedBy": "kazuho",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyNzgwMjM=",
          "commit": {
            "abbreviatedOid": "2a1688d"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T04:31:31Z",
          "updatedAt": "2017-08-04T04:31:31Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "s/if/whether/",
              "createdAt": "2017-08-04T04:31:31Z",
              "updatedAt": "2017-08-04T05:41:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyODM2Mjc=",
          "commit": {
            "abbreviatedOid": "2a1688d"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T05:42:02Z",
          "updatedAt": "2017-08-04T05:42:02Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "@martinthomson Thank you! Applied the change in 8168216.",
              "createdAt": "2017-08-04T05:42:02Z",
              "updatedAt": "2017-08-04T05:42:02Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "85f58fa3025eebfed79400089d7fa3995c9a1694",
      "headRepository": "kazuho/http-extensions",
      "headRefName": "kazuho/early-hints/h2-push-comparison",
      "headRefOid": "816821662dfb84197adf5bf0d2fe427fd64809d1",
      "mergeCommit": {
        "oid": "7102795f341b9b0af48d289a5e461abfac373791"
      }
    },
    {
      "number": 376,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM0MTIyMDM3",
      "title": "fix list rule reference",
      "url": "https://github.com/httpwg/http-extensions/pull/376",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "",
      "createdAt": "2017-08-04T09:06:43Z",
      "updatedAt": "2017-10-09T23:41:10Z",
      "closedAt": "2017-10-09T23:41:06Z",
      "mergedAt": "2017-10-09T23:41:06Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "83606e8f14e8a52b2298eb4d60a2944480d78dbc",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "list-rule-fix",
      "headRefOid": "31c4c07c36a7afd9ed7cf57d1a49e350a87025a1",
      "mergeCommit": {
        "oid": "f6f61e0cf09578c6b006a447858bb78648976fc6"
      }
    },
    {
      "number": 377,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM0MzAyODU4",
      "title": "improve service workers reference",
      "url": "https://github.com/httpwg/http-extensions/pull/377",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-08-05T19:45:04Z",
      "updatedAt": "2017-12-13T07:15:48Z",
      "closedAt": "2017-08-05T23:22:11Z",
      "mergedAt": "2017-08-05T23:22:11Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2017-08-05T23:22:16Z",
          "updatedAt": "2017-08-05T23:22:16Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "83606e8f14e8a52b2298eb4d60a2944480d78dbc",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-2",
      "headRefOid": "e41e468ff69c84df4cf4f1b8eb646e9877179f7e",
      "mergeCommit": {
        "oid": "285f20482509f9a3f1cccefd21eb29aad85a3100"
      }
    },
    {
      "number": 378,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM0MzAzMTE5",
      "title": "improve RICE reference",
      "url": "https://github.com/httpwg/http-extensions/pull/378",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-08-05T19:53:22Z",
      "updatedAt": "2017-12-13T07:15:46Z",
      "closedAt": "2017-08-05T23:21:36Z",
      "mergedAt": "2017-08-05T23:21:36Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2017-08-05T23:21:41Z",
          "updatedAt": "2017-08-05T23:21:41Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "83606e8f14e8a52b2298eb4d60a2944480d78dbc",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-5",
      "headRefOid": "821141b5b1c8b23aca6926caa8fa0ec4d315b81a",
      "mergeCommit": {
        "oid": "1718e4cb96c3cec75dfad708ceef2c1bc669a56b"
      }
    },
    {
      "number": 379,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM0MzI5ODUx",
      "title": "ref formatting",
      "url": "https://github.com/httpwg/http-extensions/pull/379",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-08-06T15:16:00Z",
      "updatedAt": "2017-12-13T07:15:45Z",
      "closedAt": "2017-08-09T05:10:39Z",
      "mergedAt": "2017-08-09T05:10:39Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "285f20482509f9a3f1cccefd21eb29aad85a3100",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-7",
      "headRefOid": "047b18e95692828af11271313d586277d84ad386",
      "mergeCommit": {
        "oid": "03e5e420b75b196a9de6851d46742d7b0f3d1598"
      }
    },
    {
      "number": 380,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM0MzY0NDk3",
      "title": "clarify multi-103 behavior",
      "url": "https://github.com/httpwg/http-extensions/pull/380",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "early-hints"
      ],
      "body": "Clarify that the disappearance of a header field (that once existed in a 103 response) from the following 103 responses does not indicate the retraction of the expectation that the header field will be included in the final response.\r\n\r\ncloses #371 ",
      "createdAt": "2017-08-07T05:23:05Z",
      "updatedAt": "2017-08-11T04:00:33Z",
      "closedAt": "2017-08-11T04:00:33Z",
      "mergedAt": "2017-08-11T04:00:33Z",
      "mergedBy": "kazuho",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ecb2c7e clarifies the general rule that this PR relies on (i.e. the nonexistence of a header field in the 103 response cannot be used as a signal that the header field will be absent in the final response), at the same time addressing Spencer Dawkins' suggestion to clarify that \"the server can add header fields in the 200 that were not present in the 103.\"",
          "createdAt": "2017-08-07T06:43:21Z",
          "updatedAt": "2017-08-07T06:44:45Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7102795f341b9b0af48d289a5e461abfac373791",
      "headRepository": "kazuho/http-extensions",
      "headRefName": "kazuho/early-hints/headers-in-multiple-103",
      "headRefOid": "2f6f42de65505557e9ecf55dd9e5e6d7d567a3fa",
      "mergeCommit": {
        "oid": "393d38ec5432ce3a038b63a65ce4c7d511da8849"
      }
    },
    {
      "number": 381,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM0ODU3ODAz",
      "title": "RFC 2616 -> 723x",
      "url": "https://github.com/httpwg/http-extensions/pull/381",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "I left the term \"request-uri\" untouched (it was renamed in the base spec because it's not always a URI). We may want to change that separately, or even refer to the effective request URI (https://www.greenbytes.de/tech/webdav/rfc7230.html#effective.request.uri)",
      "createdAt": "2017-08-09T10:18:45Z",
      "updatedAt": "2018-04-03T17:53:06Z",
      "closedAt": "2018-01-08T10:25:52Z",
      "mergedAt": "2018-01-08T10:25:52Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mikewest  - ping?",
          "createdAt": "2017-12-30T15:28:19Z",
          "updatedAt": "2017-12-30T15:28:19Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "LGTM, thank you for the patch, and for the ping!",
          "createdAt": "2018-01-08T10:25:48Z",
          "updatedAt": "2018-01-08T10:25:48Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "03e5e420b75b196a9de6851d46742d7b0f3d1598",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-8-1",
      "headRefOid": "d128694f23e7e1e6b000040ce5f552cbf5480ca9",
      "mergeCommit": {
        "oid": "384661ba1176d129e78bfd56b1e7ae7987e7ec99"
      }
    },
    {
      "number": 384,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM1NzQ4Mjg5",
      "title": "reference format",
      "url": "https://github.com/httpwg/http-extensions/pull/384",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "estark37"
      ],
      "labels": [
        "editorial",
        "expect-ct"
      ],
      "body": "Make references consistent (both within the doc and across WG documents)",
      "createdAt": "2017-08-15T07:28:47Z",
      "updatedAt": "2017-12-13T07:16:26Z",
      "closedAt": "2017-10-05T05:15:46Z",
      "mergedAt": "2017-10-05T05:15:46Z",
      "mergedBy": "estark37",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9d132f190af52a523a928867e2ec9e52e2d24873",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-9",
      "headRefOid": "efe4331cf9de6584ad879a6fa8a7c12f5c2b68c8",
      "mergeCommit": {
        "oid": "32d9b943ae4a188cddb7a1a9bed9395d9c429429"
      }
    },
    {
      "number": 385,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM3Nzc2MzA3",
      "title": "ORIGIN: reject origins on non-authoritative connection.",
      "url": "https://github.com/httpwg/http-extensions/pull/385",
      "state": "CLOSED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "origin-frame"
      ],
      "body": "",
      "createdAt": "2017-08-26T00:02:48Z",
      "updatedAt": "2017-09-12T00:39:39Z",
      "closedAt": "2017-09-12T00:39:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot @enygren @mcmanus please take a look, the current draft is a bit underspecified when dealing with misbehaving servers. Also, I'm not sure if we should also add text saying that `servers MUST NOT send origins for which they are not authoritative`, since it's kind of given.",
          "createdAt": "2017-08-26T00:11:10Z",
          "updatedAt": "2017-08-26T00:11:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Shutting down the connection because the client doesn't like the server's authority seems too severe; given that clients can (and will) have different policies for establishing authority, this creates a strong incentive for the server to be very conservative.\r\n\r\nI could see a stream error; that gives information about what happened. ",
          "createdAt": "2017-08-28T08:17:07Z",
          "updatedAt": "2017-08-28T08:17:07Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe this could have been phrased better, but what I meant is the `subjectAltName` check mentioned in the sentence before, i.e. server sending an `ORIGIN` frame for a domain it didn't present the certificate for (either during initial TLS handshake or via `CERTIFICATE` frame), not the recommended CT and/or OCSP checks, since those will vary from browser to browser.\r\n\r\nThere is no mention of such scenario in the current draft, and it's unclear how clients should behave when it happens.\r\n\r\n`ORIGIN` frame applies to the whole connection and it's not sent on a particular stream, so I don't see how clients could send a stream error, really.",
          "createdAt": "2017-08-28T09:30:06Z",
          "updatedAt": "2017-08-28T09:30:06Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@PiotrSikora I think the concern is that the server does send a potential certificate but the client rejects its use with a particular ORIGIN due to client policy that is opaque to the server. (i.e. different trust roots, stored exceptions, etc..)",
          "createdAt": "2017-08-28T13:26:38Z",
          "updatedAt": "2017-08-28T13:26:38Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mcmanus Ah, that makes more sense, thanks!\r\n\r\nHowever, as of right now, the certificate cannot be rejected, because the only one is provided during initial TLS handshake, which means that if it's rejected, then there is no HTTP/2 connection to begin with.\r\n\r\nI agree that it gets a bit more complicated with the `CERTIFICATE` frame, especially because [the current draft, section 4](https://datatracker.ietf.org/doc/html/draft-bishop-httpbis-http2-additional-certs-04#section-4) allows implementations to not terminate the connection upon receiving invalid certificate, probably for the reasons mentioned by you.\r\n\r\nHowever, I feel a bit uncomfortable with a draft that doesn't even mention the malicious behavior, and doesn't define what clients should do in such cases.\r\n\r\nAt the very least, there are 2 cases to cover:\r\n\r\n1. Client connects to `https://evil.com` (certificate valid for `evil.com`), server sends `ORIGIN` frame for `https://bank.com`.\r\n\r\n2. Client connects to `https://evil.com` (certificate valid for `evil.com`), server sends `CERTIFICATE` frame with a certificate for `bank.com` signed by unknown CA, followed by an `ORIGIN` frame for `https://bank.com`.\r\n\r\nHow should clients behave in both of those cases? Neither is even mentioned in the current draft.\r\n\r\nFor the record, I'm fine if the consensus is different from what I suggested in this pull request, but I think that those cases should be mentioned and client behavior should be defined for them.",
          "createdAt": "2017-08-29T03:56:06Z",
          "updatedAt": "2017-08-29T03:56:06Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With coalescing, this still applies to the one certificate.  A connection might be good for `evil.com`, but not for `bank.com`, even when both appear in the same certificate.  That might be because `bank.com` has a pinning rule or Expect-CT or any one of a host of other reasons that a certificate might appear OK, but not be (the variety of reasons being why certificates are a nightmare of complexity).\r\n\r\nThis draft probably doesn't want to get into the details of the `CERTIFICATE` frame.  In your examples, an `ORIGIN` frame for origin that the server on this connection isn't authoritative for can - or maybe SHOULD - be ignored.  That ignoring can stop at the point that the server becomes authoritative for any reason (straw man example that isn't `CERTIFICATE`: the `notBefore` time might pass).",
          "createdAt": "2017-08-29T04:24:33Z",
          "updatedAt": "2017-08-29T04:24:33Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As for this PR, the better question is: how does a server learn that its certificate isn't good enough?  It's a much bigger question, but probably better worth addressing directly.",
          "createdAt": "2017-08-29T04:29:45Z",
          "updatedAt": "2017-08-29T04:29:45Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We've talked about having a more specific stream error than PROTOCOL_ERROR for unauthoritative pushes; we agreed to wait for secondary certs to be defined in #355.\r\n\r\nFor client-initiated requests, an ORIGIN containing an origin that the current cert(s) held by the client doesn't cover implies that it can't be used on that connection until some sort of proof is obtained (probably a secondary cert). I think that's well covered by the current spec; it doesn't imply an error, because the Origin Set is *never* used as the sole source of truth regarding what the conn is good for. If you can suggest clarifications to improve understanding of this, they're welcome, but I don't *think* doing so requires new spec language.\r\n\r\nWRT the server learning about whether a cert is good enough -- yes, but I think that's an issue for secondary certs. Probably.\r\n\r\nBTW, @PiotrSikora - we prefer issues to be raised separately, not as PRs; it makes them more discoverable. \r\n",
          "createdAt": "2017-08-30T02:05:23Z",
          "updatedAt": "2017-08-30T02:05:23Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Closing. If someone things there's an underlying issue remaining here, please open one.",
          "createdAt": "2017-09-12T00:39:39Z",
          "updatedAt": "2017-09-12T00:39:39Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "89e6da7f5aab39ffbe27bb44b1afe93d3640de2d",
      "headRepository": "PiotrSikora/http-extensions",
      "headRefName": "origin_reject",
      "headRefOid": "a7a3ff5384ce6850274a08afbe514e58cfc4a002",
      "mergeCommit": null
    },
    {
      "number": 387,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM4MDg4MTI4",
      "title": "The matching rules in 2818 all apply",
      "url": "https://github.com/httpwg/http-extensions/pull/387",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "...not just the wildcard ones.",
      "createdAt": "2017-08-29T04:27:54Z",
      "updatedAt": "2017-08-29T04:46:08Z",
      "closedAt": "2017-08-29T04:46:03Z",
      "mergedAt": "2017-08-29T04:46:03Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "89e6da7f5aab39ffbe27bb44b1afe93d3640de2d",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "just-rules",
      "headRefOid": "a039c1c73426d796279df4d768659fb2e28a1623",
      "mergeCommit": {
        "oid": "ce8e8d3e4b9682f71f57b8324f17f31f8c65424c"
      }
    },
    {
      "number": 390,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM5NDY4NTc5",
      "title": "Add HTTP replay draft",
      "url": "https://github.com/httpwg/http-extensions/pull/390",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mcmanus"
      ],
      "labels": [],
      "body": "Since our chairs have not seen the wisdom of separate repositories, I will acquiesce.",
      "createdAt": "2017-09-06T04:12:07Z",
      "updatedAt": "2017-09-06T04:24:59Z",
      "closedAt": "2017-09-06T04:24:44Z",
      "mergedAt": "2017-09-06T04:24:44Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Bah, it looks good.  No need to wait for Pat.",
          "createdAt": "2017-09-06T04:24:59Z",
          "updatedAt": "2017-09-06T04:24:59Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8d28cfa6db5e19115219abef616a8824dfe61eba",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "http-replay",
      "headRefOid": "6eb949f9375bea24d9c93e2005087bb06d26ddb3",
      "mergeCommit": {
        "oid": "879877fa236e94434fcd4ac6ab25e3f8698953f0"
      }
    },
    {
      "number": 393,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM5NDY5OTU1",
      "title": "Just use 425",
      "url": "https://github.com/httpwg/http-extensions/pull/393",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "Closes #392.\r\n\r\n(I accidentally put this on master without noticing earlier, sorry.)",
      "createdAt": "2017-09-06T04:29:40Z",
      "updatedAt": "2017-09-27T21:58:57Z",
      "closedAt": "2017-09-27T21:58:55Z",
      "mergedAt": "2017-09-27T21:58:55Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d1c1789150ebeee895fb55eee11b847d76b04d65",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "425",
      "headRefOid": "0cd8b9fd7adfd06fcd3d16819955c4cd36ad2d27",
      "mergeCommit": {
        "oid": "9cad61f6fe4604974e1a45776585fa5dc9cdca96"
      }
    },
    {
      "number": 395,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM5ODU5NzU0",
      "title": "Trivial typo changes",
      "url": "https://github.com/httpwg/http-extensions/pull/395",
      "state": "CLOSED",
      "author": "ericlaw1979",
      "authorAssociation": "NONE",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "",
      "createdAt": "2017-09-07T17:14:47Z",
      "updatedAt": "2018-12-08T00:20:55Z",
      "closedAt": "2018-12-08T00:20:55Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks, Eric! I merged and committed these typo fixes in https://github.com/httpwg/http-extensions/commit/6a1bc679b2f57b1d9a62956c6a5d9e2c0faee611.",
          "createdAt": "2018-12-08T00:20:55Z",
          "updatedAt": "2018-12-08T00:20:55Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4807b01935df6d3914de901edac0f3a6e5f3f5b9",
      "headRepository": "ericlaw1979/http-extensions",
      "headRefName": "patch-2",
      "headRefOid": "85d3ff010018a459385519763b04d0d00a4596db",
      "mergeCommit": null
    },
    {
      "number": 396,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQwMDQxNDQ2",
      "title": "mark \"Acknowledgements\" appendix as unnumbered",
      "url": "https://github.com/httpwg/http-extensions/pull/396",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "replay"
      ],
      "body": "",
      "createdAt": "2017-09-08T13:47:00Z",
      "updatedAt": "2017-09-10T22:23:10Z",
      "closedAt": "2017-09-10T22:23:06Z",
      "mergedAt": "2017-09-10T22:23:06Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8dd3df47669491f02bf4a5b96166407661be42b2",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-10",
      "headRefOid": "8980ffe1f13bba98bc70a4414f82c41e7ea35dcb",
      "mergeCommit": {
        "oid": "9da6f1174eec534c99b1feb4ed005c82524815c6"
      }
    },
    {
      "number": 397,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQwMTcyMDYz",
      "title": "Fix typo",
      "url": "https://github.com/httpwg/http-extensions/pull/397",
      "state": "MERGED",
      "author": "inian",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "",
      "createdAt": "2017-09-09T14:41:28Z",
      "updatedAt": "2017-09-29T06:22:10Z",
      "closedAt": "2017-09-29T06:22:06Z",
      "mergedAt": "2017-09-29T06:22:06Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thx!",
          "createdAt": "2017-09-29T06:22:10Z",
          "updatedAt": "2017-09-29T06:22:10Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8dd3df47669491f02bf4a5b96166407661be42b2",
      "headRepository": "inian/http-extensions",
      "headRefName": "minor-typo",
      "headRefOid": "e7c2316c057f7296a7ca3d93c98637813103ffb7",
      "mergeCommit": {
        "oid": "fb77fbf795c2290990762717532f87c4b2f0ce5e"
      }
    },
    {
      "number": 398,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQwNzMxNTc5",
      "title": "reference format",
      "url": "https://github.com/httpwg/http-extensions/pull/398",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "origin-frame"
      ],
      "body": "",
      "createdAt": "2017-09-13T04:14:09Z",
      "updatedAt": "2017-09-22T12:16:24Z",
      "closedAt": "2017-09-22T12:16:10Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, already committed due to mishap. Sorry.",
          "createdAt": "2017-09-13T04:17:17Z",
          "updatedAt": "2017-09-13T04:17:17Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "re-opened, as I reverted the unintended commit",
          "createdAt": "2017-09-13T07:43:31Z",
          "updatedAt": "2017-09-13T07:43:31Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "97dc997aca16e3886d1751383e0c69ce65027b57",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-10",
      "headRefOid": "ffcd1f39440d484630201b1068b1ccc0d0052480",
      "mergeCommit": null
    },
    {
      "number": 399,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQwNzMxOTY4",
      "title": "type the artwork",
      "url": "https://github.com/httpwg/http-extensions/pull/399",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "origin-frame"
      ],
      "body": "",
      "createdAt": "2017-09-13T04:18:37Z",
      "updatedAt": "2017-12-13T07:16:27Z",
      "closedAt": "2017-09-22T04:58:52Z",
      "mergedAt": "2017-09-22T04:58:52Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1e819b2225e884cc7818c80309a5518c9f6240d6",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-11",
      "headRefOid": "50b94e26c7e463474820d71e55621f630ca32ac8",
      "mergeCommit": {
        "oid": "97dc997aca16e3886d1751383e0c69ce65027b57"
      }
    },
    {
      "number": 400,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQxMjYyMDQx",
      "title": "align with AUTH48 changes",
      "url": "https://github.com/httpwg/http-extensions/pull/400",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "immutable"
      ],
      "body": "",
      "createdAt": "2017-09-15T09:06:12Z",
      "updatedAt": "2017-12-13T20:25:57Z",
      "closedAt": "2017-09-16T01:54:06Z",
      "mergedAt": "2017-09-16T01:54:06Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2017-09-16T01:54:11Z",
          "updatedAt": "2017-09-16T01:54:11Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "0eafecf835b86ba5d6b9c0cf4d00b0859c8b1291",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-12",
      "headRefOid": "c3ac98af75efeaa5d99449b423c4285b6a5246c0",
      "mergeCommit": {
        "oid": "b466e4c2835b3666f0d33dded8ec420366d91af3"
      }
    },
    {
      "number": 402,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQyNDc4MzU5",
      "title": "Origin nits",
      "url": "https://github.com/httpwg/http-extensions/pull/402",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "origin-frame"
      ],
      "body": "Some really minor things.",
      "createdAt": "2017-09-22T01:13:46Z",
      "updatedAt": "2017-09-22T02:04:57Z",
      "closedAt": "2017-09-22T02:04:52Z",
      "mergedAt": "2017-09-22T02:04:52Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "52056fb8aa200e9af3f7b387431b58becbf21beb",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "origin-nits",
      "headRefOid": "787b8b8c4ca201d2f1e86c7c4ec5b5d621cd6111",
      "mergeCommit": {
        "oid": "4ff0b465bd1a1eaaa6be5939ae44990942e91f18"
      }
    },
    {
      "number": 403,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQyNDc4NTIz",
      "title": "RFC 8174",
      "url": "https://github.com/httpwg/http-extensions/pull/403",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "origin-frame"
      ],
      "body": "",
      "createdAt": "2017-09-22T01:15:29Z",
      "updatedAt": "2017-09-22T02:05:40Z",
      "closedAt": "2017-09-22T02:05:35Z",
      "mergedAt": "2017-09-22T02:05:35Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "52056fb8aa200e9af3f7b387431b58becbf21beb",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "origin8174",
      "headRefOid": "ed3039514e18c5f8183f278defe21c09c495fd24",
      "mergeCommit": {
        "oid": "70959b4d718e85028c7985d49db7e7d91c0b23ab"
      }
    },
    {
      "number": 404,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQyNTY1NzIz",
      "title": "reference format",
      "url": "https://github.com/httpwg/http-extensions/pull/404",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mnot"
      ],
      "labels": [
        "editorial",
        "origin-frame"
      ],
      "body": "",
      "createdAt": "2017-09-22T12:19:23Z",
      "updatedAt": "2017-09-23T00:05:11Z",
      "closedAt": "2017-09-23T00:05:04Z",
      "mergedAt": "2017-09-23T00:05:04Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2017-09-23T00:05:08Z",
          "updatedAt": "2017-09-23T00:05:08Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "97dc997aca16e3886d1751383e0c69ce65027b57",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-10",
      "headRefOid": "8270df9df01069966f41218d9c422c052b8d1df6",
      "mergeCommit": {
        "oid": "036c49171d376977b1f4a9ce64f5f60958e097ef"
      }
    },
    {
      "number": 405,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQyNzgyMDI3",
      "title": "You can't actually receive a 425 if the handshake doesn't complete",
      "url": "https://github.com/httpwg/http-extensions/pull/405",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "replay"
      ],
      "body": "@mcmanus was confused by the text here and I confess that I don't remember why\r\nit was added.  There are actually esoteric cases where you get server data that\r\nyou can read before the handshake is complete (QUIC tends to enable that sort\r\nof mess), but there is no circumstance where the client can read the 425 but\r\ncan't also determine whether that the handshake is not done to its\r\nsatisfaction.  The client might decide that it wants to abort and not provide a\r\ncertificate or something, but most implementations don't really allow that sort\r\nof messing around.",
      "createdAt": "2017-09-25T01:46:04Z",
      "updatedAt": "2017-09-27T21:58:12Z",
      "closedAt": "2017-09-27T21:58:09Z",
      "mergedAt": "2017-09-27T21:58:09Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "036c49171d376977b1f4a9ce64f5f60958e097ef",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "425-wo-handshake",
      "headRefOid": "99821e86bebd0cc17f76f5fbb4662683cf46ae7c",
      "mergeCommit": {
        "oid": "d1c1789150ebeee895fb55eee11b847d76b04d65"
      }
    },
    {
      "number": 406,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQzMjgyNDQx",
      "title": "rough in ORIGIN_SUPPORT",
      "url": "https://github.com/httpwg/http-extensions/pull/406",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "origin-frame"
      ],
      "body": "Note the change in document title.",
      "createdAt": "2017-09-27T02:03:32Z",
      "updatedAt": "2017-12-13T20:31:36Z",
      "closedAt": "2017-10-01T16:12:32Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@enygren @MikeBishop please review.",
          "createdAt": "2017-09-27T02:07:13Z",
          "updatedAt": "2017-09-27T02:07:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0MTc0NzU=",
          "commit": {
            "abbreviatedOid": "a099222"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "It's getting there, but I think that a few more tweaks are needed.",
          "createdAt": "2017-09-27T03:09:03Z",
          "updatedAt": "2017-09-27T03:19:05Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "We've used default = 0 and supported = 1 in the past.  I think that I'd prefer that.",
              "createdAt": "2017-09-27T03:09:03Z",
              "updatedAt": "2017-09-27T03:19:05Z"
            },
            {
              "originalPosition": 63,
              "body": "s/}}/}})/\r\ns/not be/not been/",
              "createdAt": "2017-09-27T03:09:25Z",
              "updatedAt": "2017-09-27T03:19:05Z"
            },
            {
              "originalPosition": 45,
              "body": "Please describe what semantics you want to associate with the *client* sending the setting.",
              "createdAt": "2017-09-27T03:11:26Z",
              "updatedAt": "2017-09-27T03:19:05Z"
            },
            {
              "originalPosition": 75,
              "body": "I think that you want to change the \"By default\" here too.  Perhaps:\r\n\r\n\"On a connection where the server has not sent an ORIGIN_SUPPORT setting, the rules for authority in Section 9.1.2 of {{!RFC7540}} apply and the Origin Set is not used.\"  ... or something.\r\n\r\ns/ORIGIN/ORIGIN_SUPPORT/",
              "createdAt": "2017-09-27T03:11:45Z",
              "updatedAt": "2017-09-27T03:19:05Z"
            },
            {
              "originalPosition": 95,
              "body": "ORIGIN_SUPPORT again",
              "createdAt": "2017-09-27T03:12:15Z",
              "updatedAt": "2017-09-27T03:19:05Z"
            },
            {
              "originalPosition": 105,
              "body": "ORIGIN_SETTING",
              "createdAt": "2017-09-27T03:12:23Z",
              "updatedAt": "2017-09-27T03:19:05Z"
            },
            {
              "originalPosition": 123,
              "body": "\"Once the ORIGIN_SUPPORT setting has been received\"",
              "createdAt": "2017-09-27T03:13:17Z",
              "updatedAt": "2017-09-27T03:19:05Z"
            },
            {
              "originalPosition": 166,
              "body": "Should we have it generate an error?  Also, that suggests moving this step to the first step so that we can catch more errors.",
              "createdAt": "2017-09-27T03:17:34Z",
              "updatedAt": "2017-09-27T03:19:05Z"
            },
            {
              "originalPosition": 187,
              "body": "I think that you want to point out that the ORIGIN_SUPPORT setting should be sent in the connection preface, and separately that ORIGIN frames need to be sent as early as possible.",
              "createdAt": "2017-09-27T03:18:51Z",
              "updatedAt": "2017-09-27T03:19:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0MTg2NDc=",
          "commit": {
            "abbreviatedOid": "a099222"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-09-27T03:21:51Z",
          "updatedAt": "2017-09-27T03:21:51Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "That will cause people to assume they can turn it off; is it worth the added complexity / misunderstanding?",
              "createdAt": "2017-09-27T03:21:51Z",
              "updatedAt": "2017-09-27T03:21:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0MTg2NTI=",
          "commit": {
            "abbreviatedOid": "a099222"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-09-27T03:21:54Z",
          "updatedAt": "2017-09-27T03:21:54Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "It has none, as above.",
              "createdAt": "2017-09-27T03:21:54Z",
              "updatedAt": "2017-09-27T03:21:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0MTg3Njc=",
          "commit": {
            "abbreviatedOid": "a099222"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-09-27T03:22:58Z",
          "updatedAt": "2017-09-27T03:22:58Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "Hmm. Possibly. Which step is 'this'?",
              "createdAt": "2017-09-27T03:22:58Z",
              "updatedAt": "2017-09-27T03:22:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0MTg4MDQ=",
          "commit": {
            "abbreviatedOid": "a099222"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-09-27T03:23:18Z",
          "updatedAt": "2017-09-27T03:23:18Z",
          "comments": [
            {
              "originalPosition": 187,
              "body": "yup.",
              "createdAt": "2017-09-27T03:23:18Z",
              "updatedAt": "2017-09-27T03:23:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0MTkxMTg=",
          "commit": {
            "abbreviatedOid": "a099222"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-09-27T03:26:33Z",
          "updatedAt": "2017-09-27T03:27:41Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Hmm, that's nasty.  I don't know.  Consistency is valuable though.\r\n\r\nHow about you mandate a value of 1.  Anything else is an error.",
              "createdAt": "2017-09-27T03:26:33Z",
              "updatedAt": "2017-09-27T03:27:41Z"
            },
            {
              "originalPosition": 45,
              "body": "Ahh, ignored by servers.  Yuck.  Can we just make the server generate an error instead?",
              "createdAt": "2017-09-27T03:27:12Z",
              "updatedAt": "2017-09-27T03:27:41Z"
            },
            {
              "originalPosition": 166,
              "body": "Step 4 (frame on streams other than 0)",
              "createdAt": "2017-09-27T03:27:30Z",
              "updatedAt": "2017-09-27T03:27:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU2MDQ3MDE=",
          "commit": {
            "abbreviatedOid": "a099222"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Mostly minor nits.  The Alt-Svc feedback is separate from this PR, so feel free to merge without addressing that.",
          "createdAt": "2017-09-27T16:24:08Z",
          "updatedAt": "2017-09-27T16:39:51Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "In HTTP/QUIC, it can be a Boolean (sent = true), but HTTP/2 has to have a value.  I'm on the mandate-value-of-1 wagon.",
              "createdAt": "2017-09-27T16:24:08Z",
              "updatedAt": "2017-09-27T16:39:51Z"
            },
            {
              "originalPosition": 75,
              "body": "I'll second that.  If the server doesn't declare support, return to the RFC the server knows it's implementing.",
              "createdAt": "2017-09-27T16:28:28Z",
              "updatedAt": "2017-09-27T16:39:51Z"
            },
            {
              "originalPosition": 81,
              "body": "I continue to be a little sad about the port's interaction with Alt-Svc.  At this point, we're saying that the client opened the connection to speak to a particular origin (example.com:443) via an Alternative at a different port (alt.example.com:8443).  So upon receipt of the server's settings, the connection will be valid for requests bound to https://example.com:8443, which is no outstanding request on the client, and the client can't legitimately make requests until it receives the ORIGIN frame.\r\n\r\nIf https://example.com:443 and https://example.com:8443 Alt-Svc to alt.example.com:8443, then the server can't know which origin the client thinks it's talking to except by the requests it makes.  I still think I'd initialize this to the origin (including port) which prompted opening the connection, rather than the actual server port.  The server doesn't necessarily need to know this value before the client makes a request.",
              "createdAt": "2017-09-27T16:36:09Z",
              "updatedAt": "2017-09-27T16:39:51Z"
            },
            {
              "originalPosition": 105,
              "body": "ORIGIN_SUPPORT",
              "createdAt": "2017-09-27T16:37:10Z",
              "updatedAt": "2017-09-27T16:39:51Z"
            },
            {
              "originalPosition": 139,
              "body": "Let's follow convention and make the initial value 0.",
              "createdAt": "2017-09-27T16:37:52Z",
              "updatedAt": "2017-09-27T16:39:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4MjYwMjE=",
          "commit": {
            "abbreviatedOid": "a099222"
          },
          "author": "Lekensteyn",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-09-28T11:17:10Z",
          "updatedAt": "2017-09-28T11:17:11Z",
          "comments": [
            {
              "originalPosition": 187,
              "body": "Can the behavior of late ORIGIN frames be defined? As I currently read the spec, the Origin set can be modified in the full stream lifetime, so even after HEADERS or PUSH_PROMISE frames.\r\n\r\nWhen the server was unable to prepare the Origin frame (e.g. due to validation delays), can it send it anyway as hint for future requests?",
              "createdAt": "2017-09-28T11:17:11Z",
              "updatedAt": "2017-09-28T11:17:11Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c5ee46b4c24c992bbbefb8d055897a3167f2b341",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ORIGIN_SUPPORT",
      "headRefOid": "a099222956744b48f7627732847a2b7a0dd29fa1",
      "mergeCommit": null
    },
    {
      "number": 407,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQzNTEyMjg1",
      "title": "Manage out of order early data delivery",
      "url": "https://github.com/httpwg/http-extensions/pull/407",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "The best and easiest plan is to discard, but we know that throwing out\r\nperfectly good packets can have bad effects on performance.  It sends a bad\r\nsignal to a congestion controller for instance.  So we need to say either\r\ndiscard, or ensure that the data is properly attributed and consistently\r\nprocessed.\r\n\r\nCloses #391.",
      "createdAt": "2017-09-27T22:08:36Z",
      "updatedAt": "2017-09-28T22:40:41Z",
      "closedAt": "2017-09-28T22:40:37Z",
      "mergedAt": "2017-09-28T22:40:37Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "I think you covered it all this way. +1.",
          "createdAt": "2017-09-28T22:03:16Z",
          "updatedAt": "2017-09-28T22:03:16Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9cad61f6fe4604974e1a45776585fa5dc9cdca96",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "out-of-order-early-data",
      "headRefOid": "d582c97581df481ff9d312d52f707092cb9af164",
      "mergeCommit": {
        "oid": "c0a0dc4dfdc5e23d47ec3d3fbe5af7e38d0116ae"
      }
    },
    {
      "number": 408,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQzNTE1MTEy",
      "title": "Intermediaries need to be consistent too",
      "url": "https://github.com/httpwg/http-extensions/pull/408",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "This explains how consistent handling of requests can be applied by a gateway.",
      "createdAt": "2017-09-27T22:26:19Z",
      "updatedAt": "2017-09-28T22:41:04Z",
      "closedAt": "2017-09-28T22:41:01Z",
      "mergedAt": "2017-09-28T22:41:01Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3MjIyODc=",
          "commit": {
            "abbreviatedOid": "b8f8589"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-09-28T00:10:52Z",
          "updatedAt": "2017-09-28T00:10:52Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "s/true/required/? But if that's the case, it should really be a REQUIREMENT.",
              "createdAt": "2017-09-28T00:10:52Z",
              "updatedAt": "2017-09-28T00:20:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3MjM1MTg=",
          "commit": {
            "abbreviatedOid": "b8f8589"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-09-28T00:20:39Z",
          "updatedAt": "2017-09-28T00:20:39Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Sure. Reworded.",
              "createdAt": "2017-09-28T00:20:39Z",
              "updatedAt": "2017-09-28T00:20:39Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e826f8528178be1c2904cdc29d2a463a717fc3de",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "intermediary-forwarding",
      "headRefOid": "23b4e30e35aa066c2a7f3d615b47ed000b7fda63",
      "mergeCommit": {
        "oid": "d472a07213a44ae5a9693d2c7738eccd5e0dd556"
      }
    },
    {
      "number": 409,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQzNTE3OTAw",
      "title": "Be extra consistent",
      "url": "https://github.com/httpwg/http-extensions/pull/409",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "This text from Kyle Rose highlights the decision process.  If any node might\r\nmake a different decision about processing early data, then *this* node has to\r\nwait.",
      "createdAt": "2017-09-27T22:45:23Z",
      "updatedAt": "2017-09-28T22:40:24Z",
      "closedAt": "2017-09-28T22:40:21Z",
      "mergedAt": "2017-09-28T22:40:21Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "I like it, +1",
          "createdAt": "2017-09-28T22:01:36Z",
          "updatedAt": "2017-09-28T22:01:36Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5ec71fca0bb6f3671099bf293e768b9539efca29",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "be-extra-consistent",
      "headRefOid": "6ead378ae38a80896ba6cc3b950bbf33a8f63e9a",
      "mergeCommit": {
        "oid": "4c5d685be91ebe508a5d578863259a8f1edb0e1d"
      }
    },
    {
      "number": 411,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQ0MDYxMjMy",
      "title": "headers -> header fields",
      "url": "https://github.com/httpwg/http-extensions/pull/411",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-10-01T08:26:34Z",
      "updatedAt": "2017-10-02T17:37:26Z",
      "closedAt": "2017-10-01T14:36:12Z",
      "mergedAt": "2017-10-01T14:36:12Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "77e56039f623b39fe39761b378fedc19bbe88602",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "headerfields",
      "headRefOid": "9b846f1dd96eca79c1737b18bcb331698dee3b8c",
      "mergeCommit": {
        "oid": "81d66d399f524109b5925d265b3d8b6d0a3f43d7"
      }
    },
    {
      "number": 413,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUwNzM4Mzkx",
      "title": "Switch digest to cuckoo filters, to enable O(1) removal",
      "url": "https://github.com/httpwg/http-extensions/pull/413",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "Resolves https://github.com/httpwg/http-extensions/issues/268",
      "createdAt": "2017-11-05T19:38:07Z",
      "updatedAt": "2018-03-01T02:01:13Z",
      "closedAt": "2018-03-01T02:01:13Z",
      "mergedAt": "2018-03-01T02:01:13Z",
      "mergedBy": "kazuho",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc @mnot @kazuho ",
          "createdAt": "2017-11-05T19:38:52Z",
          "updatedAt": "2017-11-05T19:38:52Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hey Yoav,\r\n\r\nThanks; will take a look. Two immediate things:\r\n\r\n1. You're getting a error in the markdown; `mapping values are not allowed in this context at line 80 column 25`. \r\n\r\n2. I see you've added yourself as an author. That's generally the decision of the chair - @mcmanus in this case.",
          "createdAt": "2017-11-05T23:53:52Z",
          "updatedAt": "2017-11-05T23:53:52Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> You're getting a error in the markdown; mapping values are not allowed in this context at line 80 column 25.\r\n\r\nHopefully fixed. Is there a way to test it locally?\r\n\r\n> \r\n> I see you've added yourself as an author. That's generally the decision of the chair - @mcmanus in this case.\r\n\r\nApologies for the noobness. Removed myself.",
          "createdAt": "2017-11-06T01:09:14Z",
          "updatedAt": "2017-11-06T01:09:14Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "See SUBMITTING.md for build info.",
          "createdAt": "2017-11-06T02:00:21Z",
          "updatedAt": "2017-11-06T02:00:21Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@yoavweiss Thank you for working on the proposal.\r\n\r\n* Am I correct in assuming that changes other than the switch to Cuckoo filters and the introduction `SENDING_CACHE_DIGEST` are unintentional? For example, I see `VALIDATORS` flag of the `CACHE_DIGEST` frame being removed.\r\n* Do you have a working code that implements Cuckoo filters? I am curious to see it working.\r\n* The concept of `SENDING_CACHE_DIGEST` makes sense to me. Maybe we might want to adjust the codepoints and the naming in relation to `ACCEPT_CACHE_DIGEST`.",
          "createdAt": "2017-11-07T00:56:03Z",
          "updatedAt": "2017-11-07T00:56:03Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For example, I see `VALIDATORS` flag of the `CACHE_DIGEST` frame being removed.\r\n\r\nOh, I now understand the intent of removing the flag.\r\n\r\nThe motive of the proposal is to build a digest without referring to every response object stored in cache. The fact means that it is not be easy for the client to determine the freshness of the entries that is going to be included in the digest.\r\n\r\nI am sympathetic to the idea, but I am afraid if the approach works well with the current mechanism of HTTP/2 caching. My understanding is that browsers that exist today only consume a pushed response when it fails to find a freshly cached response in its cache. Otherwise, the pushed response never lands in the browser cache. Unless we change the behavior of the browsers to respect the pushed response even if a freshly cached object already exists in its cache, there's a chance that servers would continually push responses that gets ignored by the client (due to the existence of a freshly cached response in the browser cache with the same URL).\r\n\r\n@yoavweiss Assuming that I correctly understand the motive of removing the distinction between a fresh digest and a stale digest, I would appreciate it if you could clarify your ideas on the problem.",
          "createdAt": "2017-11-07T04:34:04Z",
          "updatedAt": "2017-11-07T04:35:41Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for reviewing, @kazuho! :)\r\n\r\nMy intent was to include all stored resources in the digest, regardless of them being stale or fresh. Entries are added to the digest when a resource is added to the cache and removed from the digest when a resource is removed.\r\n\r\nThe reason is that I think the distinction doesn't make much sense, and maintaining it adds a lot of complexity, basically forcing browsers to recreate the digest for every connection at O(N) cost.\r\n\r\nUnder this premise what servers should do is:\r\n* Push all the resources that are known not to be in the cache digest\r\n* Push 304 responses for resources that are in the cache digest, but are likely to be stale (short freshness lifetime, etc)\r\n* Don't push resources that are in the cache digest and have a long term freshness lifetime or are immutable.\r\n\r\nDoes that make sense? I'm not sure I understand your reference to the push cache vs. the HTTP cache in your comment. In light of my explanation, is there still an issue there in your view? ",
          "createdAt": "2017-11-07T14:44:21Z",
          "updatedAt": "2017-11-07T14:44:21Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Do you have a working code that implements Cuckoo filters? I am curious to see it working.\r\n\r\nhttps://github.com/efficient/cuckoofilter is the reference implementation.\r\n\r\n\r\n\r\n> The concept of SENDING_CACHE_DIGEST makes sense to me. Maybe we might want to adjust the codepoints and the naming in relation to ACCEPT_CACHE_DIGEST.\r\n\r\nHappy to change it. Do you have any specific changes in mind?",
          "createdAt": "2017-11-07T14:45:43Z",
          "updatedAt": "2017-11-07T14:45:43Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@yoavweiss\r\n> My intent was to include all stored resources in the digest, regardless of them being stale or fresh. Entries are added to the digest when a resource is added to the cache and removed from the digest when a resource is removed.\r\n> \r\n> The reason is that I think the distinction doesn't make much sense, and maintaining it adds a lot of complexity, basically forcing browsers to recreate the digest for every connection at O(N) cost.\r\n\r\nThank you for the explanation. I now understand the intent better.\r\n\r\nI think that we need to consider two issues regarding the approach.\r\n\r\nFirst is the fact that a browser cache may contain more stale responses than fresh resources. Below are the numbers of cached objects found in my Firefox's cache (to be honest the date is from 2016, I haven't been using Firefox in recent weeks and therefore cannot provide up-to-date data).\r\n\r\n|host|fresh|stale|total\r\n|---|---:|---:|---:\r\n|*.facebook.com|790|1,483|2,273\r\n|*.google.com|373|630|1,003\r\n\r\nAs you can see, large scale websites tend to have more stale objects than fresh objects. In other words, including information of stale-cached objects increases the size of the digest roughly three times in this case. Since performance-sensitive resources (that we need to push) are likely to be stored fresh (since they are the most likely ones marked as immutable, or near-immutable), transmitting only the digest of freshly-cached responses makes sense.\r\n\r\nSecond is a configuration issue on the server side.\r\n\r\nOne strategy that can be employed by an H2 server (under the current draft) is to receive a digest of freshly cached resources only, compare the digest against the list of resources the browser should preload _by only using the URL_, and push the missing resources to the client. It is possible for a H2 server to perform the comparison without actually fetching the resource (from origin or from cache) since only the URL would be required for calculating the digest.\r\n\r\nThe proposal prevents such strategy from being deployed since it requires the ETag values to be always taken into consideration (should they be associated to the HTTP responses). In other words, servers would be required to load response headers of the resources to determine if it needs to be pushed, which could be a huge performance degradation on some deployments. \r\n\r\nFortunately, servers could avoid the issue by not including ETags for resources that it may push. I think such change on the server-side configuration would be possible, but we need to make sure if we are to take the path (of removing the fresh vs. stale distinction).\r\n\r\n> I'm not sure I understand your reference to the push cache vs. the HTTP cache in your comment. In light of my explanation, is there still an issue there in your view? \r\n\r\nLet me explain using an example.\r\n\r\nConsider the following case:\r\n* client has `https://example.com/style.css` with `ETag: 12345` and `Expires: Nov 30 2017`\r\n* on server-side, the resource has been updated to `ETag: 67890`\r\n\r\nWhen receiving a new request from the client, the server cannot determine if the client has style.css in its cache. Therefore, `style.css` would be pushed.\r\n\r\nThe client, when observing `link: </style.css>; rel=preload` (or equivalent `<link>` tag), tries to load the resource. Since the fresh resource exists within the browser cache, that would be used. The pushed version is ignored and gets discarded (*).\r\n\r\nThis would be repeated every time until the cached object either becomes stale or gets removed from the cache.\r\n\r\nMy understanding is that the browser behavior (explained in *) is true for Firefox and also for Chrome. Am I wrong, or missing something?\r\n\r\n>> Do you have a working code that implements Cuckoo filters? I am curious to see it working.\r\n>\r\n> https://github.com/efficient/cuckoofilter is the reference implementation.\r\n\r\nThank you for the link. I will try to use it.\r\n\r\nOTOH, do you have some working code that can actually calculate the cache-digest value taking a list of URLs as an input (something like https://github.com/h2o/cache-digest.js)? I ask this because it would give us a better sense in how the actual size of the digest would be.\r\n\r\n>> The concept of SENDING_CACHE_DIGEST makes sense to me. Maybe we might want to adjust the codepoints and the naming in relation to ACCEPT_CACHE_DIGEST.\r\n> \r\n> Happy to change it. Do you have any specific changes in mind?\r\n\r\nOne way to proceed would be to split the discussion of `SENDING_CACHE_DIGEST` from Cuckoo filters into a separate issue or a PR. I do not have a strong opinion on the naming or the codepoints. What do you think? @mnot ",
          "createdAt": "2017-11-07T20:29:34Z",
          "updatedAt": "2017-11-07T20:30:21Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@yoavweiss Have you considered the approach using Cuckoo filter to generate GCS?\r\n\r\nI can understand the fact that you do not want to iterate through the browser cache when sending a cache digest. Per-host Cuckoo hash seems like a good solution to the issue.\r\n\r\nOTOH, as I described in my previous comment, it seems that sending the hash directly has several issues.\r\n\r\nThat is why I am wondering if it would be viable to generate GCS from the per-host Cuckoo filter that would be maintained within the browser.\r\n\r\nI can see three benefits in the approach, compared to sending the values of Cuckoo filter directly:\r\n* the size of the digest will be smaller\r\n* we can keep the distinction between fresh vs. cache. Sending digest of fresh resources only would end up in even smaller digests. Retaining the distinction lowers the bar to deploy cache-digests on the server side.\r\n    * note: you can store the time when the cached object becomes stale in the data associated to the Cuckoo filter entry (assuming that you would have associated data to handle resize, as we discussed in https://github.com/httpwg/http-extensions/issues/268#issuecomment-261764848). That information can be used when builiding the GCS to determine if a particular object should go into a GCS of fresh resources or that of stale ones\r\n* less change to the browser push handling (no need to handle pushes of 304 or replace a freshly cached object when an object with the same URL is being pushed)\r\n\r\nIn case of `*.facebook.com` or `*.google.com` in the comment above, sending fresh-only digests using GCS would be about 1/3 the size of sending fresh & stale digests using Cuckoo filter.\r\n\r\nThe biggest cost of calculating GCS from Cuckoo hash would be the sort operation. But I think that the cost could be negligible compared to the ECDH operation that we would be doing for every connection, considering the fact that the number of entries that we would need to sort would be small (e.g., up to 1,000 entries of uint32_t), and the fact that sort algorithms faster than O(n log n) radix sort can be deployed (e.g. radix sort).\r\n\r\nWDYT?",
          "createdAt": "2017-11-07T21:00:26Z",
          "updatedAt": "2017-11-07T21:55:37Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Have you considered the approach using Cuckoo filter to generate GCS?\r\n\r\nSo have a cuckoo filter digest and then put its fingerprints in a GCS? I have not considered that. Need to give it some thought...\r\n\r\nAt the same time, it's not clear to me how that would enable a \"stale\" vs. \"fresh\" digests, or handling of improperly cached resources (fresh resources that were replaced on the server).",
          "createdAt": "2017-11-07T22:49:20Z",
          "updatedAt": "2017-11-07T22:49:20Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">> Have you considered the approach using Cuckoo filter to generate GCS?\r\n> \r\n> So have a cuckoo filter digest and then put its fingerprints in a GCS? I have not considered that. Need to give it some thought...\r\n\r\nI would appreciate it if you could consider. To me it seems it's worth giving a thought.\r\n\r\n> At the same time, it's not clear to me how that would enable a \"stale\" vs. \"fresh\" digests, or handling of improperly cached resources (fresh resources that were replaced on the server).\r\n\r\nUnder the approach proposed in this PR, structure that stores the per-host digest would look like below. `hashes` is required for resizing the filter (e.g., when doubling or halving `num_backets`).\r\n```\r\nuintFF_t fingerprints[num_backets]; // FF is the size of the fingerprint\r\nuint32_t hashes[num_backets];       // contains 32-bit hash value of each entry in `fingerprints`\r\n```\r\nWhat I am suggesting that you could change the structure to the following.\r\n```\r\nuintFF_t fingerprints[num_backets]; // FF is the size of the fingerprint\r\nstruct {\r\n  uint32_t hash;\r\n  time_t becomes_stale_at;\r\n} hashes_and_expire_times;\r\n```\r\n In addition to the hash value, each entry will contain the moment when the entry becomes stale. The moment can be calculated when the entry is added. For example, if the entry represents a HTTP response with a `cache-control: max-age=V`, `becomes_stale_at` can be calculated as `now + V`. If the entry represents an immutable HTTP response, then `becomes_stale_at` should be set to a very large value (e.g.. `INT64_MAX` assuming that underlying type of `time_t` is `int64_t`).\r\n\r\nWhen building a GCS digest, you would do the following:\r\n* step 1. prepare an empty list that would contain hashes of fresh responses\r\n* step 2. prepare an empty list that would contain hashes of stale responses\r\n* step 3. foreach entry in cuckoo_filter:\r\n  * step 3-1. check if the entry is fresh or not, by checking the value of `becomes_stale_at`\r\n  * step 3-2. if the entry is fresh, append `hash` of the entry to the list of the hashes of fresh responses\r\n  * step 3-3. otherwise, append `hash` of the entry to the list of the hashes of stale responses\r\n* step 4. sort the list of hashes of the fresh responses, encode as GCS, and send\r\n* step 5. sort the list of hashes of the stale responses, encode as GCS, and send\r\n\r\nYou can skip the operations related to stale objects (i.e. step 2, 3-3, 5) if the server is unwilling to receive stale digests.\r\n\r\nWhether the approach can be implemented depends on if a client can determine the moment a response becomes stale. I anticipate that it is possible to determine that when you register the entry to Cuckoo filters (which is when you receive the response from the server).",
          "createdAt": "2017-11-08T01:28:43Z",
          "updatedAt": "2017-11-08T01:28:43Z"
        },
        {
          "author": "sebdeckers",
          "authorAssociation": "NONE",
          "body": "> > > Do you have a working code that implements Cuckoo filters? I am curious to see it working.\r\n> >\r\n> > https://github.com/efficient/cuckoofilter is the reference implementation.\r\n>\r\n> Thank you for the link. I will try to use it.\r\n> \r\n> OTOH, do you have some working code that can actually calculate the cache-digest value taking a list of URLs as an input (something like https://github.com/h2o/cache-digest.js)? I ask this because it would give us a better sense in how the actual size of the digest would be.\r\n\r\n@yoavweiss @kazuho I'm planning to attend the IETF 100 hackathon this weekend in Singapore. (First timer here. \ud83e\udd17\ud83d\udd30) I'm happy to collaborate on a (Node.js?) implementation of this spec if either of you are around and interested. I'm fairly familiar with the current spec, having implemented it [as a service worker](https://gitlab.com/sebdeckers/cache-digest-immutable#README) and [on the server](https://gitlab.com/http2/server/blob/master/src/helpers/cacheDigestFilter.js).",
          "createdAt": "2017-11-08T03:21:29Z",
          "updatedAt": "2017-11-08T03:21:29Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@sebdeckers \r\n> I'm planning to attend the IETF 100 hackathon this weekend in Singapore. (First timer here. \ud83e\udd17\ud83d\udd30) I'm happy to collaborate on a (Node.js?) implementation of this spec if either of you are around and interested.\r\n\r\nWonderful! I'll be attending the hackathon on both days (i.e. Saturday and Sunday). I do not think that I would have time to work on Cache Digests, but would love to discuss with you (or help, if you need) about your work on Cache Digests.",
          "createdAt": "2017-11-09T01:52:43Z",
          "updatedAt": "2017-11-09T01:52:43Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've got an incomplete initial reference implementation at https://github.com/yoavweiss/cache-digests-cuckoo\r\n\r\nIt doesn't yet include removal and querying (that's what I'll be adding next), but I did run it on a list of ~3250 URL (which I got out of my main profile chrome://cache/) and it seems to be creating reasonable sized digests. One more advantage, the digests seem to be highly compressible when sparse.\r\n\r\nResults so far:\r\nDigest with 1021 entries (so room for ~4K URLs): 5621 in-memory, 5233 gzipped (when filled with 3250 URLs).\r\nDigest with 2503 entries (so room for ~10K URLs): 13772 in-memory, 6879 gzipped (same 3250 URLs).\r\nDigest with 7919 entries (so room for ~31K URLs): 43560 in-memory, 9984 gzipped (same 3250 URLs).\r\n\r\nIn practice, I think ~1000 entries is most probably enough, but it's good to know we can increase the digest size (to avoid having to recreate it), without significant over-the-wire penalty.\r\n",
          "createdAt": "2017-11-15T10:52:01Z",
          "updatedAt": "2017-11-15T10:52:26Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, I now have a complete reference implementation and it seems to be working fine. It also exposed an issue with the initial algorithm, forcing table allocation to accommodate a power of 2 number of entries.\r\n\r\nLatest results for 3250 URLs taken from my cache:\r\n\r\n|Number of entries  | Full capacity              |Digest memory size | Digest gzipped size| Digest brotli size|\r\n|-------------------|----------------------|--------------------|--------------------|------------|\r\n|1021 |    4084 |5637 | 5248 |5092 | \r\n|1109 | 4436 | 11269 | 6153 |5675|\r\n|2019 |   8076 | 11269 | 7031 |6785|\r\n|4027 |  16108|22533 | 8663 |7586|\r\n\r\nOne note: the 1021 entries table had 35 collisions, so it seems like it's insufficient for that number of URLs, unless we're willing to absorb extra pushes for ~1% of the resources. ",
          "createdAt": "2017-11-16T15:03:49Z",
          "updatedAt": "2017-11-16T15:22:02Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@yoavweiss Interesting! It's good to know that we have numbers now.\r\n\r\nWhat is the value of P (the false positive ratio) that you used?",
          "createdAt": "2017-11-16T22:38:02Z",
          "updatedAt": "2017-11-16T22:38:02Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "P=8 (so 1/256 false positive)",
          "createdAt": "2017-11-16T23:54:11Z",
          "updatedAt": "2017-11-16T23:54:11Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that the numbers here may be possible to further optimize. One example is semi-sorting of the buckets which the Cuckoo-Filters paper mentions, and which I have not yet implemented. It adds some runtime complexity, but can reduce the fingerprint size per resource by a full bit, so could have resulted in ~9% smaller digests in this case.",
          "createdAt": "2017-11-17T00:18:28Z",
          "updatedAt": "2017-11-17T00:18:39Z"
        },
        {
          "author": "sebdeckers",
          "authorAssociation": "NONE",
          "body": "@yoavweiss Awesome! \ud83e\udd29\r\n\r\nMe not being familiar with these data structures (despite reading Wikipedia article \ud83d\ude05), why does the 1/256 probability (~4/1000) result in 35 collisions?",
          "createdAt": "2017-11-17T00:46:10Z",
          "updatedAt": "2017-11-17T00:46:10Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The 35 collisions are on top of the false positive rates, and represents resources that we failed to put into the table to begin with (due to both their buckets being full). That rate of collisions seems high compared to the results in the paper, so I need to dig further to see who's wrong...",
          "createdAt": "2017-11-17T00:51:58Z",
          "updatedAt": "2017-11-17T00:51:58Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The collisions are now fixed. It was an algorithm issue, where the entry to be pushed was always the same one at the end of the bucket. I've change that to be a random fingerprint from the bucket, which significantly improved things. The ref implementation is now collision free almost up to the point where the digest is full.",
          "createdAt": "2017-11-20T09:25:20Z",
          "updatedAt": "2017-11-20T09:25:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzU5NTk5MTU=",
          "commit": {
            "abbreviatedOid": "375600c"
          },
          "author": "sebdeckers",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "Feedback based on WIP implementation of cuckoo filters for cache digest: https://gitlab.com/http2/cache-digest-koel",
          "createdAt": "2017-11-12T13:58:33Z",
          "updatedAt": "2017-11-12T14:09:52Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "`b` is not defined",
              "createdAt": "2017-11-12T13:58:33Z",
              "updatedAt": "2017-11-20T09:23:26Z"
            },
            {
              "originalPosition": 192,
              "body": "This code feels inconsistent with the writing style used throughout. Would suggest:\r\n> Substract `f` from `h`.",
              "createdAt": "2017-11-12T14:01:40Z",
              "updatedAt": "2017-11-20T09:23:26Z"
            },
            {
              "originalPosition": 227,
              "body": "This is difficult to do in JavaScript where uint operations are typically still limited to 32 bits. The truncation in the previous proposal (step 4) is more compatible and, if I understand correctly, achieves the same objective. Can this be changed to something that does not require 256 bit integer modulo?",
              "createdAt": "2017-11-12T14:04:41Z",
              "updatedAt": "2017-11-20T09:23:26Z"
            },
            {
              "originalPosition": 267,
              "body": "`b` is not defined",
              "createdAt": "2017-11-12T14:04:58Z",
              "updatedAt": "2017-11-20T09:23:26Z"
            },
            {
              "originalPosition": 256,
              "body": "From an implementor's perspective, it would help me to understand this if examples were provided.",
              "createdAt": "2017-11-12T14:06:27Z",
              "updatedAt": "2017-11-20T09:23:26Z"
            },
            {
              "originalPosition": 15,
              "body": "typo: `filter`",
              "createdAt": "2017-11-12T14:07:19Z",
              "updatedAt": "2017-11-20T09:23:26Z"
            },
            {
              "originalPosition": 86,
              "body": "Markdown escaping issue makes `N` italic and hides the `*` characters.",
              "createdAt": "2017-11-12T14:08:43Z",
              "updatedAt": "2017-11-20T09:23:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzYwNDQ2OTc=",
          "commit": {
            "abbreviatedOid": "375600c"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-13T09:55:58Z",
          "updatedAt": "2017-11-13T09:55:59Z",
          "comments": [
            {
              "originalPosition": 227,
              "body": "I wonder if the need for an integer modulo is due to an error in the specification.\r\n\r\nThe text in the PR states that `N` is `a prime number smaller than 2\\*\\*32`. Could it be the case that N is something to be defined as 2<sup>N</sup>?\r\n\r\nIf that is the case, the modulo operation can be implemented by using bitwise AND.",
              "createdAt": "2017-11-13T09:55:58Z",
              "updatedAt": "2017-11-20T09:23:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzYzMjc2NjY=",
          "commit": {
            "abbreviatedOid": "375600c"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-14T04:26:15Z",
          "updatedAt": "2017-11-14T04:56:39Z",
          "comments": [
            {
              "originalPosition": 256,
              "body": "Examples for URL and ETag? Or something else?",
              "createdAt": "2017-11-14T04:26:15Z",
              "updatedAt": "2017-11-20T09:23:26Z"
            },
            {
              "originalPosition": 227,
              "body": "OK, I'll truncate the hash before the modulo operation.",
              "createdAt": "2017-11-14T04:26:52Z",
              "updatedAt": "2017-11-20T09:23:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzYzMzMyMjE=",
          "commit": {
            "abbreviatedOid": "375600c"
          },
          "author": "sebdeckers",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-14T05:19:59Z",
          "updatedAt": "2017-11-14T05:20:00Z",
          "comments": [
            {
              "originalPosition": 256,
              "body": "ETag\r\n\r\nBtw just noticed a typo on line 321: `of a cached response`",
              "createdAt": "2017-11-14T05:19:59Z",
              "updatedAt": "2017-11-20T09:23:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzY3MDAyODU=",
          "commit": {
            "abbreviatedOid": "c90f9b4"
          },
          "author": "sebdeckers",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-15T08:10:36Z",
          "updatedAt": "2017-11-15T08:10:36Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "@yoavweiss Curious... May I ask why this change? I don't see any issues with it. Just don't understand what it means.",
              "createdAt": "2017-11-15T08:10:36Z",
              "updatedAt": "2017-11-20T09:23:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzY3MDExNzc=",
          "commit": {
            "abbreviatedOid": "c90f9b4"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-15T08:14:54Z",
          "updatedAt": "2017-11-15T08:14:55Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "It defines a way to convert fingerprint into a string, so that we can apply {{hash}} to it",
              "createdAt": "2017-11-15T08:14:54Z",
              "updatedAt": "2017-11-20T09:23:26Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c1317d63cb9536f02c0de0aff65a77180eee85a3",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "cache_digests_cuckoo_filter",
      "headRefOid": "d02e5d159e84c1bad677c864e6d9d920d99c99e0",
      "mergeCommit": {
        "oid": "d02e5d159e84c1bad677c864e6d9d920d99c99e0"
      }
    },
    {
      "number": 414,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUxNjAwNjc3",
      "title": "Incorporated comments from MartinT and some of my own edits to draft-ietf-httpbis-rand-access-live",
      "url": "https://github.com/httpwg/http-extensions/pull/414",
      "state": "MERGED",
      "author": "craigpratt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "craigpratt"
      ],
      "labels": [],
      "body": "Also added a new Security Consideration for JavaScript-based clients and servers.",
      "createdAt": "2017-11-09T09:35:06Z",
      "updatedAt": "2017-11-10T10:57:00Z",
      "closedAt": "2017-11-10T10:57:00Z",
      "mergedAt": "2017-11-10T10:56:59Z",
      "mergedBy": "craigpratt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzU1ODUzNjM=",
          "commit": {
            "abbreviatedOid": "21b611b"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-11-09T21:02:38Z",
          "updatedAt": "2017-11-09T21:11:21Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\"client\" needs to be capitalized at the start of a sentence :)",
              "createdAt": "2017-11-09T21:02:38Z",
              "updatedAt": "2017-11-10T10:51:35Z"
            },
            {
              "originalPosition": 19,
              "body": "https://grammarpartyblog.com/2012/01/17/use-versus-utilize/",
              "createdAt": "2017-11-09T21:03:51Z",
              "updatedAt": "2017-11-10T10:51:35Z"
            },
            {
              "originalPosition": 54,
              "body": "<xref target=\"establishing-range\"/> for the section reference.",
              "createdAt": "2017-11-09T21:04:45Z",
              "updatedAt": "2017-11-10T10:51:35Z"
            },
            {
              "originalPosition": 64,
              "body": "xrefs",
              "createdAt": "2017-11-09T21:04:50Z",
              "updatedAt": "2017-11-10T10:51:35Z"
            },
            {
              "originalPosition": 161,
              "body": "maybe \"will return a range covering only those bytes that are currently available:\"",
              "createdAt": "2017-11-09T21:06:26Z",
              "updatedAt": "2017-11-10T10:51:35Z"
            },
            {
              "originalPosition": 298,
              "body": "it's less about representation for this, but about ease of parsing\r\n\r\nI think that the second value here could be 2^53 instead of 2^63.",
              "createdAt": "2017-11-09T21:07:57Z",
              "updatedAt": "2017-11-10T10:51:35Z"
            },
            {
              "originalPosition": 73,
              "body": "The \"must\" here is incorrect.  It can provide the entire representation (for instance, if it didn't support range requests).  Maybe \"might\".",
              "createdAt": "2017-11-09T21:09:04Z",
              "updatedAt": "2017-11-10T10:51:35Z"
            },
            {
              "originalPosition": 73,
              "body": "Finally, the client doesn't necessarily know that the resource is continuously aggregating.  Maybe just say \"For example, a client issues a request for an indefinite range of bytes as follows:\"",
              "createdAt": "2017-11-09T21:11:17Z",
              "updatedAt": "2017-11-10T10:51:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzU3MTYzNjU=",
          "commit": {
            "abbreviatedOid": "21b611b"
          },
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-10T10:27:27Z",
          "updatedAt": "2017-11-10T10:27:27Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Yeah - I think I recall hearing that rule in an English class once...",
              "createdAt": "2017-11-10T10:27:27Z",
              "updatedAt": "2017-11-10T10:51:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzU3MTY3NjI=",
          "commit": {
            "abbreviatedOid": "21b611b"
          },
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-10T10:29:05Z",
          "updatedAt": "2017-11-10T10:29:05Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Guess I never really thought about it that much. No problem with changing it.",
              "createdAt": "2017-11-10T10:29:05Z",
              "updatedAt": "2017-11-10T10:51:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzU3MTcyMjk=",
          "commit": {
            "abbreviatedOid": "21b611b"
          },
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-10T10:30:59Z",
          "updatedAt": "2017-11-10T10:30:59Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "ok - simplified the setup...",
              "createdAt": "2017-11-10T10:30:59Z",
              "updatedAt": "2017-11-10T10:51:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzU3MTcyMzY=",
          "commit": {
            "abbreviatedOid": "21b611b"
          },
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-10T10:31:01Z",
          "updatedAt": "2017-11-10T10:31:01Z",
          "comments": [
            {
              "originalPosition": 161,
              "body": "fixed",
              "createdAt": "2017-11-10T10:31:01Z",
              "updatedAt": "2017-11-10T10:51:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzU3MTc0Njk=",
          "commit": {
            "abbreviatedOid": "21b611b"
          },
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-10T10:31:57Z",
          "updatedAt": "2017-11-10T10:31:57Z",
          "comments": [
            {
              "originalPosition": 298,
              "body": "fixed",
              "createdAt": "2017-11-10T10:31:57Z",
              "updatedAt": "2017-11-10T10:51:35Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "033ab95843febfd6bf8a309af1586cfc9877b015",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "craigpratt/martint-feedback.1",
      "headRefOid": "514a119e29f5ee5c3277cfb6b1d72e4db8b791a6",
      "mergeCommit": {
        "oid": "48aab7a23e8ccd0b3f98f1c2e294ad056b457e8b"
      }
    },
    {
      "number": 418,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUzMjg5NDU1",
      "title": "make Acknowledgements non-numbered",
      "url": "https://github.com/httpwg/http-extensions/pull/418",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "craigpratt"
      ],
      "labels": [
        "editorial",
        "rand-access-live"
      ],
      "body": "",
      "createdAt": "2017-11-17T12:45:03Z",
      "updatedAt": "2017-11-25T02:35:11Z",
      "closedAt": "2017-11-25T02:34:58Z",
      "mergedAt": "2017-11-25T02:34:58Z",
      "mergedBy": "craigpratt",
      "comments": [
        {
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\ud83d\udc4d ",
          "createdAt": "2017-11-25T02:34:44Z",
          "updatedAt": "2017-11-25T02:34:44Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ea1bd1a5e758e68612e780a843909cf819f640c4",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-rand-acks",
      "headRefOid": "dd4275ec75fe3baeadb47e95c03699d9faf21b68",
      "mergeCommit": {
        "oid": "e095465eb7c99d46fa2626dd6e0c5388d46be104"
      }
    },
    {
      "number": 419,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUzMzM1MTY0",
      "title": "remove unused reference to IANA registry",
      "url": "https://github.com/httpwg/http-extensions/pull/419",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "craigpratt"
      ],
      "labels": [
        "editorial",
        "rand-access-live"
      ],
      "body": "",
      "createdAt": "2017-11-17T16:11:28Z",
      "updatedAt": "2017-11-25T02:38:13Z",
      "closedAt": "2017-11-25T02:37:48Z",
      "mergedAt": "2017-11-25T02:37:48Z",
      "mergedBy": "craigpratt",
      "comments": [
        {
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ahh yes - this was a leftover from the draft where I proposed adding a new range unit...",
          "createdAt": "2017-11-25T02:37:00Z",
          "updatedAt": "2017-11-25T02:37:00Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ea1bd1a5e758e68612e780a843909cf819f640c4",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-rand-iana",
      "headRefOid": "f293d51a7d83bc452cf44a7e038645ef8c0f6a6a",
      "mergeCommit": {
        "oid": "259822ae83860fad06008f3ff53ef17368d53924"
      }
    },
    {
      "number": 421,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUzMzU3MTIx",
      "title": "Tune HTTP examples",
      "url": "https://github.com/httpwg/http-extensions/pull/421",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "craigpratt"
      ],
      "labels": [
        "editorial",
        "rand-access-live"
      ],
      "body": "- add type\r\n- consistently indent\r\n- trailing lines for requests\r\n- add mandatory Host header fields",
      "createdAt": "2017-11-17T17:51:21Z",
      "updatedAt": "2017-12-13T07:45:16Z",
      "closedAt": "2017-12-13T07:45:11Z",
      "mergedAt": "2017-12-13T07:45:11Z",
      "mergedBy": "craigpratt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Nzg5OTQwMzg=",
          "commit": {
            "abbreviatedOid": "2b8094c"
          },
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-25T03:02:43Z",
          "updatedAt": "2017-11-25T03:02:44Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Do you think the blank lines at the end of the examples are really necessary? (Presume the intent is to show the terminating \\n\\n?)",
              "createdAt": "2017-11-25T03:02:43Z",
              "updatedAt": "2017-11-25T03:02:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzkwMDExNDM=",
          "commit": {
            "abbreviatedOid": "2b8094c"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-25T11:27:03Z",
          "updatedAt": "2017-11-25T11:27:03Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "We do it in the base specs as well...",
              "createdAt": "2017-11-25T11:27:03Z",
              "updatedAt": "2017-11-25T11:27:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODMwODIwMTQ=",
          "commit": {
            "abbreviatedOid": "2b8094c"
          },
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-12-13T07:45:02Z",
          "updatedAt": "2017-12-13T07:45:02Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Good enough reason for me. Consistency is good....",
              "createdAt": "2017-12-13T07:45:02Z",
              "updatedAt": "2017-12-13T07:45:02Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6471a165378cf3de19dc9e3d96e33db360857df6",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-rand-http-example",
      "headRefOid": "2b8094cbb65e17cc9779ee4e531f3b4bed0e37aa",
      "mergeCommit": {
        "oid": "98ce211770095541fe8f7003aed6d7c8605ee843"
      }
    },
    {
      "number": 422,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUzMzY1NDM3",
      "title": "tune use of ABNF (closes #415)",
      "url": "https://github.com/httpwg/http-extensions/pull/422",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "craigpratt"
      ],
      "labels": [
        "editorial",
        "rand-access-live"
      ],
      "body": "- mention the syntax\r\n- update the reference\r\n- type the citations consistently",
      "createdAt": "2017-11-17T18:36:19Z",
      "updatedAt": "2017-11-25T04:32:07Z",
      "closedAt": "2017-11-25T04:32:03Z",
      "mergedAt": "2017-11-25T04:32:03Z",
      "mergedBy": "craigpratt",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "259822ae83860fad06008f3ff53ef17368d53924",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-rand-abnf",
      "headRefOid": "066167e01024ed800e3b1d4297e29bcfc8009148",
      "mergeCommit": {
        "oid": "da5f2105a7cec502078f4a089c2979535dc50e9c"
      }
    },
    {
      "number": 423,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUzODAwOTQ2",
      "title": "Changes in response to ekr's replay review",
      "url": "https://github.com/httpwg/http-extensions/pull/423",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "These should all be editorial.",
      "createdAt": "2017-11-21T05:31:29Z",
      "updatedAt": "2017-11-24T01:07:40Z",
      "closedAt": "2017-11-24T01:06:34Z",
      "mergedAt": "2017-11-24T01:06:34Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "LGTM",
          "createdAt": "2017-11-21T05:46:44Z",
          "updatedAt": "2017-11-21T05:46:44Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "Looks perfect, thanks Martin!",
          "createdAt": "2017-11-21T09:34:35Z",
          "updatedAt": "2017-11-21T09:34:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzgyNTIxMjU=",
          "commit": {
            "abbreviatedOid": "1950826"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-11-21T20:44:14Z",
          "updatedAt": "2017-11-21T21:49:11Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "It's not immediately clear to the reader how \"as though the connection was new\" could imply a different protocol, since the initial connection (with early data) was also \"new\" and got a protocol as a \"new connection\".  So, it might be more clear to say ```\"This could entail using a different negotiated protocol {{?ALPN=RFC7301}} than the one optimistically used for the early data.\"```",
              "createdAt": "2017-11-21T20:44:14Z",
              "updatedAt": "2017-11-21T23:21:18Z"
            },
            {
              "originalPosition": 75,
              "body": "I might start this sentence with \"Otherwise, an intermediary that receives [...]\" just to make extra clear that the presence of Early-Data in the header forces the intermediary's behavior.",
              "createdAt": "2017-11-21T21:48:46Z",
              "updatedAt": "2017-11-21T23:21:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzgyOTMyMTE=",
          "commit": {
            "abbreviatedOid": "362d93d"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2017-11-21T23:27:42Z",
          "updatedAt": "2017-11-21T23:27:42Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6471a165378cf3de19dc9e3d96e33db360857df6",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ekr-replay-review",
      "headRefOid": "362d93d1b516d1e230e33d7e0b49167c5364d580",
      "mergeCommit": {
        "oid": "0acbcb11d8418ff49fc4558265d287e2cf0d6bce"
      }
    },
    {
      "number": 424,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUzODMxNjU2",
      "title": "remove unneeded abbreviated title",
      "url": "https://github.com/httpwg/http-extensions/pull/424",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "craigpratt"
      ],
      "labels": [
        "editorial",
        "rand-access-live"
      ],
      "body": "",
      "createdAt": "2017-11-21T09:02:53Z",
      "updatedAt": "2017-12-13T20:25:04Z",
      "closedAt": "2017-11-25T04:32:51Z",
      "mergedAt": "2017-11-25T04:32:51Z",
      "mergedBy": "craigpratt",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6471a165378cf3de19dc9e3d96e33db360857df6",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-rand-title",
      "headRefOid": "022f39e3adde20f7af5cf463a064978dee542682",
      "mergeCommit": {
        "oid": "f79d9380703979cf37b1c75ee4b47b8ead08623a"
      }
    },
    {
      "number": 425,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU0Njg0MTk4",
      "title": "cite rfc 7233 early, and make references more specific",
      "url": "https://github.com/httpwg/http-extensions/pull/425",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "craigpratt"
      ],
      "labels": [
        "editorial",
        "rand-access-live"
      ],
      "body": "",
      "createdAt": "2017-11-26T15:41:13Z",
      "updatedAt": "2017-12-13T20:24:55Z",
      "closedAt": "2017-12-13T07:48:46Z",
      "mergedAt": "2017-12-13T07:48:46Z",
      "mergedBy": "craigpratt",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "98ce211770095541fe8f7003aed6d7c8605ee843",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-rand-http-references",
      "headRefOid": "342905183584f88630892e7630ecc7f589eb6364",
      "mergeCommit": {
        "oid": "addc32fbd3273f6907c63c25e5f041729653f473"
      }
    },
    {
      "number": 426,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU0Njg0Mzg2",
      "title": "add missing paragraph breaks",
      "url": "https://github.com/httpwg/http-extensions/pull/426",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "craigpratt"
      ],
      "labels": [
        "editorial",
        "rand-access-live"
      ],
      "body": "",
      "createdAt": "2017-11-26T15:45:51Z",
      "updatedAt": "2017-12-13T07:49:27Z",
      "closedAt": "2017-12-13T07:49:24Z",
      "mergedAt": "2017-12-13T07:49:24Z",
      "mergedBy": "craigpratt",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f79d9380703979cf37b1c75ee4b47b8ead08623a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-rand-para-breaks",
      "headRefOid": "7c68e3ad8ae83d2f6a65fc5728cf6d8a1924cbb4",
      "mergeCommit": {
        "oid": "e81f141047778fbc42a105bd028f54564b006694"
      }
    },
    {
      "number": 427,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU0Njg1NDEw",
      "title": "Expand acronyms and cite HLS and DASH",
      "url": "https://github.com/httpwg/http-extensions/pull/427",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "craigpratt"
      ],
      "labels": [
        "editorial",
        "rand-access-live"
      ],
      "body": "",
      "createdAt": "2017-11-26T16:10:44Z",
      "updatedAt": "2017-12-13T07:53:44Z",
      "closedAt": "2017-12-13T07:53:40Z",
      "mergedAt": "2017-12-13T07:53:40Z",
      "mergedBy": "craigpratt",
      "comments": [
        {
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks much @reschke !",
          "createdAt": "2017-12-13T07:53:23Z",
          "updatedAt": "2017-12-13T07:53:23Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f79d9380703979cf37b1c75ee4b47b8ead08623a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-rand-hls-dash",
      "headRefOid": "fd2e89db57a3f72f9914be3a20c3cd32e77ced1c",
      "mergeCommit": {
        "oid": "2f3981816d4628fb85f4b7b2cd03042522ed3100"
      }
    },
    {
      "number": 428,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU0NzAxNjM5",
      "title": "Be more definite about early data",
      "url": "https://github.com/httpwg/http-extensions/pull/428",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "This makes mitigation mandatory.  Either receive a signal that early data is safe for the given resource, or apply the mitigations.  That's consistent with the other text.",
      "createdAt": "2017-11-26T22:49:52Z",
      "updatedAt": "2017-12-01T00:08:57Z",
      "closedAt": "2017-12-01T00:07:59Z",
      "mergedAt": "2017-12-01T00:07:59Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "LGTM",
          "createdAt": "2017-11-27T09:52:14Z",
          "updatedAt": "2017-11-27T09:52:14Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f79d9380703979cf37b1c75ee4b47b8ead08623a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "must-mitigate",
      "headRefOid": "4bb89f815ed74181910d26b69b704d494a16803e",
      "mergeCommit": {
        "oid": "5344dbcc2c807ca893906e5b4da167d9c0516703"
      }
    },
    {
      "number": 429,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU0NzAxNzA0",
      "title": "Clarify intermediary TLS role better",
      "url": "https://github.com/httpwg/http-extensions/pull/429",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "I think that these are the main places where we weren't clear enough about the relevant TLS role.",
      "createdAt": "2017-11-26T22:51:24Z",
      "updatedAt": "2017-12-01T00:08:54Z",
      "closedAt": "2017-12-01T00:08:08Z",
      "mergedAt": "2017-12-01T00:08:08Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "LGTM",
          "createdAt": "2017-11-27T09:53:34Z",
          "updatedAt": "2017-11-27T09:53:34Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f79d9380703979cf37b1c75ee4b47b8ead08623a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "intermediary-role",
      "headRefOid": "06afc18aee0554bd8716c8f748da3123970a3848",
      "mergeCommit": {
        "oid": "60e18787cd49d56d330ef9ae4d5874e4dde99109"
      }
    },
    {
      "number": 430,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU0NzAyMDIy",
      "title": "New abstract",
      "url": "https://github.com/httpwg/http-extensions/pull/430",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "John Mattsson pointed out that we didn't really discuss the risks of use of early data.  That's fair, but we don't need to.  This rewrites the abstract.",
      "createdAt": "2017-11-26T22:58:19Z",
      "updatedAt": "2017-12-01T00:08:51Z",
      "closedAt": "2017-12-01T00:08:16Z",
      "mergedAt": "2017-12-01T00:08:16Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "Just one fix : s/mechanisms that allows/mechanisms that allow/\r\nNice overall.",
          "createdAt": "2017-11-27T09:55:26Z",
          "updatedAt": "2017-11-27T09:55:26Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f79d9380703979cf37b1c75ee4b47b8ead08623a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "abstract-risks",
      "headRefOid": "8c22103787de0e16d66fbc446f7b6e2473710a08",
      "mergeCommit": {
        "oid": "a43a199e257a89f4776d2abff5dfb288c3d1592b"
      }
    },
    {
      "number": 431,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU0NzAyMzk0",
      "title": "missing a word",
      "url": "https://github.com/httpwg/http-extensions/pull/431",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "Enjoy.",
      "createdAt": "2017-11-26T23:06:19Z",
      "updatedAt": "2017-12-01T00:08:48Z",
      "closedAt": "2017-12-01T00:08:24Z",
      "mergedAt": "2017-12-01T00:08:24Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f79d9380703979cf37b1c75ee4b47b8ead08623a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "editorial-replay",
      "headRefOid": "9f5d56990f9fb6b0e304f53b68371c7b2a958f69",
      "mergeCommit": {
        "oid": "9a927c365d68df07b6fd5c06aabce3ba00c94809"
      }
    },
    {
      "number": 432,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU0ODM3MTM5",
      "title": "Minor editorial fixes for Expect-CT",
      "url": "https://github.com/httpwg/http-extensions/pull/432",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "expect-ct"
      ],
      "body": "/cc @estark37 ",
      "createdAt": "2017-11-27T15:21:45Z",
      "updatedAt": "2017-12-01T16:11:17Z",
      "closedAt": "2017-12-01T16:11:12Z",
      "mergedAt": "2017-12-01T16:11:11Z",
      "mergedBy": "estark37",
      "comments": [
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks!",
          "createdAt": "2017-12-01T16:11:17Z",
          "updatedAt": "2017-12-01T16:11:17Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f79d9380703979cf37b1c75ee4b47b8ead08623a",
      "headRepository": null,
      "headRefName": "expect_ct_typo",
      "headRefOid": "d1a3ecff13db99015e09c2198bf0ea5b1caeeb8e",
      "mergeCommit": {
        "oid": "02dba197e122b070d127a0ec51f21eee536f9edd"
      }
    },
    {
      "number": 439,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU1MTQ3MzA2",
      "title": "Explicitly scope to Origin Set",
      "url": "https://github.com/httpwg/http-extensions/pull/439",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #438.",
      "createdAt": "2017-11-28T18:21:43Z",
      "updatedAt": "2017-11-29T00:32:11Z",
      "closedAt": "2017-11-29T00:32:11Z",
      "mergedAt": "2017-11-29T00:32:11Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "871a80d12aa359ce531274a080c30980662561aa",
      "headRepository": "MikeBishop/http-extensions",
      "headRefName": "additionally",
      "headRefOid": "7347d437283c6dbc3298aea637532d445f4a9683",
      "mergeCommit": {
        "oid": "5738c71d5ce7ca6db2d3ced278feee9c6ce25e00"
      }
    },
    {
      "number": 440,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU1Mjg1Njc2",
      "title": "Nits from Ben Kaduk's review",
      "url": "https://github.com/httpwg/http-extensions/pull/440",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "Hopefully none of this collides with other PRs in flight.",
      "createdAt": "2017-11-29T09:18:30Z",
      "updatedAt": "2017-12-01T00:09:10Z",
      "closedAt": "2017-12-01T00:09:07Z",
      "mergedAt": "2017-12-01T00:09:07Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "I think it's fine with this. Adding a bit of pragmatism as you did in the last commit also reminds that the low cost of retrying is not worth a lot of trouble :-)",
          "createdAt": "2017-11-29T09:23:17Z",
          "updatedAt": "2017-11-29T09:23:17Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5738c71d5ce7ca6db2d3ced278feee9c6ce25e00",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "kaduk-nits",
      "headRefOid": "dd735e747e85142df49d623c3736f00d8522f001",
      "mergeCommit": {
        "oid": "3548b4fae11ea872b9c6176aa296cadb04cc36c0"
      }
    },
    {
      "number": 442,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU1NzUzNDA5",
      "title": "Clarify what to do with out-of-order early data",
      "url": "https://github.com/httpwg/http-extensions/pull/442",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "In response to review by @vasilvv.",
      "createdAt": "2017-12-01T00:16:50Z",
      "updatedAt": "2017-12-08T00:51:40Z",
      "closedAt": "2017-12-08T00:51:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "It' indeed slightly clearer like this.",
          "createdAt": "2017-12-01T05:50:15Z",
          "updatedAt": "2017-12-01T05:50:15Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've a new fix, based on discussion with davidben.",
          "createdAt": "2017-12-08T00:51:39Z",
          "updatedAt": "2017-12-08T00:51:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODA1MTY5NzQ=",
          "commit": {
            "abbreviatedOid": "b721312"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "This does seem to help.  The rest of the document is probably enough that we don't need to say more about proper processing of data that is identified as early.",
          "createdAt": "2017-12-01T14:49:21Z",
          "updatedAt": "2017-12-01T14:50:53Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Hmm, I wonder how we ended up with the gratuitous re-flowing.  (Different editors using different thresholds for which column to wrap at?)",
              "createdAt": "2017-12-01T14:49:21Z",
              "updatedAt": "2017-12-01T14:50:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODA3MTg1MjA=",
          "commit": {
            "abbreviatedOid": "b721312"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-12-03T23:45:45Z",
          "updatedAt": "2017-12-03T23:45:45Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I use both emacs and vim at different times, but both are configured with the same value.  \u00af\\\\_(\u30c4)_/\u00af",
              "createdAt": "2017-12-03T23:45:45Z",
              "updatedAt": "2017-12-03T23:45:45Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3548b4fae11ea872b9c6176aa296cadb04cc36c0",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "victor-late",
      "headRefOid": "b7213126f7338c7c11faa409372fd582cf3c932c",
      "mergeCommit": null
    },
    {
      "number": 444,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU2NTI2MTg2",
      "title": "header-structure: Add a missing close parenthesis",
      "url": "https://github.com/httpwg/http-extensions/pull/444",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-12-05T17:29:22Z",
      "updatedAt": "2018-01-17T21:13:31Z",
      "closedAt": "2017-12-05T23:42:14Z",
      "mergedAt": "2017-12-05T23:42:14Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2017-12-05T23:42:10Z",
          "updatedAt": "2017-12-05T23:42:10Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4a7af674d5fafdccb4a05dd3bd27a23504d39279",
      "headRepository": "jyasskin/http-extensions",
      "headRefName": "patch-1",
      "headRefOid": "2bb1cb3d06fce50289aec0f25e6d88b4ba26e67a",
      "mergeCommit": {
        "oid": "8f9752ed1f0525a70ea637c9f0190a08155d3b99"
      }
    },
    {
      "number": 446,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU3MTQwMDI3",
      "title": "Consistency fix",
      "url": "https://github.com/httpwg/http-extensions/pull/446",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "martinthomson"
      ],
      "labels": [
        "replay"
      ],
      "body": "Thanks @davidben and @vasilvv for pushing on this.",
      "createdAt": "2017-12-08T00:54:55Z",
      "updatedAt": "2018-02-02T01:11:56Z",
      "closedAt": "2018-02-02T01:11:53Z",
      "mergedAt": "2018-02-02T01:11:53Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "I think this is good and can even emphasize how to consistently disable 0-RTT across a cluster for any reason then consistently re-enable it.\r\n",
          "createdAt": "2017-12-08T04:29:28Z",
          "updatedAt": "2017-12-08T04:29:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODI2Mzk3OTE=",
          "commit": {
            "abbreviatedOid": "05ad6d1"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-12-11T21:13:01Z",
          "updatedAt": "2017-12-11T21:13:01Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c1317d63cb9536f02c0de0aff65a77180eee85a3",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "consistency-fix",
      "headRefOid": "05ad6d10d8ee1016441118c69c0522bb45187c16",
      "mergeCommit": {
        "oid": "c091c51eb9220c0e4f2da1e3917346fd3f4bb615"
      }
    },
    {
      "number": 447,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU3MzYwMzIw",
      "title": "Clean up idnits in Secondary Certs",
      "url": "https://github.com/httpwg/http-extensions/pull/447",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "Fixes #445.",
      "createdAt": "2017-12-09T00:14:23Z",
      "updatedAt": "2017-12-09T07:55:04Z",
      "closedAt": "2017-12-09T07:54:50Z",
      "mergedAt": "2017-12-09T07:54:50Z",
      "mergedBy": "MikeBishop",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me.",
          "createdAt": "2017-12-09T04:44:46Z",
          "updatedAt": "2017-12-09T04:44:46Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9f64b5dedd14a02bfc74f7c9434b694e14db3b40",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "idnits-secondary",
      "headRefOid": "60969b6df4aa21d37b79c3ff6a27e5641df371ee",
      "mergeCommit": {
        "oid": "ac7cb072c1a11e2ce52f352830d2558991335233"
      }
    },
    {
      "number": 448,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU3MzYzNDQ1",
      "title": "Use the I-D Template",
      "url": "https://github.com/httpwg/http-extensions/pull/448",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "All the drafts appear to build cleanly on Circle in less than half the time currently required on Travis with the current setup.\r\n\r\n**Benefits:**\r\n\r\n- Doesn't require the installation of Java to build\r\n- Auto-submit\r\n- Under active development\r\n- Doesn't require manual modification of the Makefile every time we add a new draft\r\n\r\n~~**Drawbacks:**~~\r\n\r\n- ~~New template doesn't use Julian's XSLT on Circle until Martin fixes https://github.com/martinthomson/i-d-template/issues/117~~\r\n",
      "createdAt": "2017-12-09T00:51:47Z",
      "updatedAt": "2017-12-13T21:01:37Z",
      "closedAt": "2017-12-12T00:16:19Z",
      "mergedAt": "2017-12-12T00:16:19Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I find xm2rfc's current HTML output disgusting, and as far as I can tell, it doesn't integrate properly into the page HTML (@mnot).\r\n\r\nIf the concern is running Java, then let's just switch to xsltproc.",
          "createdAt": "2017-12-09T04:48:18Z",
          "updatedAt": "2017-12-09T04:48:18Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You can find the current output [here](http://mikebishop.github.io/http-extensions/new-template/); I have trouble seeing this as \"disgusting.\" They're almost exactly equivalent, from a cursory glance -- slightly different font, maybe?  And better styling on the TOC in the new template, but that's a matter of aesthetics.  Can you expand on \"doesn't integrate properly into the page HTML\"?\r\n\r\nJava is certainly a pain every time I have to spin up a new machine, but much bigger is maintainability.  See the [equivalent page in the current repo](http://httpwg.github.io/http-extensions/), in which only two drafts are actually shown, and they're not even two that are currently active in the repo.  The Makefile has to be manually updated for each new draft, rather than simply detecting the drafts as they're added, and even then clearly only builds them rather than adding them to the index.\r\n\r\nThe current version never cleans up old drafts in gh-pages, doesn't build output for branches other than master, doesn't enable you to submit draft versions by tagging and pushing, and so on and so forth.\r\n\r\nSure, you/someone could build all those things into the current version, but... why?  Martin's already done it; let's just steal his code and be done.",
          "createdAt": "2017-12-09T07:49:11Z",
          "updatedAt": "2017-12-09T07:49:11Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was referring to the default output that we used to have in the repo recently for the live-ranges extension.\r\n\r\nWith \"doesn't integrate properly into the page HTML\" I was referring to \"doesn't integrate properly into the page HTML\" I meant http://httpwg.org/specs/ which I thought was including drafts as well.\r\n\r\nI have no objections to changing the build process so that more of it is automated; but that should not affect which actual tools are used.",
          "createdAt": "2017-12-09T09:22:44Z",
          "updatedAt": "2017-12-09T10:56:23Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, some measurements for converting XML to HTML (for secondary certs):\r\n\r\n- rfc2629.xslt on Saxon: 3.4s\r\n- xml2rfc: 1.7s\r\n- rfc2629.xslt on xsltproc: 0.3s\r\n\r\nSo if the primary concern was performance, xsltproc seems to be a clear winner.\r\n\r\nRetrying with the largest in the repo (cookies):\r\n\r\n- rfc2629.xslt on Saxon: 3.5s\r\n- xml2rfc: 1.8s\r\n- rfc2629.xslt on xsltproc: 0.4s\r\n\r\n\r\n",
          "createdAt": "2017-12-09T11:13:04Z",
          "updatedAt": "2017-12-09T11:19:28Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke, last time I ran an end-to-end test, the XSLT variants lost big time because of the dependencies.  That should go away with the docker image though.\r\n\r\nBTW, i-d-template#117 should be fixed and xsltproc available.  Have you checked Mike?  It should be easy to see any speed difference, though you have to be careful with some of the caching rules (retriggers FTW).",
          "createdAt": "2017-12-10T21:20:14Z",
          "updatedAt": "2017-12-10T21:20:14Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm still failing with xsltproc on the Header Structure -- for some reason, it's not able to load the XMLs for the references, even though what appears to be the same documents are being referenced by other docs.  But that's not a problem with the Dockerfile, it's an issue running locally as well.",
          "createdAt": "2017-12-11T19:05:10Z",
          "updatedAt": "2017-12-11T19:05:10Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oops. It seems xsltproc is unable to load \"https\" resources. That's probably a showstopper, unless we can make kramdown inline the references.\r\n\r\n(This used do be a non-issue until a few months ago because IETF references were living at HTTP URIs)",
          "createdAt": "2017-12-11T19:12:39Z",
          "updatedAt": "2017-12-11T19:21:24Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here's what I'm seeing:\r\n\r\n```\r\nxsltproc --novalid lib/rfc2629.xslt draft-ietf-httpbis-header-structure.xml > draft-ietf-httpbis-header-structure.htmltmp\r\nwarning: failed to load external entity \"https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml\"\r\ndraft-ietf-httpbis-header-structure.xml:499: parser error : Failure to process entity RFC7230\r\n&RFC7230;\r\n         ^\r\ndraft-ietf-httpbis-header-structure.xml:499: parser error : Entity 'RFC7230' not defined\r\n&RFC7230;\r\n         ^\r\n```\r\nAnd it continues in that fashion.",
          "createdAt": "2017-12-11T19:20:16Z",
          "updatedAt": "2017-12-11T19:20:16Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep.  It looks like for the ones that are building properly, kramdown-rfc2629 is downloading the references and embedding them in the XML.  This draft gets these at the beginning...  `<!ENTITY RFC7230 SYSTEM \"https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml\">` followed by `&RFC7230;` in the references section.",
          "createdAt": "2017-12-11T19:23:48Z",
          "updatedAt": "2017-12-11T19:23:48Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just opened \r\n\r\n  https://bugzilla.gnome.org/show_bug.cgi?id=791491\r\n\r\n(this was actually reported to me a few days ago, but I didn't make the connection...)",
          "createdAt": "2017-12-11T19:24:14Z",
          "updatedAt": "2017-12-11T19:24:14Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Apparently, adding\r\n\r\n    stand_alone: yes\r\n\r\ndoes the in-lining trick.",
          "createdAt": "2017-12-11T19:30:33Z",
          "updatedAt": "2017-12-11T19:30:33Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, why this isn't the default is baffling.",
          "createdAt": "2017-12-11T19:32:23Z",
          "updatedAt": "2017-12-11T19:32:23Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Might make sense if you convert from MD to XML with the goal to continue editing the XML (such as when it is submitted to the RFC Editor).",
          "createdAt": "2017-12-11T19:36:01Z",
          "updatedAt": "2017-12-11T19:46:33Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Great catch -- added a fix to use stand_alone on the xslt branch.  So, with a sample size of two so far, new-template took (32,39) seconds total on the most recent build, while xslt took (28,35) seconds.  Resulting output for [xsltproc](http://mikebishop.github.io/http-extensions/xslt/) and [xml2rfc](http://mikebishop.github.io/http-extensions/new-template/) is very similar.  So I'd say they're largely equivalent as far as I can see.\r\n\r\nWhile I do like the second better aesthetically, the primary goal here is maintainability and shared code; I can live either way.",
          "createdAt": "2017-12-11T20:00:51Z",
          "updatedAt": "2017-12-11T22:20:06Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Styling the XSLT output is easier, but it would a different stack to run.  I'd say that since it will make some of the things Julian relies on easier, we should pick xslt.\r\n\r\nThat reminds me, I can add a cache for the xslt to the template and get further speed gains.  Maybe some other time.",
          "createdAt": "2017-12-11T23:51:36Z",
          "updatedAt": "2017-12-11T23:51:36Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've merged the XSLT branch into this one, so the PR now uses `xsltproc` within Martin's I-D template.  I agree with Martin that this needs chair approval:  @mnot, @mcmanus?\r\n\r\nNote too that a lot of the speed gains come from running in Martin's Docker container on Circle -- the Travis build times for this branch are already improved (90-120 seconds vs. 120-150 seconds), but not as good as Circle (30-40 seconds).  I've been testing my fork of this repo against Circle.\r\n\r\nI don't believe I have sufficient access to switch the repo from Travis to Circle, and you can't do that in a PR anyway, so that's definitely a chair action.",
          "createdAt": "2017-12-12T00:02:56Z",
          "updatedAt": "2017-12-12T00:02:56Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Switching over; please stand by...",
          "createdAt": "2017-12-12T00:13:07Z",
          "updatedAt": "2017-12-12T00:13:07Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(Note that Circle won't see anything to do on master until this PR is merged.)",
          "createdAt": "2017-12-12T00:16:07Z",
          "updatedAt": "2017-12-12T00:16:07Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "All green. Only used one container.\r\n",
          "createdAt": "2017-12-12T00:18:18Z",
          "updatedAt": "2017-12-12T00:18:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Travis hook deleted.",
          "createdAt": "2017-12-12T00:19:17Z",
          "updatedAt": "2017-12-12T00:19:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I did a push, seems to have worked. However, the HTML files are in different places from where they used to be -- we *can* update the links, but changing links is kind of uncool.\r\n\r\nAlso, I think `SUBMITTING.md` needs an update...",
          "createdAt": "2017-12-12T00:24:15Z",
          "updatedAt": "2017-12-12T00:24:15Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Maybe instead of generating `draft-ietf-httpbis-*.html` we could generate `*.html`? That would reduce the number of links we need to change.",
          "createdAt": "2017-12-12T00:26:58Z",
          "updatedAt": "2017-12-12T00:26:58Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Also - I strongly suspect that building issues.json on every push is going to burn through Github's rate limiting. Can we limit it, or at least assure that we recover from 429 gracefully?",
          "createdAt": "2017-12-12T02:49:55Z",
          "updatedAt": "2017-12-12T02:49:55Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have rate limiting on issues.json, though we still hit the rate cap occasionally.\r\n\r\nWe can add rules for generating `*.html`.  That's a fairly simple exercise.  It's something like:\r\n\r\n```make\r\nlatest:: a.html b.html c.html\r\na.html: draft-ietf-httpbis-a.html \r\n        cp $< $@\r\n# etc...\r\n```\r\n\r\nWe might do better, but it's a little sketchy.",
          "createdAt": "2017-12-12T05:44:26Z",
          "updatedAt": "2017-12-12T05:44:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "That should work; it's just for the existing drafts, going forward we can use the \"full\" names.",
          "createdAt": "2017-12-12T06:00:31Z",
          "updatedAt": "2017-12-12T06:00:31Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "ping. Links still broken.",
          "createdAt": "2017-12-13T01:18:57Z",
          "updatedAt": "2017-12-13T01:18:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I've updated SUBMITTING.md; please review.",
          "createdAt": "2017-12-13T06:29:58Z",
          "updatedAt": "2017-12-13T06:29:58Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hmm. I just commited bcp56bis-00, and it builds locally, and on Circle, but doesn't upload the drafts to `gh-pages`. Any idea why @martinthomson?",
          "createdAt": "2017-12-13T06:50:05Z",
          "updatedAt": "2017-12-13T06:50:05Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Have you set a value for GH_TOKEN in the build configuration?",
          "createdAt": "2017-12-13T14:24:41Z",
          "updatedAt": "2017-12-13T14:24:41Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Re: the *\\*ahem\\**, see https://github.com/martinthomson/i-d-template/pull/119.  It wound up being easier to do inside the template as something that the parent repo could opt into, than to have the parent repo try to force extra things into gh-pages.",
          "createdAt": "2017-12-13T17:17:26Z",
          "updatedAt": "2017-12-13T17:17:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Ah, that's right - GH_TOKEN set, thanks.\r\n\r\nIt looks like gh_issues is built even for pull requests; is there a way to only do it for master?",
          "createdAt": "2017-12-13T20:59:20Z",
          "updatedAt": "2017-12-13T20:59:20Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, though I don't much see the point, other than as another form of rate limiting.\r\n\r\nYou can check the branch in the step.  I think that the variable is CIRCLE_BRANCH.",
          "createdAt": "2017-12-13T21:01:37Z",
          "updatedAt": "2017-12-13T21:01:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODI2ODA1Njc=",
          "commit": {
            "abbreviatedOid": "25d642a"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "You should get chair approval here.",
          "createdAt": "2017-12-11T23:51:58Z",
          "updatedAt": "2017-12-11T23:52:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Add USE_XSLT := true here.",
              "createdAt": "2017-12-11T23:51:59Z",
              "updatedAt": "2017-12-11T23:55:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODI2ODExNDc=",
          "commit": {
            "abbreviatedOid": "25d642a"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-12-11T23:55:13Z",
          "updatedAt": "2017-12-11T23:55:13Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Yes, that's the extra commit on the other branch.  :-)",
              "createdAt": "2017-12-11T23:55:13Z",
              "updatedAt": "2017-12-11T23:55:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODI2ODM5MzU=",
          "commit": {
            "abbreviatedOid": "0bb37c9"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM. ",
          "createdAt": "2017-12-12T00:10:36Z",
          "updatedAt": "2017-12-12T00:10:36Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f92f68e90cc2dd8357e55392a75696d6f26585d7",
      "headRepository": "MikeBishop/http-extensions",
      "headRefName": "new-template",
      "headRefOid": "0bb37c9d3189a428d576162e9662422fe6d48c35",
      "mergeCommit": {
        "oid": "5cccf222ea0fea104b8172208ac6dc63faf801c4"
      }
    },
    {
      "number": 451,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU4MDQ4ODky",
      "title": "remove misleading WHATWG info",
      "url": "https://github.com/httpwg/http-extensions/pull/451",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "remove \"various\" as authors, just list the org, remove misleading date",
      "createdAt": "2017-12-13T10:02:03Z",
      "updatedAt": "2017-12-13T21:17:17Z",
      "closedAt": "2017-12-13T21:17:02Z",
      "mergedAt": "2017-12-13T21:17:02Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "2f3981816d4628fb85f4b7b2cd03042522ed3100",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-bcp56bis-whatwg",
      "headRefOid": "3a1f7bfbccc24c42f8d69c3fb87112b79724fbcd",
      "mergeCommit": {
        "oid": "b267aed6eea7736398184010da3edabf5ceab2ef"
      }
    },
    {
      "number": 452,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU4MTA5MDky",
      "title": "Remove the repellent ribbon",
      "url": "https://github.com/httpwg/http-extensions/pull/452",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #450",
      "createdAt": "2017-12-13T14:33:43Z",
      "updatedAt": "2017-12-13T21:18:19Z",
      "closedAt": "2017-12-13T20:49:27Z",
      "mergedAt": "2017-12-13T20:49:27Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Issue with logic here fixed in the template code.",
          "createdAt": "2017-12-13T21:18:19Z",
          "updatedAt": "2017-12-13T21:18:19Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "2f3981816d4628fb85f4b7b2cd03042522ed3100",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ribbon",
      "headRefOid": "52cae5c3f002bc76ddaaa2566a8fe9dc51fd50a1",
      "mergeCommit": {
        "oid": "369a588898b68e42a55526191a9f6c1391028417"
      }
    },
    {
      "number": 461,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU5NDMwMzcz",
      "title": "no references in abstract",
      "url": "https://github.com/httpwg/http-extensions/pull/461",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "h2-websockets"
      ],
      "body": "",
      "createdAt": "2017-12-20T14:30:32Z",
      "updatedAt": "2017-12-30T15:29:09Z",
      "closedAt": "2017-12-20T14:37:03Z",
      "mergedAt": "2017-12-20T14:37:02Z",
      "mergedBy": "mcmanus",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "145e5803108346193b1812ce95a8db96caf334c6",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-h2ws-abstract",
      "headRefOid": "de7d1865dffe2b1fd0ba52375655e9cd0ed3bbd8",
      "mergeCommit": {
        "oid": "e476cba899549260abfba3348a9537c8e8c7ec69"
      }
    },
    {
      "number": 462,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU5NDMxMTU0",
      "title": "Section reference format",
      "url": "https://github.com/httpwg/http-extensions/pull/462",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-12-20T14:33:49Z",
      "updatedAt": "2017-12-30T15:29:05Z",
      "closedAt": "2017-12-20T14:37:50Z",
      "mergedAt": "2017-12-20T14:37:50Z",
      "mergedBy": "mcmanus",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "145e5803108346193b1812ce95a8db96caf334c6",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-h2ws-refs",
      "headRefOid": "cda287d55201c671c3467201aa39bee3bd3a92ee",
      "mergeCommit": {
        "oid": "ae56f9cd6d4840d6dc8648bd9e76bc5d01149f03"
      }
    },
    {
      "number": 463,
      "id": "MDExOlB1bGxSZXF1ZXN0MTYwNTkyMzIz",
      "title": "make section reference a link",
      "url": "https://github.com/httpwg/http-extensions/pull/463",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-12-30T15:30:09Z",
      "updatedAt": "2017-12-30T15:32:05Z",
      "closedAt": "2017-12-30T15:31:54Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ae56f9cd6d4840d6dc8648bd9e76bc5d01149f03",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "section-ref-link",
      "headRefOid": "8756b09975289f00d805f0717ccd8450fcc3ad90",
      "mergeCommit": null
    },
    {
      "number": 464,
      "id": "MDExOlB1bGxSZXF1ZXN0MTYwNTkzOTc4",
      "title": "consistency: \"header field\"",
      "url": "https://github.com/httpwg/http-extensions/pull/464",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "craigpratt"
      ],
      "labels": [
        "rand-access-live"
      ],
      "body": "",
      "createdAt": "2017-12-30T16:36:57Z",
      "updatedAt": "2018-03-20T17:25:54Z",
      "closedAt": "2018-03-20T17:18:42Z",
      "mergedAt": "2018-03-20T17:18:42Z",
      "mergedBy": "craigpratt",
      "comments": [
        {
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note this was manually incorporated into draft-ietf-httpbis-rand-access-live-03",
          "createdAt": "2018-03-20T17:25:48Z",
          "updatedAt": "2018-03-20T17:25:48Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4807b01935df6d3914de901edac0f3a6e5f3f5b9",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-range-header-field",
      "headRefOid": "8a9af59a881d2665bc06d093e242be26b224389d",
      "mergeCommit": {
        "oid": "fb955824704b49e812f7534cbb587dfecade3288"
      }
    },
    {
      "number": 465,
      "id": "MDExOlB1bGxSZXF1ZXN0MTYwNTk0MDg4",
      "title": "fix missing word",
      "url": "https://github.com/httpwg/http-extensions/pull/465",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "craigpratt"
      ],
      "labels": [
        "rand-access-live"
      ],
      "body": "",
      "createdAt": "2017-12-30T16:40:59Z",
      "updatedAt": "2018-03-20T17:25:26Z",
      "closedAt": "2018-03-20T17:22:42Z",
      "mergedAt": "2018-03-20T17:22:42Z",
      "mergedBy": "craigpratt",
      "comments": [
        {
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note this was manually incorporated into draft-ietf-httpbis-rand-access-live-03",
          "createdAt": "2018-03-20T17:24:25Z",
          "updatedAt": "2018-03-20T17:24:25Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "fb955824704b49e812f7534cbb587dfecade3288",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-rand-missing-word",
      "headRefOid": "5c5c958c792e1f40f0eca02b60c416c1348f97d2",
      "mergeCommit": {
        "oid": "cd5fefd80b4373c2ccce992797efc31b399a14c9"
      }
    },
    {
      "number": 466,
      "id": "MDExOlB1bGxSZXF1ZXN0MTYwODM2ODA1",
      "title": "It's not 2017",
      "url": "https://github.com/httpwg/http-extensions/pull/466",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Uses {DATE} to let the date be auto-added at build time.",
      "createdAt": "2018-01-03T01:52:25Z",
      "updatedAt": "2018-04-03T17:52:14Z",
      "closedAt": "2018-01-03T19:27:54Z",
      "mergedAt": "2018-01-03T19:27:54Z",
      "mergedBy": "MikeBishop",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see that you removed trailing whitespace here.  Do you want to add a .editorconfig so that this is done more consistently?",
          "createdAt": "2018-01-03T05:42:43Z",
          "updatedAt": "2018-01-03T05:42:43Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps, but I did that as an incidental so the template would let me check in the change.  Let's address that separately.",
          "createdAt": "2018-01-03T18:50:05Z",
          "updatedAt": "2018-01-03T18:50:05Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ae56f9cd6d4840d6dc8648bd9e76bc5d01149f03",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "fix_date",
      "headRefOid": "f7e266c7644f30ab4e6262b52e110ee531d21605",
      "mergeCommit": {
        "oid": "03e7eaedd973726e7ee4f1411c14863eb021a116"
      }
    },
    {
      "number": 467,
      "id": "MDExOlB1bGxSZXF1ZXN0MTYwOTgxMzE0",
      "title": "Shortnames in gh-pages",
      "url": "https://github.com/httpwg/http-extensions/pull/467",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Uses the added feature in https://github.com/martinthomson/i-d-template/pull/129 to drop shortname copies of the drafts in gh-pages to fix the broken links.  These are actual copies, not symlinks, but git keeps those relatively cheap.\r\n\r\nShouldn't break anything to have in the Makefile without that change, either.",
      "createdAt": "2018-01-03T19:21:00Z",
      "updatedAt": "2018-01-03T23:17:43Z",
      "closedAt": "2018-01-03T23:16:06Z",
      "mergedAt": "2018-01-03T23:16:06Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODY1MTcxMTQ=",
          "commit": {
            "abbreviatedOid": "d9ff779"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "A few minor improvements.",
          "createdAt": "2018-01-03T23:01:56Z",
          "updatedAt": "2018-01-03T23:06:16Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Just do this:\r\n\r\n```make\r\nclean::\r\n        -rm -f $(GHPAGES_EXTRA)\r\n```",
              "createdAt": "2018-01-03T23:01:56Z",
              "updatedAt": "2018-01-03T23:09:13Z"
            },
            {
              "originalPosition": 4,
              "body": "Use `:=` or the expansion of GHPAGES_EXTRA will run the loop every time that `$(GHPAGES_EXTRA)` appears.",
              "createdAt": "2018-01-03T23:03:26Z",
              "updatedAt": "2018-01-03T23:09:13Z"
            },
            {
              "originalPosition": 15,
              "body": "Cunning.  No dependencies, but then it doesn't need any.",
              "createdAt": "2018-01-03T23:06:12Z",
              "updatedAt": "2018-01-03T23:09:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODY1MTg1NjM=",
          "commit": {
            "abbreviatedOid": "d9ff779"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-03T23:10:27Z",
          "updatedAt": "2018-01-03T23:10:27Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "That's intentional, actually.  $(drafts) is undefined until after the import, at which point it's too late.  By delaying expansion, it *is* defined by the time GHPAGES_EXTRA is used.",
              "createdAt": "2018-01-03T23:10:27Z",
              "updatedAt": "2018-01-03T23:10:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODY1MTk0MzY=",
          "commit": {
            "abbreviatedOid": "d9ff779"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-03T23:15:38Z",
          "updatedAt": "2018-01-03T23:15:38Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Ugh, oh well.  There should only be two expansions, so that isn't so bad.",
              "createdAt": "2018-01-03T23:15:38Z",
              "updatedAt": "2018-01-03T23:15:38Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ae56f9cd6d4840d6dc8648bd9e76bc5d01149f03",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ghpages_extra",
      "headRefOid": "0607e16ccfc72da782d754d997ff314508e7f07e",
      "mergeCommit": {
        "oid": "459af35a9542ef5f4e058112847e0534a32b8ff9"
      }
    },
    {
      "number": 469,
      "id": "MDExOlB1bGxSZXF1ZXN0MTYyNzAxMjk5",
      "title": "Add SETTINGS_ prefix to parameter name.",
      "url": "https://github.com/httpwg/http-extensions/pull/469",
      "state": "MERGED",
      "author": "bencebeky",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "* Add SETTINGS_ prefix to parameter name ENABLE_CONNECT_PROTOCOL.\r\n* Fix one typo (\"s/a entry/an entry/\").\r\n* Remove \"(type = 0x8)\" which is ambigous (what is type?) and redundant\r\n  with code listed in IANA Considerations section.",
      "createdAt": "2018-01-12T18:56:36Z",
      "updatedAt": "2018-01-12T19:07:43Z",
      "closedAt": "2018-01-12T19:07:43Z",
      "mergedAt": "2018-01-12T19:07:43Z",
      "mergedBy": "mcmanus",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks",
          "createdAt": "2018-01-12T19:07:37Z",
          "updatedAt": "2018-01-12T19:07:37Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6752fb44e21308e6d54ca47784112d9dc1462bf9",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "5aca6864971080503731ace9130360f6fb98532a",
      "mergeCommit": {
        "oid": "2aa295b12e30c7a6ddc1dfa2ada627105f84b4d2"
      }
    },
    {
      "number": 472,
      "id": "MDExOlB1bGxSZXF1ZXN0MTYzNTUzOTQ2",
      "title": "Fix the number of members in a list.",
      "url": "https://github.com/httpwg/http-extensions/pull/472",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "The counts forgot to include the initial required member.\r\n\r\nThe parsing algorithm also doesn't enforce any bounds on the number of items, but I haven't fixed that here.",
      "createdAt": "2018-01-17T21:13:05Z",
      "updatedAt": "2018-02-07T19:09:25Z",
      "closedAt": "2018-02-01T23:31:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks, had to manually incorporate.",
          "createdAt": "2018-02-01T23:31:52Z",
          "updatedAt": "2018-02-01T23:31:52Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c1317d63cb9536f02c0de0aff65a77180eee85a3",
      "headRepository": "jyasskin/http-extensions",
      "headRefName": "fix-list-member-count",
      "headRefOid": "a3fa7af24b8f41f310b82b5ada0e5421d3698abf",
      "mergeCommit": null
    },
    {
      "number": 478,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2OTIyMjQ0",
      "title": "bcp56bis: Status code reason phrase",
      "url": "https://github.com/httpwg/http-extensions/pull/478",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Port over of PR from mnot repo. Modified last sentence to avoid to much usage of the word \"further\".",
      "createdAt": "2018-02-02T22:54:34Z",
      "updatedAt": "2018-02-13T04:26:49Z",
      "closedAt": "2018-02-13T04:26:45Z",
      "mergedAt": "2018-02-13T04:26:45Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2018-02-13T04:26:49Z",
          "updatedAt": "2018-02-13T04:26:49Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c091c51eb9220c0e4f2da1e3917346fd3f4bb615",
      "headRepository": "LPardue/http-extensions",
      "headRefName": "patch-2",
      "headRefOid": "a1621c7ae6cf1e78736a5a93234164ce92ac07fa",
      "mergeCommit": {
        "oid": "a868e00f717b32ded38e6f0f2bebc3b8173c64d0"
      }
    },
    {
      "number": 480,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY3MjE5NDE3",
      "title": "Remove AUTOMATIC_USE",
      "url": "https://github.com/httpwg/http-extensions/pull/480",
      "state": "CLOSED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "MikeBishop"
      ],
      "labels": [
        "secondary-certs"
      ],
      "body": "Implements Kazuho's suggestion to remove AUTOMATIC_USE and replace it with the ability to send USE_CERTIFICATE as part of the request.\r\n\r\n(Note that this runs headlong into the frames-on-closed-streams problem and might need to be delayed until we fix that.)\r\n\r\nThis is a straight port of https://github.com/MikeBishop/http2-certs/pull/17; I'll address the feedback from that PR shortly.",
      "createdAt": "2018-02-05T18:25:17Z",
      "updatedAt": "2018-05-29T06:09:19Z",
      "closedAt": "2018-04-13T17:26:47Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQxNTEwMzI=",
          "commit": {
            "abbreviatedOid": "8dbce8e"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-05T21:36:03Z",
          "updatedAt": "2018-02-05T21:44:01Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "You use a lot of \"SHOULD\" here, and I think that they are for the wrong reason.\r\n\r\nIn this case, you are using SHOULD to avoid having to say *why* the client might want to verify that the server has a valid certificate.  Here, you can say that the verification is mandatory.  In many other cases, you can describe what goal the endpoint might have and how it can achieve that goal.",
              "createdAt": "2018-02-05T21:36:03Z",
              "updatedAt": "2018-02-05T21:44:01Z"
            },
            {
              "originalPosition": 147,
              "body": "lazy SHOULD: If a client requests a certificate that is already available, the server can send a `USE_CERTIFICATE` frame to signal which certificate it assumes to be effective.",
              "createdAt": "2018-02-05T21:39:36Z",
              "updatedAt": "2018-02-05T21:44:01Z"
            },
            {
              "originalPosition": 191,
              "body": "You need to explain what ordering you expect to have here.  After the header block, but before the request body.  Which implies an empty DATA frame rather than a HEADERS frame with FIN attached.",
              "createdAt": "2018-02-05T21:41:41Z",
              "updatedAt": "2018-02-05T21:44:01Z"
            },
            {
              "originalPosition": 220,
              "body": "We need to be very clear about what it means to say that the request is ended, because the client won't be able to send USE_CERTIFICATE on a half-closed stream.  (Do we have an issue for that?)",
              "createdAt": "2018-02-05T21:42:49Z",
              "updatedAt": "2018-02-05T21:44:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQxNzc3NDQ=",
          "commit": {
            "abbreviatedOid": "8dbce8e"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-05T23:15:28Z",
          "updatedAt": "2018-02-05T23:15:28Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "Yes, #482.",
              "createdAt": "2018-02-05T23:15:28Z",
              "updatedAt": "2018-02-05T23:15:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMjkyNjQz",
          "commit": {
            "abbreviatedOid": "8dbce8e"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-01T01:29:52Z",
          "updatedAt": "2018-03-01T01:29:52Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "Aside from the point raised by @martinthomson, I think we should allow a server to send a `CERTIFICATE_NEEDED` frame before seeing the end of the request.\r\n\r\nAs stated in https://github.com/MikeBishop/http2-certs/pull/17#discussion_r151328990, CGI (and other APIs that have been designed based on CGI) require the properties of a certificate (e.g. DN) to be sent before the request body.\r\n\r\nUnless we allow the `CERTIFICATE_NEEDED` to be sent while the request body is being transmitted, a server will be required to buffer entire request body when it needs to enforce the use of a client certificate.",
              "createdAt": "2018-03-01T01:29:52Z",
              "updatedAt": "2018-03-01T01:29:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwOTExODg2",
          "commit": {
            "abbreviatedOid": "8dbce8e"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-02T21:01:30Z",
          "updatedAt": "2018-03-02T21:01:30Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "That's a good point.  The reason for that text is to ensure there's not a race, so the server doesn't send in ignorance of whether the client already included one.  (And therefore, doesn't get either side confused about whether the `USE_CERTIFICATE` is in response to the server's `CERTIFICATE_REQUIRED`.)",
              "createdAt": "2018-03-02T21:01:30Z",
              "updatedAt": "2018-03-02T21:01:30Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4807b01935df6d3914de901edac0f3a6e5f3f5b9",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "not_automatic",
      "headRefOid": "8dbce8e65f05183f3896368dcdca48de8c274239",
      "mergeCommit": null
    },
    {
      "number": 481,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY3MjE5ODg0",
      "title": "Incorporate exported authenticator requests",
      "url": "https://github.com/httpwg/http-extensions/pull/481",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "Tracking changes from tlswg/tls-exported-authenticator#9 to create an exported authenticator request message at the TLS layer as well.\r\n\r\nThis is a straight port of https://github.com/MikeBishop/http2-certs/pull/18/; feedback there has already been addressed, modulo one issue I'll be adding to this repo.",
      "createdAt": "2018-02-05T18:27:31Z",
      "updatedAt": "2018-02-06T00:10:39Z",
      "closedAt": "2018-02-06T00:10:16Z",
      "mergedAt": "2018-02-06T00:10:16Z",
      "mergedBy": "MikeBishop",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQxNTQyMDc=",
          "commit": {
            "abbreviatedOid": "42f69c8"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "A couple of minor things that are probably important enough to get right at this point.",
          "createdAt": "2018-02-05T21:46:24Z",
          "updatedAt": "2018-02-05T21:55:59Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Exported authenticators require that the certificate_request_context be unpredictable.  I think that we can address this by prefixing a random sequence with the two-octet Request-ID.  Then we can ensure that we have a mapping key, but also enough entropy to avoid guessing.",
              "createdAt": "2018-02-05T21:46:24Z",
              "updatedAt": "2018-02-06T00:08:44Z"
            },
            {
              "originalPosition": 97,
              "body": "Verify that the authenticator has either an empty `certificate_request_context` (for clients only), or contains a Request-ID from a previously-sent `CERTIFICATE_REQUEST` frame.",
              "createdAt": "2018-02-05T21:53:21Z",
              "updatedAt": "2018-02-06T00:08:44Z"
            },
            {
              "originalPosition": 89,
              "body": "This statement applies to the *creation* of an authenticator.  But the following paragraph talks about validation of one.  I think that you need to make that distinction a lot clearer.",
              "createdAt": "2018-02-05T21:54:17Z",
              "updatedAt": "2018-02-06T00:08:44Z"
            },
            {
              "originalPosition": 8,
              "body": "This is really a requirement on exported authenticators.  Can we turn this into a statement of truth instead?  Or remove it entirely.",
              "createdAt": "2018-02-05T21:55:08Z",
              "updatedAt": "2018-02-06T00:08:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQxNTk2MTY=",
          "commit": {
            "abbreviatedOid": "42f69c8"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "A few clarifications.  I'll work on the others in the meantime.",
          "createdAt": "2018-02-05T22:04:40Z",
          "updatedAt": "2018-02-05T22:06:28Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I'm not sure that's true -- the exported authenticator functionality is responsible for communicating the requirements and the certificate, but it's not responsible for selecting the certificate to respond with.  I think it's a requirement on whomever does certificate selection, which I believe is the HTTP layer (or some library invoked by it, anyway).",
              "createdAt": "2018-02-05T22:04:40Z",
              "updatedAt": "2018-02-06T00:08:44Z"
            },
            {
              "originalPosition": 65,
              "body": "Should we specify the length?",
              "createdAt": "2018-02-05T22:05:24Z",
              "updatedAt": "2018-02-06T00:08:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQxODQwNTI=",
          "commit": {
            "abbreviatedOid": "42f69c8"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-05T23:46:38Z",
          "updatedAt": "2018-02-05T23:46:38Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "It's not really actionable though.  If your intent is to state an interoperability requirement (why else do you use MUST), what do we lose if someone violates that?  I mean, I know that NSS could try harder to comply, but we do have better things to do than add full support for oid_filter (just for example, which is really hard to implement in practice).",
              "createdAt": "2018-02-05T23:46:38Z",
              "updatedAt": "2018-02-06T00:08:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQxODQyNzA=",
          "commit": {
            "abbreviatedOid": "42f69c8"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-05T23:47:53Z",
          "updatedAt": "2018-02-05T23:47:53Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "We probably need a minimum size to stop someone from inducing lots of requests until the right number comes up (for the stolen credentials they have).",
              "createdAt": "2018-02-05T23:47:53Z",
              "updatedAt": "2018-02-06T00:08:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQxODQzODc=",
          "commit": {
            "abbreviatedOid": "c6e1306"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-05T23:48:32Z",
          "updatedAt": "2018-02-05T23:48:32Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Or *contains* the Request-ID.",
              "createdAt": "2018-02-05T23:48:32Z",
              "updatedAt": "2018-02-06T00:08:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQxODUwMDA=",
          "commit": {
            "abbreviatedOid": "c6e1306"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-05T23:51:52Z",
          "updatedAt": "2018-02-05T23:51:53Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I don't think that we need to stipulate order.  Can we say that it contains both the two-octet Request-ID and at least 96 bits of additional entropy.   (64-bits total isn't enough to avoid the problem I was talking about, especially when you consider that there is a good reason to choose a sequential Request-ID, which reduces that to 48 bits).\r\n\r\nBTW, those extra bits can be constructed using HMAC(secret, Request-ID), rather than randomness.",
              "createdAt": "2018-02-05T23:51:53Z",
              "updatedAt": "2018-02-06T00:08:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQxODY4Njk=",
          "commit": {
            "abbreviatedOid": "b42dc03"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-06T00:01:50Z",
          "updatedAt": "2018-02-06T00:01:50Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "26f380857c57e576ae51736325ec14cc7fabed2f",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "exported_requests",
      "headRefOid": "9cfbb2c2dfb5d8453191b2e664e9e6c46b1e4f6d",
      "mergeCommit": {
        "oid": "4fc6308c00c78a0e653f6e6ed40bb78adcd2dabe"
      }
    },
    {
      "number": 487,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY3MzgyNDk0",
      "title": "move acks to the end and make them unnumbered",
      "url": "https://github.com/httpwg/http-extensions/pull/487",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "...which is how the RFC Editor likes it.",
      "createdAt": "2018-02-06T11:03:46Z",
      "updatedAt": "2018-02-06T17:30:12Z",
      "closedAt": "2018-02-06T17:26:56Z",
      "mergedAt": "2018-02-06T17:26:56Z",
      "mergedBy": "MikeBishop",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4fc6308c00c78a0e653f6e6ed40bb78adcd2dabe",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-certs-acks",
      "headRefOid": "4be36094a50384c3c00d36890dbaf49709fffda7",
      "mergeCommit": {
        "oid": "1d287808342737b083efd8a2ff770bee77eb1eb5"
      }
    },
    {
      "number": 488,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY4NTgwMTU5",
      "title": "move acks to end and make them unnumbered",
      "url": "https://github.com/httpwg/http-extensions/pull/488",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "",
      "createdAt": "2018-02-12T13:36:55Z",
      "updatedAt": "2018-04-09T23:45:14Z",
      "closedAt": "2018-03-27T00:49:48Z",
      "mergedAt": "2018-03-27T00:49:48Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "@reschke apologies missed this PR! LGTM and thank you.",
          "createdAt": "2018-03-27T00:49:43Z",
          "updatedAt": "2018-03-27T00:49:43Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4807b01935df6d3914de901edac0f3a6e5f3f5b9",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "client-hints-acks",
      "headRefOid": "7b9db7ba7b06ee5383970f3f5bfade33c5d11bb6",
      "mergeCommit": {
        "oid": "96a0630090ee1b0ac0e0cffce9803c6ea9129d8c"
      }
    },
    {
      "number": 489,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY4NTgxMjcw",
      "title": "move change log to appendix",
      "url": "https://github.com/httpwg/http-extensions/pull/489",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "estark37"
      ],
      "labels": [
        "expect-ct"
      ],
      "body": "",
      "createdAt": "2018-02-12T13:41:51Z",
      "updatedAt": "2018-05-29T06:09:21Z",
      "closedAt": "2018-05-19T15:25:51Z",
      "mergedAt": "2018-05-19T15:25:51Z",
      "mergedBy": "estark37",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4807b01935df6d3914de901edac0f3a6e5f3f5b9",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "expect-ct-changelog",
      "headRefOid": "384f616b250720ca75146d1fe22a6ffc165b4e5c",
      "mergeCommit": {
        "oid": "cb18cc0214baf4fe9d630586c7b46bd72a80f18f"
      }
    },
    {
      "number": 490,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY4NTgxNzk0",
      "title": "make Acknowledgements appendix unnumbered",
      "url": "https://github.com/httpwg/http-extensions/pull/490",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "",
      "createdAt": "2018-02-12T13:44:00Z",
      "updatedAt": "2018-04-09T23:45:07Z",
      "closedAt": "2018-02-22T08:39:44Z",
      "mergedAt": "2018-02-22T08:39:44Z",
      "mergedBy": "mikewest",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTg0ODE3MjM=",
          "commit": {
            "abbreviatedOid": "b3caf35"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2018-02-22T08:39:38Z",
          "updatedAt": "2018-02-22T08:39:38Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1d287808342737b083efd8a2ff770bee77eb1eb5",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "cookies-acks-unnumbered",
      "headRefOid": "b3caf35d2fff3f2ef4262707aee1d965bbd71ce0",
      "mergeCommit": {
        "oid": "8656967e8c757ad8524b0370c61aee65e88219e3"
      }
    },
    {
      "number": 498,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxNTc3NTk4",
      "title": "expect-ct: move change log to appendix",
      "url": "https://github.com/httpwg/http-extensions/pull/498",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "expect-ct"
      ],
      "body": "",
      "createdAt": "2018-02-27T06:52:04Z",
      "updatedAt": "2018-04-09T23:44:57Z",
      "closedAt": "2018-03-01T04:40:36Z",
      "mergedAt": "2018-03-01T04:40:36Z",
      "mergedBy": "estark37",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "374264b694b78af5437f5a834afc3a6ba2273dbf",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-expect-back",
      "headRefOid": "385449b5588ebce9db245d005797b099c848eb75",
      "mergeCommit": {
        "oid": "951e4e73a57c94b915a42f4dfad39a069beb22a2"
      }
    },
    {
      "number": 499,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxNTc4MjQ4",
      "title": "expect: consistently talk about header *fields*",
      "url": "https://github.com/httpwg/http-extensions/pull/499",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "expect-ct"
      ],
      "body": "",
      "createdAt": "2018-02-27T06:56:29Z",
      "updatedAt": "2018-04-09T23:44:50Z",
      "closedAt": "2018-03-01T04:41:10Z",
      "mergedAt": "2018-03-01T04:41:10Z",
      "mergedBy": "estark37",
      "comments": [
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks!",
          "createdAt": "2018-03-01T04:41:06Z",
          "updatedAt": "2018-03-01T04:41:06Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "374264b694b78af5437f5a834afc3a6ba2273dbf",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-expect-field",
      "headRefOid": "b105cc61f46f3772564c7647a2219efdfd872dd0",
      "mergeCommit": {
        "oid": "50031656282e76b990c6efb5f0ad473a6edb15ad"
      }
    },
    {
      "number": 500,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxOTYxNjQz",
      "title": "Switch to Cuckoo Filter",
      "url": "https://github.com/httpwg/http-extensions/pull/500",
      "state": "CLOSED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Simply swaps GCS with Cuckoo Filter.\r\n\r\nThe difference from #413 (which this PR is based upon) is that this PR retains the possibility of the client sending a digest of fresh resources without ETag values being included as part of the hash.\r\n\r\nThis was considered necessary so that an endpoint can determine if it needs to push a resource without the knowledge of the ETag value of the resource. For example, by URL being the only source of the hash function, a H2 proxy that just holds a list of preload URLs can determine which ones in the list needs to be pushed, _and then_ fetch them from origin servers to push them.",
      "createdAt": "2018-02-28T14:03:01Z",
      "updatedAt": "2018-03-01T05:00:31Z",
      "closedAt": "2018-03-01T01:48:10Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@yoavweiss @mnot PTAL",
          "createdAt": "2018-02-28T14:11:52Z",
          "updatedAt": "2018-02-28T14:11:52Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@yoavweiss Thank you for checking!",
          "createdAt": "2018-02-28T15:22:10Z",
          "updatedAt": "2018-02-28T15:22:10Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My bad. I have accidentally removed the branch that caused the PR to get closed.",
          "createdAt": "2018-03-01T01:51:05Z",
          "updatedAt": "2018-03-01T01:51:05Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since I accidentally removed the branch, it has become impossible to continue reviewing the changes in this branch. I apologize for the inconvenience.\r\n\r\nFortunately, @yoavweiss and @mnot had already given their comments. Considering that, I have merged the PR to master in 63284be (FWIW, you can click the commit hash to see the changes that went into master).\r\n\r\nIf anybody sees an issue, I would appreciate if they could open a new issue (or a PR).",
          "createdAt": "2018-03-01T02:10:48Z",
          "updatedAt": "2018-03-01T02:11:08Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Nothing major, but s/Substract/Subtract/ig",
          "createdAt": "2018-03-01T04:19:16Z",
          "updatedAt": "2018-03-01T04:19:16Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson Thank you for pointing that out. I was able to fix that in a8f1ca0 prior to submitting -03.",
          "createdAt": "2018-03-01T05:00:31Z",
          "updatedAt": "2018-03-01T05:00:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMDc3NTMx",
          "commit": {
            "abbreviatedOid": "8d9ba5d"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-28T14:17:57Z",
          "updatedAt": "2018-02-28T14:17:57Z",
          "comments": [
            {
              "originalPosition": 358,
              "body": "s/Joav/Yoav/ :D",
              "createdAt": "2018-02-28T14:17:57Z",
              "updatedAt": "2018-03-01T01:47:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMDc4MjU3",
          "commit": {
            "abbreviatedOid": "8d9ba5d"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2018-02-28T14:19:52Z",
          "updatedAt": "2018-02-28T14:19:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMTAzODI3",
          "commit": {
            "abbreviatedOid": "8d9ba5d"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-28T15:22:06Z",
          "updatedAt": "2018-02-28T15:22:07Z",
          "comments": [
            {
              "originalPosition": 358,
              "body": "I'm terribly sorry for the mistake. Fixed in f8e63e2.",
              "createdAt": "2018-02-28T15:22:06Z",
              "updatedAt": "2018-03-01T01:47:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMTg2Mjgw",
          "commit": {
            "abbreviatedOid": "f8e63e2"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-28T18:58:52Z",
          "updatedAt": "2018-02-28T18:58:53Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Double check that the generated text and HTML are correct. In the past, list numbers higher than 9 needed to wrap around to 0 to work correctly; not sure if that's been fixed or not.",
              "createdAt": "2018-02-28T18:58:53Z",
              "updatedAt": "2018-03-01T01:47:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMjk3NTg3",
          "commit": {
            "abbreviatedOid": "f8e63e2"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-01T02:04:59Z",
          "updatedAt": "2018-03-01T02:04:59Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Thank you for pointing that out.\r\n\r\nThe numbers were correctly handled by the parser, however the numbers in the markdown were wrong.\r\n\r\nThe issue has been fixed in 8469d48.",
              "createdAt": "2018-03-01T02:04:59Z",
              "updatedAt": "2018-03-01T02:04:59Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "374264b694b78af5437f5a834afc3a6ba2273dbf",
      "headRepository": "kazuho/http-extensions",
      "headRefName": "kazuho/h2-cache-digest/cuckoo",
      "headRefOid": "a701924ef7e40535e9b4abc1ca4764ad52df32b9",
      "mergeCommit": null
    },
    {
      "number": 503,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcyMjI2NTIx",
      "title": "move acks to the end and make them unnumbered",
      "url": "https://github.com/httpwg/http-extensions/pull/503",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "kazuho"
      ],
      "labels": [
        "cache-digest"
      ],
      "body": "",
      "createdAt": "2018-03-01T12:44:07Z",
      "updatedAt": "2018-10-22T05:36:38Z",
      "closedAt": "2018-07-01T15:15:12Z",
      "mergedAt": "2018-07-01T15:15:11Z",
      "mergedBy": "kazuho",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for the fix!",
          "createdAt": "2018-07-01T15:15:26Z",
          "updatedAt": "2018-07-01T15:15:26Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4807b01935df6d3914de901edac0f3a6e5f3f5b9",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "cache-digest-acks",
      "headRefOid": "ed4dda29c9422736c055a8070c1b626f36751ec4",
      "mergeCommit": {
        "oid": "ed4dda29c9422736c055a8070c1b626f36751ec4"
      }
    },
    {
      "number": 506,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc0MzE5NDg4",
      "title": "Added description of caching limitations for Range-less shift-buffer requests",
      "url": "https://github.com/httpwg/http-extensions/pull/506",
      "state": "MERGED",
      "author": "craigpratt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "craigpratt"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2018-03-12T10:02:20Z",
      "updatedAt": "2018-03-19T22:32:07Z",
      "closedAt": "2018-03-19T19:34:55Z",
      "mergedAt": "2018-03-19T19:34:55Z",
      "mergedBy": "craigpratt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAyOTkzNTcw",
          "commit": {
            "abbreviatedOid": "64cf7c9"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-12T10:49:02Z",
          "updatedAt": "2018-03-12T10:49:03Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "either that or the resource provided might be identified differently\r\n\r\nthat is, if the start of `/live` moves by 10M, then you might redirect to `/live+10M`, all assuming that the redirect works (content-location isn't especially nice for this because it isn't any more cacheable",
              "createdAt": "2018-03-12T10:49:03Z",
              "updatedAt": "2018-03-19T19:24:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAzMjYzODk3",
          "commit": {
            "abbreviatedOid": "64cf7c9"
          },
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-13T00:20:49Z",
          "updatedAt": "2018-03-13T00:20:49Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Interesting idea @martinthomson. I'll see if I can reword to not preclude this option.\r\n\r\nSo guess I need to sprinkle in \"successful responses\" on both of these sentences and maybe include redirect as an example.\r\n\r\nI'll revise tonight. Thx!",
              "createdAt": "2018-03-13T00:20:49Z",
              "updatedAt": "2018-03-19T19:24:08Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b25285cdbbc0bda7dc347883922f1bd512b6259e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "cpratt/non-cache-shift-buffer-gets",
      "headRefOid": "e550f15a7f45ae2f7937856ceb5c16a599a6865a",
      "mergeCommit": {
        "oid": "b2761f26db7eaf5b0faa1468880bb004bc1c0eff"
      }
    },
    {
      "number": 507,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NTQ4NTUz",
      "title": "5988->8288",
      "url": "https://github.com/httpwg/http-extensions/pull/507",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "",
      "createdAt": "2018-03-16T14:27:49Z",
      "updatedAt": "2018-04-09T23:44:27Z",
      "closedAt": "2018-03-16T15:06:07Z",
      "mergedAt": "2018-03-16T15:06:07Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b25285cdbbc0bda7dc347883922f1bd512b6259e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-bcp56bis-1",
      "headRefOid": "acd30970f37f5585b412d73c0429ee7bdd86ff4a",
      "mergeCommit": {
        "oid": "4babe79bfc375c5cc862137ab27c6d705d03c940"
      }
    },
    {
      "number": 508,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NTQ5NzYw",
      "title": "7159->8259",
      "url": "https://github.com/httpwg/http-extensions/pull/508",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "",
      "createdAt": "2018-03-16T14:31:43Z",
      "updatedAt": "2018-04-09T23:44:20Z",
      "closedAt": "2018-03-16T15:07:01Z",
      "mergedAt": "2018-03-16T15:07:01Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b25285cdbbc0bda7dc347883922f1bd512b6259e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-bcp56bis-2",
      "headRefOid": "f18588d9cd9bdae5b4d0f1b010c177f96e11f591",
      "mergeCommit": {
        "oid": "07caf2026b30da12bc4c9f0171712785cf922d78"
      }
    },
    {
      "number": 509,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NTUyMTc2",
      "title": "avoid markdown syntax in spec text examples",
      "url": "https://github.com/httpwg/http-extensions/pull/509",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mnot"
      ],
      "labels": [
        "bcp56bis"
      ],
      "body": "(this change will be in conflict with the JSON reference update though)",
      "createdAt": "2018-03-16T14:40:08Z",
      "updatedAt": "2018-04-09T23:44:12Z",
      "closedAt": "2018-03-30T00:23:57Z",
      "mergedAt": "2018-03-30T00:23:57Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA0NjQwNDcx",
          "commit": {
            "abbreviatedOid": "466660c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-16T16:48:58Z",
          "updatedAt": "2018-03-16T16:48:58Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "If the intent is to avoid creating a reference, then you want `\\[RFC7230]`.  Functionally, this isn't a change at all.\r\n\r\nBTW, if the intent is to blockquote this section, it should use `> Foo Application [...]`.",
              "createdAt": "2018-03-16T16:48:58Z",
              "updatedAt": "2018-03-29T23:58:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA0NjQyOTQy",
          "commit": {
            "abbreviatedOid": "466660c"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-16T16:56:08Z",
          "updatedAt": "2018-03-16T16:56:08Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "The intent was to present text that matches what you see in a published RFC.\r\n",
              "createdAt": "2018-03-16T16:56:08Z",
              "updatedAt": "2018-03-29T23:58:59Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "af313df38675fe222784447b472323c96c334a50",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-bcp56bis-3",
      "headRefOid": "c6c1da27c72bbaf8ba1b1afaeb5253a1529817e6",
      "mergeCommit": {
        "oid": "e313a428e50f73a26085c2b088b4b2c7d1166821"
      }
    },
    {
      "number": 511,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NTU2MzU2",
      "title": "bcp56bis: use shorthand notation for [XML]",
      "url": "https://github.com/httpwg/http-extensions/pull/511",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "",
      "createdAt": "2018-03-16T14:54:24Z",
      "updatedAt": "2018-04-09T23:43:58Z",
      "closedAt": "2018-03-16T15:07:20Z",
      "mergedAt": "2018-03-16T15:07:20Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b25285cdbbc0bda7dc347883922f1bd512b6259e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-bcp56bis-4",
      "headRefOid": "f7334fca316074dac17f1a9071405d8352d572cf",
      "mergeCommit": {
        "oid": "c6ba9cc8c524f980b56884b7e0fc59cdcc2308c1"
      }
    },
    {
      "number": 512,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NTU3MzUy",
      "title": "bcp56bis: avoid overlong artwork line",
      "url": "https://github.com/httpwg/http-extensions/pull/512",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "FWIW, it might also be good not to have kramdown-specific syntax here...",
      "createdAt": "2018-03-16T14:57:34Z",
      "updatedAt": "2018-04-09T23:43:49Z",
      "closedAt": "2018-03-16T15:08:01Z",
      "mergedAt": "2018-03-16T15:08:01Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b25285cdbbc0bda7dc347883922f1bd512b6259e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-bcp56bis-5",
      "headRefOid": "dc11176acad7c9855bb93cca3eb2b797268df2b3",
      "mergeCommit": {
        "oid": "0a2f78bb101f65b0946daa103ee9cb76abdc8847"
      }
    },
    {
      "number": 514,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NTU5MjE4",
      "title": "bcp56bis: RFC 3205 ref",
      "url": "https://github.com/httpwg/http-extensions/pull/514",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "Mention obsoletion in the abstract, tune section title in appendix, and actually cite RFC 3205.",
      "createdAt": "2018-03-16T15:03:49Z",
      "updatedAt": "2018-04-09T23:43:43Z",
      "closedAt": "2018-03-16T15:06:40Z",
      "mergedAt": "2018-03-16T15:06:40Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b25285cdbbc0bda7dc347883922f1bd512b6259e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-bcp56bis-6",
      "headRefOid": "90dbf92f30137223fd89466f96e0c9ee71a4479f",
      "mergeCommit": {
        "oid": "e13406009c86150d4c79e69400466008a2f7dfba"
      }
    },
    {
      "number": 515,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NzAwMjIz",
      "title": "bcp56bis: shorthand anchor for W3C secure context",
      "url": "https://github.com/httpwg/http-extensions/pull/515",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-03-17T13:19:23Z",
      "updatedAt": "2018-04-09T23:43:37Z",
      "closedAt": "2018-03-17T13:21:16Z",
      "mergedAt": "2018-03-17T13:21:15Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "0a2f78bb101f65b0946daa103ee9cb76abdc8847",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-bcp56bis-7",
      "headRefOid": "52c164406ce8c9a492c945fc808d6fdb8c9f8913",
      "mergeCommit": {
        "oid": "6d77b549599d8fb07d26d8268141e313a5ec2001"
      }
    },
    {
      "number": 517,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NzQ4MjEw",
      "title": "Remove etag and validators",
      "url": "https://github.com/httpwg/http-extensions/pull/517",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "kazuho"
      ],
      "labels": [
        "cache-digest"
      ],
      "body": "Closes https://github.com/httpwg/http-extensions/issues/516",
      "createdAt": "2018-03-18T12:18:24Z",
      "updatedAt": "2018-07-01T15:50:20Z",
      "closedAt": "2018-07-01T15:50:20Z",
      "mergedAt": "2018-07-01T15:50:20Z",
      "mergedBy": "kazuho",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4807b01935df6d3914de901edac0f3a6e5f3f5b9",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "remove_etag_and_validators",
      "headRefOid": "5f86d8246367e60b31527a5816e37ca2c9f31c0e",
      "mergeCommit": {
        "oid": "5f86d8246367e60b31527a5816e37ca2c9f31c0e"
      }
    },
    {
      "number": 518,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NzQ5OTY4",
      "title": "improve IEEE citation",
      "url": "https://github.com/httpwg/http-extensions/pull/518",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-03-18T13:00:52Z",
      "updatedAt": "2018-04-09T23:43:31Z",
      "closedAt": "2018-03-19T08:31:42Z",
      "mergedAt": "2018-03-19T08:31:42Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6d77b549599d8fb07d26d8268141e313a5ec2001",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-hs-1",
      "headRefOid": "5ed80be2888aa6988ce868f7cbf5341ab183ea22",
      "mergeCommit": {
        "oid": "31e23d2b9b96818fe2ebe3cbd5d7f41fe715b0a0"
      }
    },
    {
      "number": 519,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NzUxMTcz",
      "title": "fix overlong artwork lines and type the artwork",
      "url": "https://github.com/httpwg/http-extensions/pull/519",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-03-18T13:28:26Z",
      "updatedAt": "2018-04-09T23:43:25Z",
      "closedAt": "2018-03-19T08:32:23Z",
      "mergedAt": "2018-03-19T08:32:23Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6d77b549599d8fb07d26d8268141e313a5ec2001",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-hs-2",
      "headRefOid": "627a253e471d4e44fbe17223776226381b6b6904",
      "mergeCommit": {
        "oid": "df2b68a6f2a5099f22987994ed003ba9a738d369"
      }
    },
    {
      "number": 521,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1OTIwMDI1",
      "title": "fix ABNF (see #520)",
      "url": "https://github.com/httpwg/http-extensions/pull/521",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mnot"
      ],
      "labels": [
        "header-structure"
      ],
      "body": "- underscores\r\n- case insensitivity (char vs CHAR)\r\n- also attempts to clarify ch(a)r / unescaped production a bit",
      "createdAt": "2018-03-19T14:39:45Z",
      "updatedAt": "2018-04-09T23:43:18Z",
      "closedAt": "2018-03-27T03:06:32Z",
      "mergedAt": "2018-03-27T03:06:32Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2018-03-27T03:06:36Z",
          "updatedAt": "2018-03-27T03:06:36Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4807b01935df6d3914de901edac0f3a6e5f3f5b9",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-hs-3",
      "headRefOid": "7072b0943f09b8b7b9d17940c0fd8a167d44bfbb",
      "mergeCommit": {
        "oid": "bd7cc5b1d4061e392e264d35b4ead2e2ab467e38"
      }
    },
    {
      "number": 526,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc2MjYwMDA3",
      "title": "Add SETTINGS_ prefix to parameter names",
      "url": "https://github.com/httpwg/http-extensions/pull/526",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "kazuho"
      ],
      "labels": [
        "cache-digest"
      ],
      "body": "Aligns with other SETTINGS parameter names defined in other docs.",
      "createdAt": "2018-03-20T17:05:49Z",
      "updatedAt": "2018-07-01T15:19:45Z",
      "closedAt": "2018-07-01T15:19:35Z",
      "mergedAt": "2018-07-01T15:19:35Z",
      "mergedBy": "kazuho",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho icymi\r\n",
          "createdAt": "2018-03-20T17:39:57Z",
          "updatedAt": "2018-03-20T17:39:57Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for the fix!",
          "createdAt": "2018-07-01T15:19:45Z",
          "updatedAt": "2018-07-01T15:19:45Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4807b01935df6d3914de901edac0f3a6e5f3f5b9",
      "headRepository": "LPardue/http-extensions",
      "headRefName": "patch-3",
      "headRefOid": "cdbb0384afb1417804656d6930e895a2e74f290c",
      "mergeCommit": {
        "oid": "cdbb0384afb1417804656d6930e895a2e74f290c"
      }
    },
    {
      "number": 531,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc3MjU0NjQw",
      "title": "Use the right amount of base64 padding in binary content examples.",
      "url": "https://github.com/httpwg/http-extensions/pull/531",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Since be5ab4c153be0a10d301d7d55c425a5025b1ab40 required it.\r\n\r\nI'd probably have kept padding forbidden to save a couple bytes here and there, and made Python folks append the right number of `=`s, but whatever.",
      "createdAt": "2018-03-24T19:30:21Z",
      "updatedAt": "2018-03-25T13:51:58Z",
      "closedAt": "2018-03-25T13:51:58Z",
      "mergedAt": "2018-03-25T13:51:58Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "cd5fefd80b4373c2ccce992797efc31b399a14c9",
      "headRepository": "jyasskin/http-extensions",
      "headRefName": "fix-binary-example",
      "headRefOid": "9567ea98a09ce24a749382e93984342ab87ec8be",
      "mergeCommit": {
        "oid": "9ea1542da2f066d678852a2f786d83ec2e4cf2b9"
      }
    },
    {
      "number": 541,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc4MTEyODUz",
      "title": "Incorporated Darshak's edits minus whitespace",
      "url": "https://github.com/httpwg/http-extensions/pull/541",
      "state": "CLOSED",
      "author": "craigpratt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "craigpratt"
      ],
      "labels": [],
      "body": "This should match what was submitted for draft -03 - without\r\n (inconsequential) whitespace changes that were introduced by\r\n his editor.",
      "createdAt": "2018-03-28T17:43:06Z",
      "updatedAt": "2018-04-09T23:42:59Z",
      "closedAt": "2018-03-29T22:38:44Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This PR was superseded by PR 542 - which is now merged to master.",
          "createdAt": "2018-03-29T22:38:44Z",
          "updatedAt": "2018-03-29T22:38:44Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e01e01e151216234a21d1767ceabf989df7e7d25",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "cpratt/incorporate-darshaks-edits-minus-whitespace",
      "headRefOid": "7081a4657ccc2f9b85c7d51f7f0e7490c99b2f5b",
      "mergeCommit": null
    },
    {
      "number": 542,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc4MTE2MTA3",
      "title": "Incorporated Darshak's editorial edits for (submitted) draft-ietf-httpbis-rand-access-live-03",
      "url": "https://github.com/httpwg/http-extensions/pull/542",
      "state": "MERGED",
      "author": "craigpratt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "craigpratt"
      ],
      "labels": [],
      "body": "This should match what was submitted for draft -03",
      "createdAt": "2018-03-28T17:56:09Z",
      "updatedAt": "2018-04-09T23:42:53Z",
      "closedAt": "2018-03-29T22:23:48Z",
      "mergedAt": "2018-03-29T22:23:48Z",
      "mergedBy": "craigpratt",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e01e01e151216234a21d1767ceabf989df7e7d25",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "cpratt/incorporate-darshaks-edits",
      "headRefOid": "61eed494466c2adafab145adc664ec49f2e87d14",
      "mergeCommit": {
        "oid": "9523fef32f52709829b667ac5a58e2f7e9a28f9d"
      }
    },
    {
      "number": 543,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc4Mzc4Njkz",
      "title": "WebSockets editorial nits",
      "url": "https://github.com/httpwg/http-extensions/pull/543",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "h2-websockets"
      ],
      "body": "",
      "createdAt": "2018-03-29T16:26:32Z",
      "updatedAt": "2018-04-09T23:42:47Z",
      "closedAt": "2018-04-03T21:59:36Z",
      "mergedAt": "2018-04-03T21:59:36Z",
      "mergedBy": "mcmanus",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "84a9617bfc5a0127b692f6050b1bc6a438208aa8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "websockets_nits",
      "headRefOid": "cec9c5e5816f6d1d72a566404f2c4269bd506389",
      "mergeCommit": {
        "oid": "801ee40f1751201ac6a7607b65fc027bbb78433a"
      }
    },
    {
      "number": 551,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc4ODE3MzE0",
      "title": "write a number algorithm that matches ABNF",
      "url": "https://github.com/httpwg/http-extensions/pull/551",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This algorithm automatically enforces the ABNF syntax, including length limits.\r\nIt still punts on the actual strtoi/strtof part.\r\n\r\nCloses #475 ?",
      "createdAt": "2018-04-02T10:49:20Z",
      "updatedAt": "2018-04-03T01:22:32Z",
      "closedAt": "2018-04-02T23:26:39Z",
      "mergedAt": "2018-04-02T23:26:39Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Much better, thanks!",
          "createdAt": "2018-04-02T23:26:45Z",
          "updatedAt": "2018-04-02T23:26:45Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a136fd8a0792bcdbda4cd9b742d78206ecb686fe",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "header-structure/number-algorithm",
      "headRefOid": "347d45b77d1c134332849a12ca7007e06379db39",
      "mergeCommit": {
        "oid": "e7792c43bfe73ad0df3a5c501c9b274910501ba9"
      }
    },
    {
      "number": 552,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc4ODIwMjUz",
      "title": "add padding to binary value in example",
      "url": "https://github.com/httpwg/http-extensions/pull/552",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As per 9567ea9",
      "createdAt": "2018-04-02T11:11:11Z",
      "updatedAt": "2018-04-03T01:23:37Z",
      "closedAt": "2018-04-02T23:27:05Z",
      "mergedAt": "2018-04-02T23:27:05Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a136fd8a0792bcdbda4cd9b742d78206ecb686fe",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "header-structure/base64-padding",
      "headRefOid": "c23ac6d78bce0287230f9ef527bcc2caab6c1fbf",
      "mergeCommit": {
        "oid": "5450ebe6d40800932fbd1ec8b35a0ffa67efa201"
      }
    },
    {
      "number": 553,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc4ODIyMjU0",
      "title": "escape some more asterisks and underscores",
      "url": "https://github.com/httpwg/http-extensions/pull/553",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "These were wreaking havoc with my syntax highlighting.",
      "createdAt": "2018-04-02T11:26:11Z",
      "updatedAt": "2018-04-03T01:22:37Z",
      "closedAt": "2018-04-02T23:24:50Z",
      "mergedAt": "2018-04-02T23:24:50Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a136fd8a0792bcdbda4cd9b742d78206ecb686fe",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "header-structure/escape-asterisks",
      "headRefOid": "a2a8c899b5da3d61d5d7cda4f0a71c7013be74e7",
      "mergeCommit": {
        "oid": "1706325404a1423c3ef32e07bb7a1c2b87fb32f2"
      }
    },
    {
      "number": 555,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc4OTk0MTQ0",
      "title": "Get and side effects fix",
      "url": "https://github.com/httpwg/http-extensions/pull/555",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This just fixes a typo, but this text has more problems.\r\n\r\nI'm having trouble connecting this final sentence to the text that precedes it.  I think that the point is that including a body on GET is unwise because it might cause explosions.  A point about side effects needs far more exposition, especially since GET is defined to be free from overt side effects (safe, idempotent, and all that business).  If this were just another statement and the \"As a result\" is dropped, that's different.",
      "createdAt": "2018-04-03T05:02:08Z",
      "updatedAt": "2018-04-03T05:59:00Z",
      "closedAt": "2018-04-03T05:47:35Z",
      "mergedAt": "2018-04-03T05:47:35Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Barg, I think that's a copy/paste error, will fix. thx.",
          "createdAt": "2018-04-03T05:47:31Z",
          "updatedAt": "2018-04-03T05:47:31Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "94bb7a0b20c4483deb5f91c03bcffa4192eb8e95",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "sde-effects",
      "headRefOid": "260cd00c1ddfd95606d7217830e284584feb509a",
      "mergeCommit": {
        "oid": "461e746de13377a5138ec5de3766a49c7492a54e"
      }
    },
    {
      "number": 559,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc5MDk0MDg1",
      "title": "replay: fix TLS section ref",
      "url": "https://github.com/httpwg/http-extensions/pull/559",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I believe Section 8 has moved to 9 (FWIW: it's dangerous to use section number references to drafts without specifying the draft number)",
      "createdAt": "2018-04-03T13:12:30Z",
      "updatedAt": "2018-04-09T23:42:14Z",
      "closedAt": "2018-04-03T15:36:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "After checking, I think it's in fact section 8 (0-RTT and Anti-Replay) in draft 28.",
          "createdAt": "2018-04-03T15:24:00Z",
          "updatedAt": "2018-04-03T15:24:00Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "oh - sorry for the confusion then",
          "createdAt": "2018-04-03T15:36:31Z",
          "updatedAt": "2018-04-03T15:36:31Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c396224e4c855a7bccc9e1ec1102102ec2405db7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-replay-tls-ref",
      "headRefOid": "8fdf2d7c7101b1ad10f8067a1bd91c2ed1e57c24",
      "mergeCommit": null
    },
    {
      "number": 561,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc5NTc3MzY3",
      "title": "Change Cache Digests authorship",
      "url": "https://github.com/httpwg/http-extensions/pull/561",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "cache-digest"
      ],
      "body": "@kazuho As discussed, here's a PR for changing the draft authorship.\r\n\r\nThanks!",
      "createdAt": "2018-04-05T05:41:12Z",
      "updatedAt": "2018-04-06T08:27:06Z",
      "closedAt": "2018-04-06T08:27:06Z",
      "mergedAt": "2018-04-06T08:27:06Z",
      "mergedBy": "kazuho",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c514aa56d92a17992714d857a1a93a46ec5a5ea1",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "change_cache_digest_authorship",
      "headRefOid": "6f4c0e0d7b45c07853602abf8fdd557d36756c6a",
      "mergeCommit": {
        "oid": "a6f87daef1c4dbf881296fec1a3496fe3ab84d45"
      }
    },
    {
      "number": 566,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgwMDc4NDYy",
      "title": "All frames on stream 0",
      "url": "https://github.com/httpwg/http-extensions/pull/566",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "Closes #480.\r\nFixes #482.\r\nFixes #484.\r\n\r\nI wasn't specifically after #485, but this improved the text in the process.\r\n\r\nMoves all frames to stream zero.  Replaces AUTOMATIC_USE on CERTIFICATE frames with UNSOLICITED on USE_CERTIFICATE frames, so you can send (one) certificate on a new request without being asked, but you have to send it every time.",
      "createdAt": "2018-04-07T00:11:42Z",
      "updatedAt": "2018-04-13T17:26:57Z",
      "closedAt": "2018-04-13T17:26:47Z",
      "mergedAt": "2018-04-13T17:26:47Z",
      "mergedBy": "MikeBishop",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1d46af2568440fbd6e0f8ab3700d1e1c13dca095",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "off_streams",
      "headRefOid": "3854d06221072b7f7c058cce63b4ad82780b1986",
      "mergeCommit": {
        "oid": "ea2859f829c084f6c39bf521b5a0b3275646a934"
      }
    },
    {
      "number": 571,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgwMjIxMTky",
      "title": "Multi variant key",
      "url": "https://github.com/httpwg/http-extensions/pull/571",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "For #548",
      "createdAt": "2018-04-09T06:27:47Z",
      "updatedAt": "2018-10-22T05:36:43Z",
      "closedAt": "2018-04-19T07:28:37Z",
      "mergedAt": "2018-04-19T07:28:37Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "85b2c20fb35aeeb5cd673089d5408006e970e0c5",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "multi-variant-key",
      "headRefOid": "f0a004fa728f75612a514f06b41284baa7a3d8b9",
      "mergeCommit": {
        "oid": "3e10a7f22a598a9b8d746b3bf5ed950053086f8b"
      }
    },
    {
      "number": 572,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgwMjMxNzUw",
      "title": "bcp56bis: ref format",
      "url": "https://github.com/httpwg/http-extensions/pull/572",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-04-09T07:33:42Z",
      "updatedAt": "2018-04-09T23:41:54Z",
      "closedAt": "2018-04-09T07:40:30Z",
      "mergedAt": "2018-04-09T07:40:30Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "85b2c20fb35aeeb5cd673089d5408006e970e0c5",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-bcp56bis-ref",
      "headRefOid": "043046a8f4dd1621ab336f0a5c27d9cd7821e50f",
      "mergeCommit": {
        "oid": "318b53e3d7707f0f544e267b35870b1655bdf7af"
      }
    },
    {
      "number": 573,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgwMjUyOTE1",
      "title": "Fixed a couple references to \"Very Large values\" lower case and \"^^\" to \"^\"",
      "url": "https://github.com/httpwg/http-extensions/pull/573",
      "state": "MERGED",
      "author": "craigpratt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "craigpratt"
      ],
      "labels": [
        "rand-access-live"
      ],
      "body": "",
      "createdAt": "2018-04-09T09:16:28Z",
      "updatedAt": "2018-04-10T07:38:46Z",
      "closedAt": "2018-04-10T07:38:40Z",
      "mergedAt": "2018-04-10T07:38:40Z",
      "mergedBy": "craigpratt",
      "comments": [
        {
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson \r\n\r\nThanks Martin,\r\n\r\nDo you think some of the language from Section 5 needs to be mentioned/reiterated earlier?\r\n\r\nGuess I could say something like \"a value much larger than the expected maximum size of the representation should be provided by the client (see section 5 for security considerations)\"?\r\n\r\nHere's most of Section 5\r\n\r\n`...in applications where there's no expectation that the representation will ever exceed 2^63, a value smaller than this value should be used as the very large last-byte-pos in a byte-seek request or content-range response. Also, some implementations (e.g. JavaScript-based clients and servers) are not able to represent all values beyond 2^53. So similarly, if there's no expectation that a representation will ever exceed 2^53 bytes, values smaller than this limit should be used for the last-byte-pos in byte-range requests.`",
          "createdAt": "2018-04-09T18:05:47Z",
          "updatedAt": "2018-04-09T18:05:47Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That would be perfect.  Note that the security considerations here are more \"compatibility considerations\" than anything else.",
          "createdAt": "2018-04-10T00:49:40Z",
          "updatedAt": "2018-04-10T00:49:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEwMzkyODA5",
          "commit": {
            "abbreviatedOid": "7f7d335"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM.\r\n\r\nDo you think that you want to provide some guidance about choice?  That is, that the client chooses this value based on it being more than they are expecting to be present on the resource, or at least enough that making another range request isn't going to be onerous.  And that that is balanced against the risk of too large values causing problems like integer overflow on the server side.",
          "createdAt": "2018-04-09T09:54:27Z",
          "updatedAt": "2018-04-09T09:54:27Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "318b53e3d7707f0f544e267b35870b1655bdf7af",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "cpratt/fix-very-large-refs",
      "headRefOid": "7f7d335724c1af53ce4862d8c59bfcb69fdb7fcd",
      "mergeCommit": {
        "oid": "24710345081d287b3204ffb8d5c1b553f4ce0390"
      }
    },
    {
      "number": 574,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgwMzk3MTAz",
      "title": "Clarify handling of invalid SameSite values (fixes #389)",
      "url": "https://github.com/httpwg/http-extensions/pull/574",
      "state": "MERGED",
      "author": "fmarier",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "There is currently a discrepancy in the spec regarding invalid values\r\nin the SameSite cookie attribute.\r\n\r\nFor example, this cookie:\r\n\r\n  Set-Cookie: foo=bar; SameSite=bogus\r\n\r\nis expected to be dropped entirely according to the \"Server Requirements\"\r\nunder Section 4.1.2.7:\r\n\r\n  If the \"SameSite\" attribute's value is neither of these [ \"Lax\",\r\n  \"Strict\" ], the cookie will be ignored.\r\n\r\nwhereas under Section 5.3.7 of \"User Agent Requirements\", the cookie\r\nis to be kept but the attribute is ignored:\r\n\r\n  If cookie-av's attribute-value is not a case-insensitive match for\r\n  \"Strict\" or \"Lax\", ignore the \"cookie-av\".\r\n\r\nAdditionally, the end of Section 4.1.2 also matches the behavior\r\ndescribed in Section 5.3.7:\r\n\r\n  User agents ignore unrecognized cookie attributes (but not the entire\r\n  cookie).\r\n\r\nFrom a forward-compatibility point of view, the behavior described in\r\nsection 5.3.7 is the ideal one since it allows for future expansion\r\nof this feature such as:\r\n\r\n  Set-Cookie: foo=bar; SameSite=medium",
      "createdAt": "2018-04-09T18:59:39Z",
      "updatedAt": "2018-04-11T18:34:16Z",
      "closedAt": "2018-04-11T06:43:19Z",
      "mergedAt": "2018-04-11T06:43:19Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "fmarier",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mikewest ",
          "createdAt": "2018-04-09T19:00:09Z",
          "updatedAt": "2018-04-09T19:00:09Z"
        },
        {
          "author": "fmarier",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done. Let me know if I missed anything else.",
          "createdAt": "2018-04-10T19:18:57Z",
          "updatedAt": "2018-04-10T19:18:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEwNjk5ODg1",
          "commit": {
            "abbreviatedOid": "8225204"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM % wording nit.\r\n\r\nWould you mind starting an `-03` section in the \"changes\" appendix, and adding this in?",
          "createdAt": "2018-04-10T05:52:57Z",
          "updatedAt": "2018-04-10T05:54:24Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```s/`cookie-av`/attribute/```: `cookie-av` doesn't have any meaning until the algorithm in 5.3.",
              "createdAt": "2018-04-10T05:52:57Z",
              "updatedAt": "2018-04-10T19:17:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMTAzMTc1",
          "commit": {
            "abbreviatedOid": "c303325"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2018-04-11T06:43:14Z",
          "updatedAt": "2018-04-11T06:43:14Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "13a5fce60937b426839789d94cbd22418bb68a46",
      "headRepository": "fmarier/http-extensions",
      "headRefName": "samesite-bogus-values-389",
      "headRefOid": "c303325cd14b3fbbda85b22f2bdee622d922c5be",
      "mergeCommit": {
        "oid": "ebe8f8ea69c02d83e5dceb91fdae0e787845c7ba"
      }
    },
    {
      "number": 575,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgwNDMwMjY2",
      "title": "Abstracts are small",
      "url": "https://github.com/httpwg/http-extensions/pull/575",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "Fixes #562.",
      "createdAt": "2018-04-09T21:17:44Z",
      "updatedAt": "2018-10-22T05:36:47Z",
      "closedAt": "2018-04-13T17:14:43Z",
      "mergedAt": "2018-04-13T17:14:43Z",
      "mergedBy": "MikeBishop",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEwNjYzMDkx",
          "commit": {
            "abbreviatedOid": "d2c7720"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-10T00:52:10Z",
          "updatedAt": "2018-04-10T00:52:13Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "s/the/a/ ?",
              "createdAt": "2018-04-10T00:52:10Z",
              "updatedAt": "2018-04-13T17:13:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEwNjc4NzY2",
          "commit": {
            "abbreviatedOid": "d2c7720"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-10T02:58:51Z",
          "updatedAt": "2018-04-10T02:58:51Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Perhaps; \"the\" when there's only one, and the point of the statement is that there's only one.  But maybe I'm over-emphasizing that?",
              "createdAt": "2018-04-10T02:58:51Z",
              "updatedAt": "2018-04-13T17:13:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEwNjgwMjY3",
          "commit": {
            "abbreviatedOid": "d2c7720"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-10T03:11:24Z",
          "updatedAt": "2018-04-10T03:11:24Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Yeah, \"the single\" is redundant in that sense.",
              "createdAt": "2018-04-10T03:11:24Z",
              "updatedAt": "2018-04-13T17:13:58Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "318b53e3d7707f0f544e267b35870b1655bdf7af",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "abstract_intro",
      "headRefOid": "85db40982524c37386eb24525f2c7752fac21d94",
      "mergeCommit": {
        "oid": "83c553d591f01a1289ef52af783cfbe05c139c9e"
      }
    },
    {
      "number": 576,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgwNTE5Mjg4",
      "title": "Added a small blurb referencing client range-end considerations from section 5",
      "url": "https://github.com/httpwg/http-extensions/pull/576",
      "state": "MERGED",
      "author": "craigpratt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "craigpratt"
      ],
      "labels": [],
      "body": "Also considering if \"Security Considerations\" can be \"Compatibility Considerations\".",
      "createdAt": "2018-04-10T08:02:51Z",
      "updatedAt": "2018-04-11T20:25:20Z",
      "closedAt": "2018-04-11T20:25:00Z",
      "mergedAt": "2018-04-11T20:25:00Z",
      "mergedBy": "craigpratt",
      "comments": [
        {
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I haven't renamed \"Security Considerations\" in this version. And I have no issue with calling this \"Compatibility Considerations\". But I have some recollection that this is a required section...",
          "createdAt": "2018-04-10T08:05:35Z",
          "updatedAt": "2018-04-10T08:05:35Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah don't do that or various people will start to scream at you :)",
          "createdAt": "2018-04-11T01:46:01Z",
          "updatedAt": "2018-04-11T01:46:01Z"
        },
        {
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Call me a perfectionist, but on reread, I realized there was a cleaner/shorter way to clarify. \r\n\r\nLet me know if you have any objection...",
          "createdAt": "2018-04-11T18:08:28Z",
          "updatedAt": "2018-04-11T18:08:28Z"
        },
        {
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks Martin!",
          "createdAt": "2018-04-11T20:25:16Z",
          "updatedAt": "2018-04-11T20:25:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMDY1MDQx",
          "commit": {
            "abbreviatedOid": "cd55f81"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-11T01:46:08Z",
          "updatedAt": "2018-04-11T01:46:08Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "24710345081d287b3204ffb8d5c1b553f4ce0390",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "cpratt/add-client-guidance-for-range-end-val",
      "headRefOid": "1c2d66b65bf6504f285dbe8a0affd9044baa1c20",
      "mergeCommit": {
        "oid": "f49b6b48f1b7195e7b3ea6e8497b2c18efad3456"
      }
    },
    {
      "number": 578,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgxMDcyNTQ0",
      "title": "Structure limits",
      "url": "https://github.com/httpwg/http-extensions/pull/578",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "For #433.\r\n\r\nThis:\r\n* Removes the size limits for all types except floats, integers and identifiers\r\n* Specifies minimum sizes for parsers to support (currently, the old limits; discuss?)\r\n* Adds some Security Considerations about header sizes.\r\n\r\nIt seemed like the right thing to do to hard-limit identifiers, since they're used as dictionary keys, etc. Thoughts?",
      "createdAt": "2018-04-12T02:07:49Z",
      "updatedAt": "2018-06-29T05:31:22Z",
      "closedAt": "2018-05-21T06:49:47Z",
      "mergedAt": "2018-05-21T06:49:47Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "56260172c7c9389a06d9e11031c7f5323f63a8cd",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "structure-limits",
      "headRefOid": "2c06d04c5bfe46662e1190be733545af0d9c60c7",
      "mergeCommit": {
        "oid": "89e90a38ccb59b845cdd27c3e0e85242b9af3e6c"
      }
    },
    {
      "number": 585,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgxNTEyMzc0",
      "title": "replay: refer to actual header field registry",
      "url": "https://github.com/httpwg/http-extensions/pull/585",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "replay"
      ],
      "body": "....instead of RFC defining it.",
      "createdAt": "2018-04-13T14:54:51Z",
      "updatedAt": "2018-04-30T05:33:34Z",
      "closedAt": "2018-04-14T05:37:12Z",
      "mergedAt": "2018-04-14T05:37:12Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "looks good to me. Thanks Julian.",
          "createdAt": "2018-04-13T17:03:28Z",
          "updatedAt": "2018-04-13T17:03:28Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c080e1a551067197f97a229636ad3b6608a08bde",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-replay-headers-ref",
      "headRefOid": "381f513c109f9b5c6d238dbc209b587f6eaa7da7",
      "mergeCommit": {
        "oid": "40cf04cffd10ac8ea9631290cd7d8fa929c14a07"
      }
    },
    {
      "number": 586,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgxNTU4MDkz",
      "title": "Stream-linking frames can reference Stream Zero",
      "url": "https://github.com/httpwg/http-extensions/pull/586",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "Fixes #564.\r\n\r\nIf clients need a server certificate before making requests for an origin, they can send `CERTIFICATE_NEEDED` for stream zero, indicating the connection.  Servers respond with `USE_CERTIFICATE`.\r\n\r\nKnown drawbacks:\r\n  - Since `USE_CERTIFICATE` has to be sent in order, if the client requests a batch of domains, the server can't provide the requested certificates out-of-order (though it can outright reject some of them).\r\n  - This is fine for H2; in HTTP/QUIC, we'll need to decide if this is still zero, or if it's 3/4, or something else.",
      "createdAt": "2018-04-13T18:04:10Z",
      "updatedAt": "2018-06-14T16:54:40Z",
      "closedAt": "2018-06-13T23:56:02Z",
      "mergedAt": "2018-06-13T23:56:02Z",
      "mergedBy": "MikeBishop",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kazuho, @martinthomson, I would appreciate it if you could give this a look.  Do you think this is a good approach?",
          "createdAt": "2018-05-24T20:42:09Z",
          "updatedAt": "2018-05-24T20:42:09Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that, while I have changed the text to indicate that an Empty Authenticator should be used when asked for a certificate you don't have, I haven't removed the text that says a USE_CERTIFICATE without a Cert-ID points to the cert provided in TLS.  Do you think that needs to go as well?",
          "createdAt": "2018-06-12T19:03:45Z",
          "updatedAt": "2018-06-12T19:03:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzMjA2ODIw",
          "commit": {
            "abbreviatedOid": "07cf01b"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "DISMISSED",
          "body": "This makes me convinced that we probably want to hold exported authenticators for a little while longer.  See the big comment.",
          "createdAt": "2018-05-24T23:36:20Z",
          "updatedAt": "2018-06-12T19:01:58Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "When you say empty, I think that you mean that the server sends an empty CERTIFICATE frame and then references that certificate when it wants to reject a CERTIFICATE_NEEDED request.\r\n\r\nThat is:\r\n\r\n```\r\nClient Sends:\r\nCERTIFICATE_REQUEST (id=N) -->\r\nCERTIFICATE_NEEDED (S=0, R=M) -->\r\n...\r\nServer can't answer, so:\r\n<-- CERTIFICATE (Cert-ID=Q, <empty>)\r\n<-- USE_CERTIFICATE (S=0, R=M)\r\n```\r\n\r\nThe problem here is that the empty CERTIFICATE frame isn't bound in any way to the CERTIFICATE_REQUEST, unless your definition of \"empty\" isn't that the authenticator is completely absent, but that it includes a valid authenticator, but no certificate in the TLS Certificate message.  Then the `certificate_request_context` can be used to correlate CERTIFICATE with CERTIFICATE_REQUEST in the usual fashion.  That's how TLS does it - it sends Certificate without the certificate and omits the CertificateVerify message entirely if it doesn't want to authenticate.  (I just realized that I used CERTIFICATE, Certificate and certificate in the same paragraph to mean three different things, which is not at all confusing.)\r\n\r\nI just read exported authenticators again and I don't see that use case being addressed at all.  @grittygrease should be aware of that given that TLSEA is in WGLC.  I think that TLSEA needs to address that case one way or other.  If the intent is to have the using application manage rejection, then it needs to be clear where the responsibility lies.  However, I think that having authenticated rejection is superior and that should be expressly included in the draft with a description of how that is done.",
              "createdAt": "2018-05-24T23:36:20Z",
              "updatedAt": "2018-06-13T23:54:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzNTcyMjc2",
          "commit": {
            "abbreviatedOid": "07cf01b"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-27T04:53:48Z",
          "updatedAt": "2018-05-27T04:53:48Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Actually, \"empty\" probably needs to be clarified here.  In the previous draft (i.e. where things were on-stream with the request and CertID was the only payload), you could omit the CertID and send a USE_CERTIFICATE with a length of zero, which meant \"I don't have / choose not to provide the requested certificate.  Deal.\"  (I think it actually said to assume the certificate provided via TLS, if any.)\r\n\r\nIf ExpAuth gives us an authenticated denial, I'd be fine using it.  But I'm also fine if it doesn't -- the point of ExpAuth is proving *possession* securely, and I think declining to provide an authenticator is sufficient for our purposes.  This isn't DNSsec where we want to authoritatively prove non-existence, we're just declining to supply (or, therefore, prove possession of) a certificate.",
              "createdAt": "2018-05-27T04:53:48Z",
              "updatedAt": "2018-06-13T23:54:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4NjE1NTQ4",
          "commit": {
            "abbreviatedOid": "4d8a71b"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-14T01:18:03Z",
          "updatedAt": "2018-06-14T01:18:07Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Why only one side?",
              "createdAt": "2018-06-14T01:18:03Z",
              "updatedAt": "2018-06-14T01:18:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4ODc5MDM5",
          "commit": {
            "abbreviatedOid": "d413282"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-14T16:54:40Z",
          "updatedAt": "2018-06-14T16:54:40Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This section is talking specifically about clients probing servers.  But you're right -- there should be a corresponding statement about clients.",
              "createdAt": "2018-06-14T16:54:40Z",
              "updatedAt": "2018-06-14T16:54:40Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1a87c91d36e673b360042683a3113a3d7a585525",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "connection_reference",
      "headRefOid": "d41328247548c5163f162a2abbe4a0d97de4d6cd",
      "mergeCommit": {
        "oid": "222cf1e296a83fc3274188eab8fca2da0f157ee5"
      }
    },
    {
      "number": 589,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgyMjE0ODY0",
      "title": "bcp56bis: split message exchange into two figures",
      "url": "https://github.com/httpwg/http-extensions/pull/589",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis",
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-04-17T15:56:22Z",
      "updatedAt": "2018-05-16T03:11:28Z",
      "closedAt": "2018-04-18T06:48:20Z",
      "mergedAt": "2018-04-18T06:48:20Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The point here is to illustrate an entire exchange, so I think it's one example.",
          "createdAt": "2018-04-17T23:31:48Z",
          "updatedAt": "2018-04-17T23:31:48Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, but it displays as a single piece of artwork which I find confusing. I don't believe we have a single spec in HTTPbis space where we made request and response part of a single piece of artwork.",
          "createdAt": "2018-04-18T04:01:43Z",
          "updatedAt": "2018-04-18T04:01:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "That make sense, because HTTPbis generally illustrates how to implement HTTP, not applications on top of it. I suspect that most applications are going to want to demonstrate complete request/response interactions, not messages in isolation. It's also better practice to show both IMO.",
          "createdAt": "2018-04-18T04:05:26Z",
          "updatedAt": "2018-04-18T04:05:26Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, both should be shown. This is about *how*.",
          "createdAt": "2018-04-18T04:08:38Z",
          "updatedAt": "2018-04-18T04:08:38Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "08e34f2782e7f312b4053b3ed3e4c72df02636a6",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-bcp56bis-example",
      "headRefOid": "32a114ccfd28fbf9858bb358f74a90ff655c9419",
      "mergeCommit": {
        "oid": "dd33309fa7b951db4ad2f452bcbaf1b2b1981ef2"
      }
    },
    {
      "number": 590,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgyMjE1NjA0",
      "title": "bcp56bis: ref for status code 308",
      "url": "https://github.com/httpwg/http-extensions/pull/590",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis",
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-04-17T15:58:46Z",
      "updatedAt": "2018-05-16T03:11:24Z",
      "closedAt": "2018-04-18T09:54:53Z",
      "mergedAt": "2018-04-18T09:54:53Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzMDM1NzAx",
          "commit": {
            "abbreviatedOid": "e45c8d7"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-17T23:30:38Z",
          "updatedAt": "2018-04-17T23:30:38Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Needs to be {{?RFC7538}}",
              "createdAt": "2018-04-17T23:30:38Z",
              "updatedAt": "2018-04-18T09:35:44Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a2fd54e4374c95e21f5d7d9556f46e426e38a2a7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-bcp56bis-308",
      "headRefOid": "15ac8d8f73af8f7e4b5dc1a7f596813a2c6bb29d",
      "mergeCommit": {
        "oid": "5b230ca7e519af6c33c44a1c00d340abb0c883bf"
      }
    },
    {
      "number": 591,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgyMjIwMDg4",
      "title": "bcp56bis: 302 *response* not *request*",
      "url": "https://github.com/httpwg/http-extensions/pull/591",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "",
      "createdAt": "2018-04-17T16:14:48Z",
      "updatedAt": "2018-05-16T03:11:19Z",
      "closedAt": "2018-04-17T23:30:03Z",
      "mergedAt": "2018-04-17T23:30:03Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a2fd54e4374c95e21f5d7d9556f46e426e38a2a7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-bcp5bis-302resp",
      "headRefOid": "50d0c9844ba54790b87376881f073154677e8219",
      "mergeCommit": {
        "oid": "903ca320862edf9b26d6b598375a7fb50d3a514d"
      }
    },
    {
      "number": 592,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgzNzMzNDI4",
      "title": "Document some of the properties of Early-Data",
      "url": "https://github.com/httpwg/http-extensions/pull/592",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "According to RFC 7231, Section 8.3.1.\r\n\r\nI didn't include anything here about Vary because I wanted to discuss that first and these seemed uncontroversial.  It seems OK to say that Vary is permitted here because we expressly talk about varied reactions based on the presence of Early-Data.  If that's right, I will amend this with a second commit.  (I'm jetlagged, so being a little cautious.)",
      "createdAt": "2018-04-24T13:19:40Z",
      "updatedAt": "2018-04-26T07:39:01Z",
      "closedAt": "2018-04-26T07:38:56Z",
      "mergedAt": "2018-04-26T07:38:56Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "Your proposal looks very clear to me, despite your jetlag :-)  I agree with you that Vary should be OK. I don't even think we need to say anything about it then.",
          "createdAt": "2018-04-24T15:17:42Z",
          "updatedAt": "2018-04-24T15:17:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE0OTEwMDg2",
          "commit": {
            "abbreviatedOid": "afc9b54"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-24T18:26:21Z",
          "updatedAt": "2018-04-24T18:26:25Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Comma after \"However\", or just drop the word.",
              "createdAt": "2018-04-24T18:26:21Z",
              "updatedAt": "2018-04-26T07:17:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE1MDYxNTY2",
          "commit": {
            "abbreviatedOid": "afc9b54"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-25T07:32:39Z",
          "updatedAt": "2018-04-25T07:32:39Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4b18cb00e3e104c6dd36d649d94af32f62bd4655",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "early-data-props",
      "headRefOid": "ce2bdcfccf484f1e8cc0ced5811f3a6b6d797740",
      "mergeCommit": {
        "oid": "7dba6c91819a144cf0f27fc722cd605a3336f676"
      }
    },
    {
      "number": 598,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg1Mzc0NDU3",
      "title": "variants: reference formatting",
      "url": "https://github.com/httpwg/http-extensions/pull/598",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-02T08:57:35Z",
      "updatedAt": "2018-05-03T04:38:22Z",
      "closedAt": "2018-05-03T04:30:31Z",
      "mergedAt": "2018-05-03T04:30:31Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE3MDk2NTQz",
          "commit": {
            "abbreviatedOid": "fea85b2"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-02T22:51:54Z",
          "updatedAt": "2018-05-02T22:51:54Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "typo here",
              "createdAt": "2018-05-02T22:51:54Z",
              "updatedAt": "2018-05-03T04:21:57Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "665d69342d2aba2e1b3d1a5b38e9ea4c08664e10",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-1",
      "headRefOid": "5fa0a4ba8bfb9bac5313a8db712a25a2570ee06d",
      "mergeCommit": {
        "oid": "c9d3733d4af5bada6a38b6ab0d5b414dd9808f18"
      }
    },
    {
      "number": 600,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg1Mzc1OTU4",
      "title": "variants: type the artwork",
      "url": "https://github.com/httpwg/http-extensions/pull/600",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-02T09:03:44Z",
      "updatedAt": "2018-05-16T03:10:28Z",
      "closedAt": "2018-05-02T22:51:18Z",
      "mergedAt": "2018-05-02T22:51:17Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "665d69342d2aba2e1b3d1a5b38e9ea4c08664e10",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-2",
      "headRefOid": "623d63ddca491773ed90a5c7e38410eb6d93931d",
      "mergeCommit": {
        "oid": "3984426313cdabab2292f12b2acac7a86c4a1dfd"
      }
    },
    {
      "number": 601,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg1NTE0NjAz",
      "title": "variants: acks should be last and unnumbered",
      "url": "https://github.com/httpwg/http-extensions/pull/601",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-02T17:54:49Z",
      "updatedAt": "2018-05-03T02:16:10Z",
      "closedAt": "2018-05-02T22:50:59Z",
      "mergedAt": "2018-05-02T22:50:59Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "665d69342d2aba2e1b3d1a5b38e9ea4c08664e10",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-3",
      "headRefOid": "45d4b87bb0eb5d8e153cb335b3859cacc04bbaa3",
      "mergeCommit": {
        "oid": "1b67fe0a4eea40a2176b94a6abf4682e2d6e88b5"
      }
    },
    {
      "number": 602,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg1NjAwNDMx",
      "title": "Mention rejection of 0-RTT",
      "url": "https://github.com/httpwg/http-extensions/pull/602",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "Our basic list of mitigations missed a fairly obvious one.\r\n\r\nMentioning it should help with the class of confusion Magnus N. had with the draft.\r\n\r\nI decided not to include a note about the server being unable to examine early data before making this decision.  That's just something people will need to discover for themselves.  Generally, you have to decide whether you want 0-RTT without seeing any of it.  Partly this is because it avoids a potential deadlock, but mostly it's because the TLS stack will not even decrypt 0-RTT if it is rejected.",
      "createdAt": "2018-05-03T01:38:03Z",
      "updatedAt": "2018-05-03T23:25:16Z",
      "closedAt": "2018-05-03T23:25:13Z",
      "mergedAt": "2018-05-03T23:25:13Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "Looks good to me, and indeed clearer. Thanks.",
          "createdAt": "2018-05-03T02:16:11Z",
          "updatedAt": "2018-05-03T02:16:11Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1",
          "createdAt": "2018-05-03T20:01:08Z",
          "updatedAt": "2018-05-03T20:01:08Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3984426313cdabab2292f12b2acac7a86c4a1dfd",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mention-reject",
      "headRefOid": "f9879202f5314569083844256fb1f4e2035b1e5e",
      "mergeCommit": {
        "oid": "9832827f91bd6f425503c1ac396580e486db1cba"
      }
    },
    {
      "number": 603,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg1NjAxNTAz",
      "title": "Attempt to clarify the replay attack",
      "url": "https://github.com/httpwg/http-extensions/pull/603",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "This was a little obtuse in the previous iteration, likely as a result of trying to be parsimonious.  Expand it a little and clarify the attack.",
      "createdAt": "2018-05-03T01:50:48Z",
      "updatedAt": "2018-05-03T23:25:19Z",
      "closedAt": "2018-05-03T23:25:05Z",
      "mergedAt": "2018-05-03T23:25:05Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "It's indeed better like this in my opinion.",
          "createdAt": "2018-05-03T02:17:41Z",
          "updatedAt": "2018-05-03T02:17:41Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3984426313cdabab2292f12b2acac7a86c4a1dfd",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "attack-synopsis",
      "headRefOid": "1b7b133745ca567487dd70c7774be04dfc45f74f",
      "mergeCommit": {
        "oid": "4d850818ff6a14e477811fd166725fb46742817f"
      }
    },
    {
      "number": 604,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg1NjE5Mzc1",
      "title": "h2-ws: acks should be unnumbered",
      "url": "https://github.com/httpwg/http-extensions/pull/604",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-03T05:20:51Z",
      "updatedAt": "2018-05-16T03:10:20Z",
      "closedAt": "2018-05-04T21:22:38Z",
      "mergedAt": "2018-05-04T21:22:38Z",
      "mergedBy": "mcmanus",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c9d3733d4af5bada6a38b6ab0d5b414dd9808f18",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-1",
      "headRefOid": "6853d4a77d2d8b2722bd771bd40fb2b75bbab38a",
      "mergeCommit": {
        "oid": "703c62e4a555b31370281fe4afe7f56a44592bd3"
      }
    },
    {
      "number": 605,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg1NjIxNDM4",
      "title": "h2-ws: ref format and typo",
      "url": "https://github.com/httpwg/http-extensions/pull/605",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "h2-websockets"
      ],
      "body": "",
      "createdAt": "2018-05-03T05:43:03Z",
      "updatedAt": "2018-05-16T03:10:17Z",
      "closedAt": "2018-05-03T20:02:33Z",
      "mergedAt": "2018-05-03T20:02:33Z",
      "mergedBy": "mcmanus",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c9d3733d4af5bada6a38b6ab0d5b414dd9808f18",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-3",
      "headRefOid": "d78494e13d32e1266dfc636675c84cf464c1786a",
      "mergeCommit": {
        "oid": "c38841d4533ec7b341130cb6524ebe1f492e9490"
      }
    },
    {
      "number": 606,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg1NjIxNjg0",
      "title": "h2-ws: artwork width",
      "url": "https://github.com/httpwg/http-extensions/pull/606",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(attempt to fix it)",
      "createdAt": "2018-05-03T05:45:31Z",
      "updatedAt": "2018-05-16T03:10:13Z",
      "closedAt": "2018-05-03T20:47:12Z",
      "mergedAt": "2018-05-03T20:47:12Z",
      "mergedBy": "mcmanus",
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks. 72. gah.\r\n\r\n",
          "createdAt": "2018-05-03T20:47:07Z",
          "updatedAt": "2018-05-03T20:47:07Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c9d3733d4af5bada6a38b6ab0d5b414dd9808f18",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-4",
      "headRefOid": "f7d3315f1069068988d77e1223fb5993297ed3c3",
      "mergeCommit": {
        "oid": "f30220616cc9f719cdb6ba3e3e140e76f7ce5da2"
      }
    },
    {
      "number": 609,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg2MTM5OTMx",
      "title": "bcp56bis: fix typo in FETCH reference",
      "url": "https://github.com/httpwg/http-extensions/pull/609",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis",
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-05-05T05:06:29Z",
      "updatedAt": "2018-05-16T03:10:10Z",
      "closedAt": "2018-05-05T10:53:26Z",
      "mergedAt": "2018-05-05T10:53:26Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d7a80c7c429a55a5f06a83b0ecd3c6737121db95",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-5",
      "headRefOid": "a990a2a05a15bffd3039541ff18356dece7be001",
      "mergeCommit": {
        "oid": "91768f3a440606dd7eec86e5c36c49b96073361c"
      }
    },
    {
      "number": 610,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg2MTQ4OTQ1",
      "title": "h2-ws: no references in abstract",
      "url": "https://github.com/httpwg/http-extensions/pull/610",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "h2-websockets"
      ],
      "body": "",
      "createdAt": "2018-05-05T09:43:59Z",
      "updatedAt": "2018-05-16T03:10:06Z",
      "closedAt": "2018-05-05T14:08:54Z",
      "mergedAt": "2018-05-05T14:08:54Z",
      "mergedBy": "mcmanus",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d7a80c7c429a55a5f06a83b0ecd3c6737121db95",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-6",
      "headRefOid": "a4024b5f51a618c135e4b35254c2111399457b1d",
      "mergeCommit": {
        "oid": "16edf5b479b87e154afaf6c95e3ff45a379b814b"
      }
    },
    {
      "number": 611,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg2MTQ5MDI0",
      "title": "h2-ws: type the artwork and reduce the width once more",
      "url": "https://github.com/httpwg/http-extensions/pull/611",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "h2-websockets"
      ],
      "body": "",
      "createdAt": "2018-05-05T09:46:09Z",
      "updatedAt": "2018-05-16T03:10:03Z",
      "closedAt": "2018-05-07T12:03:59Z",
      "mergedAt": "2018-05-07T12:03:59Z",
      "mergedBy": "mcmanus",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d7a80c7c429a55a5f06a83b0ecd3c6737121db95",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-7",
      "headRefOid": "a2b29e4d2b80c37d6d34a62f59644794df45814d",
      "mergeCommit": {
        "oid": "a28d1a38d90dfb42105a300dfabf100fadc9f4c6"
      }
    },
    {
      "number": 616,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg2NzY5NjE4",
      "title": "Reword exclusion regarding retries",
      "url": "https://github.com/httpwg/http-extensions/pull/616",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "@MikeBishop noted that automated retries can be initiated by other enties than the client, which might be without client knowledge.  That's a fair point and an opportunity to improve text more.",
      "createdAt": "2018-05-08T22:10:41Z",
      "updatedAt": "2018-10-08T08:23:52Z",
      "closedAt": "2018-10-08T08:23:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You're still glossing over the fact that retries can be initiated by something other than the client, but this focuses specifically on client-initiated actions, so that's probably okay.",
          "createdAt": "2018-05-08T23:07:26Z",
          "updatedAt": "2018-05-08T23:07:26Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The glossing-over is intentional. :)\r\n\r\nGetting into what an intermediary might do here is what the rest of the document covers.  The primary point here is to separate replay from intentional retries.",
          "createdAt": "2018-05-08T23:58:43Z",
          "updatedAt": "2018-05-08T23:58:43Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "I'm not seeing the benefit of the rewording here. How about this instead ?\r\n\r\nThe difference between replay attacks and retries is that retries may be performed by a user, a client or an intermediary for the purpose of getting a response that will be delivered to the client, while a replay attack is generally performed by a third party not part of the chain from the client to the server, which is not interested in receiving a response, will often not receive it, and not even know whether or not such a response was provided or not.\r\n",
          "createdAt": "2018-05-09T05:07:52Z",
          "updatedAt": "2018-05-09T05:07:52Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OBE.",
          "createdAt": "2018-10-08T08:23:29Z",
          "updatedAt": "2018-10-08T08:23:29Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3e2354cb535374d6f49f150b4346aee875bad851",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "intro-nit",
      "headRefOid": "95cf0e4333ff21c64f103bddfd759be23801d9fa",
      "mergeCommit": null
    },
    {
      "number": 618,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3MjI4ODg2",
      "title": "typo 6265bis fix",
      "url": "https://github.com/httpwg/http-extensions/pull/618",
      "state": "MERGED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mikewest"
      ],
      "labels": [
        "6265bis"
      ],
      "body": "",
      "createdAt": "2018-05-10T15:41:27Z",
      "updatedAt": "2018-05-10T15:55:33Z",
      "closedAt": "2018-05-10T15:55:27Z",
      "mergedAt": "2018-05-10T15:55:27Z",
      "mergedBy": "mikewest",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE5MTQyNDg5",
          "commit": {
            "abbreviatedOid": "a650c10"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2018-05-10T15:55:21Z",
          "updatedAt": "2018-05-10T15:55:21Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3e2354cb535374d6f49f150b4346aee875bad851",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mcmanus-typo-b1",
      "headRefOid": "a650c10297ff4487b15ba1009ac2db36816a4e30",
      "mergeCommit": {
        "oid": "a30d81a543ce951fc6843a4b33c65afd120a656e"
      }
    },
    {
      "number": 619,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3Mzg4ODMz",
      "title": "typo in GET bcp56bis",
      "url": "https://github.com/httpwg/http-extensions/pull/619",
      "state": "MERGED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mnot"
      ],
      "labels": [
        "bcp56bis"
      ],
      "body": "",
      "createdAt": "2018-05-11T07:35:45Z",
      "updatedAt": "2018-05-16T03:09:57Z",
      "closedAt": "2018-05-11T08:22:28Z",
      "mergedAt": "2018-05-11T08:22:28Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a30d81a543ce951fc6843a4b33c65afd120a656e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mcmanus-typo-b2",
      "headRefOid": "3a3ddae2c5a1764cf1e9f7fcfec46ebf60d534c6",
      "mergeCommit": {
        "oid": "a21de669291f9f0ee4cc14e68ca83236b17ba0b6"
      }
    },
    {
      "number": 620,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NDEzMjM3",
      "title": "h2-ws: consistent use of \"header field\"",
      "url": "https://github.com/httpwg/http-extensions/pull/620",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "h2-websockets"
      ],
      "body": "",
      "createdAt": "2018-05-11T09:33:44Z",
      "updatedAt": "2018-10-27T00:04:42Z",
      "closedAt": "2018-10-08T08:27:09Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Hmm, we missed this, but it seems to have gotten into the published RFC.",
          "createdAt": "2018-10-08T08:27:09Z",
          "updatedAt": "2018-10-08T08:27:09Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a21de669291f9f0ee4cc14e68ca83236b17ba0b6",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-8",
      "headRefOid": "9c1cdddfdbda4b0ddefb7d159179145cb617dc99",
      "mergeCommit": null
    },
    {
      "number": 621,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NDM2Mzgw",
      "title": "early-data: iana links",
      "url": "https://github.com/httpwg/http-extensions/pull/621",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "replay"
      ],
      "body": "use registry URIs consistently",
      "createdAt": "2018-05-11T11:19:01Z",
      "updatedAt": "2018-05-12T00:42:59Z",
      "closedAt": "2018-05-12T00:39:15Z",
      "mergedAt": "2018-05-12T00:39:15Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a21de669291f9f0ee4cc14e68ca83236b17ba0b6",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-9",
      "headRefOid": "c7425de7f308d11f8dfc1c918d38fc1aff0b7f3f",
      "mergeCommit": {
        "oid": "0c9022cfdf6653438ef29bda33236f20ebcd3a3d"
      }
    },
    {
      "number": 622,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg3NjQzMDE2",
      "title": "Treat invalid header fields conservatively",
      "url": "https://github.com/httpwg/http-extensions/pull/622",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed on the list.",
      "createdAt": "2018-05-12T22:25:39Z",
      "updatedAt": "2018-05-13T10:12:48Z",
      "closedAt": "2018-05-13T10:12:45Z",
      "mergedAt": "2018-05-13T10:12:45Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "looks good, OK for me. Thanks Martin!",
          "createdAt": "2018-05-13T04:41:28Z",
          "updatedAt": "2018-05-13T04:41:28Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "0c9022cfdf6653438ef29bda33236f20ebcd3a3d",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "invalid-early-data",
      "headRefOid": "5cc8464eaf0681b3b426195deb7a47d12097e033",
      "mergeCommit": {
        "oid": "e49a9f5b1503eff72d82b0c64fda1f7fd1e4a20d"
      }
    },
    {
      "number": 624,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5NjE3NDEz",
      "title": "expect-ct: add IANA considerations",
      "url": "https://github.com/httpwg/http-extensions/pull/624",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "expect-ct"
      ],
      "body": "",
      "createdAt": "2018-05-22T10:35:17Z",
      "updatedAt": "2018-10-22T05:36:52Z",
      "closedAt": "2018-05-23T02:40:28Z",
      "mergedAt": "2018-05-23T02:40:28Z",
      "mergedBy": "estark37",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "89e90a38ccb59b845cdd27c3e0e85242b9af3e6c",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "e-ct-iana",
      "headRefOid": "41b081b892bde7c50830f1f252c8e49cd2996d9b",
      "mergeCommit": {
        "oid": "7243c6514827b1b341e534ce101ac06def820c3b"
      }
    },
    {
      "number": 625,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5NjMzMjc5",
      "title": "expect-ct: tune examples",
      "url": "https://github.com/httpwg/http-extensions/pull/625",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "expect-ct"
      ],
      "body": "...avoid too wide artwork by changing the second example to use multiple field instances (which, in itself, is good to have in the examples anyway)",
      "createdAt": "2018-05-22T11:39:04Z",
      "updatedAt": "2018-05-29T06:09:17Z",
      "closedAt": "2018-05-23T02:39:55Z",
      "mergedAt": "2018-05-23T02:39:55Z",
      "mergedBy": "estark37",
      "comments": [
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks!",
          "createdAt": "2018-05-23T02:39:45Z",
          "updatedAt": "2018-05-23T02:39:45Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "89e90a38ccb59b845cdd27c3e0e85242b9af3e6c",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "e-ct-examples",
      "headRefOid": "0f7bb1a34c31c017a272a45d819539d19ab1e251",
      "mergeCommit": {
        "oid": "50ffd429492f956b7c1b0fa27ad6f0a7e35aa42a"
      }
    },
    {
      "number": 626,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5ODQyNzUy",
      "title": "Expect-CT: update text about http-equiv",
      "url": "https://github.com/httpwg/http-extensions/pull/626",
      "state": "MERGED",
      "author": "estark37",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "mnot",
        "reschke"
      ],
      "labels": [
        "expect-ct"
      ],
      "body": "",
      "createdAt": "2018-05-23T02:47:41Z",
      "updatedAt": "2018-06-02T11:35:48Z",
      "closedAt": "2018-05-29T15:51:15Z",
      "mergedAt": "2018-05-29T15:51:15Z",
      "mergedBy": "estark37",
      "comments": [
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke @mnot thanks for the explanation/suggestion on the list. Does this look about right to you?",
          "createdAt": "2018-05-23T02:48:08Z",
          "updatedAt": "2018-05-23T02:48:08Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "LGTM.",
          "createdAt": "2018-05-23T03:09:28Z",
          "updatedAt": "2018-05-23T03:09:28Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- avoid lowercase \"should\" unless you refer to [RFC8174] in \"Terminology\"\r\n\r\nFWIW, I still think that citing both HTML specs does not help the reader, and that the whole section isn't needed. If it was needed, why don't we say the same thing in draft-ietf-httpbis-replay-03?\r\n",
          "createdAt": "2018-05-23T03:35:42Z",
          "updatedAt": "2018-05-23T03:35:42Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't have any strong feelings on this, I'm happy to just remove it. I cribbed it from HPKP originally. (https://tools.ietf.org/html/rfc7469#section-2.3.4)",
          "createdAt": "2018-05-23T16:47:39Z",
          "updatedAt": "2018-05-23T16:47:39Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is removed now.",
          "createdAt": "2018-05-24T22:32:09Z",
          "updatedAt": "2018-05-24T22:32:09Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM, and thanks for pointing to RFC 7469. @mnot - should we raise an erratum for that spec?",
          "createdAt": "2018-05-25T05:27:46Z",
          "updatedAt": "2018-05-25T05:27:46Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW: https://www.rfc-editor.org/errata/eid5377",
          "createdAt": "2018-06-02T11:35:48Z",
          "updatedAt": "2018-06-02T11:35:48Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7243c6514827b1b341e534ce101ac06def820c3b",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "expect-ct-meta-elems",
      "headRefOid": "e25254c3f8e9a1e3637acae4661d92a3dab7626d",
      "mergeCommit": {
        "oid": "c7c39ad2cd6b3728ad2e6e6d4eb4603d1970d071"
      }
    },
    {
      "number": 631,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkxMDM4MjUy",
      "title": "secondary-certs: type artwork consistently",
      "url": "https://github.com/httpwg/http-extensions/pull/631",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-29T05:46:37Z",
      "updatedAt": "2018-05-29T06:09:00Z",
      "closedAt": "2018-05-29T06:08:55Z",
      "mergedAt": "2018-05-29T06:08:55Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "2394891cb83bd33072e36bcae1ec7cae34ed2684",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "sec-certs-artwork",
      "headRefOid": "6f0dce60ffc5dac0fe3c834315a64520e47b28bb",
      "mergeCommit": {
        "oid": "54c7d262a0004ded984c81a9fa87d6ecb931aa4f"
      }
    },
    {
      "number": 633,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkxMDM5NTQx",
      "title": "uppercase \"section\"",
      "url": "https://github.com/httpwg/http-extensions/pull/633",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-29T05:57:24Z",
      "updatedAt": "2018-05-29T06:32:39Z",
      "closedAt": "2018-05-29T06:32:30Z",
      "mergedAt": "2018-05-29T06:32:30Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks.",
          "createdAt": "2018-05-29T06:32:36Z",
          "updatedAt": "2018-05-29T06:32:36Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "2394891cb83bd33072e36bcae1ec7cae34ed2684",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-secondary-certs-sections",
      "headRefOid": "6cad2da6d90017dffddd8383d31b4a46f1253f46",
      "mergeCommit": {
        "oid": "f93a2b639f1322e47e3446b2e43e7fa516cc87cd"
      }
    },
    {
      "number": 634,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkxMjIxMDUz",
      "title": "Encourage kramdown to use brackets",
      "url": "https://github.com/httpwg/http-extensions/pull/634",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "Fixes #632.\r\n\r\nThey were both special, but for some reason the first reference wasn't getting brackets in the text output.  Putting whitespace between them doesn't affect that, but putting other characters does.",
      "createdAt": "2018-05-29T17:42:13Z",
      "updatedAt": "2018-06-01T06:19:24Z",
      "closedAt": "2018-05-29T21:43:20Z",
      "mergedAt": "2018-05-29T21:43:20Z",
      "mergedBy": "MikeBishop",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM. (And yes, I tried whitespace as well :-)",
          "createdAt": "2018-05-29T18:16:18Z",
          "updatedAt": "2018-05-29T18:16:18Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5a6173b2f4b3564f80dc545b1f92b40d805cf034",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "citation",
      "headRefOid": "f169d38fddb9ce9546674c9467a232ef0abb08d7",
      "mergeCommit": {
        "oid": "58e96ca23fd958dac4d7a92ef73534cb8420c4bd"
      }
    },
    {
      "number": 636,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkxOTQyNjEx",
      "title": "Restructure structure",
      "url": "https://github.com/httpwg/http-extensions/pull/636",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Separate parsing out, and add serialisation. Also, allow referencing specs to use ABNF.",
      "createdAt": "2018-06-01T06:11:51Z",
      "updatedAt": "2018-06-05T08:51:46Z",
      "closedAt": "2018-06-05T08:51:36Z",
      "mergedAt": "2018-06-05T08:51:36Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "HTML at http://httpwg.org/http-extensions/mnot-restructure-structure/draft-ietf-httpbis-header-structure.html",
          "createdAt": "2018-06-01T06:18:04Z",
          "updatedAt": "2018-06-01T06:18:04Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "The remaining issue here is the ABNF; right now it specifies the HTTP/1 wire serialisation, not what the abstract data types accept.",
          "createdAt": "2018-06-01T06:24:32Z",
          "updatedAt": "2018-06-01T06:24:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MDU3MzU5",
          "commit": {
            "abbreviatedOid": "2c4766d"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-01T06:20:35Z",
          "updatedAt": "2018-06-01T06:27:45Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "serialization*\r\n\r\nOr does the IETF not use en-US?",
              "createdAt": "2018-06-01T06:20:35Z",
              "updatedAt": "2018-06-01T06:40:40Z"
            },
            {
              "originalPosition": 14,
              "body": "serializers*",
              "createdAt": "2018-06-01T06:20:56Z",
              "updatedAt": "2018-06-01T06:40:40Z"
            },
            {
              "originalPosition": 346,
              "body": "Is there a reason you didn't go with early returns here?",
              "createdAt": "2018-06-01T06:22:12Z",
              "updatedAt": "2018-06-01T06:40:40Z"
            },
            {
              "originalPosition": 345,
              "body": "This works, but it seems cleaner as an Assert upfront, since it's invalid input and only other specifications would call this and they better do the correct thing.",
              "createdAt": "2018-06-01T06:22:59Z",
              "updatedAt": "2018-06-01T06:40:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MDU4NjM2",
          "commit": {
            "abbreviatedOid": "2c4766d"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-01T06:28:33Z",
          "updatedAt": "2018-06-01T06:28:33Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "I let the RFC editor figure it out.",
              "createdAt": "2018-06-01T06:28:33Z",
              "updatedAt": "2018-06-01T06:40:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MDU4NzIw",
          "commit": {
            "abbreviatedOid": "2c4766d"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-01T06:29:00Z",
          "updatedAt": "2018-06-01T06:29:01Z",
          "comments": [
            {
              "originalPosition": 346,
              "body": "No particular reason, will switch.",
              "createdAt": "2018-06-01T06:29:01Z",
              "updatedAt": "2018-06-01T06:40:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MDU4NzQ4",
          "commit": {
            "abbreviatedOid": "2c4766d"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-01T06:29:10Z",
          "updatedAt": "2018-06-01T06:29:10Z",
          "comments": [
            {
              "originalPosition": 345,
              "body": "ack.",
              "createdAt": "2018-06-01T06:29:10Z",
              "updatedAt": "2018-06-01T06:40:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MjU3NzEx",
          "commit": {
            "abbreviatedOid": "f534984"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-01T17:44:40Z",
          "updatedAt": "2018-06-01T17:44:41Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Section 3.1 of RFC 7322 says:\r\n\r\n> The RFC publication language is English.  Spelling may be either American or British, as long as an individual document is internally consistent.  Where both American and British English spelling are used within a document or cluster of documents, the text will be modified to be consistent with American English spelling.",
              "createdAt": "2018-06-01T17:44:40Z",
              "updatedAt": "2018-06-01T17:44:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1MzU2Nzcw",
          "commit": {
            "abbreviatedOid": "f534984"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-02T05:37:45Z",
          "updatedAt": "2018-06-02T05:37:45Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Wow, I wonder how that hasn't been a problem in practice. Maybe because the IETF doesn't really do direct cross-references to algorithms and such?",
              "createdAt": "2018-06-02T05:37:45Z",
              "updatedAt": "2018-06-02T05:37:45Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4ea3052e2e26282fdb02b22b0c695ba4f1cc7dbc",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-restructure-structure",
      "headRefOid": "f534984d8b652b6734f0a3684b5eec2102d3ed3e",
      "mergeCommit": {
        "oid": "a4e3c23af509030ab2af93f8f2cba12adfe37be8"
      }
    },
    {
      "number": 645,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkyNjg2MTQ3",
      "title": "Ben's comments",
      "url": "https://github.com/httpwg/http-extensions/pull/645",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "@kaduk had a few comments in the review of this that are easy to solve.",
      "createdAt": "2018-06-05T12:14:46Z",
      "updatedAt": "2018-06-27T21:55:27Z",
      "closedAt": "2018-06-27T21:55:24Z",
      "mergedAt": "2018-06-27T21:55:24Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "All changes are OK to me as well. Thanks!",
          "createdAt": "2018-06-05T13:19:28Z",
          "updatedAt": "2018-06-05T13:19:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI1OTQ4Mzc1",
          "commit": {
            "abbreviatedOid": "6ffb4d7"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2018-06-05T12:37:49Z",
          "updatedAt": "2018-06-05T12:37:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI2MDE4NjY1",
          "commit": {
            "abbreviatedOid": "43d2c16"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "43d2c16 does a great job capturing the point that I made poorly off-list; thanks again!",
          "createdAt": "2018-06-05T15:13:43Z",
          "updatedAt": "2018-06-05T15:13:43Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "61b227727ea980d209e745fe78513030b4b2f4b2",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "kaduk-ad-replay",
      "headRefOid": "43d2c16368ffa10e7c2e1e2b38f40b364de6d003",
      "mergeCommit": {
        "oid": "9b34b9981c01fc35c58829eea9ea1aebfe0693cf"
      }
    },
    {
      "number": 646,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkzMjI4NDM4",
      "title": "Adam's editorial suggestsions",
      "url": "https://github.com/httpwg/http-extensions/pull/646",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "",
      "createdAt": "2018-06-07T07:34:42Z",
      "updatedAt": "2018-06-27T21:55:45Z",
      "closedAt": "2018-06-27T21:55:41Z",
      "mergedAt": "2018-06-27T21:55:41Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "LGTM.",
          "createdAt": "2018-06-07T09:15:16Z",
          "updatedAt": "2018-06-07T09:15:16Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "61b227727ea980d209e745fe78513030b4b2f4b2",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "abr-edits",
      "headRefOid": "bbe5c5f99c94fca6ce495dd1f3a8b0ac1eed24b4",
      "mergeCommit": {
        "oid": "879a7d2222cba3dc8dd54485753fe4b64de413b8"
      }
    },
    {
      "number": 647,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkzMjQzNzg4",
      "title": "ekr's review of replay",
      "url": "https://github.com/httpwg/http-extensions/pull/647",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "Just editorial suggestions here, but all good ones.",
      "createdAt": "2018-06-07T08:39:43Z",
      "updatedAt": "2018-06-27T21:55:59Z",
      "closedAt": "2018-06-27T21:55:57Z",
      "mergedAt": "2018-06-27T21:55:57Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "Nice wording, I really like this new version. Thanks!",
          "createdAt": "2018-06-07T08:59:03Z",
          "updatedAt": "2018-06-07T08:59:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI2NjkyMDc2",
          "commit": {
            "abbreviatedOid": "ac8bdc5"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-07T09:03:14Z",
          "updatedAt": "2018-06-07T09:04:42Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Perhaps \"particular requests\" or \"an individual request\"?",
              "createdAt": "2018-06-07T09:03:14Z",
              "updatedAt": "2018-06-08T13:53:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI2OTY3MTM3",
          "commit": {
            "abbreviatedOid": "ac8bdc5"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-07T21:40:10Z",
          "updatedAt": "2018-06-07T21:40:10Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "61b227727ea980d209e745fe78513030b4b2f4b2",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ekr-replay",
      "headRefOid": "1906059e516383723fe1b0c5a1fd19121d6b433f",
      "mergeCommit": {
        "oid": "2522f9ad9b09754586ba706b5a98b1055b9e107c"
      }
    },
    {
      "number": 648,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkzMjYyNjQw",
      "title": "Spencer's q",
      "url": "https://github.com/httpwg/http-extensions/pull/648",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "This will conflict with the changes ekr suggested, but I integrated them, so merging shouldn't lose the important changes.",
      "createdAt": "2018-06-07T09:47:13Z",
      "updatedAt": "2018-06-27T21:57:44Z",
      "closedAt": "2018-06-27T21:57:41Z",
      "mergedAt": "2018-06-27T21:57:41Z",
      "mergedBy": "martinthomson",
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "For \"sent in early data on another connection\", I think Spencer's proposal \"sent in early data on a previous hop\" would make it even clearer regarding the hop chain so as not to confuse this with another connection from the same user-agent. OK for the rest.",
          "createdAt": "2018-06-07T09:52:09Z",
          "updatedAt": "2018-06-07T09:52:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI2OTY2Nzgz",
          "commit": {
            "abbreviatedOid": "cf8008d"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-07T21:38:55Z",
          "updatedAt": "2018-06-07T21:38:55Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "2522f9ad9b09754586ba706b5a98b1055b9e107c",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "spencer-q",
      "headRefOid": "dfe0561e75ec3c34360faccbf22ccfd80218a75b",
      "mergeCommit": {
        "oid": "125f54d2593372f9e081db0a0ee98cda3d00aa06"
      }
    },
    {
      "number": 649,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkzNTY2MTE4",
      "title": "Ben C review comments",
      "url": "https://github.com/httpwg/http-extensions/pull/649",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "Mostly the text got shorter, which is a nice bonus.",
      "createdAt": "2018-06-08T10:00:53Z",
      "updatedAt": "2018-06-27T21:59:25Z",
      "closedAt": "2018-06-27T21:59:21Z",
      "mergedAt": "2018-06-27T21:59:21Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "125f54d2593372f9e081db0a0ee98cda3d00aa06",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "benc-replay",
      "headRefOid": "0c93841306dbaa02ad3f9fc68eead3f1f1ad0d1e",
      "mergeCommit": {
        "oid": "2263731c131e88727eee08e4dcacf17bd30865d1"
      }
    },
    {
      "number": 650,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0MDk1MTk5",
      "title": "ekr's last call comments for h2ws",
      "url": "https://github.com/httpwg/http-extensions/pull/650",
      "state": "MERGED",
      "author": "mcmanus",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-11T20:33:39Z",
      "updatedAt": "2018-10-22T05:37:04Z",
      "closedAt": "2018-06-15T16:20:31Z",
      "mergedAt": "2018-06-15T16:20:31Z",
      "mergedBy": "mcmanus",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "61b227727ea980d209e745fe78513030b4b2f4b2",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "h2ws-lc-ekr",
      "headRefOid": "5635edd4107b087cc0e545d3a34be14d9709d8e6",
      "mergeCommit": {
        "oid": "5635edd4107b087cc0e545d3a34be14d9709d8e6"
      }
    },
    {
      "number": 651,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0Mzk4Mzc2",
      "title": "Man-in-the-middle protection via SETTINGS",
      "url": "https://github.com/httpwg/http-extensions/pull/651",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "Fixes #617.\r\n\r\nSpecifies an exporter-derived value in SETTINGS to prove that the TLS connection is between the same endpoints as the HTTP connection.  If there is a TLS-terminating proxy intermediating the connection, the expected value will not match the received value, and the work of producing exported authenticators can be skipped.\r\n\r\nOne open question is around the use of early exporters.  I think this is probably something we want, so that servers can send additional certificates in their 0.5-RTT flight to 0-RTT clients.  However, should clients be required to supply a value derived from a regular exporter after the handshake finishes?  This is a minor pain in H2, but in HTTP/QUIC would require defining a separate frame type to carry the updated token.  The obvious value is that the server could still validate the token after forgetting the 0-RTT secret, but it seems like the server could as easily validate the setting early and remember the result even after discarding the secret.  Is there any additional security benefit to the client re-proving the connection is end-to-end after the handshake completes?",
      "createdAt": "2018-06-12T20:28:27Z",
      "updatedAt": "2018-06-13T23:50:45Z",
      "closedAt": "2018-06-13T23:50:39Z",
      "mergedAt": "2018-06-13T23:50:39Z",
      "mergedBy": "MikeBishop",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Without early data, the client can't include this in the initial SETTINGS frame, which means servers don't know whether the client supports things when it decides whether to supply certificates on the 0.5-RTT flight.  I'm not sure how important that is, though.",
          "createdAt": "2018-06-12T20:44:08Z",
          "updatedAt": "2018-06-12T20:44:08Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In h2 at least, we can defer enabling the feature. And if neither side can provide certificates until after the handshake, that is ok.\r\n\r\nThat isn't an answer for hq. I don't know how I feel about that. \r\n",
          "createdAt": "2018-06-13T23:01:58Z",
          "updatedAt": "2018-06-13T23:01:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MTM3Nzk3",
          "commit": {
            "abbreviatedOid": "7e8314f"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I don't think that we need to worry about early data here.  The only potential use of that is client authentication before regular client authentication.\r\n\r\nThat means you can use OR the value with 1 or 0x80000000 to get a non-zero value.",
          "createdAt": "2018-06-12T20:35:25Z",
          "updatedAt": "2018-06-12T20:35:25Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "bcd334e124e530215b860078889e9bcbc71fcb7e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "sc/mitm",
      "headRefOid": "91e306eed0df46a4e2ef6b27b14e274c124abeec",
      "mergeCommit": {
        "oid": "1a87c91d36e673b360042683a3113a3d7a585525"
      }
    },
    {
      "number": 652,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0NDg3NDky",
      "title": "variants: avoid wide artwork",
      "url": "https://github.com/httpwg/http-extensions/pull/652",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-13T06:57:57Z",
      "updatedAt": "2018-06-13T07:06:12Z",
      "closedAt": "2018-06-13T07:06:07Z",
      "mergedAt": "2018-06-13T07:06:07Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b2f8e3e727b5cfc2391129b89e61ba61d713eb3f",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-variants-artwork",
      "headRefOid": "de29c4b3f4f1f3b350a4b73fcd945cd4578f37e2",
      "mergeCommit": {
        "oid": "24cb0b28621280a27c930ededfdb00a926f31349"
      }
    },
    {
      "number": 653,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0OTcwMTI0",
      "title": "Clients use Empty Authenticator as well",
      "url": "https://github.com/httpwg/http-extensions/pull/653",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "Follow-on to #586; in the process of fixing this, I noticed that I'd added a \"server\" header but missed adding a corresponding \"client\" header, so the client discussion appeared in the server section.",
      "createdAt": "2018-06-14T17:50:41Z",
      "updatedAt": "2018-06-15T17:59:36Z",
      "closedAt": "2018-06-15T17:59:31Z",
      "mergedAt": "2018-06-15T17:59:31Z",
      "mergedBy": "MikeBishop",
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For some reason, that seems to be endemic in this doc.  Let's do that cleanup separately.",
          "createdAt": "2018-06-15T17:58:54Z",
          "updatedAt": "2018-06-15T17:58:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MjAzMTQ0",
          "commit": {
            "abbreviatedOid": "8b82463"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I appreciate the addition of the section heading.  Though Section Headings Use Title Case.",
          "createdAt": "2018-06-15T15:00:28Z",
          "updatedAt": "2018-06-15T15:00:28Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "222cf1e296a83fc3274188eab8fca2da0f157ee5",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "sc/clients_too",
      "headRefOid": "8b824632ca49ce5d340b1731fa6ec1d3cb4c7005",
      "mergeCommit": {
        "oid": "a39d555a0bb544bbc97f96bba3438c37d50a911e"
      }
    },
    {
      "number": 654,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1MjQ5OTEx",
      "title": "Adjust casing in Section Headers and figure captions",
      "url": "https://github.com/httpwg/http-extensions/pull/654",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "Capitalized section headers throughout; sentence-cased figure captions.  Both were previously a mix throughout the document.",
      "createdAt": "2018-06-15T18:21:03Z",
      "updatedAt": "2018-06-15T20:16:18Z",
      "closedAt": "2018-06-15T20:16:14Z",
      "mergedAt": "2018-06-15T20:16:14Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a39d555a0bb544bbc97f96bba3438c37d50a911e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "sc/title_case",
      "headRefOid": "e46af540cdbe148ea094746318fb8cabd9a4d5b7",
      "mergeCommit": {
        "oid": "9b5f8fabeee6521fd481b8e1b993fd1b7dbf7fb9"
      }
    },
    {
      "number": 656,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk3ODYxODA0",
      "title": "Accept-CH+Lifetime opt-in is for same-origin resources",
      "url": "https://github.com/httpwg/http-extensions/pull/656",
      "state": "MERGED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Per discussions in fetch#726 [1], update the opt-in example to apply to\r\nsame-origin resources only, with Accept-CH-Lifetime being processed on\r\nnavigation requests.\r\n\r\n[1] https://github.com/whatwg/fetch/issues/726\r\n\r\n/cc @yoavweiss @tarunban",
      "createdAt": "2018-06-27T21:42:49Z",
      "updatedAt": "2018-10-22T05:37:07Z",
      "closedAt": "2018-06-28T06:37:15Z",
      "mergedAt": "2018-06-28T06:37:15Z",
      "mergedBy": "igrigorik",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNjgxNDg2",
          "commit": {
            "abbreviatedOid": "1449aa3"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-28T04:09:32Z",
          "updatedAt": "2018-06-28T04:09:33Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I think this example works, but would be good to also include the same rules in the processing definition above. e.g. s/When a client receives an HTTP response/When a client receives an HTTP navigation response, which is the same origin as the request which initiated the navigation/\r\n\r\nWould such a language work for non-browser scenarios? ",
              "createdAt": "2018-06-28T04:09:32Z",
              "updatedAt": "2018-06-28T04:09:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNjg0ODE4",
          "commit": {
            "abbreviatedOid": "1449aa3"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-28T04:42:12Z",
          "updatedAt": "2018-06-28T04:42:13Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "> Would such a language work for non-browser scenarios?\r\n\r\nMy hunch is \"no\" and we shouldn't impose this restriction here / scope it to browsers only. UA's have a concept of user-initiated \"navigation\", but this doesn't extend to other potential clients \u2014 e.g. a native app using CH negotiation with a CDN should be able to define own logic for how to process the opt-in; FP doesn't apply for other clients.\r\n\r\nMy suggestion is to keep the text as is, otherwise we'll quickly find ourselves redefining HTML concepts, which we should instead defer to the HTML spec.\r\n\r\nWDYT?",
              "createdAt": "2018-06-28T04:42:13Z",
              "updatedAt": "2018-06-28T04:42:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNjg4NzM4",
          "commit": {
            "abbreviatedOid": "1449aa3"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-28T05:14:59Z",
          "updatedAt": "2018-06-28T05:14:59Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "OK, so the normative text is for all clients and the examples is UAs only? I guess that makes sense.",
              "createdAt": "2018-06-28T05:14:59Z",
              "updatedAt": "2018-06-28T05:14:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNjg5MzM0",
          "commit": {
            "abbreviatedOid": "1449aa3"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-28T05:19:44Z",
          "updatedAt": "2018-06-28T05:19:44Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Yep, that's how we've structured it so far.\r\n\r\nThat aside, good to merge?",
              "createdAt": "2018-06-28T05:19:44Z",
              "updatedAt": "2018-06-28T05:19:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNjg5NzIx",
          "commit": {
            "abbreviatedOid": "1449aa3"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2018-06-28T05:22:48Z",
          "updatedAt": "2018-06-28T05:22:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNjk2MzEz",
          "commit": {
            "abbreviatedOid": "1449aa3"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-28T06:03:43Z",
          "updatedAt": "2018-06-28T06:03:43Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "yup :)",
              "createdAt": "2018-06-28T06:03:43Z",
              "updatedAt": "2018-06-28T06:03:43Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a3ae3014306cc4d8fd0d7a3b81a321fa6364a87e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ch-same-origin",
      "headRefOid": "1449aa365974f3cad805d42d2f8a6d9299e20752",
      "mergeCommit": {
        "oid": "b4f397652553ab7f99a671ce2eb2838bdf7ecaf1"
      }
    },
    {
      "number": 661,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4MjExMTc5",
      "title": "Reword as discussed on list",
      "url": "https://github.com/httpwg/http-extensions/pull/661",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "replay"
      ],
      "body": "This moves to SHOULD from MAY for automatic retry and shift the subject of the tricky sentence about potential replays at an intermediary.",
      "createdAt": "2018-06-29T04:16:46Z",
      "updatedAt": "2018-10-08T08:24:19Z",
      "closedAt": "2018-10-08T08:24:15Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "OK to me, thanks!",
          "createdAt": "2018-06-29T04:31:10Z",
          "updatedAt": "2018-06-29T04:31:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OBE (or I think incorporated elsewhere?)",
          "createdAt": "2018-10-08T08:24:15Z",
          "updatedAt": "2018-10-08T08:24:15Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c00978ad8009062cf2e4cf88324a4c67b404f045",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "replay-late-tweaks",
      "headRefOid": "b75f2356b2822e7d3f5e0bfaf6bccb841e6d3eb6",
      "mergeCommit": null
    },
    {
      "number": 665,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNDA4NDYy",
      "title": "Fix VCHAR references in draft-ietf-httpbis-header-structure.md",
      "url": "https://github.com/httpwg/http-extensions/pull/665",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix #664. Step 4.4 equates \"the range %x00-1f or %x7f\" to \"not in VCHAR\", but VCHAR doesn't include %x20; this change adds \"or SP\" and imports SP from RFC5234.",
      "createdAt": "2018-07-13T21:51:38Z",
      "updatedAt": "2018-10-19T23:29:11Z",
      "closedAt": "2018-07-15T15:02:49Z",
      "mergedAt": "2018-07-15T15:02:49Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2018-07-15T15:02:53Z",
          "updatedAt": "2018-07-15T15:02:53Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "bf0aa2d3a22b770eb9fb53c4938b6d30ef4206e5",
      "headRepository": "twifkak/http-extensions",
      "headRefName": "patch-1",
      "headRefOid": "05f60de79f5b8e4e5d68c498862e421d89f66032",
      "mergeCommit": {
        "oid": "6131d3b7d503063b9b8dc461ddbc24e00c143c16"
      }
    },
    {
      "number": 666,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNDMwMzAx",
      "title": "Add \";\" missing from #ser-param-list",
      "url": "https://github.com/httpwg/http-extensions/pull/666",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "This corresponds with the ABNF in the #param section.",
      "createdAt": "2018-07-14T01:53:27Z",
      "updatedAt": "2018-10-19T23:29:09Z",
      "closedAt": "2018-07-15T15:04:24Z",
      "mergedAt": "2018-07-15T15:04:24Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks.",
          "createdAt": "2018-07-15T15:04:34Z",
          "updatedAt": "2018-07-15T15:04:34Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "bf0aa2d3a22b770eb9fb53c4938b6d30ef4206e5",
      "headRepository": "twifkak/http-extensions",
      "headRefName": "patch-2",
      "headRefOid": "3543e422bd031797a9b69560df1812012c29d3c2",
      "mergeCommit": {
        "oid": "927968c804f0845d027ce939da401a8d383feca3"
      }
    },
    {
      "number": 667,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNDMwNDUx",
      "title": "Disallow trailing whitespace in #parse-param-list",
      "url": "https://github.com/httpwg/http-extensions/pull/667",
      "state": "CLOSED",
      "author": "twifkak",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "This corresponds with the ABNF in the #param section.",
      "createdAt": "2018-07-14T01:57:11Z",
      "updatedAt": "2018-10-09T04:34:43Z",
      "closedAt": "2018-10-09T03:40:45Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot",
          "createdAt": "2018-07-26T01:07:36Z",
          "updatedAt": "2018-07-26T01:07:36Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot Is this PR faulty? If so, let me know so I can close and forget about it. :)",
          "createdAt": "2018-08-16T19:18:41Z",
          "updatedAt": "2018-08-16T19:18:41Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Sorry for the wait.\r\n\r\nI think we should be forgiving about whitespace around commas and at the end of headers, since there will be HTTP implementations (outside the control of this spec) that add them / combine them, etc.",
          "createdAt": "2018-08-17T05:09:04Z",
          "updatedAt": "2018-08-17T05:09:04Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the feedback! (No worries re: delay.) Should the ABNF in #param be updated to match, or are you okay with the difference between #param and #parse-param-list? Perhaps the difference should be documented as intentional?",
          "createdAt": "2018-08-20T16:41:55Z",
          "updatedAt": "2018-08-20T16:41:55Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I've noted that the parsing algorithms can be \"greedy\" regarding trailing whitespace. As the notational conventions section mentions, the ABNF is the \"ideal\" form, but the algorithms define conformance.",
          "createdAt": "2018-10-09T03:40:45Z",
          "updatedAt": "2018-10-09T03:40:45Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "bf0aa2d3a22b770eb9fb53c4938b6d30ef4206e5",
      "headRepository": "twifkak/http-extensions",
      "headRefName": "patch-3",
      "headRefOid": "fd30d310ef01481ad1c5361b3da3cc6ede7fa6d2",
      "mergeCommit": null
    },
    {
      "number": 672,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0MDQyODM2",
      "title": "[SH] add commas to dict,plist algorithms",
      "url": "https://github.com/httpwg/http-extensions/pull/672",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Serialisation algorithms for dictionary and parameterised-list didn't include commas (?)\r\n\r\nThis copies the equivalent steps from the `list` algorithm",
      "createdAt": "2018-07-26T06:44:35Z",
      "updatedAt": "2018-08-01T11:05:41Z",
      "closedAt": "2018-08-01T01:11:16Z",
      "mergedAt": "2018-08-01T01:11:16Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Just noticed that this is #669",
          "createdAt": "2018-07-27T01:54:11Z",
          "updatedAt": "2018-07-27T01:54:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thx.",
          "createdAt": "2018-08-01T01:11:21Z",
          "updatedAt": "2018-08-01T01:11:21Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "172e4d8efe999f77f8a928c40bc886dfe95cb12e",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "algorithm-commas",
      "headRefOid": "5ea7e214ad85c8133a43983ec002c1ae84dbeef2",
      "mergeCommit": {
        "oid": "1ffcc2ae7fea30851be7058a7674ff2f3a0a7a49"
      }
    },
    {
      "number": 673,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0MDQyODk4",
      "title": "[SH] various a/an fixes, and a rogue plural",
      "url": "https://github.com/httpwg/http-extensions/pull/673",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-26T06:44:56Z",
      "updatedAt": "2018-07-28T12:59:27Z",
      "closedAt": "2018-07-27T19:44:36Z",
      "mergedAt": "2018-07-27T19:44:36Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2018-07-27T19:44:40Z",
          "updatedAt": "2018-07-27T19:44:40Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "172e4d8efe999f77f8a928c40bc886dfe95cb12e",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "a-an",
      "headRefOid": "739f7a2568632fe77e1777f23c8c90ba19074c19",
      "mergeCommit": {
        "oid": "4d67ad1068b849af26205e83963331e65dbfba85"
      }
    },
    {
      "number": 674,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0MDQzMDcz",
      "title": "[SH] change a comma and a parenthetical",
      "url": "https://github.com/httpwg/http-extensions/pull/674",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Purely editorial.",
      "createdAt": "2018-07-26T06:45:55Z",
      "updatedAt": "2018-07-31T03:34:49Z",
      "closedAt": "2018-07-29T23:17:10Z",
      "mergedAt": "2018-07-29T23:17:10Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2018-07-29T23:17:15Z",
          "updatedAt": "2018-07-29T23:17:15Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "172e4d8efe999f77f8a928c40bc886dfe95cb12e",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "editorial-commas",
      "headRefOid": "b9bafdcfcaecda0232c125416de8210738065012",
      "mergeCommit": {
        "oid": "4617b97ca9f7aa01be4cd47d262286527d05ac5b"
      }
    },
    {
      "number": 675,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0OTg2Nzkx",
      "title": "[SH] make 'parse number from text' less greedy",
      "url": "https://github.com/httpwg/http-extensions/pull/675",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Makes \"Parse a Number from Text\" not be greedy, and return (not fail) when it encounters a non-digit character.\r\n\r\nResolves #668 ",
      "createdAt": "2018-07-31T03:33:40Z",
      "updatedAt": "2018-08-17T05:08:01Z",
      "closedAt": "2018-08-16T08:15:52Z",
      "mergedAt": "2018-08-16T08:15:52Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm pretty sure it works.\r\n\r\n* Steps 5 & 6 ensure there's always at least one digit.\r\n* All the calling contexts of \"Parsing an Item from Text\" (including the top-level algorithm in \u00a74.2) inspect the next character, and handle it appropriately.",
          "createdAt": "2018-07-31T03:41:30Z",
          "updatedAt": "2018-07-31T03:41:30Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "SGTM",
          "createdAt": "2018-08-16T08:15:59Z",
          "updatedAt": "2018-08-16T08:15:59Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4617b97ca9f7aa01be4cd47d262286527d05ac5b",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "return-a-number",
      "headRefOid": "333f40ec273b14ea20637ec4fb0d66810e2af03b",
      "mergeCommit": {
        "oid": "0e7180f7c32ee410a65417f601c0fa5bda56b80d"
      }
    },
    {
      "number": 676,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA1OTM5Nzg0",
      "title": "[SH] make Serialising an Item return a value",
      "url": "https://github.com/httpwg/http-extensions/pull/676",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Serialised `value` wasn't getting appended to `output`",
      "createdAt": "2018-08-03T06:46:30Z",
      "updatedAt": "2018-08-14T00:06:04Z",
      "closedAt": "2018-08-13T04:08:30Z",
      "mergedAt": "2018-08-13T04:08:30Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Would it be better to just have each of the steps before return their result?",
          "createdAt": "2018-08-10T01:28:59Z",
          "updatedAt": "2018-08-10T01:28:59Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I did wonder that when writing it.  Or make them all `s/let value/let output`.  Or however you think looks best.\r\n\r\nI probably should have just filed it as an Issue. :thinking: ",
          "createdAt": "2018-08-10T06:50:57Z",
          "updatedAt": "2018-08-10T06:50:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "\ud83d\udc4d ",
          "createdAt": "2018-08-13T04:08:41Z",
          "updatedAt": "2018-08-13T04:08:41Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1ffcc2ae7fea30851be7058a7674ff2f3a0a7a49",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "serialise-item",
      "headRefOid": "3fa47961e3523ad18a49e45e61b574811c0f1837",
      "mergeCommit": {
        "oid": "b051177c88b80d971ec34d610360d25767f59d55"
      }
    },
    {
      "number": 677,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA1OTUwOTg1",
      "title": "[SH] multiply int by sign before testing range",
      "url": "https://github.com/httpwg/http-extensions/pull/677",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When parsing a number, multiply `sign` back in to `output_number`\r\n*before* testing against the range defined in Section 3.5.",
      "createdAt": "2018-08-03T07:46:42Z",
      "updatedAt": "2018-08-10T06:53:43Z",
      "closedAt": "2018-08-10T01:29:53Z",
      "mergedAt": "2018-08-10T01:29:53Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2018-08-10T01:30:00Z",
          "updatedAt": "2018-08-10T01:30:00Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1ffcc2ae7fea30851be7058a7674ff2f3a0a7a49",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "validate-integer",
      "headRefOid": "2d2f9ab8d5ee3ccf5bb8ea12b3f80410db57057f",
      "mergeCommit": {
        "oid": "5d5114275ac2ee1bdcc9f875791d667e89894ad5"
      }
    },
    {
      "number": 678,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA1OTUzNzU5",
      "title": "[SH] remove rogue 'Otherwise' from string parser",
      "url": "https://github.com/httpwg/http-extensions/pull/678",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-08-03T07:59:47Z",
      "updatedAt": "2018-08-14T00:05:51Z",
      "closedAt": "2018-08-13T04:09:04Z",
      "mergedAt": "2018-08-13T04:09:04Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "How's that?  It looks kind of like the equivalent case in Parse Dict/Parse List, but more descriptive than it was.",
          "createdAt": "2018-08-10T07:01:44Z",
          "updatedAt": "2018-08-10T07:01:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ1MDc5NjA0",
          "commit": {
            "abbreviatedOid": "3ab25f2"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-10T01:30:57Z",
          "updatedAt": "2018-08-10T01:30:57Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Maybe make this a tiny bit less terse -- e.g., \"Fail parsing (due to the string being unterminated).\"?",
              "createdAt": "2018-08-10T01:30:57Z",
              "updatedAt": "2018-08-10T06:59:34Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1ffcc2ae7fea30851be7058a7674ff2f3a0a7a49",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "unnecessary-otherwise",
      "headRefOid": "2e473a55059ba5736d09ad410988a2ee483b612d",
      "mergeCommit": {
        "oid": "4efefe21e89be7a87c97f0733982c14b99c67fae"
      }
    },
    {
      "number": 679,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA2NTgwODY5",
      "title": "[SH] tweak examples",
      "url": "https://github.com/httpwg/http-extensions/pull/679",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Tweak some examples to make them a bit more valid",
      "createdAt": "2018-08-07T05:07:09Z",
      "updatedAt": "2018-08-10T07:02:07Z",
      "closedAt": "2018-08-10T01:31:51Z",
      "mergedAt": "2018-08-10T01:31:51Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6cd1d9ccfebfdf28108f31a96db5bb4be5080738",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "sh-examples",
      "headRefOid": "a864f23ea28bfec5767e5db52b3e373f8609d7b9",
      "mergeCommit": {
        "oid": "0b778403396f862b404e379aadaabf39f03b1167"
      }
    },
    {
      "number": 682,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA3MTU3MDkw",
      "title": "Fix a comma in a Variants example",
      "url": "https://github.com/httpwg/http-extensions/pull/682",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-08-08T22:37:20Z",
      "updatedAt": "2018-08-09T03:41:39Z",
      "closedAt": "2018-08-09T03:41:33Z",
      "mergedAt": "2018-08-09T03:41:33Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2018-08-09T03:41:39Z",
          "updatedAt": "2018-08-09T03:41:39Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c2ae923f03a25432c145292b0ceda5f99f750e22",
      "headRepository": "jyasskin/http-extensions",
      "headRefName": "patch-1",
      "headRefOid": "7044407486b0a6ba965a8e22a84c4c0396539977",
      "mergeCommit": {
        "oid": "384415acf55b351146d4628add1cac6f0f816a36"
      }
    },
    {
      "number": 689,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA5Njk0NDA1",
      "title": "[SH] make \"parse a boolean\" consume the T/F char",
      "url": "https://github.com/httpwg/http-extensions/pull/689",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #688",
      "createdAt": "2018-08-21T02:50:13Z",
      "updatedAt": "2018-08-21T02:51:00Z",
      "closedAt": "2018-08-21T02:50:23Z",
      "mergedAt": "2018-08-21T02:50:23Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "thx (again)",
          "createdAt": "2018-08-21T02:50:29Z",
          "updatedAt": "2018-08-21T02:50:29Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "dd0add9c6cce1c214de679f0a36485bb0d0d8e79",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "structured-headers/parse-boolean",
      "headRefOid": "a69a15f541b9a8395ddacda97dcf3899ade65e89",
      "mergeCommit": {
        "oid": "f316aee5b2d47601c849660fe9c3c0cdd44fbbae"
      }
    },
    {
      "number": 690,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEwMjQ2MzQ0",
      "title": "Adding a note about 303 See Other",
      "url": "https://github.com/httpwg/http-extensions/pull/690",
      "state": "OPEN",
      "author": "evert",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "I noticed in my testing that 303 See Other works pretty much everywhere. A very common case for application developers is to send browsers a redirect after a POST. Almost every framework will default to using 302 for this, but really they should be using 303.\r\n\r\nLet me know if you don't like the wording, happy to make edits.",
      "createdAt": "2018-08-22T19:55:55Z",
      "updatedAt": "2019-05-03T20:30:16Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNjU1NTM0",
          "commit": {
            "abbreviatedOid": "fdc4e41"
          },
          "author": "ericlaw1979",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T20:21:53Z",
          "updatedAt": "2019-05-03T20:21:53Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nA common use-case for redirects that change the request method to GET is to communicate to the browser\r\n```",
              "createdAt": "2019-05-03T20:21:53Z",
              "updatedAt": "2019-05-03T20:30:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNjU1Njg4",
          "commit": {
            "abbreviatedOid": "fdc4e41"
          },
          "author": "ericlaw1979",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T20:22:18Z",
          "updatedAt": "2019-05-03T20:22:18Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nfor this is 303 See Other. This status code is widely supported and is the recommended status code\r\n```",
              "createdAt": "2019-05-03T20:22:18Z",
              "updatedAt": "2019-05-03T20:30:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNjU1NzY4",
          "commit": {
            "abbreviatedOid": "fdc4e41"
          },
          "author": "ericlaw1979",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T20:22:30Z",
          "updatedAt": "2019-05-03T20:22:30Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nfor such purposes.\r\n```",
              "createdAt": "2019-05-03T20:22:30Z",
              "updatedAt": "2019-05-03T20:30:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNjU1OTI1",
          "commit": {
            "abbreviatedOid": "fdc4e41"
          },
          "author": "ericlaw1979",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "proposed a few wording changes. ",
          "createdAt": "2019-05-03T20:22:58Z",
          "updatedAt": "2019-05-03T20:22:58Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "69ce5f74f9835ecf818c943bc1a74b93c076f9e9",
      "headRepository": "evert/http-extensions",
      "headRefName": "patch-1",
      "headRefOid": "d7e7b02fb514890eadc63847197d595779a5d4a8",
      "mergeCommit": null
    },
    {
      "number": 693,
      "id": "MDExOlB1bGxSZXF1ZXN0MjExMTQ2NjE4",
      "title": "RFC6265bis: Include 'host-only-flag' when calculating uniqueness.",
      "url": "https://github.com/httpwg/http-extensions/pull/693",
      "state": "MERGED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "Closes https://github.com/httpwg/http-extensions/issues/199\r\n\r\n@johnwilander, mind taking a look?",
      "createdAt": "2018-08-27T15:33:06Z",
      "updatedAt": "2018-08-31T06:48:08Z",
      "closedAt": "2018-08-31T06:48:04Z",
      "mergedAt": "2018-08-31T06:48:04Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "(@mnot, would you mind adding @johnwilander to the repo as a collaborator so I can ask him to review via the GitHub tool? :) )",
          "createdAt": "2018-08-27T15:34:04Z",
          "updatedAt": "2018-08-27T15:34:04Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Ping.",
          "createdAt": "2018-08-30T10:00:25Z",
          "updatedAt": "2018-08-30T10:00:25Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Invite was sent a while back. Still listed as \"pending.\"",
          "createdAt": "2018-08-30T10:05:33Z",
          "updatedAt": "2018-08-30T10:05:33Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> I probably need to read more of the context but would it be useful to point out that this is an internal flag for the user agent? It is, right? Inferred from whether the setting of the cookie included the domain or not.\r\n\r\nIt is an internal flag, but I don't think the PR needs additional documentation. The change we're making is in the middle of an algorithm, and `host-only-flag` is basically a variable that was set earlier in the process. I think folks reading the document will understand that. :)",
          "createdAt": "2018-08-31T06:47:37Z",
          "updatedAt": "2018-08-31T06:47:37Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the review! I'll merge this, and look forward to your PR adding yourself as an editor.",
          "createdAt": "2018-08-31T06:47:56Z",
          "updatedAt": "2018-08-31T06:47:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxMDkxNTA1",
          "commit": {
            "abbreviatedOid": "b415d03"
          },
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I probably need to read more of the context but would it be useful to point out that this is an internal flag for the user agent? It is, right? Inferred from whether the setting of the cookie included the domain or not.",
          "createdAt": "2018-08-30T17:02:13Z",
          "updatedAt": "2018-08-30T17:02:13Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f316aee5b2d47601c849660fe9c3c0cdd44fbbae",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "rfc6265-uniqueness",
      "headRefOid": "b415d03dbf4f009d298c69a50bde9eb6248e2a99",
      "mergeCommit": {
        "oid": "0eb360deac3c8702fe9181dc3ce68d2f72480181"
      }
    },
    {
      "number": 694,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2NTI5NDkx",
      "title": "h2-websockets: apply AUTH48 changes",
      "url": "https://github.com/httpwg/http-extensions/pull/694",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "h2-websockets"
      ],
      "body": "",
      "createdAt": "2018-09-19T06:41:25Z",
      "updatedAt": "2019-10-28T09:57:59Z",
      "closedAt": "2018-10-08T08:25:18Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Rebase?",
          "createdAt": "2018-10-08T08:25:18Z",
          "updatedAt": "2018-10-08T08:25:18Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "50ccc98e8bc72761d8099cd435730d0473a39c7a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-h2-ws-auth48",
      "headRefOid": "f959c4c2d629d20b8ec777b66f3e4465c8f93e92",
      "mergeCommit": null
    },
    {
      "number": 695,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE3NjkwOTMx",
      "title": "replay: replay AUTH48 changes",
      "url": "https://github.com/httpwg/http-extensions/pull/695",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-24T15:11:44Z",
      "updatedAt": "2018-09-24T17:32:55Z",
      "closedAt": "2018-09-24T17:32:52Z",
      "mergedAt": "2018-09-24T17:32:52Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "50ccc98e8bc72761d8099cd435730d0473a39c7a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-replay-auth48",
      "headRefOid": "2b5ad659b9ed4fb3e6714ec86650341b294adeaf",
      "mergeCommit": {
        "oid": "6698d49f788fe2c3bb091d27988c44d24de36781"
      }
    },
    {
      "number": 696,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE3NzEwOTc2",
      "title": "Define policy-controlled features",
      "url": "https://github.com/httpwg/http-extensions/pull/696",
      "state": "CLOSED",
      "author": "eeeps",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "This PR is part of an attempt to address https://github.com/WICG/feature-policy/issues/129 \u2013 using Feature Policy to let authors opt-into sending specific Client Hints to specific origins.\r\n\r\nThe overall, basic idea is:\r\n\r\n1. A new set of policy-controlled features \u2013 one for each Client Hint header field \u2013 is defined in the Client Hints spec. Those are defined in this PR.\r\n2. A new algorithm which determines whether a request is able to use a policy-controlled feature is [defined in the Feature Policy spec](https://github.com/WICG/feature-policy/pull/220).\r\n3. The step in Fetch that appends Client Hint headers [calls the new algorithm](https://github.com/whatwg/fetch/pull/811), checking if a request is allowed to use a Client Hints\u2019 policy-controlled feature before appending the Client Hint header.",
      "createdAt": "2018-09-24T16:13:55Z",
      "updatedAt": "2019-03-26T00:45:32Z",
      "closedAt": "2019-03-26T00:45:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "eeeps",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@yoavweiss is adding these definitions to the HTML spec here: https://github.com/whatwg/html/pull/3774/commits/335f566e0162a8fdb71e0acd513cff148e32eb53\r\n\r\n@mnot @igrigorik Maybe spin up a separate issue to discuss the level which delegation mechanisms should be explained/exampled in the CH spec?",
          "createdAt": "2019-03-26T00:45:31Z",
          "updatedAt": "2019-03-26T00:45:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYwMDk1OTQz",
          "commit": {
            "abbreviatedOid": "fe566da"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-29T23:04:13Z",
          "updatedAt": "2018-09-29T23:04:13Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "@eeeps this entire section should live in Feature Policy spec, not here. Could you move it over to your FP PR?",
              "createdAt": "2018-09-29T23:04:13Z",
              "updatedAt": "2018-09-29T23:04:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg0NTIyOTE4",
          "commit": {
            "abbreviatedOid": "fe566da"
          },
          "author": "eeeps",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-13T07:01:23Z",
          "updatedAt": "2018-12-13T07:01:23Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I'm not sure it belongs in the Feature Policy spec. The Feature Policy spec only defines a generic set of mechanisms, and is not in the business of defining (or even, to date, [enumerating](https://github.com/WICG/feature-policy/issues/244)) specific policy-controlled features like this.\r\n\r\nCan you explain why you don't think these feature policy definitions belong in the Client Hints spec?\r\n\r\nPerhaps there's somewhere in the HTML or Fetch specs that'd be a better home? \r\n\r\ncc: @yoavweiss ",
              "createdAt": "2018-12-13T07:01:23Z",
              "updatedAt": "2018-12-13T07:01:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg1MDY5OTMw",
          "commit": {
            "abbreviatedOid": "fe566da"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-14T11:30:16Z",
          "updatedAt": "2018-12-14T11:30:16Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I think you're both right! :)\r\n\r\nCross-origin fetches is a web concept, so it has no place here. At the same time, FP does indeed just define the mechanisms, not the features.\r\n\r\nHTML and Fetch are probably the right places for this, where the features are defined in HTML and initialize an object keeping track of the Document's CH delegation to certain third-parties, which is later used in Fetch to actually make a decision on sending the hints themselves using it.\r\n",
              "createdAt": "2018-12-14T11:30:16Z",
              "updatedAt": "2018-12-14T11:30:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg1MjQyMjY2",
          "commit": {
            "abbreviatedOid": "fe566da"
          },
          "author": "eeeps",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-14T19:01:01Z",
          "updatedAt": "2018-12-14T19:01:02Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "@yoavweiss do you think this policy-controlled feature definition belongs in (or is blocked by?) https://github.com/whatwg/html/pull/3774, or should I create a new PR on the HTML spec?\r\n",
              "createdAt": "2018-12-14T19:01:01Z",
              "updatedAt": "2018-12-14T19:01:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg1NDExMzcw",
          "commit": {
            "abbreviatedOid": "fe566da"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-17T00:07:30Z",
          "updatedAt": "2018-12-17T00:07:30Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "If we're going to make the CH spec generic (which still needs to be properly explained/discussed, btw :), I'd think that the CH spec should have a mention of FP and some general guidance, whereas the specific feature definitions / guidance should go wherever those particular hints are defined. YMMV, of course.",
              "createdAt": "2018-12-17T00:07:30Z",
              "updatedAt": "2018-12-17T00:07:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2MzkyMTgy",
          "commit": {
            "abbreviatedOid": "fe566da"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-19T05:31:22Z",
          "updatedAt": "2018-12-19T05:31:22Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Fair enough. We could mention FP as an example of how delegation can happen for a browser use case. For other environments.. they may or may not use a similar pattern. \r\n\r\n@mnot does that sound reasonable to you?",
              "createdAt": "2018-12-19T05:31:22Z",
              "updatedAt": "2018-12-19T05:31:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2NDM2NzQy",
          "commit": {
            "abbreviatedOid": "fe566da"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-19T08:47:05Z",
          "updatedAt": "2018-12-19T08:47:06Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "If feature policy were a done deal, that might be OK, but it's still very unstable.",
              "createdAt": "2018-12-19T08:47:06Z",
              "updatedAt": "2018-12-19T08:47:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2NDUxODk4",
          "commit": {
            "abbreviatedOid": "fe566da"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-19T09:26:48Z",
          "updatedAt": "2018-12-19T09:26:48Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "OK, that sounds like an argument for more generic language.",
              "createdAt": "2018-12-19T09:26:48Z",
              "updatedAt": "2018-12-19T09:26:48Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "50ccc98e8bc72761d8099cd435730d0473a39c7a",
      "headRepository": "eeeps/http-extensions",
      "headRefName": "feature-policy-opt-in",
      "headRefOid": "fe566da549037afd354e37a4d2ded6f82bbcb9b7",
      "mergeCommit": null
    },
    {
      "number": 704,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIxNjg2MTUy",
      "title": "sh: fix ABNF width problem",
      "url": "https://github.com/httpwg/http-extensions/pull/704",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "",
      "createdAt": "2018-10-10T07:36:51Z",
      "updatedAt": "2018-10-10T22:32:02Z",
      "closedAt": "2018-10-10T22:31:54Z",
      "mergedAt": "2018-10-10T22:31:54Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks.",
          "createdAt": "2018-10-10T22:31:59Z",
          "updatedAt": "2018-10-10T22:31:59Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "bcbaba62bbcc259aff57e873f7e6bfdd3d614270",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-sh-abnf-width",
      "headRefOid": "b9918eb00ffe4535c0d36c6e4697c2bf8c13ac34",
      "mergeCommit": {
        "oid": "eb1fac605792b61197c2f067e110a9e4a911d5a8"
      }
    },
    {
      "number": 705,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0NTk2MzQy",
      "title": "Flip around variant-key syntax",
      "url": "https://github.com/httpwg/http-extensions/pull/705",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "For #663",
      "createdAt": "2018-10-22T06:15:32Z",
      "updatedAt": "2018-10-22T23:23:30Z",
      "closedAt": "2018-10-22T23:23:26Z",
      "mergedAt": "2018-10-22T23:23:26Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "eb1fac605792b61197c2f067e110a9e4a911d5a8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-variant-key-revisit",
      "headRefOid": "748b101125a1263e07446fbb33590703fc6e296d",
      "mergeCommit": {
        "oid": "c978c11c39d0ad94422399b21455ca405999eacf"
      }
    },
    {
      "number": 707,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI1MTg1MTU4",
      "title": "Request-ID matching",
      "url": "https://github.com/httpwg/http-extensions/pull/707",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "Fixes #486.  Takes a dependency on https://github.com/tlswg/tls-exported-authenticator/issues/43.",
      "createdAt": "2018-10-23T20:59:28Z",
      "updatedAt": "2019-10-23T06:30:40Z",
      "closedAt": "2019-04-25T19:25:13Z",
      "mergedAt": "2019-04-25T19:25:13Z",
      "mergedBy": "MikeBishop",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "bfa940baef0235e3729f7828dc83f59e72c55610",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "sc/id-matching",
      "headRefOid": "779963bbf3529a8eb7e692a92b896cdc7b325a3a",
      "mergeCommit": {
        "oid": "7a6d269ae886f42f82038d6357102340a715694f"
      }
    },
    {
      "number": 708,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI1MTkzNjgz",
      "title": "Persistence of service text",
      "url": "https://github.com/httpwg/http-extensions/pull/708",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "Fixes #660, but I'd prefer a better recommendation here than \"educate your customers.\"",
      "createdAt": "2018-10-23T21:29:51Z",
      "updatedAt": "2019-10-23T06:30:40Z",
      "closedAt": "2019-04-25T19:26:23Z",
      "mergedAt": "2019-04-25T19:26:23Z",
      "mergedBy": "MikeBishop",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "bfa940baef0235e3729f7828dc83f59e72c55610",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "sc/persistence",
      "headRefOid": "e63270be6bab1bed94ea15c40dd0e6be6f64077b",
      "mergeCommit": {
        "oid": "de6e1a050b619111fbf663b6ee703755dc61067c"
      }
    },
    {
      "number": 709,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI1MTk4NDU5",
      "title": "Required Primary Domain",
      "url": "https://github.com/httpwg/http-extensions/pull/709",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "Fixes #522.\r\n\r\nDefines ~~two~~ certificate extension:\r\n- ~~**Affiliated Domain** effectively operates as a tag for all certificates managed by an entity (pick a domain you control), but doesn't make the certificate authoritative for that domain.~~\r\n- **Required Primary Domain** says that you can only use *this* cert as a Secondary Certificate if you've already presented a cert that says you control the indicated domain.\r\n\r\nIn the simple case, you'd set this to a domain you include on all your certificates, \"coalesce.example.com\", and any of your certificates can be coalesced with any of your other certificates.  A CDN which requests certs on behalf of its customers can do the same thing, adding an extra domain owned by the CDN to each certificate.\r\n\r\nIn the more complex case, customers create certificates with RPD=\"coalesce.cdn.com\".  Now any customer's certificate can be coalesced onto any connection to the CDN *provided that* the CDN first presents a certificate for \"coalesce.cdn.com\" where RPD is either the primary certificate or \"*\".\r\n\r\n(One comment which has been raised in offline discussion:  Some origins might not want the CDN name human-readable in the certificate.  CDNs could address this by using a less-branded domain, but we could also address this in the extension design by using hashes of domain names if desired.)",
      "createdAt": "2018-10-23T21:48:18Z",
      "updatedAt": "2019-10-23T06:30:36Z",
      "closedAt": "2019-04-25T19:24:06Z",
      "mergedAt": "2019-04-25T19:24:05Z",
      "mergedBy": "MikeBishop",
      "comments": [
        {
          "author": "grittygrease",
          "authorAssociation": "NONE",
          "body": "It's not clear to me that Affiliated Domain adds anything. In what situation would someone use an affiliated domain that they are not authoritative for?",
          "createdAt": "2018-11-29T03:04:13Z",
          "updatedAt": "2018-11-29T03:04:13Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You want the same tag on all of your organization's certs so they can be referenced as a set, but you may not want all of your certs to be authoritative for the same domain.  That is, do you necessarily want cloudflare.com on every cert Cloudflare ever issues?",
          "createdAt": "2018-11-29T04:23:09Z",
          "updatedAt": "2018-11-29T04:23:09Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "NONE",
          "body": "I don't think that's an issue. We currently have <certid>.cloudflaressl.com as the CN on all Cloudflare-issued certs. It wouldn't be a stretch to put coalesce.cloudflare.com or something similar on all certificates.",
          "createdAt": "2018-11-29T18:07:25Z",
          "updatedAt": "2018-11-29T18:07:25Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "**UPDATES:**\r\n- Required Domain is no longer a list, per @grittygrease's suggestion\r\n- It borrows the SAN syntax wholesale (`GeneralName`), per @martinthomson's suggestion\r\n- Per @martinthomson's observation that matching two sets is annoying, it can no longer be a partial wildcard.  It's either a total wildcard (\"Use with anything\") or a specific name.  That specific name could be matched by a wildcard in the primary certificate, of course.\r\n- Requires CAs to verify the presence of a CAA record before issuing, so the issue of a misissued certificate is somewhat better constrained.",
          "createdAt": "2019-04-23T18:22:59Z",
          "updatedAt": "2019-04-23T18:22:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3NjkwNDcw",
          "commit": {
            "abbreviatedOid": "cd0478b"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I don't think that the hashing idea works here.  Hashing only works if the set of inputs is potentially large, but the number of potential fronts is fairly small, cryptographically speaking. \r\n\r\nAnything needed to verify that a given CDN is a front for a given customer has to be available either in primary certificates from the CDN, or from the certificate that the CDN customer presents.  Because the set of the former is small, testing all combinations for a given customer is small.  If you set APD to H(cdn.domain), then I can take a list of CDN domain names and test each in turn.\r\n\r\nLots of other comments here unfortunately.",
          "createdAt": "2018-10-24T00:28:39Z",
          "updatedAt": "2018-10-24T00:58:16Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Don't leave this bit empty.  A brief summary of the options might help.",
              "createdAt": "2018-10-24T00:28:39Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            },
            {
              "originalPosition": 20,
              "body": "Does this crib from text elsewhere?  Can that text be included by reference instead?  The reason I ask is that this entire section seems to be copied from something, and I don't know if it is the same as that other thing, or subtly different.",
              "createdAt": "2018-10-24T00:30:02Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            },
            {
              "originalPosition": 26,
              "body": "I know that the effect of tolerance here is disabling the feature, but do we really need to mandate this particular form of tolerance?  Wouldn't it be better to consider the certificate invalid?  That is, if the extension is present and understood, it is an error for it to violate the rules.  That way we avoid weirdnesses accumulating.",
              "createdAt": "2018-10-24T00:31:47Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            },
            {
              "originalPosition": 9,
              "body": "This doesn't say *how* the use is limited.\r\n\r\nI assume that this means that the certificate won't be accepted as a secondary certificate unless the certificate offered in the TLS handshake contains one of the identified names  in subjectAltName?\r\n\r\nThe name of the extension implies that there is only one, but this appears to allow many-to-many matching, which might be a bit gross to implement.",
              "createdAt": "2018-10-24T00:37:16Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            },
            {
              "originalPosition": 31,
              "body": "If the primary connection is to foo.example.com and the primary certificate contains *.example.com, does this extension match if it includes bar.example.com?  I can't tell.\r\n\r\nI think that this only addresses the scenario where the primary connection is to foo.example.com and the primary certificate contains foo.example.com, allowing this extension to match if it includes *.example.com.\r\n",
              "createdAt": "2018-10-24T00:37:52Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            },
            {
              "originalPosition": 35,
              "body": "Why not structure this like subjectAltName and allow alternative identifier types as well?  Too much feature?  The advantage would be that you could cite the subjectAltName definition whole cloth and concentrate on matching rules.",
              "createdAt": "2018-10-24T00:39:01Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            },
            {
              "originalPosition": 43,
              "body": "Here I think that the list of names is a genuine problem.  For this, I would recommend instead that this include a single name.  Keep the requirement that it be a domain name under the control of the entity that is serving these connections, but don't constrain it.  Basically, say that it must be validated as though it were subjectAltName (see below for more on this point.)\r\n\r\nThe problem with multiple values is that you can have a primary with A and B, a secondary with B and C, and a third secondary with C and D and that might be allowed, even though the third secondary shares no common points with the primary.\r\n\r\nSimilarly, you might have a secondary with A and D, which means that you can have secondaries with no common affiliated domains.\r\n\r\nThe reason you validate this is so that an attacker who compromises a key for foo.example.com and can cause a connection to be established to example.attacker can't get the two together because example.attacker because both certificates no longer match up.",
              "createdAt": "2018-10-24T00:44:33Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            },
            {
              "originalPosition": 61,
              "body": "If they are validated, then I believe that name constraints are necessary, not optional.",
              "createdAt": "2018-10-24T00:44:52Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            },
            {
              "originalPosition": 90,
              "body": "This isn't very clear to me.  The point here is that you can allow either mechanism.",
              "createdAt": "2018-10-24T00:51:21Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5NDA2NzY5",
          "commit": {
            "abbreviatedOid": "cd0478b"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-29T16:49:33Z",
          "updatedAt": "2018-10-29T16:49:33Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Cribs a lot from the definition of SAN, but cuts out the allowance for different name types since this is specifically a domain name.",
              "createdAt": "2018-10-29T16:49:33Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5NDA3NTQy",
          "commit": {
            "abbreviatedOid": "cd0478b"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-29T16:51:02Z",
          "updatedAt": "2018-10-29T16:51:03Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Yes, that restriction is down in the Security Considerations.  I can add a ref, unless you think it belongs here (or elsewhere).",
              "createdAt": "2018-10-29T16:51:03Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5NDA5NzYy",
          "commit": {
            "abbreviatedOid": "cd0478b"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-29T16:55:31Z",
          "updatedAt": "2018-10-29T16:55:32Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Yeah, mostly too much feature.  The security properties are probably similar -- if you can hijack a domain to fool DV, you can hijack any e-mail address on the domain to fool an e-mail validation, etc.  We expect domains to be the common case and they're sufficient, so let's not multiply entities without need.",
              "createdAt": "2018-10-29T16:55:31Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5NDEyNjA3",
          "commit": {
            "abbreviatedOid": "cd0478b"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-29T17:00:48Z",
          "updatedAt": "2018-10-29T17:00:48Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Yes, but I think the chaining is necessary (and that's why the affiliated and the allowed are separate), or at least strongly desirable.  Consider:\r\n\r\n- Primary:  (Affiliated:  M)\r\n- First Secondary:  (Affiliated:  A, Allowed:  *)\r\n- Second Secondary:  (Allowed:  A, Affiliated:  Z)\r\n- Third Secondary:  (Allowed:  A, Affiliated: Y)\r\n\r\nIt's fine to have secondaries without overlapping affiliations, provided that there's a clear chain in the allowed path.",
              "createdAt": "2018-10-29T17:00:48Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5NDEzMjgx",
          "commit": {
            "abbreviatedOid": "cd0478b"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-29T17:02:09Z",
          "updatedAt": "2018-10-29T17:02:09Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Imported text from SAN, but I read this as saying that name constraints are permissible behavior (and the converse is that they MUST be supported).  I'll reword to clarify, unless you're arguing for name constraints being required to be present.",
              "createdAt": "2018-10-29T17:02:09Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5NTYzNjMz",
          "commit": {
            "abbreviatedOid": "cd0478b"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-29T23:42:20Z",
          "updatedAt": "2018-10-29T23:42:20Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "OK, so I *really* don't want chain building here.  But I can see how you get there and it sucks.  Need to think more about this.",
              "createdAt": "2018-10-29T23:42:20Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5NTY0Mzk2",
          "commit": {
            "abbreviatedOid": "cd0478b"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-29T23:45:55Z",
          "updatedAt": "2018-10-29T23:45:55Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "If the CA is responsible for validating a name, then it can't validate a name outside of its name constraints.  For instance, if an enterprise were delegated *.enterprise.example, then it wouldn't be permitted to say that foo.example.com was OK.",
              "createdAt": "2018-10-29T23:45:55Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5NTY0NzQz",
          "commit": {
            "abbreviatedOid": "cd0478b"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-29T23:47:34Z",
          "updatedAt": "2018-10-29T23:47:34Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I think that you could just copy the SAN grammar and say that the rules are inherited.  I know that means that you get other name types, but I don't think that's fatal (we still accept IP SANs, and probably wouldn't have a problem if they were included in this).",
              "createdAt": "2018-10-29T23:47:34Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MjA2MjE0",
          "commit": {
            "abbreviatedOid": "4a29400"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Took Nick's suggestion to remove the Affiliated Domain extension.  CDNs can designate a sacrificial domain to indicate affiliation, if needed.",
          "createdAt": "2019-03-25T09:02:33Z",
          "updatedAt": "2019-03-25T09:06:40Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "I think it should, yes.",
              "createdAt": "2019-03-25T09:02:33Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            },
            {
              "originalPosition": 26,
              "body": "I'm okay with tightening here, but this seems at odds with importing the full set of SAN rules by reference.  I'd rather just state the rules for this extension than be \"like SAN, except....\"",
              "createdAt": "2019-03-25T09:04:57Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            },
            {
              "originalPosition": 20,
              "body": "I'm okay either way, but I think I'd like broader WG opinion on whether we want the extra feature of non-domain requirements.",
              "createdAt": "2019-03-25T09:05:57Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5ODQyNTI1",
          "commit": {
            "abbreviatedOid": "294eb7b"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I think that this is a much better design than what we've had before.",
          "createdAt": "2019-04-23T23:28:19Z",
          "updatedAt": "2019-04-23T23:35:55Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "The design in signed exchanges also requires a CAA parameter for the issuance to be allowed.  Because we are interested in limiting the scope of misissuance, perhaps it would be good to define a new CAA parameter and require that the name match the value of the parameter.  That doesn't have to happen here, but we should discuss whether that helps any.",
              "createdAt": "2019-04-23T23:28:19Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            },
            {
              "originalPosition": 26,
              "body": "We discussed having stricter validation for certificates that use \"\\*\".  It's not appropriate to mandate that, but this could mention that there are far greater risks to issuing certificates with a required domain of \"\\*\".",
              "createdAt": "2019-04-23T23:30:23Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            },
            {
              "originalPosition": 44,
              "body": "I think that you want to explicitly address the question ekr raised at the meeting (which might not have been minuted).\r\n\r\nHe asks whether you can produce an EA that has a certificate without a required domain and then use that as the target of required domain in other certificates.  I don't think that this is a good idea because it allows an attacker to muddy the audit trail if they are able to acquire a certificate they control. But we should be very clear either way and this isn't quite clear enough.\r\n\r\n\"Any certificate presented in an exported authenticator MUST be rejected if it does not include a RequiredDomain extension.\" might be enough.",
              "createdAt": "2019-04-23T23:35:29Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjc3MTM5",
          "commit": {
            "abbreviatedOid": "294eb7b"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T18:15:42Z",
          "updatedAt": "2019-04-24T18:15:42Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Except that's not quite correct, because we're not requiring this in the client->server direction.  I thought ekr's concern was already covered by this requirement:\r\n\r\n> Clients MUST require that server certificates presented via this\r\nmechanism contain the Required Domain extension and require that a certificate\r\npreviously accepted on the connection (including the certificate presented in\r\nTLS) lists the Required Domain in the Subject field or the Subject Alternative\r\nName extension.\r\n\r\nThat is, a certificate with no Required Domain will never be an acceptable secondary to clients and therefore can't have been previously accepted (except in the TLS handshake), but can still be acceptable to servers for client verification.",
              "createdAt": "2019-04-24T18:15:42Z",
              "updatedAt": "2019-04-24T18:26:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjgyNzEw",
          "commit": {
            "abbreviatedOid": "b39856d"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T18:26:58Z",
          "updatedAt": "2019-04-24T18:26:58Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I added a reference to this requirement in the section about validating the contents of an EA.  Hopefully that addresses the concern.",
              "createdAt": "2019-04-24T18:26:58Z",
              "updatedAt": "2019-04-24T18:26:58Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "84212181e9db24918b7ab065e8fe51a64d5ab5e7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "sc/affiliated_domain",
      "headRefOid": "fb27a26c8146a53dea6f65636775faf86c05c291",
      "mergeCommit": {
        "oid": "ccbe3f86e989eea960d13b0de90d2bf92816373e"
      }
    },
    {
      "number": 710,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI3MDI5Mzk4",
      "title": "Minor nit & TLS RFC",
      "url": "https://github.com/httpwg/http-extensions/pull/710",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "* s/in/it\r\n* Replace links to TLS I-D with RFC 8446",
      "createdAt": "2018-10-30T18:14:23Z",
      "updatedAt": "2018-10-30T18:42:59Z",
      "closedAt": "2018-10-30T18:42:59Z",
      "mergedAt": "2018-10-30T18:42:59Z",
      "mergedBy": "MikeBishop",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY5OTM5MTQy",
          "commit": {
            "abbreviatedOid": "6278c54"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-30T18:42:31Z",
          "updatedAt": "2018-10-30T18:42:31Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "50c233544c746ed826b9b2b778ace17e0b65f66b",
      "headRepository": "LPardue/http-extensions",
      "headRefName": "patch-4",
      "headRefOid": "6278c5433acbfd920cf13a95bfa3273ae2d40aac",
      "mergeCommit": {
        "oid": "a4e062b5f5ea5c6042a55334a47a402092ea77d8"
      }
    },
    {
      "number": 711,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI3MjY1ODI2",
      "title": "a -> an",
      "url": "https://github.com/httpwg/http-extensions/pull/711",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-31T12:25:09Z",
      "updatedAt": "2018-11-04T05:09:29Z",
      "closedAt": "2018-11-04T05:09:29Z",
      "mergedAt": "2018-11-04T05:09:29Z",
      "mergedBy": "MikeBishop",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxMzUwMDAy",
          "commit": {
            "abbreviatedOid": "56ad003"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-04T05:09:19Z",
          "updatedAt": "2018-11-04T05:09:19Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a4e062b5f5ea5c6042a55334a47a402092ea77d8",
      "headRepository": "LPardue/http-extensions",
      "headRefName": "patch-5",
      "headRefOid": "56ad0034bf6192f9d9c29ef61835d2cc766812d4",
      "mergeCommit": {
        "oid": "7dbd368d81b3f5a314fb817266fb1c8b816b2fc3"
      }
    },
    {
      "number": 713,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI3MzU1MTMw",
      "title": "TLS, it difficult",
      "url": "https://github.com/httpwg/http-extensions/pull/713",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-10-31T16:25:44Z",
      "updatedAt": "2018-11-04T05:10:17Z",
      "closedAt": "2018-11-04T05:10:17Z",
      "mergedAt": "2018-11-04T05:10:17Z",
      "mergedBy": "MikeBishop",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a4e062b5f5ea5c6042a55334a47a402092ea77d8",
      "headRepository": "LPardue/http-extensions",
      "headRefName": "patch-6",
      "headRefOid": "f6f954e75f17f4f82488f71bf3b6072927310cec",
      "mergeCommit": {
        "oid": "8fd2b99522e60d7a625031238f42eae688284625"
      }
    },
    {
      "number": 722,
      "id": "MDExOlB1bGxSZXF1ZXN0MjMxODYyNDk0",
      "title": "[SH] fix key=item serialisation",
      "url": "https://github.com/httpwg/http-extensions/pull/722",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Serialisation of dictionary and param-list currently say `identifier=key` instead of `key=item`\r\n\r\nThis fixes that.",
      "createdAt": "2018-11-19T06:03:55Z",
      "updatedAt": "2018-11-20T04:15:43Z",
      "closedAt": "2018-11-20T04:15:36Z",
      "mergedAt": "2018-11-20T04:15:36Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Blah, good catch; thanks.",
          "createdAt": "2018-11-20T04:15:43Z",
          "updatedAt": "2018-11-20T04:15:43Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6b2fdb32ce953fdc7829b90cdd3e1c1a32f6a2b4",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "structured-headers/key-item",
      "headRefOid": "01298973e03a3fa9e9e8a26039e6857fe571f01e",
      "mergeCommit": {
        "oid": "fa9668250c89e94f9871122913dfe986d0d35a8e"
      }
    },
    {
      "number": 724,
      "id": "MDExOlB1bGxSZXF1ZXN0MjMyNDk1Mzc4",
      "title": "Update example boolean header to use \"?\" leader",
      "url": "https://github.com/httpwg/http-extensions/pull/724",
      "state": "MERGED",
      "author": "asankah",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`Example-BoolHdr: !T` to ``Example-BoolHdr: ?T`",
      "createdAt": "2018-11-20T23:47:31Z",
      "updatedAt": "2018-11-21T22:28:28Z",
      "closedAt": "2018-11-21T22:28:24Z",
      "mergedAt": "2018-11-21T22:28:24Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks.",
          "createdAt": "2018-11-21T22:28:28Z",
          "updatedAt": "2018-11-21T22:28:28Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "fa9668250c89e94f9871122913dfe986d0d35a8e",
      "headRepository": "asankah/http-extensions",
      "headRefName": "patch-1",
      "headRefOid": "876a38f478b6742b3bdb88f291544680afd5f979",
      "mergeCommit": {
        "oid": "9a95d52abd16926710e115f2859a517801fe7933"
      }
    },
    {
      "number": 726,
      "id": "MDExOlB1bGxSZXF1ZXN0MjMyODQ2NTQw",
      "title": "[SH] make boolean ABNF case-sensitive",
      "url": "https://github.com/httpwg/http-extensions/pull/726",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "the `boolean` ABNF rule is case-*in*sensitive, but the algorithm for parsing (and the test case in the separate repo) enforce capitals only.",
      "createdAt": "2018-11-22T02:58:04Z",
      "updatedAt": "2018-11-22T04:09:57Z",
      "closedAt": "2018-11-22T03:35:59Z",
      "mergedAt": "2018-11-22T03:35:59Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2018-11-22T03:36:06Z",
          "updatedAt": "2018-11-22T03:36:06Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh! It should have been `%54 / %46`\r\n\r\nI'm going to stop typing anything at all today.",
          "createdAt": "2018-11-22T04:07:26Z",
          "updatedAt": "2018-11-22T04:07:26Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "No worries - fixed :)",
          "createdAt": "2018-11-22T04:09:57Z",
          "updatedAt": "2018-11-22T04:09:57Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9a95d52abd16926710e115f2859a517801fe7933",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "structures-headers/insensitive-bools",
      "headRefOid": "c2f656a4ae4ac0db14007a9781853143b13d669c",
      "mergeCommit": {
        "oid": "d3742777aedf6ded7639b694b086c0d56d76ff73"
      }
    },
    {
      "number": 729,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM0ODMzMTkx",
      "title": "CH suggestions",
      "url": "https://github.com/httpwg/http-extensions/pull/729",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [
        "igrigorik"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Suggested elaboration / re-focusing in the introduction to clarify how CH fits into things.",
      "createdAt": "2018-11-30T00:28:42Z",
      "updatedAt": "2018-12-05T05:18:04Z",
      "closedAt": "2018-12-05T04:56:42Z",
      "mergedAt": "2018-12-05T04:56:42Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "CI failed due to rfc-editor.org DNS failure; should be transient.",
          "createdAt": "2018-11-30T00:54:36Z",
          "updatedAt": "2018-11-30T00:54:36Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Feedback addressed, I think.",
          "createdAt": "2018-12-02T01:40:57Z",
          "updatedAt": "2018-12-02T01:40:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwMjAwNzAz",
          "commit": {
            "abbreviatedOid": "b68df7e"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-30T10:19:16Z",
          "updatedAt": "2018-11-30T10:19:16Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "It also defines `Accept-CH-Lifetime`",
              "createdAt": "2018-11-30T10:19:16Z",
              "updatedAt": "2018-12-04T22:23:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwMjAxNDU1",
          "commit": {
            "abbreviatedOid": "b68df7e"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-30T10:21:06Z",
          "updatedAt": "2018-11-30T10:21:06Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "s/used to \"fingerprint\"/used to passively \"fingerprint\"/?",
              "createdAt": "2018-11-30T10:21:06Z",
              "updatedAt": "2018-12-04T22:23:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwMjQyNDgw",
          "commit": {
            "abbreviatedOid": "b68df7e"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-30T12:22:37Z",
          "updatedAt": "2018-11-30T12:22:37Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Nit: should header names somehow be marked as \"code\" or italic?",
              "createdAt": "2018-11-30T12:22:37Z",
              "updatedAt": "2018-12-04T22:23:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwMjQyODU2",
          "commit": {
            "abbreviatedOid": "b68df7e"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-30T12:23:56Z",
          "updatedAt": "2018-11-30T12:23:57Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "s/evicence/evidence/",
              "createdAt": "2018-11-30T12:23:56Z",
              "updatedAt": "2018-12-04T22:23:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwMjQzMjA5",
          "commit": {
            "abbreviatedOid": "b68df7e"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for working on this! A few comments...",
          "createdAt": "2018-11-30T12:25:07Z",
          "updatedAt": "2018-11-30T12:25:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwMjYyNDAw",
          "commit": {
            "abbreviatedOid": "b68df7e"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Ditto, great suggestions Mark! Left a few comments..",
          "createdAt": "2018-11-30T13:23:55Z",
          "updatedAt": "2018-11-30T13:41:38Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "+1\r\n\r\n> ... defines a mechanism, based on `Accept-CH` and `Accept-CH-Lifetime` response headers, that servers ...",
              "createdAt": "2018-11-30T13:23:55Z",
              "updatedAt": "2018-12-04T22:23:00Z"
            },
            {
              "originalPosition": 10,
              "body": "I think our current plan is to omit it, actually.",
              "createdAt": "2018-11-30T13:24:21Z",
              "updatedAt": "2018-12-04T22:23:00Z"
            },
            {
              "originalPosition": 23,
              "body": "Perhaps...\r\n\r\n> ... This causes performance concerns due to \"bloat\" of request headers, as well as privacy concerns due to passive fingerprinting that the data carried in these request headers may enable.",
              "createdAt": "2018-11-30T13:32:09Z",
              "updatedAt": "2018-12-04T22:23:00Z"
            },
            {
              "originalPosition": 27,
              "body": "> ... and privacy concerns of passive fingerprinting by requiring explicit opt-in and disclosure of required headers by the server through the use of the Accept-CH response header.\r\n\r\nMaybe a bit more explicit and clearer?",
              "createdAt": "2018-11-30T13:40:38Z",
              "updatedAt": "2018-12-04T22:23:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwMjc1OTM2",
          "commit": {
            "abbreviatedOid": "b68df7e"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-30T13:59:28Z",
          "updatedAt": "2018-11-30T13:59:29Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "\"header\" -> \"header field\" (throughout)",
              "createdAt": "2018-11-30T13:59:28Z",
              "updatedAt": "2018-12-04T22:23:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNTQ0Mzk1",
          "commit": {
            "abbreviatedOid": "b68df7e"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-02T01:35:00Z",
          "updatedAt": "2018-12-02T01:35:01Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "No; we don't have that luxury in RFCs.",
              "createdAt": "2018-12-02T01:35:01Z",
              "updatedAt": "2018-12-04T22:23:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNTQ0NDg1",
          "commit": {
            "abbreviatedOid": "5378c17"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-02T01:40:42Z",
          "updatedAt": "2018-12-02T01:40:42Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Let's separate those out.",
              "createdAt": "2018-12-02T01:40:42Z",
              "updatedAt": "2018-12-04T22:23:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgxNTkxMDM3",
          "commit": {
            "abbreviatedOid": "eba6c61"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Looks great, thanks Mark!\r\n\r\nBased on recent direction and discussions, the sections that mention \"defines initial set of hints\" and reference to User-Agent header may need to be updated, but we'll tackle that in a separate thread.",
          "createdAt": "2018-12-05T04:55:56Z",
          "updatedAt": "2018-12-05T04:55:56Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "99b763b266a28c021dcb25e08e018fdd9416904c",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-ch-suggestions",
      "headRefOid": "eba6c61730115a55db4eea4c4f37d57e16cabeb3",
      "mergeCommit": {
        "oid": "e54fe69d7910100ee814dfb10c461d444dc2947f"
      }
    },
    {
      "number": 732,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM1ODg2NTI0",
      "title": "bcp56bis: fix broken reference",
      "url": "https://github.com/httpwg/http-extensions/pull/732",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis",
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-12-04T17:01:08Z",
      "updatedAt": "2019-10-23T06:30:39Z",
      "closedAt": "2018-12-04T22:06:51Z",
      "mergedAt": "2018-12-04T22:06:51Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "99b763b266a28c021dcb25e08e018fdd9416904c",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-1",
      "headRefOid": "0903ef3fe07e1fee96aa6fdce45eb50509af4e35",
      "mergeCommit": {
        "oid": "312769070dc238501e448b0350a0d2ba12de05b2"
      }
    },
    {
      "number": 733,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM1ODkwMTM1",
      "title": "bcp56bis: redirects",
      "url": "https://github.com/httpwg/http-extensions/pull/733",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis",
        "editorial"
      ],
      "body": "- fix one reference\r\n- drop 308 reference, it's now in the base spec",
      "createdAt": "2018-12-04T17:11:43Z",
      "updatedAt": "2019-01-23T02:04:42Z",
      "closedAt": "2019-01-23T02:04:38Z",
      "mergedAt": "2019-01-23T02:04:38Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "99b763b266a28c021dcb25e08e018fdd9416904c",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-2",
      "headRefOid": "40f3041a1369ff143b4d521638524fa9d2322d60",
      "mergeCommit": {
        "oid": "2d40fef5be6158fa60dfb775beeb0d41ec30ddd0"
      }
    },
    {
      "number": 735,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM3MDE5MTQ5",
      "title": "Handle absent request headers.",
      "url": "https://github.com/httpwg/http-extensions/pull/735",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "This change passes 'null' to the content-negotiation algorithm if the\r\nrequest header is absent. For list headers, the algorithms can always\r\nturn that into the empty list, but for non-list headers they need to\r\ncome up with something appropriate to do.\r\n\r\nFixes #731. This also tries to do better about #734, but may not completely fix it.",
      "createdAt": "2018-12-07T23:13:28Z",
      "updatedAt": "2019-01-04T17:33:21Z",
      "closedAt": "2019-01-04T04:57:31Z",
      "mergedAt": "2019-01-04T04:57:31Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks.",
          "createdAt": "2019-01-04T04:57:38Z",
          "updatedAt": "2019-01-04T04:57:38Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e54fe69d7910100ee814dfb10c461d444dc2947f",
      "headRepository": "jyasskin/http-extensions",
      "headRefName": "variants-missing-request-header",
      "headRefOid": "bb926d01b68031b9e9bc1bbe597ca4870cfbf2f7",
      "mergeCommit": {
        "oid": "499d6cae9c4e0dbc471e7ec85551dc3e0b044a43"
      }
    },
    {
      "number": 738,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM4NTM1NDU1",
      "title": "Monospace variable names in draft-variants.",
      "url": "https://github.com/httpwg/http-extensions/pull/738",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This made it easier for me to read some of the algorithms, but feel free to reject it if it doesn't help you.",
      "createdAt": "2018-12-13T21:18:51Z",
      "updatedAt": "2020-10-12T23:21:39Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6a1bc679b2f57b1d9a62956c6a5d9e2c0faee611",
      "headRepository": "jyasskin/http-extensions",
      "headRefName": "typography",
      "headRefOid": "8908c24fc84ceb25093a4e4712da0eb10086ad82",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We've tried this syntax in the past, but the \"`\" marks get into the .txt, and then we have to work with the RFC Editor to remove them before publication. ",
          "createdAt": "2018-12-13T23:53:04Z",
          "updatedAt": "2018-12-13T23:53:04Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see `\"` quotes in the .txt, but I would believe the formal RFC process does something different. That said, \"`\" backticks are arguably a better text syntax than quotes for variable names, and would, IMO help readability in the text format too.\r\n\r\nBut I won't be mad if you don't want this change. :)",
          "createdAt": "2018-12-14T00:04:45Z",
          "updatedAt": "2018-12-14T00:04:45Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Personally I was OK with it, but we got a lot of negative feedback.",
          "createdAt": "2018-12-14T00:44:43Z",
          "updatedAt": "2018-12-14T00:44:43Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As @jyasskin says, backticks turn into double quotes with no issue.  Some other specs in this repo used that with reasonable outcomes.  You just have to be sure that you wanted those quotes.",
          "createdAt": "2018-12-14T05:28:12Z",
          "updatedAt": "2018-12-14T05:29:51Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes. I'm saying that my experience is that the RFC Editor and others don't like to see variable names surrounded by \"`\". ",
          "createdAt": "2018-12-14T05:47:50Z",
          "updatedAt": "2018-12-14T05:47:50Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "but they won't see the backticks.  Are we speaking past each other?",
          "createdAt": "2018-12-14T05:49:40Z",
          "updatedAt": "2018-12-14T05:49:40Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Ah - so are you saying that something in between .md and .txt (kramdown-rfc2629 or xml2rfc) now produces a double quote instead of a backtick? When / where did that happen?",
          "createdAt": "2018-12-14T05:51:45Z",
          "updatedAt": "2018-12-14T05:51:45Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "In my experience it's always done that, at least when I build my .txt files locally. (Where \"always\" means \"for at least a couple of years\".)\r\n\r\nFor example, search these documents for \"n00\" -- in the HTML it renders as `<span class=\"tt\">n00</span>` and in the text it is `\"n00\"`:\r\n\r\n* https://httpwg.org/http-extensions/bcp56bis.html\r\n* https://httpwg.org/http-extensions/bcp56bis.txt",
          "createdAt": "2018-12-14T05:57:26Z",
          "updatedAt": "2018-12-14T06:06:16Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "body": "kramdown-rfc2629 turns backticks into `<spanx style=\"verb\">`, and xml2rfc converts that to quotes at https://trac.tools.ietf.org/tools/xml2rfc/trac/browser/trunk/cli/xml2rfc/writers/raw_txt.py?rev=2843#L486.\r\n\r\nThere is some risk to using typography in RFCs: https://mozphab-ietf.devsvcdev.mozaws.net/D4234#inline-7837 shows CDDL describing typewriter text, while the reviewer saw quotes.",
          "createdAt": "2018-12-14T22:36:23Z",
          "updatedAt": "2018-12-14T22:36:23Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK. I may have been confusing \"`\" with something else.\r\n\r\nThe only issue I see here is that lines like this:\r\n\r\n> 3. If \"identity\" is not a member of `preferred-codings`, append \"identity\".\r\n\r\nwill become in `.txt`:\r\n\r\n> 3. If \"identity\" is not a member of \"preferred-codings\", append \"identity\".\r\n\r\n... so there won't be any discriminator between a variable reference and a literal. That doesn't seem good.\r\n\r\nRight now we depend on the uniqueness of the term to identify variables, reserving double-quotes for literals. I agree that the HTML rendering is MUCH better, but sadly that still isn't the authoritative version. \r\n\r\n",
          "createdAt": "2018-12-17T00:11:05Z",
          "updatedAt": "2018-12-17T00:11:05Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The discussion is useful, but I wouldn't go there for specs that are planned to be published anytime soon.",
          "createdAt": "2018-12-17T04:31:03Z",
          "updatedAt": "2018-12-17T04:31:03Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can we align on this for new spec? I think it improves readability...",
          "createdAt": "2020-10-12T23:21:39Z",
          "updatedAt": "2020-10-12T23:21:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 741,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM4ODI3NDgx",
      "title": "Requests that match a non-cached variant should go to the origin.",
      "url": "https://github.com/httpwg/http-extensions/pull/741",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "I've also added examples of the new behavior.\r\n\r\nThis is an attempt to fix #740.",
      "createdAt": "2018-12-14T20:02:54Z",
      "updatedAt": "2019-01-07T03:38:50Z",
      "closedAt": "2019-01-07T02:54:04Z",
      "mergedAt": "2019-01-07T02:54:04Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MjUzNjYy",
          "commit": {
            "abbreviatedOid": "930b530"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "A few notes, but more discussion to come in #740.",
          "createdAt": "2019-01-04T03:08:47Z",
          "updatedAt": "2019-01-04T04:41:24Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Is it necessary to show this as well as the previous one, since they're so similar?",
              "createdAt": "2019-01-04T03:08:47Z",
              "updatedAt": "2019-01-04T19:41:18Z"
            },
            {
              "originalPosition": 41,
              "body": "Who is *it* here? I think you want to say something like \"... since `Variants` indicates that `de` is available, and that is acceptable to the client.\"",
              "createdAt": "2019-01-04T03:09:21Z",
              "updatedAt": "2019-01-04T19:41:18Z"
            },
            {
              "originalPosition": 96,
              "body": "Encoding is not different; the server can ignore the client's preferences here too.",
              "createdAt": "2019-01-04T04:40:17Z",
              "updatedAt": "2019-01-04T19:41:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MjYzNzkz",
          "commit": {
            "abbreviatedOid": "930b530"
          },
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-04T05:08:13Z",
          "updatedAt": "2019-01-04T05:08:13Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "\"it\" was the origin server, but I'll update to your wording tomorrow morning.",
              "createdAt": "2019-01-04T05:08:13Z",
              "updatedAt": "2019-01-04T19:41:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MjYzODM0",
          "commit": {
            "abbreviatedOid": "930b530"
          },
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-04T05:08:42Z",
          "updatedAt": "2019-01-04T05:08:42Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "That is, I should undo this change? That's fine with me.",
              "createdAt": "2019-01-04T05:08:42Z",
              "updatedAt": "2019-01-04T19:41:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MjY4NjU0",
          "commit": {
            "abbreviatedOid": "930b530"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-04T06:03:29Z",
          "updatedAt": "2019-01-04T06:03:29Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Yes.",
              "createdAt": "2019-01-04T06:03:29Z",
              "updatedAt": "2019-01-04T19:41:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NTAwMjA1",
          "commit": {
            "abbreviatedOid": "dee3ec0"
          },
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I've also changed the MAYs under {backports} to MUSTs.",
          "createdAt": "2019-01-04T19:35:28Z",
          "updatedAt": "2019-01-04T19:42:06Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Nope, I can remove this code block.",
              "createdAt": "2019-01-04T19:35:28Z",
              "updatedAt": "2019-01-04T19:42:06Z"
            },
            {
              "originalPosition": 41,
              "body": "Done.",
              "createdAt": "2019-01-04T19:36:20Z",
              "updatedAt": "2019-01-04T19:42:06Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "499d6cae9c4e0dbc471e7ec85551dc3e0b044a43",
      "headRepository": "jyasskin/http-extensions",
      "headRefName": "fix-incomplete-cache",
      "headRefOid": "2968944d8c55760b85596bd1f2e6cce2ddf1bb01",
      "mergeCommit": {
        "oid": "478b8a504ac5614d2684af504a8887578aa440e8"
      }
    },
    {
      "number": 744,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM5NjI4Nzk4",
      "title": "Convert Variants to use Structured Headers.",
      "url": "https://github.com/httpwg/http-extensions/pull/744",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "Fixes #570. I think this also fixes #743, but I might have missed something.\r\n\r\nMisc changes that aren't actually necessary to use Structured Headers:\r\n\r\n* \"variant-item\" became \"variant-axis\".\r\n* I defined what clients (\"caches\"?) MUST do when a server violates one of its MUSTs.\r\n* I removed the (incorrect) `token / \"/\" / \"?\" / \"\\\" / \"[\" / \"]\" / \":\" / \"@\" / \"(\" / \")\"` definition of available-value in favor of allowing arbitrary [Structured Header strings](https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#string). It wasn't clear what excluding characters like `{` was gaining us, and the restriction would have required extra words when parsing the headers.\r\n* I removed {{gen-variant-key}} entirely and had Compute Possible Keys return a list of lists that could be directly compared against the Structured Header parse of `Variant-Key`. It would be difficult to keep the old behavior of returning a list of strings without re-adding some restriction on an available-value, for example by requiring that they don't contain spaces.\r\n* I simplified Compute Possible Keys a bit.",
      "createdAt": "2018-12-18T20:56:45Z",
      "updatedAt": "2019-01-07T03:38:10Z",
      "closedAt": "2019-01-07T02:52:41Z",
      "mergedAt": "2019-01-07T02:52:41Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg4ODc4MTU2",
          "commit": {
            "abbreviatedOid": "59e6719"
          },
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-03T00:45:57Z",
          "updatedAt": "2019-01-03T00:45:58Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Should a malformed `Variants` header be treated as absent, or should it disable caching for that resource?",
              "createdAt": "2019-01-03T00:45:58Z",
              "updatedAt": "2019-01-04T17:49:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MjUwNzE4",
          "commit": {
            "abbreviatedOid": "59e6719"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "This looks good; just one immediate issue I can see (although I might tweak some once it's in).\r\n\r\nThanks!",
          "createdAt": "2019-01-04T02:39:26Z",
          "updatedAt": "2019-01-04T02:58:55Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Treated as absent, I think; Vary should still ensure correct (if suboptimal) behaviour.",
              "createdAt": "2019-01-04T02:39:27Z",
              "updatedAt": "2019-01-04T17:49:32Z"
            },
            {
              "originalPosition": 79,
              "body": "This requirement addresses an implementation constraint; if they can't easily link a response to multiple potential requests, this allows them to still behave correctly (if not optimally). Why did you remove it?",
              "createdAt": "2019-01-04T02:50:48Z",
              "updatedAt": "2019-01-04T17:49:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MjY1MzA1",
          "commit": {
            "abbreviatedOid": "59e6719"
          },
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-04T05:25:36Z",
          "updatedAt": "2019-01-04T05:26:36Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "I don't remember exactly what I was thinking, but it seems redundant right now. All of the variant-key values are variant-keys for the response they occur within, so of course the first one is also a variant-key for that response. Do you mean that the first variant-key list item should be the \"best\"? And that caches MAY discard subsequent ones?",
              "createdAt": "2019-01-04T05:25:37Z",
              "updatedAt": "2019-01-04T17:49:32Z"
            },
            {
              "originalPosition": 27,
              "body": "Ok, I think that's the behavior I have spec'ed now.",
              "createdAt": "2019-01-04T05:26:24Z",
              "updatedAt": "2019-01-04T17:49:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MjY4NTIx",
          "commit": {
            "abbreviatedOid": "59e6719"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-04T06:02:05Z",
          "updatedAt": "2019-01-04T06:02:05Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "The wording above doesn't reflect the intent well. It should be:\r\n\r\n> When more than one Variant-Key value is in a response, the first one present MUST correspond to the request that caused that response to be generated.",
              "createdAt": "2019-01-04T06:02:05Z",
              "updatedAt": "2019-01-04T17:49:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NDY0NTI5",
          "commit": {
            "abbreviatedOid": "40809a4"
          },
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-04T17:53:23Z",
          "updatedAt": "2019-01-04T17:53:23Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "Ah, that makes sense. I've added your wording back.\r\n\r\nI think it could be wordsmithed a little better now that Variant-Key is a structured header, but I don't want to delay merging the overall change. Specifically, \"more than one Variant-Key value\" implies to me that the Variant-Key header appears more than once, but we actually mean that the list parsed for Variant-Key from a response contains more than one inner-list, even if they're all parsed from a single instance of the header.",
              "createdAt": "2019-01-04T17:53:23Z",
              "updatedAt": "2019-01-04T17:53:23Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "499d6cae9c4e0dbc471e7ec85551dc3e0b044a43",
      "headRepository": "jyasskin/http-extensions",
      "headRefName": "structured-variants",
      "headRefOid": "40809a40d7b90fe07a718af8cdbf2faa25b483b6",
      "mergeCommit": {
        "oid": "dd19a764fe213f22e2dc1f4695a44944125bfe25"
      }
    },
    {
      "number": 746,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyMzMwOTI2",
      "title": "Fix a typo: \"request)\"",
      "url": "https://github.com/httpwg/http-extensions/pull/746",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-04T17:56:06Z",
      "updatedAt": "2019-01-07T00:49:50Z",
      "closedAt": "2019-01-07T00:49:44Z",
      "mergedAt": "2019-01-07T00:49:44Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks.",
          "createdAt": "2019-01-07T00:49:50Z",
          "updatedAt": "2019-01-07T00:49:50Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "499d6cae9c4e0dbc471e7ec85551dc3e0b044a43",
      "headRepository": "jyasskin/http-extensions",
      "headRefName": "fix-typo",
      "headRefOid": "cde2bb2ec8064b4eae0bad68ba5e8d67229d19bb",
      "mergeCommit": {
        "oid": "7cc578879f0f5b255e59b882753118785e943c47"
      }
    },
    {
      "number": 749,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQzNTI4Njc5",
      "title": "Define support requirements for integers",
      "url": "https://github.com/httpwg/http-extensions/pull/749",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #737",
      "createdAt": "2019-01-10T00:26:23Z",
      "updatedAt": "2019-10-28T09:57:57Z",
      "closedAt": "2019-04-17T06:59:50Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "All this suddenly makes me think that we have another integer representation used in H1, which is the chunk size expressed as an hexadecimal value, which can also trigger an overflow during parsing and which can be represented inaccurately on some implementations for the same reasons. Thus probably the block above should mention that it is valid for decimal numbers only ? Or we must take care of the base in use ?",
          "createdAt": "2019-01-10T03:42:07Z",
          "updatedAt": "2019-01-10T03:42:07Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "> All this suddenly makes me think that we have another integer representation used in H1, which is the chunk size expressed as an hexadecimal value, which can also trigger an overflow during parsing and which can be represented inaccurately on some implementations for the same reasons. Thus probably the block above should mention that it is valid for decimal numbers only ? Or we must take care of the base in use ?\r\n\r\nDo you mean adding a note to the \"Parsers MUST accurately support integers in the range...\" chunk?  Because the ABNF `sh-integer = [\"-\"] 1*19DIGIT` already implies as much.",
          "createdAt": "2019-01-11T00:26:19Z",
          "updatedAt": "2019-01-11T00:26:19Z"
        },
        {
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "body": "> Do you mean adding a note to the \"Parsers MUST accurately support integers in the range...\" chunk?\r\n> Because the ABNF sh-integer = [\"-\"] 1*19DIGIT already implies as much.\r\n\r\nYes, so that implementers are warned about this problem they don't necessarily think about while implementing. Quite frankly, who really verifies each character in a number before passing it to strtol() ? Not that many...\r\n\r\nHowever, my point about chunk sizes is irrelevant to structured headers since it's not in headers that we find it.\r\n",
          "createdAt": "2019-01-11T03:33:40Z",
          "updatedAt": "2019-01-11T03:33:40Z"
        },
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Having turned this one around in my head for days, I am on board for a clear <\u00b12^53-1 limit.\r\n\r\nI cannot come up with any plausible need for more than 8 peta-anything in HTTP headers which are not better served by other means.\r\n\r\nHowever, this removes the need to have the Integer type in the first place, we added that because of the 15 digit limitation of what is now called \"sh-float.\"\r\n\r\nA much simpler edit is:\r\n\r\n1. Remove sh-integer\r\n\r\n2. Rename sh-float to sh-number\r\n\r\n3. add \"15DIGIT\" to sh-numbers ABNF\r\n\r\nThis way we do not need to spend any text on the limit or its enforcement, because it is implicit in the 15 digit upper limit.\r\n\r\n(and for that reason I'm thumbs down on this PR)",
          "createdAt": "2019-01-13T20:40:01Z",
          "updatedAt": "2019-01-13T20:44:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDA2NzY4",
          "commit": {
            "abbreviatedOid": "fae251f"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T00:33:36Z",
          "updatedAt": "2019-01-10T00:35:20Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I think that this is clearer:\r\n\r\n```suggestion\r\nParsers MUST fail parsing if values are not within the range supported by the parser.\r\n```\r\n\r\nI think that's simpler.\r\n\r\nThat is, say that parsers need to support up to 2^53-1.  Allow more.  Require parsing failure for numbers outside that range (whatever it is).",
              "createdAt": "2019-01-10T00:33:36Z",
              "updatedAt": "2019-01-10T01:46:29Z"
            },
            {
              "originalPosition": 16,
              "body": "The two lines could be one, as follows:\r\n```suggestion\r\n   2. If output_number is outside the range for integers supported by the parser (see {{integer}}), fail parsing.\r\n```",
              "createdAt": "2019-01-10T00:34:08Z",
              "updatedAt": "2019-01-10T01:46:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDE5MzAy",
          "commit": {
            "abbreviatedOid": "fae251f"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T01:34:49Z",
          "updatedAt": "2019-01-10T01:34:50Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I'd rather be explicit.",
              "createdAt": "2019-01-10T01:34:50Z",
              "updatedAt": "2019-01-10T01:46:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDE5NjQz",
          "commit": {
            "abbreviatedOid": "fae251f"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T01:36:38Z",
          "updatedAt": "2019-01-10T01:36:39Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Took a slightly different approach.",
              "createdAt": "2019-01-10T01:36:39Z",
              "updatedAt": "2019-01-10T01:46:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDIwNzgz",
          "commit": {
            "abbreviatedOid": "a4d06e4"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T01:43:10Z",
          "updatedAt": "2019-01-10T01:43:10Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "In which case, your two points need to be switched.  As written, this would prohibit supporting a larger range.",
              "createdAt": "2019-01-10T01:43:10Z",
              "updatedAt": "2019-01-10T01:46:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDIxMzYy",
          "commit": {
            "abbreviatedOid": "a4d06e4"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T01:46:14Z",
          "updatedAt": "2019-01-10T01:46:15Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I don't think it prohibits supporting a larger range directly, but it does beg the question of how you can check that the number falls within the greater range if you can't accurately represent it. Will fix.",
              "createdAt": "2019-01-10T01:46:15Z",
              "updatedAt": "2019-01-10T01:46:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDIxMDcw",
          "commit": {
            "abbreviatedOid": "fae251f"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T01:44:41Z",
          "updatedAt": "2019-01-10T01:51:49Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Belay that.  The comment stands.  There is no way to have a fail parsing on this condition.",
              "createdAt": "2019-01-10T01:44:42Z",
              "updatedAt": "2019-01-10T01:51:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDIyNTgy",
          "commit": {
            "abbreviatedOid": "1d106b7"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T01:53:15Z",
          "updatedAt": "2019-01-10T01:53:18Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "As noted, this needs another condition ...and the implementation does not support integers outside this range.",
              "createdAt": "2019-01-10T01:53:15Z",
              "updatedAt": "2019-01-10T01:53:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDIzNzkx",
          "commit": {
            "abbreviatedOid": "1d106b7"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T02:00:00Z",
          "updatedAt": "2019-01-10T02:00:00Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Where?",
              "createdAt": "2019-01-10T02:00:00Z",
              "updatedAt": "2019-01-10T02:00:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDI4NDYw",
          "commit": {
            "abbreviatedOid": "1d106b7"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T02:29:03Z",
          "updatedAt": "2019-01-10T02:29:03Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Maybe it's better to specify this as: \"Parse input_number as an integer and if it is within the range, let output_number be the product of the result and sign; otherwise fail parsing\".\r\n\r\nThe reason I suggest this is because testing `output_number` is not always the correct thing to do (even though it would work fine for floating point numbers). Consider the case where you have something like below in C. You cannot use the `output_number` to see if the parsing succeeded, because the `abs(value)` might decrease thereby moving `output_number` into the range when overflow happens<sup>1</sup>.\r\n```\r\nint64_t output_number = 0;\r\nwhile (isdigit(*p))\r\n    output_number = output_number * 10 + *p++ - '0';\r\n```\r\n\r\n1: Technically, the output will be undefined in case of overflow, but let's assume that the the integer arithmetic rounds the output to the least significant 64 bits.",
              "createdAt": "2019-01-10T02:29:03Z",
              "updatedAt": "2019-01-10T02:59:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDM5MTc5",
          "commit": {
            "abbreviatedOid": "1d106b7"
          },
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T03:36:37Z",
          "updatedAt": "2019-01-10T03:36:37Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I totally agree with Kazuho here. It's mandatory to check for overflows during the parsing, like we do here for example : http://git.haproxy.org/?p=haproxy.git;a=blob;f=src/h1.c;hb=HEAD#l52\r\nMany integer parsers will reliably provide the information about the fact that an overflow was detected, but when it comes to floats it might not necessarily be the case (since very large numbers can still fit in a float), however the check against bounds is expected to work.\r\n\r\nThis means that we should mandate the use of a reliable parser known for detecting overflows, AND then check for the output number to fall within our bounds.\r\n\r\nWe should also warn against the risk of using generic parsers which as a byproduct of checking for errors, also happen to support base prefixes like \"0x\", or float parsers supporting exponents like \"1e32\" or special values like \"inf\", \"-inf\", \"nan\", all of which defeat length checks.\r\n",
              "createdAt": "2019-01-10T03:36:37Z",
              "updatedAt": "2019-01-10T03:36:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMTg4OTI1",
          "commit": {
            "abbreviatedOid": "1d106b7"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T12:52:01Z",
          "updatedAt": "2019-01-10T12:52:02Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This reads a little awkward to me. Perhaps something like \"Implementations must have a range for supported integers. At a minimum this range must be X to Y. Parsers must fail on parsing values outside the range for supported integers.\"",
              "createdAt": "2019-01-10T12:52:02Z",
              "updatedAt": "2019-01-10T12:52:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxNDM1NjQz",
          "commit": {
            "abbreviatedOid": "1d106b7"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T22:01:59Z",
          "updatedAt": "2019-01-10T22:01:59Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Let's say that I support -2^63 to 2^63-1, something that isn't unreasonable if you aren't javascript.  This code turns into:\r\n\r\n```js\r\nif (n < -2^63 || n > 2^63-1) { // Step 2.\r\n  return fail_parsing;\r\n}\r\nif (n < -2^53+1 || n > 2^53-1) { // Step 3.\r\n  return fail_parsing;\r\n}\r\n```\r\n\r\nPass n = 2^60 into that code and you get an error.  Hence my insistence that the first test is adequate.\r\n\r\nNow, you could read \"the range for integers\" as meaning  -2^63 to 2^63-1 in this case, but then you just repeated yourself.\r\n\r\nDoes that help clarify the concern?",
              "createdAt": "2019-01-10T22:01:59Z",
              "updatedAt": "2019-01-10T22:01:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxNDc2OTA5",
          "commit": {
            "abbreviatedOid": "1d106b7"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-11T00:30:57Z",
          "updatedAt": "2019-01-11T00:30:57Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "> We should also warn against the risk of using generic parsers which as a byproduct of checking for errors, also happen to support base prefixes like \"0x\", or float parsers supporting exponents like \"1e32\" or special values like \"inf\", \"-inf\", \"nan\", all of which defeat length checks.\r\n\r\nAt this point in the algorithm the string has been preprocessed and is guaranteed to have no more than 19 characters, all of which are decimal digits. Or do you mean explicit warning against replacing the entire integer-parsing algorithm with a generic `to_int()` or equivalent?",
              "createdAt": "2019-01-11T00:30:57Z",
              "updatedAt": "2019-01-11T00:30:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxNTA2MTQ1",
          "commit": {
            "abbreviatedOid": "1d106b7"
          },
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-11T03:23:40Z",
          "updatedAt": "2019-01-11T03:23:40Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Yes that's what I mean. We know that everyone does this. I've seen \"atol()\" being used quite a number of times in the past to parse content-length, in good faith since it was expected that the syntax check was performed at the same time as the conversion. Even strtol() with no forced base is dangerous, believed to return an error if something doesn't match, except that \"0x12\" is automatically converted.\r\n\r\nThus the warning I'm proposing is that many conversion functions provided by libraries or languages are more tolerant than the spec and allow values or ranges which can introduce vulnerabilities.",
              "createdAt": "2019-01-11T03:23:40Z",
              "updatedAt": "2019-01-11T03:23:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxNTA2NDk2",
          "commit": {
            "abbreviatedOid": "1d106b7"
          },
          "author": "wtarreau",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-11T03:26:33Z",
          "updatedAt": "2019-01-11T03:26:33Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Suggesting that any agent in the chain blocks numbers outside this range will help limit the risk of inconsistencies. If your component supports a larger range but the next one does not and fails to check for overflows, then you have the problem.",
              "createdAt": "2019-01-11T03:26:33Z",
              "updatedAt": "2019-01-11T03:26:33Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "df36f5b1dfdf2b094b907a9ec0f4497d20b5ede3",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-737",
      "headRefOid": "1d106b7c79179249595b83a0f632ed3ce3fd37b9",
      "mergeCommit": null
    },
    {
      "number": 750,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQzNTI5NzE0",
      "title": "Use versioned header names for draft implementations.",
      "url": "https://github.com/httpwg/http-extensions/pull/750",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #747.\r\n\r\n@nyaxt @hajimehoshi",
      "createdAt": "2019-01-10T00:33:08Z",
      "updatedAt": "2019-01-14T21:18:41Z",
      "closedAt": "2019-01-10T01:39:08Z",
      "mergedAt": "2019-01-10T01:39:08Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "df36f5b1dfdf2b094b907a9ec0f4497d20b5ede3",
      "headRepository": "jyasskin/http-extensions",
      "headRefName": "version-header",
      "headRefOid": "40474a0218f3f041cf7fe8296bd9a9e1e7772b30",
      "mergeCommit": {
        "oid": "8756922372386c1f88628e66145c7bd894349907"
      }
    },
    {
      "number": 754,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0Mjk4MzA2",
      "title": "Remove URL redirection",
      "url": "https://github.com/httpwg/http-extensions/pull/754",
      "state": "MERGED",
      "author": "SuriyaaKudoIsc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #753",
      "createdAt": "2019-01-13T19:05:49Z",
      "updatedAt": "2019-01-15T21:07:14Z",
      "closedAt": "2019-01-14T05:57:09Z",
      "mergedAt": "2019-01-14T05:57:09Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "SuriyaaKudoIsc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "ping @mnot ",
          "createdAt": "2019-01-13T19:08:03Z",
          "updatedAt": "2019-01-13T19:08:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2019-01-14T05:57:15Z",
          "updatedAt": "2019-01-14T05:57:15Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8756922372386c1f88628e66145c7bd894349907",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "82512df8bfcf9c51bac8733c785a6165c28184fd",
      "mergeCommit": {
        "oid": "5848fa82703fafed03942f2c7168c5a52a469908"
      }
    },
    {
      "number": 755,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0MzA1MTcz",
      "title": "Collapse sh-integer and sh-float back into sh-number",
      "url": "https://github.com/httpwg/http-extensions/pull/755",
      "state": "CLOSED",
      "author": "bsdphk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Instead of adding text to limit sh-integer to fit inside JS's use of IEEE doubles, collapse sh-integer and sh-float back into sh-number which has the limitation built in already.",
      "createdAt": "2019-01-13T21:13:23Z",
      "updatedAt": "2019-10-28T09:57:55Z",
      "closedAt": "2019-04-17T06:59:50Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8756922372386c1f88628e66145c7bd894349907",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "phk-737",
      "headRefOid": "f7cd88a48af9e05054908ed56c409aea25d82fae",
      "mergeCommit": null
    },
    {
      "number": 756,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0Nzg4NTc0",
      "title": "bcp56bis: consistently use \"header field\" (resolves #748)",
      "url": "https://github.com/httpwg/http-extensions/pull/756",
      "state": "OPEN",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "",
      "createdAt": "2019-01-15T13:09:49Z",
      "updatedAt": "2019-05-07T01:03:35Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5848fa82703fafed03942f2c7168c5a52a469908",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-748",
      "headRefOid": "6ec222a88a02e561df11208e8d85d9b01e1a125c",
      "mergeCommit": null
    },
    {
      "number": 758,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0ODIyMTAz",
      "title": "bcp56bis: URI vs URL (see #757)",
      "url": "https://github.com/httpwg/http-extensions/pull/758",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This change switches from \"URL\" to \"URI\" specifically for two contexts:\r\n\r\n- URI schemes\r\n- URI syntax\r\n\r\n(It might be good to also add an explanation somewhere in the Introduction; I can make a proposal if needed)",
      "createdAt": "2019-01-15T14:53:46Z",
      "updatedAt": "2019-01-18T16:18:05Z",
      "closedAt": "2019-01-18T16:18:00Z",
      "mergedAt": "2019-01-18T16:17:59Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is a PR, no?",
          "createdAt": "2019-01-18T05:14:39Z",
          "updatedAt": "2019-01-18T05:14:39Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Weird, it didn't show the UX for PRs before, but does now. *shrug*",
          "createdAt": "2019-01-18T16:17:44Z",
          "updatedAt": "2019-01-18T16:17:44Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5848fa82703fafed03942f2c7168c5a52a469908",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-757",
      "headRefOid": "75cd8cd2f5efb56f1878a9db899577aa7e08c227",
      "mergeCommit": {
        "oid": "46b95988a33176656b6312a213d0c4ba8aee4791"
      }
    },
    {
      "number": 759,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ3MjY2OTA1",
      "title": "Added a section with more detailed description of Very Large Value to rand-access-live",
      "url": "https://github.com/httpwg/http-extensions/pull/759",
      "state": "MERGED",
      "author": "craigpratt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Also removed some of the VLV description from the Security section\r\n and put some more on-point security considerations in the section.\r\n\r\nThese edits are in response to Adam Roach's feedback in IESG.",
      "createdAt": "2019-01-24T10:02:03Z",
      "updatedAt": "2019-01-29T21:51:36Z",
      "closedAt": "2019-01-29T21:51:31Z",
      "mergedAt": "2019-01-29T21:51:31Z",
      "mergedBy": "craigpratt",
      "comments": [
        {
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK - think I'm done tweaking @martinthomson. Let me know if I've addressed your comments.\r\n\r\nthx again!",
          "createdAt": "2019-01-26T22:39:01Z",
          "updatedAt": "2019-01-26T22:39:01Z"
        },
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "can be merged imo",
          "createdAt": "2019-01-29T20:25:02Z",
          "updatedAt": "2019-01-29T20:25:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk2Mjk1MzE3",
          "commit": {
            "abbreviatedOid": "d576e25"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "The almost-duplicated text looks a little troublesome, but the sentiment is generally OK.  I'd make some more editorial suggestions, but GitHub would make a real hash of the text.",
          "createdAt": "2019-01-24T23:11:42Z",
          "updatedAt": "2019-01-24T23:15:28Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\"e.g.\" is followed by a comma: \"e.g.,\"\r\n\r\nAnd I think that you can drop \"for efficiency\" on the second to last sentence.",
              "createdAt": "2019-01-24T23:11:42Z",
              "updatedAt": "2019-01-29T21:21:55Z"
            },
            {
              "originalPosition": 16,
              "body": "Is this duplicated text?  It's almost the same as the above.  You should probably just forward-reference this section from above.\r\n\r\nGiven that you have a dedicated section, I would split the paragraph at \"So this draft recommends\" and drop the \"So\".",
              "createdAt": "2019-01-24T23:13:43Z",
              "updatedAt": "2019-01-29T21:21:55Z"
            },
            {
              "originalPosition": 33,
              "body": "s/may be/are/",
              "createdAt": "2019-01-24T23:14:40Z",
              "updatedAt": "2019-01-29T21:21:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk2MzA5OTQ3",
          "commit": {
            "abbreviatedOid": "d576e25"
          },
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-25T00:08:17Z",
          "updatedAt": "2019-01-25T00:08:17Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Oops - thought I moved the section. Guess I copied during my late-night editing. Fixing...",
              "createdAt": "2019-01-25T00:08:17Z",
              "updatedAt": "2019-01-29T21:21:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk2MzA5OTU4",
          "commit": {
            "abbreviatedOid": "d576e25"
          },
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-25T00:08:19Z",
          "updatedAt": "2019-01-25T00:08:19Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Agreed. Thanks as always Martin!",
              "createdAt": "2019-01-25T00:08:19Z",
              "updatedAt": "2019-01-29T21:21:55Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "2d40fef5be6158fa60dfb775beeb0d41ec30ddd0",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "cpratt/define-very-large-value",
      "headRefOid": "a1e9cf6c52681d3cffa399edbed71117ef26d1ff",
      "mergeCommit": {
        "oid": "696bd8208ce59621f0fe6500dd977a11af1fe9c8"
      }
    },
    {
      "number": 760,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ3MjY3NDA4",
      "title": "Removed the \"Requirements Language\" section",
      "url": "https://github.com/httpwg/http-extensions/pull/760",
      "state": "CLOSED",
      "author": "craigpratt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This draft isn't using MUST/SHOULD/MAY/etc as the normative\r\n language is supplied by the referenced HTTP RFCs. So removed\r\n the \"Requirements Language\" section defining them.\r\n\r\nThese edits are in response to Adam Roach's feedback in IESG.\r\n\r\n",
      "createdAt": "2019-01-24T10:03:42Z",
      "updatedAt": "2019-01-29T21:57:04Z",
      "closedAt": "2019-01-29T21:54:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "craigpratt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "this was incorporated into PR #759",
          "createdAt": "2019-01-29T21:54:16Z",
          "updatedAt": "2019-01-29T21:54:16Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "2d40fef5be6158fa60dfb775beeb0d41ec30ddd0",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "cpratt/change-case-of-keywords",
      "headRefOid": "59626542f6b476e14df5070ec2640e2c1f542f0d",
      "mergeCommit": null
    },
    {
      "number": 763,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ4MDI5NDc3",
      "title": "cache-header: fix title",
      "url": "https://github.com/httpwg/http-extensions/pull/763",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "cache-header"
      ],
      "body": "",
      "createdAt": "2019-01-28T06:27:04Z",
      "updatedAt": "2020-08-05T00:17:21Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8740db5485b7f15911fd52e6859716ea685a50fe",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-cache-header-1",
      "headRefOid": "21cac3a064fc2d86b0e0a869a44a7934adf219ac",
      "closedAt": "2020-03-17T06:55:13Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mcmanus",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/httpwg/http-core/issues/111  .. that issue is still open, but sense of room in bkk was to greenlight the common parlance of header",
          "createdAt": "2019-01-29T20:16:23Z",
          "updatedAt": "2019-01-29T20:16:23Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would prefer the WG to stick to the current terminology until we decide to change/extend it.",
          "createdAt": "2019-01-30T05:01:25Z",
          "updatedAt": "2019-01-30T05:01:25Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot can this be closed?",
          "createdAt": "2019-11-21T06:19:40Z",
          "updatedAt": "2019-11-21T06:19:40Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 770,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUzNDI1MzQ3",
      "title": "Remove stray closing brace",
      "url": "https://github.com/httpwg/http-extensions/pull/770",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-02-15T13:17:48Z",
      "updatedAt": "2019-02-18T02:08:46Z",
      "closedAt": "2019-02-18T02:08:46Z",
      "mergedAt": "2019-02-18T02:08:46Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "dba36b20be776d6c7a6a8d433a9ea8296cec1a9b",
      "headRepository": "LPardue/http-extensions",
      "headRefName": "patch-7",
      "headRefOid": "ee25bf25f6661c5d65ed12445468aa05f1fd404f",
      "mergeCommit": {
        "oid": "28f172de8b27a69490556513290cee7382a36e34"
      }
    },
    {
      "number": 772,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU0NDU5ODQ0",
      "title": "Clarify TLS 1.3 post-handshake auth with HTTP/2",
      "url": "https://github.com/httpwg/http-extensions/pull/772",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "HTTP/2 blocked renegotiation for a number of reasons. Among other\r\nproblems, as this document notes in section 1.2.3, there is no defined\r\nway to correlate application-visible renegotiation events\r\n(CertificateRequest) with HTTP/2 requests. In essence, the prohibition\r\nis a reflection of TLS+renegotiation being the wrong API shape for\r\nHTTP/2 (and most protocols).\r\n\r\nTLS 1.3 removed renegotiation, but added post-handshake client\r\nauthentication to replace some of renegotiation's use cases. This\r\nretains the problems above. However, with the feature renamed,\r\nRFC7540's prohibition no longer applies and we're stuck with an\r\nincompatibility between RFC8446 and RFC7540.\r\n\r\nPost-handshake authentication is optional in TLS 1.3 and advertised with\r\nan extension, but this is not sufficient. Most HTTP/2 clients are also\r\nHTTP/1.1 clients and TLS parameters are negotiated in parallel. An\r\nHTTP/1.1+HTTP/2 client that advertises the extension for HTTP/1.1 (see\r\nsection 1.2.2 of this document) also advertises it for HTTP/2.\r\n\r\nBy a strict composition of the existing specification text,\r\nHTTP/2-capable clients cannot offer post-handshake authentication to\r\nHTTP/1.1 servers.\r\n\r\nIn reality, existing HTTP/2 servers won't use this mechanism because no\r\none has defined a request correlation. Thus we can fix all this by\r\nclarifying that TLS 1.3 post-handshake auth is forbidden whether or not\r\nthe client offered it.\r\n\r\nIf some future use case comes up, it can define an overriding extension\r\nwith a correlation mechanism. It would already need to do so, because\r\nexisting clients wouldn't know about the correlation. This is unlikely\r\nto happen anyway because this document *is* that use case, and it\r\nalready defines a separate mechanism.",
      "createdAt": "2019-02-20T00:35:34Z",
      "updatedAt": "2019-04-02T14:27:07Z",
      "closedAt": "2019-04-02T14:27:07Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Two points here:\r\n- Is there an issue for this?  I'd prefer to do non-editorial discussion on the issue or the list.\r\n- I'd be fine saying that clients which support this extension MUST NOT use post-handshake auth in HTTP/2 over TLS 1.3 even if negotiated; saying that for all HTTP/2 clients oversteps some bounds.  This document defines an extension -- pretty much by definition, it can only impose requirements scoped to implementations which support the extension.  This isn't the right place to make a prohibition on the behavior of HTTP/2 clients in general.",
          "createdAt": "2019-02-27T18:49:42Z",
          "updatedAt": "2019-02-27T18:49:42Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would say that the reasons we prohibited renegotiation apply to post-handshake authentication.  So unless you have negotiated an extension (the likes of which @MikeBishop defined), then this is a good idea.\r\n\r\nYes, that oversteps bounds, so I would say we should discuss whether it needs a document of its own.  That seems like it is overkill though.",
          "createdAt": "2019-02-27T21:10:07Z",
          "updatedAt": "2019-02-27T21:10:07Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Using this document seems natural given it already talks about the gamut of reactive client certificates, and indeed by doing so has a dependency on this bugfix. Section 1.2.2 of draft-ietf-httpbis-http2-secondary-certs does not work without this fix in it.\r\n\r\nBut if folks want a separate document, that works too I suppose. Though, note that due to the section 1.2.2 problem, we'd then need to queue that new document up in front of this one.",
          "createdAt": "2019-02-27T23:20:35Z",
          "updatedAt": "2019-02-27T23:20:35Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see that 1.2.2 is impacted, since it merely describes the use of post-handshake auth with HTTP/1.1 (which is perfectly valid) after it's been negotiated.  It's worth mentioning that post-handshake auth doesn't fix HTTP/2's problems with renegotiation in 1.2.3; that's currently a gap.  I don't think filling that gap with a change to HTTP/2 all-up is appropriate.\r\n\r\nI agree, a separate RFC for this text seems overkill.  It's certainly not an erratum, as the mechanism in question didn't exist at the time of 7540. But I don't think this document is the right home and I don't know of another in-progress document that would be either.  So my inclination would still be a super-short RFC.\r\n\r\nI suspect we could sidestep making a blocking reference pretty easily.  Your proposed text focuses on client behavior when negotiating which protocol to use, which the document currently doesn't address.  If it publishes first, it could crib some introductory content from here and we'll add an informative reference to it here (close the gap above, \"...and it is therefore prohibited by XXXX.\"); if later, it can point to this doc for a description of the problem it's solving and be even shorter.",
          "createdAt": "2019-02-27T23:34:51Z",
          "updatedAt": "2019-02-27T23:35:11Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Remember that HTTP/1.1 and HTTP/2 share a ClientHello. A client which implements both cannot offer the post_handshake_auth extension to HTTP/1.1 without also offering it to HTTP/2. But it fundamentally doesn't work because there is no request correlation.\r\n\r\nThis means that modern clients effectively cannot implement the scheme described in 1.2.2. Chrome doesn't currently implement it, but if we ever do, the bugfix in this PR is a hard requirement. I'd rather it be codified in a spec, as this is a general problem, than for us to just make up a rule ad-hoc.\r\n\r\n(This is why I wanted post-handshake auth to be conditioned on an application profile. Alas, it wasn't, so now it is unusable for even HTTP/1.1 without this fix.)",
          "createdAt": "2019-02-28T01:26:20Z",
          "updatedAt": "2019-02-28T01:26:20Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, what are the next steps here?",
          "createdAt": "2019-03-07T20:20:59Z",
          "updatedAt": "2019-03-07T20:20:59Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since this is a WG doc, the fact that _I_ don't want this text in this doc doesn't trump the WG's decision.  My recommendation is a separate draft; if we had more time before the submission deadline, I'd say write a simple draft and ask for time in Prague.\r\n\r\nIf that doesn't happen, I'll put at least one slide on this in the update on Secondary Certs; we can have the discussion there about whether this needs to be in a separate doc.",
          "createdAt": "2019-03-09T00:38:10Z",
          "updatedAt": "2019-03-09T00:38:10Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm rather hosed this week and am unlikely to put together a whole new document in time.\r\n\r\nTo clarify, do you not want this text to exist at all, or do you just want it in a separate document for editorial reasons? I agree with MT the latter is overkill, but I wouldn't object if it materialized in its own document. The former is just a fact of life given how ALPN and TLS work. If TLS-level post-handshake auth in HTTP/1.1 is to exist, it *must* be forbidden in HTTP/2.",
          "createdAt": "2019-03-09T01:46:32Z",
          "updatedAt": "2019-03-09T01:47:10Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think an extension to HTTP/2 ought to make a requirement on all of HTTP/2 in the absence of the extension.  So, process reasons rather than editorial reasons -- this isn't the right doc, and in the absence of one that is, make one.  I don't object to the text itself.",
          "createdAt": "2019-03-09T06:44:23Z",
          "updatedAt": "2019-03-09T06:44:23Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing in favor of https://tools.ietf.org/html/draft-davidben-http2-tls13-00",
          "createdAt": "2019-04-02T14:27:07Z",
          "updatedAt": "2019-04-02T14:27:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA1NTc3MTAy",
          "commit": {
            "abbreviatedOid": "f68bae8"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-20T04:59:06Z",
          "updatedAt": "2019-02-20T04:59:06Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "28f172de8b27a69490556513290cee7382a36e34",
      "headRepository": "davidben/http-extensions",
      "headRefName": "h2-post-handshake-certs",
      "headRefOid": "f68bae81204b63874aa76ed56a899df0615e06dd",
      "mergeCommit": null
    },
    {
      "number": 775,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5NDM0MDY1",
      "title": "Remove image-related Client Hints",
      "url": "https://github.com/httpwg/http-extensions/pull/775",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As previously discussed, the current state where some CH hints are defined in the IETF draft and some in accompanying specifications is confusing. Furthermore, defining the image related hints in web specifications would be a better fit, as they have direct implications to image processing there.\r\n\r\nThis PR removes those hints from the IETF draft. This hints are [being added](https://github.com/yoavweiss/html/commit/7bd134ec67472303d06700686be5d37d45ada048) to the HTML specification as part of a larger Client Hints related PR.",
      "createdAt": "2019-03-08T10:40:02Z",
      "updatedAt": "2019-03-11T16:29:55Z",
      "closedAt": "2019-03-11T16:28:35Z",
      "mergedAt": "2019-03-11T16:28:35Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "/cc @igrigorik @mnot ",
          "createdAt": "2019-03-08T10:40:28Z",
          "updatedAt": "2019-03-08T10:40:28Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Merging. \r\n\r\n@mnot if you have any nits or suggestions, please chime in here and we can address in a separate PR. In the meantime, I'll push a new draft so we have the updated version to discuss at upcoming IETF.",
          "createdAt": "2019-03-11T16:29:54Z",
          "updatedAt": "2019-03-11T16:29:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNDk0MDcw",
          "commit": {
            "abbreviatedOid": "2a9e0c1"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Overall, lgtm. A couple quick comments..",
          "createdAt": "2019-03-08T21:47:12Z",
          "updatedAt": "2019-03-08T21:49:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "s/defined/defines? Past tense doesn't make sense here, I think?\r\n\r\nIs \"infrastructure\" well understood term, or should we elaborate a bit on what this means? Something like, a framework for advertising hints that the client wants to receive, persisting them, and corresponding server logic? Ish?",
              "createdAt": "2019-03-08T21:47:13Z",
              "updatedAt": "2019-03-11T13:22:02Z"
            },
            {
              "originalPosition": 27,
              "body": "Add `Sec-` prefix? `Sec-CH-Example1`, ...",
              "createdAt": "2019-03-08T21:48:14Z",
              "updatedAt": "2019-03-11T13:22:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNTAwNDE0",
          "commit": {
            "abbreviatedOid": "2a9e0c1"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T22:06:08Z",
          "updatedAt": "2019-03-08T22:06:08Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "> s/defined/defines? Past tense doesn't make sense here, I think?\r\n\r\nOops. definitely \"defines\".\r\n\r\nI'll also elaborate on \"infrastructure\"",
              "createdAt": "2019-03-08T22:06:08Z",
              "updatedAt": "2019-03-11T13:22:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNTAwNDY3",
          "commit": {
            "abbreviatedOid": "2a9e0c1"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T22:06:18Z",
          "updatedAt": "2019-03-08T22:06:18Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "yup",
              "createdAt": "2019-03-08T22:06:18Z",
              "updatedAt": "2019-03-11T13:22:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNTEyODMy",
          "commit": {
            "abbreviatedOid": "8f11f30"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "\ud83d\udc4d \r\n\r\nThis may be a separate PR: should we document guidance on naming hints? In the examples we use `Sec-CH-` prefix and it seems like something worth documenting in the spec, and explain why.",
          "createdAt": "2019-03-08T22:50:03Z",
          "updatedAt": "2019-03-08T22:50:03Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f72889db0d8ea25aa98dadfa86028a8f5fa04354",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "client_hints_remove_image_headers",
      "headRefOid": "a217c260dace41aae37d5b1f73867d1614be8abd",
      "mergeCommit": {
        "oid": "08a8f12bb17073ac48cb2181de691c6c64f15602"
      }
    },
    {
      "number": 776,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5OTkyNTI2",
      "title": "Add Sec- prefix to security considerations",
      "url": "https://github.com/httpwg/http-extensions/pull/776",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "As discussed in https://github.com/httpwg/http-extensions/issues/716 and https://github.com/httpwg/http-extensions/pull/775, this PR adds a recommended `Sec-` prefix to Client Hints request header values.\r\n\r\nOpen questions:\r\n* Should it be `Sec-CH`?\r\n* Should it be a `MUST`?\r\n\r\n/cc @igrigorik @reschke @mnot @mikewest @arturjanc",
      "createdAt": "2019-03-11T14:32:26Z",
      "updatedAt": "2020-01-20T10:42:02Z",
      "closedAt": "2020-01-20T10:42:01Z",
      "mergedAt": "2020-01-20T10:42:00Z",
      "mergedBy": "yoavweiss",
      "comments": [
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "My opinion doesn't carry a lot of weight here, but I like both `MUST` and `Sec-CH` (or potentially some other namespace-like thing, e.g. `Sec-Hint`) -- this mirrors what @mikewest  did for `Sec-Fetch-*`.\r\n\r\nIlya's suggestion also LGTM.",
          "createdAt": "2019-03-24T18:34:56Z",
          "updatedAt": "2019-03-24T18:34:56Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Apologies for my slowness on this. Adopted Ilya's suggestion.\r\nI know that @reschke was wary of adding more namespace like things though. \r\n@reschke - can you repeat your concerns around this?",
          "createdAt": "2019-07-18T10:03:09Z",
          "updatedAt": "2019-07-18T10:03:09Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, the discussion is in #716 - maybe this is a good topic for the WG meetings in Montreal?",
          "createdAt": "2019-07-18T10:07:14Z",
          "updatedAt": "2019-07-18T10:07:14Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, I'll revive the discussion there",
          "createdAt": "2019-07-18T12:13:37Z",
          "updatedAt": "2019-07-18T12:13:37Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixes #767 and #716 ",
          "createdAt": "2019-07-25T16:36:46Z",
          "updatedAt": "2019-07-25T16:36:46Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@igrigorik - integrated your suggestions and then suggestions from @sleevi. PTAL? ",
          "createdAt": "2019-07-26T19:42:33Z",
          "updatedAt": "2019-07-26T19:42:33Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "mnot@ - Friendly ping :) Do you think the \"CH-\" bit is required?",
          "createdAt": "2019-08-13T10:57:27Z",
          "updatedAt": "2019-08-13T10:57:27Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Friendly ping! :)",
          "createdAt": "2019-09-26T06:01:43Z",
          "updatedAt": "2019-09-26T06:01:43Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "mnot@ - apologies for the delay. Addressed your comments. PTAL? ",
          "createdAt": "2019-11-05T10:17:45Z",
          "updatedAt": "2019-11-05T10:17:45Z"
        },
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "The `Sec-` prefix guarantees that application developers are not currently sending requests with that header to their server (i.e. they're not adding it in XHR/Fetch because it's a forbidden header name.)  If a browser starts sending a new header without the prefix, it can result in unexpected behavior if the header name clashes with a custom header already in use by an application. In some cases this can create a security issue, e.g. if an application uses the presence of such a header to identify trusted requests -- this approach is a relatively common CSRF protection because the server can be sure that requests with a custom header were sent same-origin, or the server had opted into them in response to a CORS preflight.\r\n\r\nI don't feel very strongly about this particular case, but in general I'm worried about browsers sending new unprefixed headers by default for this reason.",
          "createdAt": "2019-11-06T18:10:01Z",
          "updatedAt": "2019-11-06T18:10:01Z"
        },
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "I believe @annevk had some comments about similar situations in the past.",
          "createdAt": "2019-11-06T18:11:27Z",
          "updatedAt": "2019-11-06T18:11:27Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@arturjanc that basically means we can't define any new request HTTP headers, which is pretty demonstrably untrue. What we shouldn't do is choose especially generic names, like `HTTPS`. Don't generalise from one bad experience.",
          "createdAt": "2019-11-06T21:53:37Z",
          "updatedAt": "2019-11-06T21:53:37Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, the establishment of the convention to use a \"CH-\" prefix would seem to avoid that problem amply.  But @mnot's point is the stronger one.  I realize that having a standard bulldoze your established use of \"My-Header\" is an experience people are reluctant to be exposed to the possibility of, but they could always [register header field names](https://www.iana.org/assignments/message-headers/message-headers.xhtml).",
          "createdAt": "2019-11-06T23:04:14Z",
          "updatedAt": "2019-11-06T23:04:14Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Each new request header that a browser is to transmit cross-origin and is not prefixed with `Sec-` (or subject to a CORS preflight) would be another enshrined exception to the same-origin policy and a possible security issue until servers are updated to expect it.\r\n\r\nFurthermore, some new request headers are not supposed to be spoofable same-origin and for those the prefix is important too. We have not had to update https://fetch.spec.whatwg.org/#forbidden-header-name for about a decade now and it would be nice to keep it that way.\r\n\r\n(There's also a problem if an attacker can control these fields somehow. We've had to impose length restrictions on Referer and the CORS-safelisted request-headers. I suspect that's not applicable to client hints.)",
          "createdAt": "2019-11-07T08:15:19Z",
          "updatedAt": "2019-11-07T09:13:47Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(OK, disclaimer: I'm not 100% clear on the model for cross-origin use of client hints then, but this is my operating model.  If this model is incorrect somehow, I think that the fetch changes here are what needs adjusting...)\r\n\r\nGiven that these aren't sent unless the server specifically requests them, I think that the cross-origin concern isn't that significant.  Rather than insisting on a one-by-one exception, a systemic exception for client hints would be preferable.\r\n\r\nThe way that this draft models CH header fields is that the site collects the information and injects the header field in every request as it leaves for the server (as if by service worker fetch interception).  The browser is just helping out.  If we are able to adhere to that model, then allowing insertion is different than header fields like `User-Agent` or `Origin` or other security-critical fields.\r\n\r\nIf this model is correct, then it doesn't make sense for these to be forbidden or for them to require special processing for exemption.  Note that this changes how the information needs to be generated (it can't access privileged information; that's already in this doc), and it means that these are treated like any other header field.\r\n\r\nAs for concerns about interaction with ambient authority that a server might associate with the request, I think that I will point back at the bit where the server explicitly asked for the hint to be provided.  I concede that cross-resource concerns might be a problem (resource A asks, resource B is unprepared), but the set of fields will be small, carefully groomed by browser makers, mostly prefixed with `CH-`, and carrying information that is not obviously useful in security-critical decisions. ",
          "createdAt": "2019-11-07T09:12:49Z",
          "updatedAt": "2019-11-07T09:12:49Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Agreed that if the server asks for the browser to set these headers on subsequent requests the cross-origin concern does not apply. However, that does assume these headers are not attacker-controlled and depending on when they are set (and the ask has been that they are set early to expose them to service workers as normal headers) they would also have to bypass CORS and we'd have to ensure they cannot be manipulated, etc.\r\n\r\nAnd writing that down I realize there's a security problem there as now A can figure out that B requested client hints (and see what hints B will get).\r\n\r\nAlso, does the spoofing concern not apply?\r\n\r\nIt's also not entirely clear if server opt-in is tenable as we've seen requests for client hint like data to be available on the first request.",
          "createdAt": "2019-11-07T09:22:50Z",
          "updatedAt": "2019-11-07T09:22:50Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Given that these aren't sent unless the server specifically requests\r\n\r\nThat is true for the same origin case, but not for the cross-origin one. For privacy purposes, we've limited the Client Hints opt-in to top-level documents, so a cross-origin resource cannot opt-in to client hints. And with Feature Policy, the top-level document can delegate hints to certain origins.\r\n\r\nThat means that those origins will get the hints without opting into them, which increases the risk.\r\n\r\nAt the same time, we want to avoid Client Hints request headers from triggering preflights, while being sure that it's indeed safe to do so. ",
          "createdAt": "2019-11-07T11:29:29Z",
          "updatedAt": "2019-11-07T11:29:29Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> A can figure out that B requested client hints (and see what hints B will get).\r\n\r\nA seeing the values isn't an issue as it is A that put the hints there (and A sees the same values).\r\n\r\nI don't see A having influence over values (viewport width maybe...).\r\n\r\nB being unprepared for the hints does seem to be a problem.  I know that avoiding preflight is appealing from a performance perspective, but that's how we've decided to operate for these things.  Because A is essentially forcing the inclusion of header fields into cross-origin requests, I think that we have a few options:\r\n\r\n1. perform some sort of analysis for each client hint to verify that no server conditions behaviour on the newly introduced header field in a way that would expose security-critical information\r\n\r\n2. preflight always \r\n\r\n3. find a better alternative to preflights (origin policy, the TLS extension, etc...)\r\n\r\n4. pretend that `Sec-`-prefixed header fields aren't subject to these same concerns\r\n\r\n5. require the use of `CH-` prefixes and perform generic analysis\r\n\r\nFWIW, for the first reason, we can't remember that B was OK with hints when it was top-level or framed in C because that lets A observe that B has been visited elsewhere.",
          "createdAt": "2019-11-08T00:54:08Z",
          "updatedAt": "2019-11-08T00:54:08Z"
        },
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "> * pretend that `Sec-`-prefixed header fields aren't subject to these same concerns\r\n\r\nI'm not sure we need to do a lot of pretending here ;-) We know that applications can't get `Sec-`prefixed headers with ambient authority, so developers don't use them in their applications (unlike other headers which may be set same-origin or allowed via a response to a preflight). I believe delivering hints with a `Sec-` prefix would indeed avoid the class of problems discussed above; is there a specific issue that you're still worried about in this case?\r\n\r\n\r\n",
          "createdAt": "2019-11-10T15:11:18Z",
          "updatedAt": "2019-11-10T15:11:18Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson - does @arturjanc's response answer concerns you had around option (4)?\r\nAs I'm not sure how to go about either (1) or (5), (2) would be a significant performance regression and (3) seems somewhat orthogonal, (4) seems like the best path forward.\r\n\r\n\r\n  ",
          "createdAt": "2019-11-17T05:02:02Z",
          "updatedAt": "2019-11-17T05:02:02Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "At IETF 106, we agreed that it might be better to modify this so that the infrastructure draft indicates that features need to make sure that adding new request headers would be safe for servers. Individual features would then be able to decide if they enforce `Sec-`, live with a preflight and its performance regressions, or otherwise add their request headers to the CORS safe list. An alternative PR outlining that will follow.",
          "createdAt": "2019-11-21T06:43:58Z",
          "updatedAt": "2019-11-21T06:43:58Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> At IETF 106, we agreed that it might be better to modify this so that the infrastructure draft indicates that features need to make sure that adding new request headers would be safe for servers. Individual features would then be able to decide if they enforce `Sec-`, live with a preflight and its performance regressions, or otherwise add their request headers to the CORS safe list. An alternative PR outlining that will follow.\r\n\r\n@martinthomson - looking at the current language, it seems to well-align with that decision without much modification. Can you take a look and let me know if you agree?",
          "createdAt": "2019-12-04T11:13:45Z",
          "updatedAt": "2019-12-04T11:13:45Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson - friendly ping! :)",
          "createdAt": "2019-12-09T09:19:41Z",
          "updatedAt": "2019-12-09T09:19:41Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Post holidays ping! :)",
          "createdAt": "2020-01-07T10:21:11Z",
          "updatedAt": "2020-01-07T10:21:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE3MDc1NzI5",
          "commit": {
            "abbreviatedOid": "fa406fb"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-21T04:33:02Z",
          "updatedAt": "2019-03-21T04:34:26Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Hmm, I believe a big part of the motivation for `Sec` prefix is that it's a reserved prefix that only the browser can emit, which seems like something worth mentioning here? This allows the servers to treat such headers with different policies; have some confidence in the data being delivered.\r\n\r\n\r\n> Adding new request headers introduces potential deployment risks. For example, some servers may already use the same header for a different purpose, which may result in conflicts or other undesired behaviors.\r\n>\r\n>While this risk is significantly mitigated by the opt-in mechanisms of Client Hints, specifications and features relying on Client Hints should use the `Sec-` prefix for request header names. User agents reserve this namespace for headers that can only be emitted by the browser and thus can guarantee and enforce the type and format of the data communicated in the header value fields.\r\n\r\nwdyt, warmer?",
              "createdAt": "2019-03-21T04:33:03Z",
              "updatedAt": "2020-01-20T10:40:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYzNTUyMjcx",
          "commit": {
            "abbreviatedOid": "fa406fb"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-18T10:00:52Z",
          "updatedAt": "2019-07-18T10:00:53Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Yup, SGTM",
              "createdAt": "2019-07-18T10:00:53Z",
              "updatedAt": "2020-01-20T10:40:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY2NzUwNzc1",
          "commit": {
            "abbreviatedOid": "43493fc"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-25T16:40:41Z",
          "updatedAt": "2019-07-25T16:40:42Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "@sleevi - can you take a look to see that this language reflects what you had in mind when we discussed this at the IETF105 HTTPWG meeting? ",
              "createdAt": "2019-07-25T16:40:42Z",
              "updatedAt": "2020-01-20T10:40:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY2ODAyNTY3",
          "commit": {
            "abbreviatedOid": "43493fc"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-25T18:20:22Z",
          "updatedAt": "2019-07-25T18:20:22Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Deployment of new request headers requires several considerations:\r\n\r\n- Potential conflicts due to existing use of field name\r\n- Properties and validation of communicated data in field value\r\n\r\nSpecifications and features relying on Client Hints MUST use the \"Sec-\" prefix for request header names. User agents reserve this namespace that can only be emitted by the browser and thus can guarantee and enforce the type and format of the data communicated in the header value fields. Further, specifications and features relying on Client Hints are encouraged to include \"CH-\" in the header name, in order to make it easier to distinguish Client Hint request headers from others. \r\n\r\nThe combination of the above recommendations and requirements, plus the opt-in mechanism of Client Hints, helps minimize deployment risks. Further, these requirements enable server and intermediaries handling requests with Client Hints to identify such request headers and take precautions in how they are used and processed \u2014 e.g. opt out from storing them as they may expose information about the user.",
              "createdAt": "2019-07-25T18:20:22Z",
              "updatedAt": "2020-01-20T10:40:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY3Mjg1NDgw",
          "commit": {
            "abbreviatedOid": "07574cb"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-26T16:28:42Z",
          "updatedAt": "2019-07-26T16:28:42Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "So, the first half of your recommendation, the \"Sec-\" prefix, is immediately explained as to why such a requirement exists.\r\n\r\nHowever, the second half, \"CH-\", does not explain _why_ it's useful to distinguish Client Hint request headers from others.\r\n\r\n**BEGIN**\r\nSpecifications and features relying on Client Hints MUST prefix request header names with a \"Sec-\" prefix. User agents, such as web browsers, ensure such prefixed headers may only be emitted by the browser, and application content, such as scripts, are forbidden from emitting such headers {{FETCH}}. This provides assurance that, when transmitted by user agents, that both the type and format of data communicated in such request headers are enforced by the user agent.\r\n\r\nAdditionally, specifications and features relying on Client Hints are RECOMMENDED to include the \"CH-\" in the header name, for example, in the form `Sec-CH-Foo` for a hypothetical Client Hint `Foo`. Client Hints provide additional information about a user agent [1] that previously may only have been accessible to scripts or content [2], and not necessarily transmitted in requests. Servers that wish to minimize the data collected in intermediate steps may wish to filter out all unrecognized or unprocessed \"CH-\" values from its records or intermediate steps, and a consistent use of \"CH-\" helps facilitate filtering new and unrecognized Client Hint Values.\r\n**END**\r\n\r\n[1] I'm not sure if this is strictly about UAs?\r\n[2] I'm not entirely happy with that wording, but *shrug*\r\n\r\nHowever, from our IETF 105 conversation, @mnot aptly pointed out that such concerns arguably apply to any/all new headers, and so perhaps the 'CH-' infix may be entirely unnecessary, because it's a generalized problem. The language I offer above attempts to provide explanation/justification for the RECOMMENDation, but I could also see with doing away with 'CH-' entirely.",
              "createdAt": "2019-07-26T16:28:42Z",
              "updatedAt": "2020-01-20T10:40:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY3MzczMjY1",
          "commit": {
            "abbreviatedOid": "9c1b603"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Yep, this looks great!\r\n\r\nPer Ryan's earlier comment.. I don't have a strong opinion on whether CH- bit is necessary. I'll defer to @mnot and @martinthomson's guidance here.",
          "createdAt": "2019-07-26T19:46:15Z",
          "updatedAt": "2019-07-26T19:46:15Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NDM1MDkw",
          "commit": {
            "abbreviatedOid": "a2f6bab"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-19T09:19:51Z",
          "updatedAt": "2019-08-19T09:23:58Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "That's managed by registering the header field, and is well-documented in HTTP. Why is this important to call out here?",
              "createdAt": "2019-08-19T09:19:52Z",
              "updatedAt": "2020-01-20T10:40:56Z"
            },
            {
              "originalPosition": 75,
              "body": "Instead of this graph, I'd say something like:\r\n\r\nBy convention, request headers that are client hints use a `CH-` prefix, to make them easier to identify as using this framework; for example, `Sec-CH-Foo`. Doing so makes them easier to identify programmatically (e.g., for stripping unrecognised hints from requests by privacy filters).",
              "createdAt": "2019-08-19T09:23:11Z",
              "updatedAt": "2020-01-20T10:40:56Z"
            },
            {
              "originalPosition": 73,
              "body": "You're going to get pushback that MUST is only for targeting implementations, not specifications. Make this advisory.",
              "createdAt": "2019-08-19T09:23:38Z",
              "updatedAt": "2020-01-20T10:40:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg0MTAyMDYx",
          "commit": {
            "abbreviatedOid": "a2f6bab"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for reviewing! :)",
          "createdAt": "2019-09-05T08:43:22Z",
          "updatedAt": "2019-09-05T08:45:44Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "The example I had in mind were the conflicts @mikewest ran into when deploying the initial version of `upgrade-insecure-requests` as `https`. I believe that resulted in some server side conflicts with some servers that already used that name internally, and read all incoming request headers to be global variables. (@mikewest - please correct me if I remember that wrong)\r\n",
              "createdAt": "2019-09-05T08:43:22Z",
              "updatedAt": "2020-01-20T10:40:56Z"
            },
            {
              "originalPosition": 73,
              "body": "OK",
              "createdAt": "2019-09-05T08:43:53Z",
              "updatedAt": "2020-01-20T10:40:56Z"
            },
            {
              "originalPosition": 75,
              "body": ":+1:",
              "createdAt": "2019-09-05T08:45:16Z",
              "updatedAt": "2020-01-20T10:40:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MjkxMzk1",
          "commit": {
            "abbreviatedOid": "f9e6899"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-04T06:57:41Z",
          "updatedAt": "2019-10-04T06:57:41Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Some versions of PHP do strange things with certain headers. `https` was one of them. I'm not sure that has much weight in either direction, except as an anecdote that gave me a very bad week a few years ago. :)",
              "createdAt": "2019-10-04T06:57:41Z",
              "updatedAt": "2020-01-20T10:40:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3OTE5MTA5",
          "commit": {
            "abbreviatedOid": "f9e6899"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-07T06:19:55Z",
          "updatedAt": "2019-10-07T06:19:55Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Sure. I just don't know why we're doing this specifically here, rather than relying on the generic HTTP text (DRY and all that). Not a huge deal, just struck me as odd.",
              "createdAt": "2019-10-07T06:19:55Z",
              "updatedAt": "2020-01-20T10:40:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3OTE5NzE5",
          "commit": {
            "abbreviatedOid": "f9e6899"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-07T06:22:24Z",
          "updatedAt": "2019-10-07T06:22:25Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Once again -- this text assumes that EVERY Client Hint is designed such that making it settable from code is an attack, and that there isn't any value in allowing it happen. I'd be much more comfortable saying that specs defining (not relying upon, btw) a Client Hint _carefully consider_ whether it should be exposed to code, and if it's a risk, to prefix with `Sec-`.",
              "createdAt": "2019-10-07T06:22:24Z",
              "updatedAt": "2020-01-20T10:40:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3OTE5Nzkx",
          "commit": {
            "abbreviatedOid": "f9e6899"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-07T06:22:44Z",
          "updatedAt": "2019-10-07T06:22:44Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "... are encouraged to use...?",
              "createdAt": "2019-10-07T06:22:44Z",
              "updatedAt": "2020-01-20T10:40:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExNjA3NTM0",
          "commit": {
            "abbreviatedOid": "f9e6899"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-05T09:44:41Z",
          "updatedAt": "2019-11-05T09:44:42Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": ":+1:",
              "createdAt": "2019-11-05T09:44:42Z",
              "updatedAt": "2020-01-20T10:40:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExNjA4NzUz",
          "commit": {
            "abbreviatedOid": "f9e6899"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-05T09:46:39Z",
          "updatedAt": "2019-11-05T09:46:39Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "changed to \"Specifications and features ... are advised to carefully consider prefixing...\"",
              "createdAt": "2019-11-05T09:46:39Z",
              "updatedAt": "2020-01-20T10:40:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExODIxODcy",
          "commit": {
            "abbreviatedOid": "30afe42"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Looks good on this end \ud83d\udc4d\r\n\r\n@mnot I'll defer to you for final once over and approve. ",
          "createdAt": "2019-11-05T15:35:28Z",
          "updatedAt": "2019-11-05T15:35:28Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEyMTQxMzM3",
          "commit": {
            "abbreviatedOid": "30afe42"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Originally, I was sure I didn't understand this.  Then I thought that I might have understood.  Now I'm closer to being sure that I think this is not the right answer.",
          "createdAt": "2019-11-06T01:04:12Z",
          "updatedAt": "2019-11-06T01:12:48Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "carfully?\r\n\r\nAlso, the number, of, commas, here, is, starting to, get tiresome.  Maybe there are two sentences in that second one.",
              "createdAt": "2019-11-06T01:04:12Z",
              "updatedAt": "2020-01-20T10:40:57Z"
            },
            {
              "originalPosition": 70,
              "body": "So Yoav explained that the main reason here is that the reason for the Sec- prefix was to avoid problems like the one where header fields are turned into environment variables in a non-injective fashion by some frameworks.  So you get the value of the \"Foo\" header field mixed in with the \"foo\" query parameter.  That motivates **a** prefix, but it doesn't motivate the \"Sec-\" one.\r\n\r\nI hadn't heard that reason properly before.  It took me a while to internalize it.\r\n\r\nAnd then it didn't make sense.  The more I think about this, the more that I think that the \"CH-\" prefix is useful, but the \"Sec-\" one isn't.  On the contrary, I see value in giving script the ability to query for different content using these header fields.  For one, it might allow an app that is preparing for going offline in the browser the ability to request content based on anticipated rather than current needs.\r\n\r\nFor example, assuming for a moment that I thought `Save-Data` was useful (it's not), then the content could request the lightweight content that this targets, to avoid expending resources on the fetch or storage.  At that point, I don't have to have an opinion on `Save-Data` from the browser perspective, it might as well be yet another proprietary header field.",
              "createdAt": "2019-11-06T01:11:55Z",
              "updatedAt": "2020-01-20T10:40:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEyMTY0ODI0",
          "commit": {
            "abbreviatedOid": "30afe42"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-06T02:36:11Z",
          "updatedAt": "2019-11-06T02:36:12Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "I think it's much more clear to say something like:\r\n\r\nAuthors of new Client Hints are advised to carefully consider whether they should be able to be added by client-side content (e.g., scripts), or whether they should be exclusively set by the user agent. In the latter case, the `Sec-` prefix on the header field name has the effect of preventing scripts and other application content from setting them in many user agents. See {{FETCH}} for more information.",
              "createdAt": "2019-11-06T02:36:11Z",
              "updatedAt": "2020-01-20T10:40:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEyMTcyMDAz",
          "commit": {
            "abbreviatedOid": "30afe42"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-06T03:06:59Z",
          "updatedAt": "2019-11-06T03:06:59Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "That is definitely better phrasing.  Assuming that you still want to do this based on [my earlier comments](https://github.com/httpwg/http-extensions/pull/776#discussion_r342875878).",
              "createdAt": "2019-11-06T03:06:59Z",
              "updatedAt": "2020-01-20T10:40:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEyNDYxOTcy",
          "commit": {
            "abbreviatedOid": "30afe42"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-06T14:17:18Z",
          "updatedAt": "2019-11-06T14:17:18Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Oops regarding \"carfully\"...\r\n\r\nOtherwise, I like @mnot's proposed text, assuming we are fine with user-added Client-Hints. I need to give them some more thought.",
              "createdAt": "2019-11-06T14:17:18Z",
              "updatedAt": "2020-01-20T10:40:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5NTM5OTQy",
          "commit": {
            "abbreviatedOid": "a3f7681"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T01:27:23Z",
          "updatedAt": "2019-12-10T01:27:24Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Yeah, Mark's text seems fine to me.",
              "createdAt": "2019-12-10T01:27:24Z",
              "updatedAt": "2020-01-20T10:40:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MTg1MDQy",
          "commit": {
            "abbreviatedOid": "a3f7681"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I'm seeing pretty strong encouragement to use \"Sec-\" here.",
          "createdAt": "2020-01-20T09:46:42Z",
          "updatedAt": "2020-01-20T09:47:12Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "> Using the \"Sec-\" prefix signals to servers that the user agent - and not application content - generated the values.",
              "createdAt": "2020-01-20T09:46:42Z",
              "updatedAt": "2020-01-20T10:40:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MTk0MzE5",
          "commit": {
            "abbreviatedOid": "a98cc42"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T10:00:44Z",
          "updatedAt": "2020-01-20T10:00:45Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "@martinthomson I incorporated mnot's text (I thought I done so earlier :/) as well as your suggestion. PTAL?",
              "createdAt": "2020-01-20T10:00:44Z",
              "updatedAt": "2020-01-20T10:40:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MTk3ODMw",
          "commit": {
            "abbreviatedOid": "5cf4f9e"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-20T10:06:26Z",
          "updatedAt": "2020-01-20T10:07:40Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "WFM, one tweak below.",
              "createdAt": "2020-01-20T10:06:26Z",
              "updatedAt": "2020-01-20T10:40:57Z"
            },
            {
              "originalPosition": 8,
              "body": "By convention, request headers that are client hints are encouraged to use a CH- prefix, to make them easier to identify as using this framework; for example, CH-Foo or, with a \"Sec-\" prefix, Sec-CH-Foo. Doing so makes them easier to identify programmatically (e.g., for stripping unrecognised hints from requests by privacy filters).",
              "createdAt": "2020-01-20T10:07:36Z",
              "updatedAt": "2020-01-20T10:40:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MjE4ODcy",
          "commit": {
            "abbreviatedOid": "a98cc42"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T10:41:04Z",
          "updatedAt": "2020-01-20T10:41:04Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Thanks, added!",
              "createdAt": "2020-01-20T10:41:04Z",
              "updatedAt": "2020-01-20T10:41:04Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a982692cbb04a418f2c3bf7a0c996a76bdd79700",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "client_hints_sec_prefix",
      "headRefOid": "79a21d242e4593b43529a0524ff17320a3d6bd38",
      "mergeCommit": {
        "oid": "dd248502d9c43f234c2637f18dbfa226f05f6f12"
      }
    },
    {
      "number": 777,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYwMDQ4Njgy",
      "title": "Rename Cache header to Cache-Status",
      "url": "https://github.com/httpwg/http-extensions/pull/777",
      "state": "CLOSED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "cache-header"
      ],
      "body": "Cache-Status seems to better describe the information this header carries\r\nand is potentially less confusing. It also seems more consistent with other\r\nCache-related headers (e.g. Cache-Control).\r\n\r\nFWIW, some variants of *-Cache-Control are also somewhat popular in the\r\nwild, e.g. the NGINX caching guide [0] uses X-Cache-Status and Cloudflare\r\nuses CF-Cache-Control (though I'm not sure popularity matters much, since\r\neither way servers will need to be updated).\r\n\r\n[0] https://www.nginx.com/blog/nginx-caching-guide/\r\n\r\n---\r\n\r\n@mnot As proposed a while ago on the mailing list https://lists.w3.org/Archives/Public/ietf-http-wg/2018JulSep/0318.html Happy to discuss this more in Prague.",
      "createdAt": "2019-03-11T16:45:26Z",
      "updatedAt": "2019-11-21T06:19:06Z",
      "closedAt": "2019-11-21T06:19:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "OlliV",
          "authorAssociation": "NONE",
          "body": "I support the one that is already in the draft because I don't see how it could be misleading. `X-Something-Cache` but I don't think the popularity matters because everybody will need to do some adjustment if they want to go for this.",
          "createdAt": "2019-03-28T13:11:34Z",
          "updatedAt": "2019-03-28T13:11:44Z"
        },
        {
          "author": "wimleers",
          "authorAssociation": "NONE",
          "body": "The current name is also clear to me. Can you explain what you find confusing about `Cache`? \r\n\r\nI think it can be argued that `Cache-Status` would be more confusing since this header effectively is a log of _actions_ by intermediaries, it doesn't convey any status. At most, it helps explain the values of the HTTP response.\r\n\r\nA strong potential reason I can see to rename this to `Cache-Status` is to convey this exists to provide cache debugging information just like `Proxy-Status` exists to provide proxy debugging information (`Proxy-Status` is in progress at https://tools.ietf.org/html/draft-nottingham-proxy-status-00). Similarity in naming should then probably also imply similarity in structure though.",
          "createdAt": "2019-04-17T11:11:45Z",
          "updatedAt": "2019-04-17T11:11:45Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@wimleers `Cache[-Status]` and now-adopted `Proxy-Status` both use parameterised list from [draft-ietf-httpbis-header-structure](https://tools.ietf.org/html/draft-ietf-httpbis-header-structure).\r\n\r\nNow that `Proxy-Status` has been adopted by the WG, I'm also in favor of renaming `Cache` to `Cache-Status`.",
          "createdAt": "2019-05-02T17:51:42Z",
          "updatedAt": "2019-05-02T17:51:42Z"
        },
        {
          "author": "wimleers",
          "authorAssociation": "NONE",
          "body": "Thanks, then the last paragraph of my comment applies, so I now agree with renaming :)",
          "createdAt": "2019-07-03T13:30:02Z",
          "updatedAt": "2019-07-03T13:30:02Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Singapore: Already renamed, closing",
          "createdAt": "2019-11-21T06:19:06Z",
          "updatedAt": "2019-11-21T06:19:06Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "08a8f12bb17073ac48cb2181de691c6c64f15602",
      "headRepository": "ghedo/http-extensions",
      "headRefName": "cache-status",
      "headRefOid": "fcf1f689bbb11f47089591cd98fad57d5676d009",
      "mergeCommit": null
    },
    {
      "number": 780,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY0Njk1NTU0",
      "title": "Deleted intro\u2019s promise of an \u201cinitial set of Client Hints\u201d",
      "url": "https://github.com/httpwg/http-extensions/pull/780",
      "state": "MERGED",
      "author": "eeeps",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Tweak/cleanup in light of #775 ",
      "createdAt": "2019-03-26T21:08:33Z",
      "updatedAt": "2019-04-21T19:03:57Z",
      "closedAt": "2019-04-21T19:03:57Z",
      "mergedAt": "2019-04-21T19:03:57Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot or @igrigorik, can you push the green button?",
          "createdAt": "2019-04-21T18:19:28Z",
          "updatedAt": "2019-04-21T18:19:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4OTIyMDE1",
          "commit": {
            "abbreviatedOid": "9acaf49"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2019-04-21T18:18:45Z",
          "updatedAt": "2019-04-21T18:18:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4OTIzMzY4",
          "commit": {
            "abbreviatedOid": "9acaf49"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "\ud83d\udc4d ",
          "createdAt": "2019-04-21T19:03:52Z",
          "updatedAt": "2019-04-21T19:03:52Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "08a8f12bb17073ac48cb2181de691c6c64f15602",
      "headRepository": "eeeps/http-extensions",
      "headRefName": "client-hints-intro-tweak",
      "headRefOid": "9acaf4959bb29bdbdfe30eebbaa0f75cc82ed4f4",
      "mergeCommit": {
        "oid": "7aab1c92862e7c8438b08bf0863d90fa387d3a99"
      }
    },
    {
      "number": 789,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcxMjA5MDA2",
      "title": "structured-headers: fix artwork width for sh-token abnf",
      "url": "https://github.com/httpwg/http-extensions/pull/789",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-04-17T08:38:52Z",
      "updatedAt": "2019-10-23T06:30:37Z",
      "closedAt": "2019-04-23T08:05:14Z",
      "mergedAt": "2019-04-23T08:05:14Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9d5ce5bef7f1093e07abf58d41631d86ebb3b6f3",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-sh-token-abnf",
      "headRefOid": "9278ce7fd11a9985937fab22bf79cf2127cbf926",
      "mergeCommit": {
        "oid": "84212181e9db24918b7ab065e8fe51a64d5ab5e7"
      }
    },
    {
      "number": 792,
      "id": "MDExOlB1bGxSZXF1ZXN0MjczNDAyNTUz",
      "title": "AUTH48 changes",
      "url": "https://github.com/httpwg/http-extensions/pull/792",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-04-25T07:16:08Z",
      "updatedAt": "2019-04-25T23:35:22Z",
      "closedAt": "2019-04-25T23:35:17Z",
      "mergedAt": "2019-04-25T23:35:17Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2019-04-25T23:35:12Z",
          "updatedAt": "2019-04-25T23:35:12Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "84212181e9db24918b7ab065e8fe51a64d5ab5e7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-cdn-loop-auth48",
      "headRefOid": "508e8c97e435fae3332c828f494b8be8f8eaf294",
      "mergeCommit": {
        "oid": "5696a951370fbd3248529797d4d30723b71889f5"
      }
    },
    {
      "number": 793,
      "id": "MDExOlB1bGxSZXF1ZXN0MjczNjU3NTI0",
      "title": "Remove dangling reference",
      "url": "https://github.com/httpwg/http-extensions/pull/793",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "Fixes #714 and fixes #715, filed by @LPardue.  Given #480, the AUTOMATIC_USE text is entirely superfluous, and given #566, the correct wording would be \"for a stream.\"",
      "createdAt": "2019-04-25T19:42:44Z",
      "updatedAt": "2019-10-23T06:30:36Z",
      "closedAt": "2019-07-22T20:00:51Z",
      "mergedAt": "2019-07-22T20:00:51Z",
      "mergedBy": "MikeBishop",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "cea2a79d3e959edc22db762a6eb435f0be2a6ecd",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "sc/dangling_au",
      "headRefOid": "c511effdd3fa17ec86e7e7a6df5e985c9038d2e2",
      "mergeCommit": {
        "oid": "19e1ad560d6cbbbb35da0d14c9a9f9f193724c75"
      }
    },
    {
      "number": 795,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc1MjQzOTYw",
      "title": "proxy-status: editorial - escape square brackets",
      "url": "https://github.com/httpwg/http-extensions/pull/795",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-05-02T06:09:52Z",
      "updatedAt": "2019-10-23T06:30:35Z",
      "closedAt": "2019-05-02T06:28:34Z",
      "mergedAt": "2019-05-02T06:28:34Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2019-05-02T06:28:39Z",
          "updatedAt": "2019-05-02T06:28:39Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5a929e0451a412496c7a21aaae12bb889b7b1c6f",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-ps-brackets",
      "headRefOid": "f7e123f777073926818c08ba26e4ea3acfd6a149",
      "mergeCommit": {
        "oid": "59a575cd7a0f395b139edffba3797aaeb6f69168"
      }
    },
    {
      "number": 796,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc1MjQ0NjA5",
      "title": "proxy-status: fix section reference formatting",
      "url": "https://github.com/httpwg/http-extensions/pull/796",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "See <https://www.rfc-editor.org/styleguide/part2/>, \"Referring to specific sections within another document\"",
      "createdAt": "2019-05-02T06:14:03Z",
      "updatedAt": "2019-10-23T06:30:34Z",
      "closedAt": "2019-05-02T06:28:58Z",
      "mergedAt": "2019-05-02T06:28:58Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2019-05-02T06:29:02Z",
          "updatedAt": "2019-05-02T06:29:02Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5a929e0451a412496c7a21aaae12bb889b7b1c6f",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-ps-sec-ref",
      "headRefOid": "50d19b90b1a8e45832e965c8f37728fcab37dce3",
      "mergeCommit": {
        "oid": "007c4081ddb270339c37744b029e41eea4a7eafd"
      }
    },
    {
      "number": 798,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc1MjQ2NzM5",
      "title": "sh: avoid use of markdown syntax in example",
      "url": "https://github.com/httpwg/http-extensions/pull/798",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "",
      "createdAt": "2019-05-02T06:27:24Z",
      "updatedAt": "2019-05-02T06:29:44Z",
      "closedAt": "2019-05-02T06:29:33Z",
      "mergedAt": "2019-05-02T06:29:33Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks.",
          "createdAt": "2019-05-02T06:29:38Z",
          "updatedAt": "2019-05-02T06:29:38Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5a929e0451a412496c7a21aaae12bb889b7b1c6f",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-sh-example-md",
      "headRefOid": "bbc5725d82cd2ca17b43fe7f0e4860c39f935af5",
      "mergeCommit": {
        "oid": "ad6707f44912d24b7b95ba008a162ba36338d1b9"
      }
    },
    {
      "number": 800,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc1NDQ3NDQ0",
      "title": "RFC6265bis: Allow `SameSite` cookies to be set for all top-level navigation",
      "url": "https://github.com/httpwg/http-extensions/pull/800",
      "state": "MERGED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Based on the discussion in httpwg/http-extensions#594, this patch aligns\r\nthe specification with Firefox's status quo behavior: allowing\r\n`SameSite=*` cookies to be set from all top-level navigations, not just\r\nnavigations for which `SameSite=*` cookies would also be sent.",
      "createdAt": "2019-05-02T17:12:49Z",
      "updatedAt": "2019-05-04T04:28:08Z",
      "closedAt": "2019-05-04T04:28:04Z",
      "mergedAt": "2019-05-04T04:28:04Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "/cc @mozmark @ericlaw @ericlaw1979 @johnwilander",
          "createdAt": "2019-05-02T17:13:31Z",
          "updatedAt": "2019-05-02T17:13:31Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I've taken another pass at it, @morlovich. Mind taking another look?",
          "createdAt": "2019-05-02T19:55:27Z",
          "updatedAt": "2019-05-02T19:55:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMTk1NjEw",
          "commit": {
            "abbreviatedOid": "de1cacd"
          },
          "author": "morlovich",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-02T19:29:27Z",
          "updatedAt": "2019-05-02T19:33:41Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Does this mean that in a context that's not same-site-strict but same-site-lax, a same-site=lax cookie will not be settable by JavaScript? I am not sure such difference between JS and HTTP is desirable.\r\n\r\nHmm. I may be confused here between context's \"site for cookies\" and \"request\"'s client's \"site for cookies\" as used in section 5.2.\r\n\r\n(Also a typo in line 1451, regisgered)\r\n",
              "createdAt": "2019-05-02T19:29:27Z",
              "updatedAt": "2019-05-03T20:32:27Z"
            },
            {
              "originalPosition": 24,
              "body": "So I think this takes a different decision than the checking CL --- both in your and my takes on it --- on whether setting a strict cookie in a lax context is allowed.",
              "createdAt": "2019-05-02T19:33:20Z",
              "updatedAt": "2019-05-03T20:32:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMjA0NTQ3",
          "commit": {
            "abbreviatedOid": "de1cacd"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-02T19:50:41Z",
          "updatedAt": "2019-05-02T19:51:50Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "It's hard to be precise here, because this document doesn't have much relation to HTML. But, my goal is something like this:\r\n\r\nWhen the `document.cookie` setter is executed, execute the \"site for cookies\" algorithm from https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-5.2.1. That'll give you either the top-level document's origin's host's registrable domain, or an empty string.\r\n\r\nIn the case we're debating, it'll give you the registrable domain of the document that was just navigated-to. That is, both `samesite=strict` and `samesite=lax` will be settable.",
              "createdAt": "2019-05-02T19:50:42Z",
              "updatedAt": "2019-05-03T20:32:27Z"
            },
            {
              "originalPosition": 24,
              "body": "Yes, I'm not sure why I wrote this. The proposal I made in the bug was that `SameSite=*` would be settable from a top-level navigation. Let me take another stab at it. :)",
              "createdAt": "2019-05-02T19:51:46Z",
              "updatedAt": "2019-05-03T20:32:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNjU0NDgz",
          "commit": {
            "abbreviatedOid": "8050043"
          },
          "author": "ericlaw1979",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T20:19:08Z",
          "updatedAt": "2019-05-03T20:19:08Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\n        value, even if the new cookie wouldn't have been sent along with\r\n```",
              "createdAt": "2019-05-03T20:19:08Z",
              "updatedAt": "2019-05-03T20:32:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNjU0NjQ4",
          "commit": {
            "abbreviatedOid": "8050043"
          },
          "author": "ericlaw1979",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T20:19:32Z",
          "updatedAt": "2019-05-03T20:19:32Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\n        the request had it already existed prior to the navigation.\r\n```",
              "createdAt": "2019-05-03T20:19:32Z",
              "updatedAt": "2019-05-03T20:32:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNjU1MDQ0",
          "commit": {
            "abbreviatedOid": "8050043"
          },
          "author": "ericlaw1979",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "LGTM. Proposed a minor wording tweak to try to improve clarity for the subtle scenario in the note. ",
          "createdAt": "2019-05-03T20:20:32Z",
          "updatedAt": "2019-05-03T20:20:32Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ad6707f44912d24b7b95ba008a162ba36338d1b9",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "samesite-creation",
      "headRefOid": "0f4443d0b5759d3f14cf21e77312adad8f2eae25",
      "mergeCommit": {
        "oid": "49bcb4fddb8a8c294749ec9d81a236cde4df94b0"
      }
    },
    {
      "number": 803,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc1NTU4NTgx",
      "title": "[SH] Americanise spelling of serialise and parameterise",
      "url": "https://github.com/httpwg/http-extensions/pull/803",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It pains me, but I understand.  This changes the name of one of our types (including the section header), and (internal) section references, but I think it's still editorial.\r\n\r\nsee #791",
      "createdAt": "2019-05-03T00:02:29Z",
      "updatedAt": "2019-05-03T06:59:54Z",
      "closedAt": "2019-05-03T06:54:53Z",
      "mergedAt": "2019-05-03T06:54:53Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thansks.",
          "createdAt": "2019-05-03T06:54:59Z",
          "updatedAt": "2019-05-03T06:54:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMjg5MDky",
          "commit": {
            "abbreviatedOid": "80a3556"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T00:06:21Z",
          "updatedAt": "2019-05-03T00:06:21Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": ":thinking: ",
              "createdAt": "2019-05-03T00:06:21Z",
              "updatedAt": "2019-05-03T01:31:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMjk3ODkz",
          "commit": {
            "abbreviatedOid": "80a3556"
          },
          "author": "evert",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-03T01:02:27Z",
          "updatedAt": "2019-05-03T01:02:50Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "```suggestion\r\n   1. Let name be the result of applying Serializing a Key ({{ser-key}}) to mem's member-name.\r\n```",
              "createdAt": "2019-05-03T01:02:27Z",
              "updatedAt": "2019-05-03T01:31:42Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ad6707f44912d24b7b95ba008a162ba36338d1b9",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "791-SH-American-English",
      "headRefOid": "82e18c8f050d256417e8d9005e269ddd25a5938b",
      "mergeCommit": {
        "oid": "daf6dd38aa935436b6aa32ad9204f08f11c0ac90"
      }
    },
    {
      "number": 804,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc1NTY4NjYz",
      "title": "Proxy-Status: remove error restriction in http_response_status.",
      "url": "https://github.com/httpwg/http-extensions/pull/804",
      "state": "MERGED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Piotr Sikora <piotrsikora@google.com>",
      "createdAt": "2019-05-03T01:21:59Z",
      "updatedAt": "2019-05-03T06:58:05Z",
      "closedAt": "2019-05-03T06:58:05Z",
      "mergedAt": "2019-05-03T06:58:05Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is effectively editorial, since the error restriction was removed in https://github.com/mnot/I-D/commit/1be85db7a3ae0c8c93b970d1d2946831d292308a, where this type was renamed from `origin_http_error_status` to `http_response_status`, but the description didn't reflect that change.\r\n\r\ncc @mnot",
          "createdAt": "2019-05-03T01:24:29Z",
          "updatedAt": "2019-05-03T01:24:29Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ad6707f44912d24b7b95ba008a162ba36338d1b9",
      "headRepository": "PiotrSikora/http-extensions",
      "headRefName": "proxy-status-happy_path",
      "headRefOid": "1090d2685a4af2659d334c4deff5873802300122",
      "mergeCommit": {
        "oid": "618f44884b62a625bb7879b5327169ba33d876ec"
      }
    },
    {
      "number": 805,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc1NTY4OTUz",
      "title": "Proxy-Status: rename reminding FooCDN to SomeCDN.",
      "url": "https://github.com/httpwg/http-extensions/pull/805",
      "state": "MERGED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Reported by Rainer Jung.\r\n\r\nSigned-off-by: Piotr Sikora <piotrsikora@google.com>",
      "createdAt": "2019-05-03T01:24:38Z",
      "updatedAt": "2019-05-03T06:58:18Z",
      "closedAt": "2019-05-03T06:58:18Z",
      "mergedAt": "2019-05-03T06:58:18Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc @mnot",
          "createdAt": "2019-05-03T01:24:50Z",
          "updatedAt": "2019-05-03T01:24:50Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ad6707f44912d24b7b95ba008a162ba36338d1b9",
      "headRepository": "PiotrSikora/http-extensions",
      "headRefName": "proxy-status-foocdn",
      "headRefOid": "2d7370cfffbdb128e5ad0564f43c2f7fb3f881f6",
      "mergeCommit": {
        "oid": "1204dd83c2223da3675e56af9d84240f7fc977bb"
      }
    },
    {
      "number": 806,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc1NTY5MDE0",
      "title": "Proxy-Status: add Proxy Internal Response.",
      "url": "https://github.com/httpwg/http-extensions/pull/806",
      "state": "MERGED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Piotr Sikora <piotrsikora@google.com>",
      "createdAt": "2019-05-03T01:25:06Z",
      "updatedAt": "2019-07-03T04:19:56Z",
      "closedAt": "2019-07-03T04:19:56Z",
      "mergedAt": "2019-07-03T04:19:55Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc @mnot ",
          "createdAt": "2019-05-03T01:25:23Z",
          "updatedAt": "2019-05-03T01:25:23Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ad6707f44912d24b7b95ba008a162ba36338d1b9",
      "headRepository": "PiotrSikora/http-extensions",
      "headRefName": "proxy-status-internal_response",
      "headRefOid": "8d93494ac67d1ebe8c9d8f7542c000452010367b",
      "mergeCommit": {
        "oid": "91a494b563fd691067818e475f3dd1fbe1d3fea9"
      }
    },
    {
      "number": 811,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgwOTUxOTk4",
      "title": "Add draft-ietf-httpbis-http2-tls13.md",
      "url": "https://github.com/httpwg/http-extensions/pull/811",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Per @mcmanus, I've added a dummy artwork block to work around https://github.com/martinthomson/i-d-template/issues/188",
      "createdAt": "2019-05-21T21:14:37Z",
      "updatedAt": "2019-05-22T15:32:41Z",
      "closedAt": "2019-05-22T15:32:41Z",
      "mergedAt": "2019-05-22T15:32:41Z",
      "mergedBy": "mcmanus",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMzA1MDg0",
          "commit": {
            "abbreviatedOid": "8c4c04d"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-21T21:17:02Z",
          "updatedAt": "2019-05-21T21:17:03Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I just made up a label name. Let me know if there's something else I should be doing here.",
              "createdAt": "2019-05-21T21:17:02Z",
              "updatedAt": "2019-05-21T21:17:03Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "fc1aa3f5c5eee8fe57d9df6eeb9d28e347048cf8",
      "headRepository": "davidben/http-extensions",
      "headRefName": "http2-tls13",
      "headRefOid": "8c4c04daaba764a7f207574b2ecb96b3ebd9f7ad",
      "mergeCommit": {
        "oid": "dc19c72c927ed236c0589256c42f467a80be2a80"
      }
    },
    {
      "number": 812,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgxNTgxNTcx",
      "title": "http2-tls13: add standard WG boilerplate",
      "url": "https://github.com/httpwg/http-extensions/pull/812",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-05-23T12:13:53Z",
      "updatedAt": "2019-10-23T06:30:33Z",
      "closedAt": "2019-05-31T07:06:47Z",
      "mergedAt": "2019-05-31T07:06:47Z",
      "mergedBy": "reschke",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3cfe6de84653643828886fc9b516991fe4d77528",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-h2tls13-1",
      "headRefOid": "a8106b97a29eaa719a1c306867ea90484815f1d4",
      "mergeCommit": {
        "oid": "976834c57b51e2b8d57884069f7ff8cb13a66e93"
      }
    },
    {
      "number": 813,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgxNzcxNzI3",
      "title": "Remove workaround for addstyle.sed bug.",
      "url": "https://github.com/httpwg/http-extensions/pull/813",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "http2-tls13"
      ],
      "body": "Per\r\nhttps://github.com/martinthomson/i-d-template/pull/189#issuecomment-495170877,\r\nthe fix should be picked up automatically, but local copies will need to be\r\nupdated. cd lib && git pull appears to do the trick.",
      "createdAt": "2019-05-23T20:28:15Z",
      "updatedAt": "2019-07-22T21:20:05Z",
      "closedAt": "2019-07-22T21:19:43Z",
      "mergedAt": "2019-07-22T21:19:43Z",
      "mergedBy": "martinthomson",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3cfe6de84653643828886fc9b516991fe4d77528",
      "headRepository": "davidben/http-extensions",
      "headRefName": "remove-workaround",
      "headRefOid": "3b8b50eaf9f8598c1c9ad904f2bbbdc1e578ed0e",
      "mergeCommit": {
        "oid": "97ee65cd732f33226a2578b0194ebd2a1bd85334"
      }
    },
    {
      "number": 817,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzMTYxNjYx",
      "title": "Allow empty dictionaries and lists.",
      "url": "https://github.com/httpwg/http-extensions/pull/817",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #781.\r\n\r\nThis modifies parsing to consider empty or not-present header fields as\r\nempty containers; serialisation omits them from output.",
      "createdAt": "2019-07-01T02:59:13Z",
      "updatedAt": "2019-07-04T08:48:15Z",
      "closedAt": "2019-07-04T08:48:07Z",
      "mergedAt": "2019-07-04T08:48:06Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f4bbdbed4cc3dd7f58db3d32154d4c79787563ef",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-781",
      "headRefOid": "700f31735433dcd8007a80f9cafc5bafd4f54e70",
      "mergeCommit": {
        "oid": "bf9f8f5ef60c2ffa5eae3be8d346a352daa05ec7"
      }
    },
    {
      "number": 818,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzMTc1MTQy",
      "title": "Change parameterized lists to have primary items",
      "url": "https://github.com/httpwg/http-extensions/pull/818",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #797.",
      "createdAt": "2019-07-01T04:36:43Z",
      "updatedAt": "2019-07-04T07:50:41Z",
      "closedAt": "2019-07-04T07:50:37Z",
      "mergedAt": "2019-07-04T07:50:37Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4cff455820c42b7f781348d48ad8f90c18e11c2c",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-797",
      "headRefOid": "98148345532a92c608f33d424c85020771ed5671",
      "mergeCommit": {
        "oid": "f4bbdbed4cc3dd7f58db3d32154d4c79787563ef"
      }
    },
    {
      "number": 820,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzMjEyNjIy",
      "title": "Structured Headers: Allow lists as dictionary values.",
      "url": "https://github.com/httpwg/http-extensions/pull/820",
      "state": "CLOSED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "This patch allows 'inner-list' as a valid dictionary member value. Fixes #816.",
      "createdAt": "2019-07-01T07:26:24Z",
      "updatedAt": "2019-10-28T09:58:11Z",
      "closedAt": "2019-08-26T05:46:44Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "What about the algorithms? Particularly the parsing one...",
          "createdAt": "2019-07-01T08:28:07Z",
          "updatedAt": "2019-07-01T08:28:07Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "^^ what @phluid61 said.",
          "createdAt": "2019-07-01T08:46:11Z",
          "updatedAt": "2019-07-01T08:46:11Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Ah. Yes. That was dumb. I took a first pass at the algorithms in https://github.com/httpwg/http-extensions/pull/820/commits/2ab04f852459cb135f65288ad37da592b06ac757. The core of it is to reuse \"Parsing/Serializing a List\"'s logic by passing in \"Inner\" or \"Outer\". I'm not sure if this makes things more or less complex to follow. :)\r\n\r\nTwo stylistic questions:\r\n\r\n1.  Some places in the text use the \"result of [ALGORITHM]\". Others the \"result of applying [ALGORITHM]\", others \"running [ALGORITHM]\". Some pass in arguments, others leave them inferred. What would you like this patch to do? :)\r\n\r\n2.  COMMA is spelled out in algorithms, while \";\" is not (nor are \"-\", \"_\", \"-\", etc). There's probably a reason for this, but I don't understand it. Is it an ABNF grammar thing? Is COMMA actually a set of characters?\r\n\r\nAnd, as noted in the issue, these algorithm rely on quite a bit of magical knowledge of type expectations. That makes me uncomfortable as someone who might someday need to write a parser in Chromium...",
          "createdAt": "2019-07-01T09:38:39Z",
          "updatedAt": "2019-07-01T09:38:39Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OBE",
          "createdAt": "2019-08-26T05:46:44Z",
          "updatedAt": "2019-08-26T05:46:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2MTk0MTgx",
          "commit": {
            "abbreviatedOid": "b2ed9ba"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-01T08:24:46Z",
          "updatedAt": "2019-07-01T08:24:47Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "ABNF alteration is `/` (sorry, I probably misled you into that)",
              "createdAt": "2019-07-01T08:24:46Z",
              "updatedAt": "2019-07-01T09:30:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2MTk0NDk4",
          "commit": {
            "abbreviatedOid": "b2ed9ba"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-01T08:25:30Z",
          "updatedAt": "2019-07-01T08:25:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Hmm, I don't think the reference to `list` is appropriate here; probably just say \"arrays thereof.\"",
              "createdAt": "2019-07-01T08:25:30Z",
              "updatedAt": "2019-07-01T09:30:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2MTk0OTQ2",
          "commit": {
            "abbreviatedOid": "b2ed9ba"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-01T08:26:24Z",
          "updatedAt": "2019-07-01T08:26:24Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Big question here is whether we should refactor List and ListOfLists to be just List with this kind of production as well -- but that's a separable issue.",
              "createdAt": "2019-07-01T08:26:24Z",
              "updatedAt": "2019-07-01T09:30:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2MjI2MjM1",
          "commit": {
            "abbreviatedOid": "2ab04f8"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-01T09:29:23Z",
          "updatedAt": "2019-07-01T09:29:23Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": ":+1: ",
              "createdAt": "2019-07-01T09:29:23Z",
              "updatedAt": "2019-07-01T09:30:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2MjI2MzE5",
          "commit": {
            "abbreviatedOid": "2ab04f8"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-01T09:29:30Z",
          "updatedAt": "2019-07-01T09:29:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": ":+1: ",
              "createdAt": "2019-07-01T09:29:30Z",
              "updatedAt": "2019-07-01T09:30:00Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e53d0574ddbd4b3bb0db4ddf2786567f112d3e0a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "dictionary-of-lists",
      "headRefOid": "a564d63c5da82f98bb4a3f4096e594aaddd627a3",
      "mergeCommit": null
    },
    {
      "number": 823,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzNjM3OTc2",
      "title": "Add digest headers draft.",
      "url": "https://github.com/httpwg/http-extensions/pull/823",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nFix: #822. \r\n\r\nAdds the digest-headers draft to the repository.\r\n\r\nThe original repository, with the issues to be migrated, is here:\r\n\r\n  - https://github.com/ioggstream/draft-polli-resource-digests-http\r\n\r\n",
      "createdAt": "2019-07-02T08:24:49Z",
      "updatedAt": "2019-07-03T08:29:06Z",
      "closedAt": "2019-07-03T07:53:10Z",
      "mergedAt": "2019-07-03T07:53:10Z",
      "mergedBy": "ioggstream",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Looks good to me.",
          "createdAt": "2019-07-03T01:33:05Z",
          "updatedAt": "2019-07-03T01:33:05Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot Do you or @reschke  want to merge? Can I proceed by myself?",
          "createdAt": "2019-07-03T07:34:33Z",
          "updatedAt": "2019-07-03T07:34:33Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@ioggstream give it a try.",
          "createdAt": "2019-07-03T07:36:34Z",
          "updatedAt": "2019-07-03T07:36:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NzQwOTQ4",
          "commit": {
            "abbreviatedOid": "e673381"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-02T08:32:43Z",
          "updatedAt": "2019-07-02T08:34:55Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Remove abbreviation; title is short enough.",
              "createdAt": "2019-07-02T08:32:43Z",
              "updatedAt": "2019-07-03T07:27:57Z"
            },
            {
              "originalPosition": 4,
              "body": "need to be draft-ietf-httpbis...",
              "createdAt": "2019-07-02T08:33:06Z",
              "updatedAt": "2019-07-03T07:27:57Z"
            },
            {
              "originalPosition": 8,
              "body": "Applications and Real-Time",
              "createdAt": "2019-07-02T08:34:04Z",
              "updatedAt": "2019-07-03T07:27:57Z"
            },
            {
              "originalPosition": 9,
              "body": "HTTP",
              "createdAt": "2019-07-02T08:34:06Z",
              "updatedAt": "2019-07-03T07:27:57Z"
            },
            {
              "originalPosition": 10,
              "body": "remove",
              "createdAt": "2019-07-02T08:34:07Z",
              "updatedAt": "2019-07-03T07:27:57Z"
            },
            {
              "originalPosition": 120,
              "body": "need to adjust for HTTP WG Github.",
              "createdAt": "2019-07-02T08:34:50Z",
              "updatedAt": "2019-07-03T07:27:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NzUxMjAw",
          "commit": {
            "abbreviatedOid": "e673381"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-02T08:51:45Z",
          "updatedAt": "2019-07-02T08:51:45Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "should I put something else here, eg. \"Digest\" ?\r\n\r\n",
              "createdAt": "2019-07-02T08:51:45Z",
              "updatedAt": "2019-07-03T07:27:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2ODM4NDYz",
          "commit": {
            "abbreviatedOid": "ed5a0e6"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-02T11:47:09Z",
          "updatedAt": "2019-07-02T11:47:10Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Sure.",
              "createdAt": "2019-07-02T11:47:09Z",
              "updatedAt": "2019-07-03T07:27:57Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e53d0574ddbd4b3bb0db4ddf2786567f112d3e0a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "822-digest-headers",
      "headRefOid": "5571466268b6f5d9873ba93efa53166edfb8adbf",
      "mergeCommit": {
        "oid": "8454a6ede4f1676c833d35105db0309da157d8f4"
      }
    },
    {
      "number": 824,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0MDEzODI1",
      "title": "Mnot 816",
      "url": "https://github.com/httpwg/http-extensions/pull/824",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Proposal for #816. ",
      "createdAt": "2019-07-03T06:00:21Z",
      "updatedAt": "2019-07-04T07:49:33Z",
      "closedAt": "2019-07-04T07:49:29Z",
      "mergedAt": "2019-07-04T07:49:29Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MjkzMDU0",
          "commit": {
            "abbreviatedOid": "7c2f758"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T07:03:53Z",
          "updatedAt": "2019-07-03T07:03:53Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Would it be possible to add param-item as an option here?\r\n\r\nConsidering the fact that list and parameterized list are the two compound types that can use a `;` separator, I think it would be beneficial to allow both, for example when defining a new Cache-Control directive that takes a parameterized list as an argument (pretending that Cache-Control is a SH header).",
              "createdAt": "2019-07-03T07:03:53Z",
              "updatedAt": "2019-07-04T02:53:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MzAwNTE3",
          "commit": {
            "abbreviatedOid": "7c2f758"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T07:22:12Z",
          "updatedAt": "2019-07-03T07:22:13Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "If we added param-item here, it would have the effect of collapsing parameterised lists into lists -- which is possible, I think (if we could define a sane parsing algorithm that could tell the difference). \r\n\r\nHowever, that doesn't seem like what you're asking for. Cache-Control maps to a dictionary; if you allowed a dictionary member to be a parameterised item, what would that look like?",
              "createdAt": "2019-07-03T07:22:12Z",
              "updatedAt": "2019-07-04T02:53:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MzUzMDI3",
          "commit": {
            "abbreviatedOid": "7c2f758"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T09:05:22Z",
          "updatedAt": "2019-07-03T09:05:23Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Doesn't that undo #443 and bring back the [atomic-or-complex problem](https://github.com/httpwg/http-extensions/issues/443#issuecomment-362997206)?",
              "createdAt": "2019-07-03T09:05:22Z",
              "updatedAt": "2019-07-04T02:53:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3ODA5ODMz",
          "commit": {
            "abbreviatedOid": "746a1f7"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T03:03:02Z",
          "updatedAt": "2019-07-04T03:03:02Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "@phluid61 Thanks for pointing that out. OTOH, am I correct in assuming that the reason we handled #443 that way is because we did not know of a good way to resolve the issue?\r\n\r\nIf that is the case, this might be the correct moment to revisit the issue, now that we are leaning towards having surrounding parens.",
              "createdAt": "2019-07-04T03:03:02Z",
              "updatedAt": "2019-07-04T03:03:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3ODEwNDQz",
          "commit": {
            "abbreviatedOid": "746a1f7"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T03:06:53Z",
          "updatedAt": "2019-07-04T03:06:53Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "@mnot \r\n> However, that doesn't seem like what you're asking for. Cache-Control maps to a dictionary;\r\n\r\nApologies. I should have left my comment where the change for the Dictionary is made.\r\n\r\n>  if you allowed a dictionary member to be a parameterised item, what would that look like?\r\n\r\nWhat I have in mind is something like `Cache-Control: no-cache, mydirective arg1=a;arg2=b`.",
              "createdAt": "2019-07-04T03:06:53Z",
              "updatedAt": "2019-07-04T03:06:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3ODI5ODg0",
          "commit": {
            "abbreviatedOid": "746a1f7"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T05:10:04Z",
          "updatedAt": "2019-07-04T05:10:04Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I think what you're asking for there essentially is a Parameterised Dictionary. I'd do it as something like \r\n\r\n~~~\r\nExample: foo=1, bar=2;a=b;c=d\r\n~~~\r\n\r\n... but that's just a fairly minor syntactic difference. Could you open an issue for that?",
              "createdAt": "2019-07-04T05:10:04Z",
              "updatedAt": "2019-07-04T05:10:04Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "91a494b563fd691067818e475f3dd1fbe1d3fea9",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-816",
      "headRefOid": "746a1f7e3bc9a5a425330fd238320657bf4fc0e4",
      "mergeCommit": {
        "oid": "4cff455820c42b7f781348d48ad8f90c18e11c2c"
      }
    },
    {
      "number": 826,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0MDYwNzUz",
      "title": "Fix: #825. Add post -00 sections.",
      "url": "https://github.com/httpwg/http-extensions/pull/826",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\n- [x] adds post-00 sections as per SUBMITTING.md\r\n\r\nFixes #825",
      "createdAt": "2019-07-03T08:36:30Z",
      "updatedAt": "2019-09-06T10:23:48Z",
      "closedAt": "2019-09-06T10:23:47Z",
      "mergedAt": "2019-09-06T10:23:47Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8729a2d9981e37a7fa060ca6993a4f78dd5e81a4",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-825",
      "headRefOid": "1517e603c2955a4f70fb57d0e6aacb1e8006e33c",
      "mergeCommit": {
        "oid": "fca731ac11fc9fcf240fb181c82b37ec0d2789a9"
      }
    },
    {
      "number": 829,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0MDY1OTgy",
      "title": "Fix: #827. typo in reference: FIPS-180 -> FIPS180",
      "url": "https://github.com/httpwg/http-extensions/pull/829",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nfixes typo in reference #827 ",
      "createdAt": "2019-07-03T08:50:39Z",
      "updatedAt": "2019-10-23T06:30:32Z",
      "closedAt": "2019-07-03T09:10:39Z",
      "mergedAt": "2019-07-03T09:10:39Z",
      "mergedBy": "ioggstream",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FYI, there is (at least) a 180-4 now.",
          "createdAt": "2019-07-04T04:16:10Z",
          "updatedAt": "2019-07-04T04:16:10Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4b75cc62f202412e4bf09c0f81edab6ee86cb875",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-827",
      "headRefOid": "c3812b7ff5013e28d5ec3f983628835d71b696b8",
      "mergeCommit": {
        "oid": "c1968d51dc1598222d01c01489ad76c7a6be2176"
      }
    },
    {
      "number": 830,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0MDc1Mzcz",
      "title": "Digest: move Acks section to end (and make it unnumbered)",
      "url": "https://github.com/httpwg/http-extensions/pull/830",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "",
      "createdAt": "2019-07-03T09:15:12Z",
      "updatedAt": "2019-10-23T06:30:31Z",
      "closedAt": "2019-07-03T10:59:24Z",
      "mergedAt": "2019-07-03T10:59:24Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c1968d51dc1598222d01c01489ad76c7a6be2176",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-digest-1",
      "headRefOid": "fb8065892eb110f06d44c627033cb36d6d473bf8",
      "mergeCommit": {
        "oid": "ed226bc792450eb9db875e91a036e57c9e0580b7"
      }
    },
    {
      "number": 833,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0MDkyNTg3",
      "title": "Fix unused references",
      "url": "https://github.com/httpwg/http-extensions/pull/833",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nFixes unused references.    \r\n\r\n- Removed reference to FIPS180-4 and opened issue #832\r\n- Removed unneeded references\r\n- Uses required references.",
      "createdAt": "2019-07-03T09:58:04Z",
      "updatedAt": "2019-07-03T10:17:03Z",
      "closedAt": "2019-07-03T10:16:57Z",
      "mergedAt": "2019-07-03T10:16:57Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Mzg1MjMx",
          "commit": {
            "abbreviatedOid": "cca294e"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T10:02:01Z",
          "updatedAt": "2019-07-03T10:02:09Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I'm not sure if you want to remove FIPS180-4, or if you want to update references to FIPS180-3 to point to FIPS180-4. Then remove FIPS180-3.\r\n\r\nNote that references to FIPS180-1 are due to historical reference, e.g. an algorithm that was removed from later drafts.",
              "createdAt": "2019-07-03T10:02:01Z",
              "updatedAt": "2019-07-03T10:10:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Mzg1ODIy",
          "commit": {
            "abbreviatedOid": "cca294e"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T10:03:07Z",
          "updatedAt": "2019-07-03T10:03:08Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Oh, I just saw https://github.com/httpwg/http-extensions/issues/832",
              "createdAt": "2019-07-03T10:03:08Z",
              "updatedAt": "2019-07-03T10:10:48Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c1968d51dc1598222d01c01489ad76c7a6be2176",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-831",
      "headRefOid": "b6681fd285ed2e57fd99bdc7c1edad91a60a2097",
      "mergeCommit": {
        "oid": "af9c035a0d9df57166ef917a36a20ce0c967e51f"
      }
    },
    {
      "number": 835,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0MTA0Njc1",
      "title": "Fix: #834. Add -latest to docname.",
      "url": "https://github.com/httpwg/http-extensions/pull/835",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nAdds -latest to docname",
      "createdAt": "2019-07-03T10:31:21Z",
      "updatedAt": "2019-07-03T10:39:12Z",
      "closedAt": "2019-07-03T10:38:52Z",
      "mergedAt": "2019-07-03T10:38:52Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "af9c035a0d9df57166ef917a36a20ce0c967e51f",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-834",
      "headRefOid": "5976815deab2b4e272742d7378a62ad3dde5f1a4",
      "mergeCommit": {
        "oid": "a627dfa54201c822e916f46e7f3f9c8bdbb0a2d2"
      }
    },
    {
      "number": 837,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0MTEwMzY5",
      "title": "Fix: #836. Remove citations from abstracts.",
      "url": "https://github.com/httpwg/http-extensions/pull/837",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nremoves citations from abstract.",
      "createdAt": "2019-07-03T10:47:54Z",
      "updatedAt": "2019-07-03T10:55:21Z",
      "closedAt": "2019-07-03T10:54:46Z",
      "mergedAt": "2019-07-03T10:54:46Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a627dfa54201c822e916f46e7f3f9c8bdbb0a2d2",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-836",
      "headRefOid": "9c77fa47879050de5aec39fa6a18a722f480b86a",
      "mergeCommit": {
        "oid": "d70ba0c09463b8614b665c8ed76ea31482c158a3"
      }
    },
    {
      "number": 838,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0MTE1MDcy",
      "title": "use standard form for referring to RFCs",
      "url": "https://github.com/httpwg/http-extensions/pull/838",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "see https://tools.ietf.org/html/rfc7322#section-3.5",
      "createdAt": "2019-07-03T11:01:11Z",
      "updatedAt": "2019-09-06T10:26:25Z",
      "closedAt": "2019-07-03T11:05:44Z",
      "mergedAt": "2019-07-03T11:05:44Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ed226bc792450eb9db875e91a036e57c9e0580b7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-digest-2",
      "headRefOid": "00bf5ff078e84c84e9a26231bb10b33447fe954c",
      "mergeCommit": {
        "oid": "bdbf7a0621d0316673567305dd4f79264d587fe9"
      }
    },
    {
      "number": 841,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0NDc0MzEw",
      "title": "Roughing in collapse of ParamList into List",
      "url": "https://github.com/httpwg/http-extensions/pull/841",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "For #839",
      "createdAt": "2019-07-04T08:24:44Z",
      "updatedAt": "2019-07-07T23:17:57Z",
      "closedAt": "2019-07-07T23:17:53Z",
      "mergedAt": "2019-07-07T23:17:53Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "bf9f8f5ef60c2ffa5eae3be8d346a352daa05ec7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-839",
      "headRefOid": "94629cef38c2cb0710eac35b803913f41d45bed5",
      "mergeCommit": {
        "oid": "b29172e567e1702c9e3b04ed6b7f0ed07fcc969f"
      }
    },
    {
      "number": 843,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0NzA5MzU4",
      "title": "Rough in Proxy-Info",
      "url": "https://github.com/httpwg/http-extensions/pull/843",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "proxy-status"
      ],
      "body": "For #821",
      "createdAt": "2019-07-05T01:42:39Z",
      "updatedAt": "2020-03-13T04:27:58Z",
      "closedAt": "2019-11-28T05:04:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY0MTM2NTA2",
          "commit": {
            "abbreviatedOid": "7e93cab"
          },
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-19T10:32:24Z",
          "updatedAt": "2019-07-19T10:48:46Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Nit: details details.",
              "createdAt": "2019-07-19T10:32:25Z",
              "updatedAt": "2019-07-19T10:48:46Z"
            },
            {
              "originalPosition": 30,
              "body": "That isn't always true, though. e.g. `Proxy-Status: http_response_incomplete` could be sent in a trailer of an incomplete response.",
              "createdAt": "2019-07-19T10:35:05Z",
              "updatedAt": "2019-07-19T10:48:46Z"
            },
            {
              "originalPosition": 51,
              "body": "I really don't like the fact that the identifier is now the primary-id, and not `\"node\"` parameter  like in `Proxy-Status` and `Cache`.",
              "createdAt": "2019-07-19T10:37:19Z",
              "updatedAt": "2019-07-19T10:48:46Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "bf9f8f5ef60c2ffa5eae3be8d346a352daa05ec7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-821",
      "headRefOid": "7e93cab1dda95f250a01f6c9eafd991fdfd39a4e",
      "mergeCommit": null
    },
    {
      "number": 846,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1Mjg3NDAz",
      "title": "digests: fix ref to Appendix B of RFC 7231",
      "url": "https://github.com/httpwg/http-extensions/pull/846",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-08T11:12:03Z",
      "updatedAt": "2019-10-23T06:30:30Z",
      "closedAt": "2019-07-08T15:06:46Z",
      "mergedAt": "2019-07-08T15:06:46Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4ODM4NTM5",
          "commit": {
            "abbreviatedOid": "bf04a77"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T11:20:08Z",
          "updatedAt": "2019-07-08T11:20:08Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "94fdcbba0fd1cf01e026451769f3a17e04721a19",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-digest-3",
      "headRefOid": "bf04a77ac006fce2caed790746ca10229a307d92",
      "mergeCommit": {
        "oid": "55327bc8c555018e6ae00d0450b82b4439fcb1de"
      }
    },
    {
      "number": 847,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1Mjk1MDQ1",
      "title": "digest: consistency \"header\" vs \"header field\"",
      "url": "https://github.com/httpwg/http-extensions/pull/847",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-08T11:35:14Z",
      "updatedAt": "2019-10-23T06:30:29Z",
      "closedAt": "2019-07-08T15:06:31Z",
      "mergedAt": "2019-07-08T15:06:31Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4ODc1NjQ1",
          "commit": {
            "abbreviatedOid": "f8177aa"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T12:45:13Z",
          "updatedAt": "2019-07-08T12:45:13Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "94fdcbba0fd1cf01e026451769f3a17e04721a19",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-digest-4",
      "headRefOid": "f8177aa8963e5cdaf8e8f24e9a9f6b619c2db6cd",
      "mergeCommit": {
        "oid": "4c09f7c9f2b9531a446b12797c483e7ca642c659"
      }
    },
    {
      "number": 856,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk2MjYzNTE4",
      "title": "Make OPTIONAL violation report keys clearer",
      "url": "https://github.com/httpwg/http-extensions/pull/856",
      "state": "OPEN",
      "author": "freddieleeman",
      "authorAssociation": "FIRST_TIME_CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "expect-ct"
      ],
      "body": "Although the document describes the 'test-report' as optional, this is not communicated in #generating-a-violation-report. I have updated the 'scheme' key description to match the new 'test-report' key description.",
      "createdAt": "2019-07-10T17:02:08Z",
      "updatedAt": "2019-07-22T21:18:31Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4c924d66d99a5d38a436dc1e673c5b451b208026",
      "headRepository": "freddieleeman/http-extensions",
      "headRefName": "freddieleeman-report-optional-key-clarify",
      "headRefOid": "3922094603dd56f446c3e8287d2feb1abe808638",
      "mergeCommit": null
    },
    {
      "number": 857,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk3MzY3NDcx",
      "title": "sh: missing parentheses around reference",
      "url": "https://github.com/httpwg/http-extensions/pull/857",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "",
      "createdAt": "2019-07-14T04:59:26Z",
      "updatedAt": "2019-07-14T05:10:09Z",
      "closedAt": "2019-07-14T05:10:04Z",
      "mergedAt": "2019-07-14T05:10:04Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4c924d66d99a5d38a436dc1e673c5b451b208026",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-sh-par",
      "headRefOid": "b206f9974437e179358919e275dc5fcd4ee0a967",
      "mergeCommit": {
        "oid": "628aeab41e5b310c52fbc8f3c98cdb4d2e72c715"
      }
    },
    {
      "number": 858,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk3MzY5MzAz",
      "title": "sh: more misformatted references",
      "url": "https://github.com/httpwg/http-extensions/pull/858",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "",
      "createdAt": "2019-07-14T05:41:32Z",
      "updatedAt": "2019-07-14T06:06:20Z",
      "closedAt": "2019-07-14T06:06:17Z",
      "mergedAt": "2019-07-14T06:06:17Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "628aeab41e5b310c52fbc8f3c98cdb4d2e72c715",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-sh-refs",
      "headRefOid": "9544c54bf9fb1543016fc00cbab7b75a8ce2799f",
      "mergeCommit": {
        "oid": "376bfe2797e42a10e4d76c878293d103c4183e46"
      }
    },
    {
      "number": 859,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk3MzY5NjQ1",
      "title": "sh: missing artwork annotation",
      "url": "https://github.com/httpwg/http-extensions/pull/859",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "",
      "createdAt": "2019-07-14T05:49:12Z",
      "updatedAt": "2019-07-14T06:06:49Z",
      "closedAt": "2019-07-14T06:06:44Z",
      "mergedAt": "2019-07-14T06:06:44Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "628aeab41e5b310c52fbc8f3c98cdb4d2e72c715",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-sh-artwork",
      "headRefOid": "92532852f46053724035c0e45eb5fc192408dfa9",
      "mergeCommit": {
        "oid": "55d2c1e1f02fbbd5b29d774f9f573fabea179072"
      }
    },
    {
      "number": 860,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk4ODQ2NDAz",
      "title": "Clarify defined headers are response headers",
      "url": "https://github.com/httpwg/http-extensions/pull/860",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Closes #761 \r\n\r\n@dbaron - can you take a look and see if that clarifies things?",
      "createdAt": "2019-07-18T10:16:40Z",
      "updatedAt": "2019-07-25T14:40:58Z",
      "closedAt": "2019-07-25T14:40:58Z",
      "mergedAt": "2019-07-25T14:40:58Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "dbaron",
          "authorAssociation": "NONE",
          "body": "This seems helpful given what's currently in the spec.\r\n\r\nHowever, I think some of the material I was talking about when I filed #761 is no longer there.  But I suspect that material may now be in other specs, and could perhaps still gain from being clarified at its current location.",
          "createdAt": "2019-07-18T18:53:23Z",
          "updatedAt": "2019-07-18T18:53:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY2NjczNTcz",
          "commit": {
            "abbreviatedOid": "8061efc"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "lgtm, thank you!",
          "createdAt": "2019-07-25T14:40:52Z",
          "updatedAt": "2019-07-25T14:40:52Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5658199e633c6cc81bbb753f4c5d3d59a98185ec",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "request_vs_response",
      "headRefOid": "8061efc398f467e07e8c0cafd099160180263d90",
      "mergeCommit": {
        "oid": "94bbf5f80d4f0f64bdb50305fe780838ad1a78c9"
      }
    },
    {
      "number": 861,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk4OTI2NjU3",
      "title": "Replace Key with Variants",
      "url": "https://github.com/httpwg/http-extensions/pull/861",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Closes #730\r\n\r\n@mnot - It's not very descriptive, and seems like each CH feature will have to specify its own Variants model, but mentioning it seems like a good idea. Also, I'm not sure how to setup the related links in a nicer way.",
      "createdAt": "2019-07-18T13:58:15Z",
      "updatedAt": "2019-07-25T14:34:23Z",
      "closedAt": "2019-07-25T14:34:23Z",
      "mergedAt": "2019-07-25T14:34:23Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Seems like a good start.",
          "createdAt": "2019-07-20T14:36:27Z",
          "updatedAt": "2019-07-20T14:36:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY1MDkxNjIz",
          "commit": {
            "abbreviatedOid": "b7ff79a"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-22T22:35:28Z",
          "updatedAt": "2019-07-22T22:36:07Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Please use `{{I-D.ietf-httpbis-variants}}` rather than a URI.\r\n\r\n```suggestion\r\nClient Hints may be combined with Variants response header field {{?VARIANTS=I-D.ietf-httpbis-variants}} to enable fine-grained control of the cache key for improved cache efficiency.\r\n```",
              "createdAt": "2019-07-22T22:35:28Z",
              "updatedAt": "2019-07-22T22:49:44Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nFeatures that define Client Hints will need to specify the related variants algorithms as described in Section 6 of {{?VARIANTS}}.\r\n```",
              "createdAt": "2019-07-22T22:35:56Z",
              "updatedAt": "2019-07-22T22:49:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY2NjY4Nzgx",
          "commit": {
            "abbreviatedOid": "70f0838"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "\ud83d\udc4d ",
          "createdAt": "2019-07-25T14:34:08Z",
          "updatedAt": "2019-07-25T14:34:08Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "55d2c1e1f02fbbd5b29d774f9f573fabea179072",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "variants",
      "headRefOid": "70f0838c1928d31d620624fe40dc3ec420d4f6f5",
      "mergeCommit": {
        "oid": "5658199e633c6cc81bbb753f4c5d3d59a98185ec"
      }
    },
    {
      "number": 862,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk4OTM5MTQ5",
      "title": "[Client Hints] Replace ABNF with Structured Headers",
      "url": "https://github.com/httpwg/http-extensions/pull/862",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Closes #700\r\n\r\n@mnot - can you take a look?",
      "createdAt": "2019-07-18T14:25:27Z",
      "updatedAt": "2019-07-25T14:32:50Z",
      "closedAt": "2019-07-25T14:32:50Z",
      "mergedAt": "2019-07-25T14:32:50Z",
      "mergedBy": "igrigorik",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYzOTQ5ODUx",
          "commit": {
            "abbreviatedOid": "1f3837e"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-18T23:08:29Z",
          "updatedAt": "2019-07-18T23:08:29Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Does this want the `#`?",
              "createdAt": "2019-07-18T23:08:29Z",
              "updatedAt": "2019-07-21T19:27:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY0MDA3NjM1",
          "commit": {
            "abbreviatedOid": "790f4fa"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-19T04:18:47Z",
          "updatedAt": "2019-07-19T04:18:47Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Nope. Thanks for catching that!",
              "createdAt": "2019-07-19T04:18:47Z",
              "updatedAt": "2019-07-21T19:27:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY0NDk5NTM2",
          "commit": {
            "abbreviatedOid": "790f4fa"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-20T14:35:09Z",
          "updatedAt": "2019-07-20T14:35:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "`sh-list-of-tokens` hasn't been defined as ABNF; you probably need to use just `sh-list` and say its contents are tokens in prose.",
              "createdAt": "2019-07-20T14:35:09Z",
              "updatedAt": "2019-07-21T19:27:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY2NjY2NTA4",
          "commit": {
            "abbreviatedOid": "fb33487"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-25T14:30:59Z",
          "updatedAt": "2019-07-25T14:31:00Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Thanks, fixed it!",
              "createdAt": "2019-07-25T14:31:00Z",
              "updatedAt": "2019-07-25T14:31:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY2NjY3NzA2",
          "commit": {
            "abbreviatedOid": "fb33487"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Based on group discussion at IETF, everyone is on board.\r\n\r\n\ud83d\udc4d ",
          "createdAt": "2019-07-25T14:32:38Z",
          "updatedAt": "2019-07-25T14:32:38Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "55d2c1e1f02fbbd5b29d774f9f573fabea179072",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "structured_headers",
      "headRefOid": "fb33487f1d80033063e8bd3f824fb8dd13cae13e",
      "mergeCommit": {
        "oid": "4eeac2584cf60bf0488bc8c83b7494327afa0a90"
      }
    },
    {
      "number": 864,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk5Mjc3MzA2",
      "title": "Proxy-Status: merge tls_unexpected_peer_{certificate,identity}.",
      "url": "https://github.com/httpwg/http-extensions/pull/864",
      "state": "MERGED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #819.\r\n\r\nSigned-off-by: Piotr Sikora <piotrsikora@google.com>",
      "createdAt": "2019-07-19T10:28:27Z",
      "updatedAt": "2019-07-20T14:33:09Z",
      "closedAt": "2019-07-20T14:33:09Z",
      "mergedAt": "2019-07-20T14:33:09Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc @mnot ",
          "createdAt": "2019-07-19T10:53:37Z",
          "updatedAt": "2019-07-19T10:53:37Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "55d2c1e1f02fbbd5b29d774f9f573fabea179072",
      "headRepository": "PiotrSikora/http-extensions",
      "headRefName": "tls_unexpected_peer_certificate",
      "headRefOid": "77e0218d84d7c17fa5f530b50aaa46cede9e6493",
      "mergeCommit": {
        "oid": "ff9f03b97d05ebe7e899a5d5c869a31d2d609696"
      }
    },
    {
      "number": 865,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk5Mjc3MzE4",
      "title": "Proxy-Status: replace last occurrence of \"details\".",
      "url": "https://github.com/httpwg/http-extensions/pull/865",
      "state": "MERGED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "proxy-status"
      ],
      "body": "Signed-off-by: Piotr Sikora <piotrsikora@google.com>",
      "createdAt": "2019-07-19T10:28:28Z",
      "updatedAt": "2019-10-18T18:49:38Z",
      "closedAt": "2019-10-18T18:49:38Z",
      "mergedAt": "2019-10-18T18:49:38Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc @mnot ",
          "createdAt": "2019-07-19T10:53:42Z",
          "updatedAt": "2019-07-19T10:53:42Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "55d2c1e1f02fbbd5b29d774f9f573fabea179072",
      "headRepository": "PiotrSikora/http-extensions",
      "headRefName": "proxy_internal_error",
      "headRefOid": "02bd44b30a5c95977e3dd80694feafd8709007a5",
      "mergeCommit": {
        "oid": "26f29e097b8729e0cff00fe610a18ce204d9682e"
      }
    },
    {
      "number": 866,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk5NTg1MTIy",
      "title": "Add an Alt-Svc extension",
      "url": "https://github.com/httpwg/http-extensions/pull/866",
      "state": "CLOSED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "In order to enable first view Client Hints with [HTTPSSVC](https://tools.ietf.org/html/draft-nygren-httpbis-httpssvc-01), this PR adds an Alt-Svc extension to Client Hints",
      "createdAt": "2019-07-20T19:17:19Z",
      "updatedAt": "2019-07-25T14:33:42Z",
      "closedAt": "2019-07-25T14:33:41Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We probably need to think a bit about the security model for sticking random things into HTTPSSVC by way of Alt-Svc. (I'm a little torn on whether HTTPSSVC should actually align with the Alt-Svc HTTP header. They do very similar things, but the authentication is very different.)\r\n\r\nWhen the client fetches HTTPSSVC from DNS, there is no authentication from the actual origin server. Even if using DoH, DoH only authenticates the resolver. The resolver could still inject things. (I'm ignoring DNSSEC here as that's not really a thing on the web today.)\r\n\r\nOf the features in HTTPSSVC right now, alias records and remote Alt-Svc are just funny CNAMEs. The resolver can deny you access to the server, up to the record's TTL, but that is already true. Injecting a bad QUIC advertisement is similar. Injecting an invalid ESNI key can likewise just deny access to the server or cause the client to encrypt the SNI badly. The DNS resolver, already learns the SNI, so that's consistent. (It would not be okay to, e.g., just use the ESNI key as-is to replace the TLS certificate because of this.)\r\n\r\nClient hints affects the HTTP requests we'd actually send over TLS, so that has different properties to think through.",
          "createdAt": "2019-07-22T19:20:16Z",
          "updatedAt": "2019-07-22T19:20:16Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that this can be deferred.  I appreciate the thinking behind this, but it seems like it might jeopardize the possible near-term success of CH.",
          "createdAt": "2019-07-22T21:37:45Z",
          "updatedAt": "2019-07-22T21:37:45Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "related issue is #871 ",
          "createdAt": "2019-07-22T21:41:48Z",
          "updatedAt": "2019-07-22T21:41:48Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think that this can be deferred. I appreciate the thinking behind this, but it seems like it might jeopardize the possible near-term success of CH.\r\n\r\n@martinthomson - Thanks. That's useful feedback!",
          "createdAt": "2019-07-22T21:42:50Z",
          "updatedAt": "2019-07-22T21:42:50Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing as it seems we can defer this to a later time and I've lost confidence that Alt-SVC is necessarily the right mechanism for this.",
          "createdAt": "2019-07-25T14:33:41Z",
          "updatedAt": "2019-07-25T14:33:41Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ff9f03b97d05ebe7e899a5d5c869a31d2d609696",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "altsvc_extension",
      "headRefOid": "830f5602b6db5f8d29754a49fc25e7ae61b1257a",
      "mergeCommit": null
    },
    {
      "number": 873,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwMjgwODU1",
      "title": "Add use cases section.",
      "url": "https://github.com/httpwg/http-extensions/pull/873",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nAdds an `Use Case` section\r\n\r\n#872 ",
      "createdAt": "2019-07-23T12:49:21Z",
      "updatedAt": "2020-10-26T03:55:42Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "63e6c86f685f04592db24d645d0a9ea8fe284c58",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "add-use-cases",
      "headRefOid": "a5c497f2d7a88e76c500f88a186b7e781ac1b05c",
      "closedAt": "2020-08-17T13:16:25Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I added the discussion we had on #872. Feel free to add whatever you think is appropriate.",
          "createdAt": "2019-10-22T09:02:35Z",
          "updatedAt": "2019-10-22T09:02:35Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Addressed in #971 ",
          "createdAt": "2020-08-17T13:16:25Z",
          "updatedAt": "2020-08-17T13:16:25Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 875,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwNzk1NzM1",
      "title": "md5 must not be used",
      "url": "https://github.com/httpwg/http-extensions/pull/875",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nStates that `MD5` MUST NOT be used.\r\n\r\nSets the MD5 status to deprecated.\r\n\r\n",
      "createdAt": "2019-07-24T16:10:22Z",
      "updatedAt": "2019-08-09T10:59:49Z",
      "closedAt": "2019-07-26T14:56:35Z",
      "mergedAt": "2019-07-26T14:56:35Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY2MjI4ODc4",
          "commit": {
            "abbreviatedOid": "db0c995"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good, thanks!",
          "createdAt": "2019-07-24T19:12:03Z",
          "updatedAt": "2019-07-24T19:12:03Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "97ee65cd732f33226a2578b0194ebd2a1bd85334",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "867-md5-must-not-be-used",
      "headRefOid": "db0c995f64428a11900215824d5b2b5399cc4379",
      "mergeCommit": {
        "oid": "fece06d0a5f72608404490a0b21d3db063f1b40d"
      }
    },
    {
      "number": 876,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAxMDE5Njg1",
      "title": "Fix: #832. Reference RFC6234 instead of FIPS180.",
      "url": "https://github.com/httpwg/http-extensions/pull/876",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nSimplifies references to sha algorithms pointing to RFC 6234\r\ninstead of FIPS180 documents.\r\n\r\nFix: #832 \r\n",
      "createdAt": "2019-07-25T07:39:19Z",
      "updatedAt": "2019-09-05T16:52:53Z",
      "closedAt": "2019-09-05T15:49:54Z",
      "mergedAt": "2019-09-05T15:49:54Z",
      "mergedBy": "ioggstream",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue ping :)",
          "createdAt": "2019-08-30T09:51:37Z",
          "updatedAt": "2019-08-30T09:51:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY3NTQyNTcx",
          "commit": {
            "abbreviatedOid": "64a305f"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-29T02:10:17Z",
          "updatedAt": "2019-07-29T02:10:23Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "You can drop this and use `{{!SHA2=RFC6234}}` in the first use of the reference.  You can use the same afterwards, or even just `{{!SHA2}}`.",
              "createdAt": "2019-07-29T02:10:17Z",
              "updatedAt": "2019-09-05T15:31:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY4OTMxNTg1",
          "commit": {
            "abbreviatedOid": "64a305f"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-31T10:53:58Z",
          "updatedAt": "2019-07-31T10:53:59Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Cool, thanks! I'll use that syntax in an editorial review of the whole doc.",
              "createdAt": "2019-07-31T10:53:58Z",
              "updatedAt": "2019-09-05T15:31:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg0MjYxMDE5",
          "commit": {
            "abbreviatedOid": "64a305f"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-05T13:30:08Z",
          "updatedAt": "2019-09-05T13:30:09Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Strictly, SHA-1 is specified in https://tools.ietf.org/html/rfc3174 \r\n\r\nI got there by following the link from RFC 6234, both are still active RFCs.",
              "createdAt": "2019-09-05T13:30:08Z",
              "updatedAt": "2019-09-05T15:31:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg0MjY1NDY2",
          "commit": {
            "abbreviatedOid": "64a305f"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-05T13:36:22Z",
          "updatedAt": "2019-09-05T13:36:22Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "3174 is updated by 6234. Do you think we should change the PR and reference both?",
              "createdAt": "2019-09-05T13:36:22Z",
              "updatedAt": "2019-09-05T15:31:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg0MjkzOTEx",
          "commit": {
            "abbreviatedOid": "64a305f"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-05T14:15:09Z",
          "updatedAt": "2019-09-05T14:15:09Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Personally I'd like to reference both.\r\n\r\n\"Updates\" or \"Updated by\" is additive (in contrast, \"Obsoletes\" is replacement) so both documents are still active and IMO if we reference 3174 we avoid one level of indirection for people that want to see the active spec for SHA-1.\r\n\r\n",
              "createdAt": "2019-09-05T14:15:09Z",
              "updatedAt": "2019-09-05T15:31:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg0MzUzMTI0",
          "commit": {
            "abbreviatedOid": "fa2f734"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-05T15:31:33Z",
          "updatedAt": "2019-09-05T15:31:33Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "should be fixed now, WDYT?",
              "createdAt": "2019-09-05T15:31:33Z",
              "updatedAt": "2019-09-05T15:31:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg0MzU4MzIx",
          "commit": {
            "abbreviatedOid": "fa2f734"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-05T15:39:21Z",
          "updatedAt": "2019-09-05T15:39:21Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "97ee65cd732f33226a2578b0194ebd2a1bd85334",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "832-references-for-sha",
      "headRefOid": "fa2f7340f7aa725651aeeb5705ffc4793ec50b46",
      "mergeCommit": {
        "oid": "f25cd1c803a7a7717286a889c419817df3457d66"
      }
    },
    {
      "number": 877,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAxMTIxNDE4",
      "title": "Obsolete ADLER-32 but don't forbid it. It's now NOT RECOMMENDED #828 ",
      "url": "https://github.com/httpwg/http-extensions/pull/877",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nObsolete ADLER-32 but don't forbid it. #828",
      "createdAt": "2019-07-25T12:29:09Z",
      "updatedAt": "2019-10-09T08:17:27Z",
      "closedAt": "2019-10-09T08:17:26Z",
      "mergedAt": "2019-10-09T08:17:26Z",
      "mergedBy": "ioggstream",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@manger will this work for you?",
          "createdAt": "2019-08-01T08:19:09Z",
          "updatedAt": "2019-08-01T08:19:09Z"
        },
        {
          "author": "paulmillar",
          "authorAssociation": "NONE",
          "body": "I think the pull request is OK as-is, but might be improved slightly.\r\n\r\nIn particularly, I'm wondering if SHOULD NOT is too strong for the server.  A server could support ADLER32 without that support impacting on cryptographic data integrity provided that server also supports a cryptographically secure hash; e.g., SHA-512.  Clients that wish to protect against malicious actor changes would use the SHA-512 hash and not request (or ignore) the ADLER32 value.  Therefore, I would suggest that, for the server, the document says a server MAY implement ADLER32.\r\n\r\nI think it is perfectly reasonable for the document to say the client SHOULD NOT use ADLER32, for the reasons stated.\r\n\r\nThat said, I can't decide if this distinction is really helpful, so I defer to your judgement, here.",
          "createdAt": "2019-08-12T08:24:07Z",
          "updatedAt": "2019-08-12T08:24:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not so sure we want to make a distinction between client and server as you write it. Both client and server can attach Digest header to request or response. It is the receiver of Digest that is exposed to the risk of using a weak digest.\r\n\r\nThe current language avoids mentioning either endpoint so we leave it to implementers. I'm not opposed to spelling things out more clearly but we'd really need to nail down what we mean by \"using Digest  algorithms\" because that relates to requesting them, generating them, regenerating them (proxy), validating them (endpoint or proxy) etc.",
          "createdAt": "2019-08-12T09:57:40Z",
          "updatedAt": "2019-08-12T09:57:40Z"
        },
        {
          "author": "paulmillar",
          "authorAssociation": "NONE",
          "body": "That's a good point about client/server.  Sorry, I had that wrong.  As you say, it's the recipient of a Digest that must decide whether the algorithm is sufficient.  This recipient may be either the client or the server.\r\n\r\nI think the document is right to point out the dangers of accepting a weak digest.\r\n\r\nPerhaps there is a useful distinction between generating a digest and accepting a digest; e.g., an agent MAY support generating a weak digest but SHOULD NOT accept a weak digest.",
          "createdAt": "2019-08-12T10:10:59Z",
          "updatedAt": "2019-08-12T10:10:59Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That's a good point about client/server. Sorry, I had that wrong.\r\n\r\nNot wrong, just partially true. \r\n\r\n> Perhaps there is a useful distinction between generating a digest and accepting a digest; e.g., an agent MAY support generating a weak digest but SHOULD NOT accept a weak digest.\r\n\r\nThat could work for me. I'll leave it to @ioggstream to decide what he things makes sense to do.",
          "createdAt": "2019-08-12T10:27:14Z",
          "updatedAt": "2019-08-12T10:27:14Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@paulmillar @LPardue as this issue is for ADLER, I moved the `weak digest` discussion  to #894 \r\n\r\n> .. A server could support ADLER32 without that support impacting on cryptographic data integrity \r\n> [.. ] the document says a server MAY implement ADLER32.\r\n\r\nAs it's in the listed algorithms, the server MAY already implement ADLER32, though it SHOULD NOT be used by both sides of the communication. I think sender and receiver should behave consistently (see #894 again).\r\n\r\n",
          "createdAt": "2019-08-19T13:53:38Z",
          "updatedAt": "2019-08-19T14:01:35Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merging as for the positive feedback from @phluid61 and @LPardue comment https://github.com/httpwg/http-extensions/pull/877#issuecomment-520372044",
          "createdAt": "2019-10-09T08:13:06Z",
          "updatedAt": "2019-10-09T08:13:06Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "07961624ee6d82175d37a25e6b9620d37aadbaa3",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "828-other-algorithms",
      "headRefOid": "58902303b93c2bbba8419d3ddb9362be30cb86a9",
      "mergeCommit": {
        "oid": "032840d0fd3f834e2312199a8af46c37c2d4b70e"
      }
    },
    {
      "number": 878,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAxMjA4OTQw",
      "title": "Remove Accept-CH-Lifetime",
      "url": "https://github.com/httpwg/http-extensions/pull/878",
      "state": "MERGED",
      "author": "igrigorik",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Based on discussion at IETF 105, removing explicit lifetime in favor of\r\nimplicit opt-in registration and persistence.\r\n\r\n@martinthomson can you please take a look? In particular, current language states the preference should be persisted but doesn't explicitly state for what the lifetime is.. Modulo, in privacy section we do talk about MUST criteria for clearing it. Any suggestions or recommendations for how to best approach this?",
      "createdAt": "2019-07-25T15:55:50Z",
      "updatedAt": "2019-10-23T06:31:05Z",
      "closedAt": "2019-07-29T04:19:25Z",
      "mergedAt": "2019-07-29T04:19:25Z",
      "mergedBy": "igrigorik",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY2NzM5MzUw",
          "commit": {
            "abbreviatedOid": "349df00"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2019-07-25T16:19:12Z",
          "updatedAt": "2019-07-25T16:21:36Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "\ud83d\udc4d ",
              "createdAt": "2019-07-25T16:19:12Z",
              "updatedAt": "2019-07-29T02:49:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY3NTQyODEy",
          "commit": {
            "abbreviatedOid": "349df00"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-29T02:11:42Z",
          "updatedAt": "2019-07-29T02:12:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThis document defines an Accept-CH response header that servers can use to advertise their use of request headers for proactive content negotiation, along with a set of guidelines for the creation of such headers, colloquially known as \"Client Hints.\"\r\n```",
              "createdAt": "2019-07-29T02:11:43Z",
              "updatedAt": "2019-07-29T02:49:51Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8ffcebb2f831c0ff8c0b9760dcb04247d6680b46",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "drop-lifetime",
      "headRefOid": "72c2d6fe08597c21948bfa69c7b0a61051e4a010",
      "mergeCommit": {
        "oid": "7d24ea40f02ba791c13e5fd70d6932079abf14cf"
      }
    },
    {
      "number": 879,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAxMzY2OTgw",
      "title": "Detail dimensions of information exposure",
      "url": "https://github.com/httpwg/http-extensions/pull/879",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "A first pass at resolving #786 \r\n\r\n@igrigorik & @martinthomson - Can you take a look and see if this properly sums up our Monday conversations?",
      "createdAt": "2019-07-26T01:55:00Z",
      "updatedAt": "2019-12-04T22:23:10Z",
      "closedAt": "2019-12-04T22:23:09Z",
      "mergedAt": "2019-12-04T22:23:09Z",
      "mergedBy": "yoavweiss",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@sleevi - care to take a look as well?",
          "createdAt": "2019-07-26T17:33:25Z",
          "updatedAt": "2019-07-26T17:33:25Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr - could you please take a look? :)",
          "createdAt": "2019-08-13T09:34:38Z",
          "updatedAt": "2019-08-13T09:34:38Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "I agree that this text is an improvement, but my concern is that it seems to leave way too much up to the client implementors. It seems to me that it's our responsibility as spec designers to map out the space of what's acceptable to some degree.",
          "createdAt": "2019-08-28T19:35:06Z",
          "updatedAt": "2019-08-28T19:35:06Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr - friendly ping :) Would be great to drive this to conclusion\r\n\r\n/cc @mnot as we discussed this last week at TPAC",
          "createdAt": "2019-09-26T06:01:04Z",
          "updatedAt": "2019-09-26T06:01:04Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "See above. I think this text is still far too positive about this feature.",
          "createdAt": "2019-09-27T21:37:45Z",
          "updatedAt": "2019-09-27T21:37:45Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson - friendly ping! :) I believe we agreed at the HTTPWG meeting at IETF106 that this is good to go",
          "createdAt": "2019-12-04T11:01:10Z",
          "updatedAt": "2019-12-04T11:01:10Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep.  I just assumed you were going ahead.",
          "createdAt": "2019-12-04T21:14:33Z",
          "updatedAt": "2019-12-04T21:14:33Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson In that case, can you land it? (I don't have the permissions)",
          "createdAt": "2019-12-04T21:25:35Z",
          "updatedAt": "2019-12-04T21:25:35Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Well that's an oversight; you should have an invite in your inbox.",
          "createdAt": "2019-12-04T21:48:27Z",
          "updatedAt": "2019-12-04T21:48:27Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Well that's an oversight; you should have an invite in your inbox.\r\n\r\nThanks! :)",
          "createdAt": "2019-12-04T22:22:55Z",
          "updatedAt": "2019-12-04T22:22:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY3MzI5NDIz",
          "commit": {
            "abbreviatedOid": "efbc4d0"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-26T18:05:32Z",
          "updatedAt": "2019-07-26T18:16:13Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "This last sentence is a little tricky. I don't think we have any data to support the 'likely' claim - we're assuming that, but it may be that it turns out folks just have trouble with CH and implementing it (in)correctly.\r\n\r\n\r\n> As Client Hints are provided in order to allow variation and optimization of the content to the provided Client-Hints, resource responses that do not vary on the Client Hints provided may indicate that such Hints are being used for nefarious purposes.\r\n\r\nI mean, it makes it weaker in terms of *is* being used nefariously, so perhaps that's not worth it. I'm just a little uncomfortable stating such things without data, and without explanation about why the conclusion is there.",
              "createdAt": "2019-07-26T18:05:32Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY3MzM1MTA2",
          "commit": {
            "abbreviatedOid": "efbc4d0"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-26T18:17:48Z",
          "updatedAt": "2019-07-26T18:17:48Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "yeah, that's fair",
              "createdAt": "2019-07-26T18:17:48Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY3MzcxNDY3",
          "commit": {
            "abbreviatedOid": "542f68a"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-26T19:41:28Z",
          "updatedAt": "2019-07-26T19:41:29Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "> resource responses that do not vary on the Client Hints provided can indicate that such Hints are being used for nefarious purposes\r\n\r\nHmm.. I can see `no-cache` + `no-store` responses not emitting Vary by default today, and that doesn't directly imply \"nefarious\" use. If we're making that claim, perhaps we should also be recommending that servers always emit such Vary responses, regardless of cacheability of the response? Or, am I overthinking it?",
              "createdAt": "2019-07-26T19:41:28Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY3MzcyNjgy",
          "commit": {
            "abbreviatedOid": "542f68a"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-26T19:44:41Z",
          "updatedAt": "2019-07-26T19:44:42Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I'm not talking about using the `Vary` header, but about actually varying the resource served when different hints are included in the request. Maybe I should clarify that?",
              "createdAt": "2019-07-26T19:44:41Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY3MzczODI2",
          "commit": {
            "abbreviatedOid": "542f68a"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-26T19:47:47Z",
          "updatedAt": "2019-07-26T19:47:47Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Ah, I see. Yeah, I was picturing an implementation looking for `Vary` in the response to asses use: seems like a straightforward + explicit signal? Probably worth being (slightly) more explicit.",
              "createdAt": "2019-07-26T19:47:47Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY3Mzc4ODQ1",
          "commit": {
            "abbreviatedOid": "9ae8ffe"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-26T20:00:19Z",
          "updatedAt": "2019-07-26T20:00:20Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Added another sentence to clarify that.",
              "createdAt": "2019-07-26T20:00:20Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY3NDUzMjky",
          "commit": {
            "abbreviatedOid": "9ae8ffe"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Looks great, thanks! \r\n\r\n@martinthomson before we merge.. does this capture what you had in mind?",
          "createdAt": "2019-07-27T03:13:33Z",
          "updatedAt": "2019-07-27T03:13:33Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY3NTQxNDYx",
          "commit": {
            "abbreviatedOid": "9ae8ffe"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "@ekr should probably take a look.",
          "createdAt": "2019-07-29T02:03:11Z",
          "updatedAt": "2019-07-29T02:04:46Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "\"their\" variance?\r\n\r\nThe problem here is that it is difficult to identify variance from a single instance.  You need to establish patterns of behaviour, which means comparing the response to a baseline.  Maybe \"Research into abuse of Client Hints might look at how HTTP responses that contain Client Hints differ from those without.  This might be used to reveal which Client Hints are in use, allowing researchers to further analyze that use.\"\r\n\r\nI don't think that you need the mention of Vary here.  Bad actors won't use that, or might use `Cache-Control: no-store` and friends.",
              "createdAt": "2019-07-29T02:03:11Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            },
            {
              "originalPosition": 15,
              "body": "\"spectrum\" implies linear.  Consider rewording.",
              "createdAt": "2019-07-29T02:04:31Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY3NTgzMjE1",
          "commit": {
            "abbreviatedOid": "0fd294f"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-29T06:15:08Z",
          "updatedAt": "2019-07-29T06:15:08Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Cool, incorporated your language (while mentioning different values, on top of a with/without comparison)",
              "createdAt": "2019-07-29T06:15:08Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY3NTgzNDMw",
          "commit": {
            "abbreviatedOid": "0fd294f"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-29T06:15:54Z",
          "updatedAt": "2019-07-29T06:15:54Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Would \"range\" be better?",
              "createdAt": "2019-07-29T06:15:54Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5OTc1NDgw",
          "commit": {
            "abbreviatedOid": "0fd294f"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-02T03:59:56Z",
          "updatedAt": "2019-08-02T03:59:56Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Hmm, I don't think \"spectrum\" connotes linear; spectrum can be linear and nonlinear.\r\n\r\n![image](https://user-images.githubusercontent.com/10652/62313398-86dec400-b445-11e9-825e-d38f5bb92f45.png)\r\n\r\nThat said, if a different term or turn of phrase is a better fit.. \r\n\r\nRiffing.. \r\n\r\n> Each feature will have different characteristics with respect to key considerations such as: static vs. dynamic information, low vs. high entropy, and user sensitive vs non-sensitive information. For example, user agent version number that is shared by many users is static, low entropy, and does not reveal user sensitive information, whereas geolocation is dynamic, high entropy, and user sensitive. User agents SHOULD consider the value provided by each particular feature on a per-feature basis and MAY have different policies on whether and how the feature is made available.\r\n\r\nWarmer?",
              "createdAt": "2019-08-02T03:59:56Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc0MTY0OTYy",
          "commit": {
            "abbreviatedOid": "0fd294f"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-13T09:34:05Z",
          "updatedAt": "2019-08-13T09:34:05Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "@martinthomson friendly ping! :)",
              "createdAt": "2019-08-13T09:34:05Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgxMDU0ODcw",
          "commit": {
            "abbreviatedOid": "0fd294f"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-28T19:33:24Z",
          "updatedAt": "2019-08-28T19:35:24Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I don't think that this really reflects my position. Imagine that there was a geo \"moved\" callback, that still wouldn't make me want it exposed via client hints.",
              "createdAt": "2019-08-28T19:33:25Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            },
            {
              "originalPosition": 15,
              "body": "\"different points in the space\"\r\n\r\n",
              "createdAt": "2019-08-28T19:34:06Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            },
            {
              "originalPosition": 25,
              "body": "i don't understand how I would implement this.",
              "createdAt": "2019-08-28T19:34:23Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgxMDU3NjE0",
          "commit": {
            "abbreviatedOid": "0fd294f"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-28T19:39:01Z",
          "updatedAt": "2019-08-28T19:39:01Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "https://blog.chromium.org/2019/08/potential-uses-for-privacy-sandbox.html\r\n\r\n> As [referenced in May at I/O](https://blog.chromium.org/2019/05/improving-privacy-and-security-on-web.html), we are actively taking steps to prevent fingerprinting. We are proposing the implementation of what we call a privacy budget. With a privacy budget, websites can call APIs until those calls have revealed enough information to narrow a user down to a group sufficiently large enough to maintain anonymity. After that, any further attempts to call APIs that would reveal information will cause the browser to intervene and block further calls.\r\n\r\nWithout normatively requiring such an implementation, it's attempting to highlight that user agents that have policies or tracking around equivalent APIs should also consider the emissions of client hints in that context.",
              "createdAt": "2019-08-28T19:39:01Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgxMDgxMjc4",
          "commit": {
            "abbreviatedOid": "0fd294f"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-28T20:25:21Z",
          "updatedAt": "2019-08-28T20:25:21Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Well, 2119 SHOULD *is* a normative statement, and so this text needs to be a lot clearer.",
              "createdAt": "2019-08-28T20:25:21Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg0MDk2NTUz",
          "commit": {
            "abbreviatedOid": "0fd294f"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for reviewing! Replied to your comments",
          "createdAt": "2019-09-05T08:33:22Z",
          "updatedAt": "2019-09-05T08:38:44Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This does not mandate exposing every JS state change in Client Hints as well, but the inverse. If something is not exposed in JS, it SHOULD NOT be exposed through CH.\r\n\r\nYour example of geo \"moved\" callback would be covered by the bullet above this one: \"The feature SHOULD NOT expose user sensitive information. To that end, information available to the application, but gated behind specific user actions (e.g. a permission prompt or user activation) SHOULD NOT be exposed as a Client Hint\"\r\n\r\nI don't think that we can be overly descriptive here (e.g. call out geo or other features specifically). At the same time, any feature that will use this framework will go through a separate privacy review process, so we'd be able to catch more specific issues at that point as well.\r\n\r\nDoes that make sense? Or do you think further clarifications are required?\r\n\r\n",
              "createdAt": "2019-09-05T08:33:22Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            },
            {
              "originalPosition": 15,
              "body": "SGTM",
              "createdAt": "2019-09-05T08:33:42Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            },
            {
              "originalPosition": 25,
              "body": "I was imagining both the \"privacy budget\" work as well as Mozilla's forensic work we discussed at IETF105 as potential ways to \"track access to active fingerprinting information\". I'm happy to drop the normative SHOULD here, if you think that'd be better. Alternatively, I can add examples pointing to those two methods of fingerprinting tracking.",
              "createdAt": "2019-09-05T08:38:06Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0NTc0NTgz",
          "commit": {
            "abbreviatedOid": "0fd294f"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-27T21:35:24Z",
          "updatedAt": "2019-09-27T21:35:25Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I think my point is broader than this: While the current client hints may be innocuous, this document does not provide any rubric for rationally evaluating abuse or for assessing new client hints, and this guidance doesn't help. So this just creates an open door for new dangerous features.\r\n\r\nAs I said in Montreal: I'm generally OK with taking features that are currently sent in headers and client-hintizing them, because that seems better. I'm not fine with a document that suggests that it is a good thing to take things that currently are acquired by active JS APIs and turn them into client hints.\r\n",
              "createdAt": "2019-09-27T21:35:25Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0NTc1MzAz",
          "commit": {
            "abbreviatedOid": "0fd294f"
          },
          "author": "ekr",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-27T21:37:26Z",
          "updatedAt": "2019-09-27T21:37:27Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I don't think further clarifications are required. I think it should remove everything after the comma. I.e., \"The feature SHOULD NOT expose user information that changes over time\".\r\n\r\n\r\n",
              "createdAt": "2019-09-27T21:37:27Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3MDA3MzM5",
          "commit": {
            "abbreviatedOid": "0fd294f"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I realized that I hadn't hit \"send\" on these comments.  Yoav reminded me, so here they are.",
          "createdAt": "2019-10-25T06:41:55Z",
          "updatedAt": "2019-11-06T01:19:28Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "This probably belongs outside, with a MUST NOT.",
              "createdAt": "2019-10-25T06:41:55Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            },
            {
              "originalPosition": 14,
              "body": "After Yoav walked me through this, I think that this specific problem isn't what we want to fixate on.\r\n\r\nBasically, though we might agree about the relative utility of the different methods for accounting for information use, I can understand how you might conclude that there is an equivalence here.  This all rides on having strong coupling between information access controls and the network query.  That is, it is assumed that sites that can access information are also able to send themselves that information and that having those two events conjoined in the browser is equivalent to that in every way.  As long as that is true - it's an assumption here that probably needs to be more clearly articulated - then this is OK.\r\n\r\nThe problem here is that this list isn't all that needs to be considered when deciding whether it is appropriate to expose information as a client hint.  I opened #962 to track the most obvious unaddressed aspect of the decision; I can't think of any others right now.",
              "createdAt": "2019-11-06T01:19:05Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEyMzczOTM5",
          "commit": {
            "abbreviatedOid": "fe2d19a"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-06T11:50:08Z",
          "updatedAt": "2019-11-06T11:50:08Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Makes sense!",
              "createdAt": "2019-11-06T11:50:08Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEyMzc2ODc3",
          "commit": {
            "abbreviatedOid": "fe2d19a"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-06T11:56:00Z",
          "updatedAt": "2019-11-06T11:56:01Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "@martinthomson so if I understand correctly, I need to better articulate the fact the underlying assumption( that sites that can access the information can also send it to themselves) and resolve #962. I'll add the former here, and the latter as a followup, if that works for you.",
              "createdAt": "2019-11-06T11:56:01Z",
              "updatedAt": "2019-11-06T12:16:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEyODA1Njg4",
          "commit": {
            "abbreviatedOid": "2631203"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-06T23:07:14Z",
          "updatedAt": "2019-11-06T23:07:14Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Yep.  A follow-up is fine.  I'm happy to defer to you on how you want to proceed.",
              "createdAt": "2019-11-06T23:07:14Z",
              "updatedAt": "2019-11-06T23:07:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEyODE3NTE2",
          "commit": {
            "abbreviatedOid": "2631203"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-06T23:22:01Z",
          "updatedAt": "2019-11-06T23:22:02Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "If this PR looks good to you, I'd love to land it :)\r\nAdded the MUST and clarified the underlying assumptions. Let me know if there are other things to address here.",
              "createdAt": "2019-11-06T23:22:02Z",
              "updatedAt": "2019-11-06T23:22:02Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8ffcebb2f831c0ff8c0b9760dcb04247d6680b46",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "fingerprinting_spectrum",
      "headRefOid": "2631203e9da0a40d35a668ba4d5fba4c22370415",
      "mergeCommit": {
        "oid": "a78bdd8487b48c7ef3da139f39bbc32dd3f276f9"
      }
    },
    {
      "number": 882,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAyOTAxMDAw",
      "title": "Fix #881: digest for br-compressed representations",
      "url": "https://github.com/httpwg/http-extensions/pull/882",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nFixes the digest values b/w request and response, which were swapped.\r\n\r\n#881 ",
      "createdAt": "2019-07-31T11:05:16Z",
      "updatedAt": "2019-10-23T06:31:06Z",
      "closedAt": "2019-07-31T11:10:28Z",
      "mergedAt": "2019-07-31T11:10:28Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4b571d27775da5ee2d9d85143a5f36b988fee753",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "881-fix-compressed-digest",
      "headRefOid": "c5f6cb46d3705c0545965a61e3fcba15a3655d85",
      "mergeCommit": {
        "oid": "c20c3f462178b3dc010eaffb8cff99dcccfae648"
      }
    },
    {
      "number": 883,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAyOTExMDMy",
      "title": "Fix: #880. Add id-sha-* algorithm examples.",
      "url": "https://github.com/httpwg/http-extensions/pull/883",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nAdds id-sha-* algorithm examples throughout the document.",
      "createdAt": "2019-07-31T11:35:26Z",
      "updatedAt": "2019-08-09T10:59:38Z",
      "closedAt": "2019-08-09T09:33:18Z",
      "mergedAt": "2019-08-09T09:33:18Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY4OTY1MzM5",
          "commit": {
            "abbreviatedOid": "79066d1"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "One way to interpret the change to the examples is that when using the content-encoding `identitiy`, you must always use the digest algorithm `id-sha-*`. I don't think that interpretation is our intention, so perhaps we want to leave one of the `identity` examples as still using the plain `sha-*` algorithm.",
          "createdAt": "2019-07-31T12:10:07Z",
          "updatedAt": "2019-07-31T12:13:56Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nAs there is no content coding applied, the `sha-256` and the `id-sha-256`\r\n```",
              "createdAt": "2019-07-31T12:10:07Z",
              "updatedAt": "2019-08-09T09:15:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5MDkxNjI1",
          "commit": {
            "abbreviatedOid": "76f77c9"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-31T15:21:43Z",
          "updatedAt": "2019-07-31T15:21:43Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "1- thanks for the fix :) I mis-typed the algorithm name\r\n\r\n2- Here and below some `Content-Encoding: identity` + `sha-256`:\r\n\r\n- https://github.com/httpwg/http-extensions/blame/76f77c9ce2e9ffa51eb1fe01c8656b9b41b52584/draft-ietf-httpbis-digest-headers.md#L571-L573\r\n- https://github.com/httpwg/http-extensions/blame/76f77c9ce2e9ffa51eb1fe01c8656b9b41b52584/draft-ietf-httpbis-digest-headers.md#L533-L534\r\n\r\nLet me know if that works for you!\r\n\r\nThanks++,\r\nR:",
              "createdAt": "2019-07-31T15:21:43Z",
              "updatedAt": "2019-08-09T09:15:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5MTE5NDE1",
          "commit": {
            "abbreviatedOid": "76f77c9"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-31T16:03:05Z",
          "updatedAt": "2019-07-31T16:03:06Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Ah yeah I missed those sorry. Changes look good to me, lets see if the issue creator has any further suggestions",
              "createdAt": "2019-07-31T16:03:05Z",
              "updatedAt": "2019-08-09T09:15:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5MTE5NTE2",
          "commit": {
            "abbreviatedOid": "76f77c9"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-31T16:03:15Z",
          "updatedAt": "2019-07-31T16:03:15Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5MzgwMTc0",
          "commit": {
            "abbreviatedOid": "76f77c9"
          },
          "author": "manger",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-01T03:26:00Z",
          "updatedAt": "2019-08-01T03:26:49Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I'd drop the first line (sha-256=X48...) and keep the other two.\r\nIt is probably legal to have multiple Digest headers so this looks like it might be 1 HTTP message (instead of lines from 3 separate messages). But having sha-256 twice with different values in 1 message wouldn't make sense.",
              "createdAt": "2019-08-01T03:26:00Z",
              "updatedAt": "2019-08-09T09:15:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5NDQ0MjYw",
          "commit": {
            "abbreviatedOid": "76f77c9"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-01T07:39:42Z",
          "updatedAt": "2019-08-01T07:39:43Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Ok for leaving just two digest algorithms. \r\nI think that the plural noun \"Examples\" clarifies that \r\nthe two headers come from different HTTP messages.",
              "createdAt": "2019-08-01T07:39:42Z",
              "updatedAt": "2019-08-09T09:15:20Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c20c3f462178b3dc010eaffb8cff99dcccfae648",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "880-add-id-digest-examples",
      "headRefOid": "882cc27f73078994a65cf0a82f19283d4499c768",
      "mergeCommit": {
        "oid": "c313264d8a538fb94ca8696e1e4e132ac0791315"
      }
    },
    {
      "number": 887,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAzMjg2MzQ1",
      "title": "Align README with BCP56bis title. See #595",
      "url": "https://github.com/httpwg/http-extensions/pull/887",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nAlign README with #595 ",
      "createdAt": "2019-08-01T09:00:03Z",
      "updatedAt": "2019-08-09T10:59:26Z",
      "closedAt": "2019-08-05T00:12:39Z",
      "mergedAt": "2019-08-05T00:12:39Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c20c3f462178b3dc010eaffb8cff99dcccfae648",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-595-bis",
      "headRefOid": "9ee9b3a15b1e93b90b8d529550d61c36311a0a6f",
      "mergeCommit": {
        "oid": "70c9368c4967f6e8b309480b61230354d4367fe2"
      }
    },
    {
      "number": 888,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAzODU4NzY3",
      "title": "fixing typo",
      "url": "https://github.com/httpwg/http-extensions/pull/888",
      "state": "MERGED",
      "author": "dret",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix: missing dot at EOL.",
      "createdAt": "2019-08-02T16:45:34Z",
      "updatedAt": "2019-08-03T15:19:57Z",
      "closedAt": "2019-08-03T15:19:57Z",
      "mergedAt": "2019-08-03T15:19:57Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcwMjg2NzIw",
          "commit": {
            "abbreviatedOid": "666387e"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-02T16:49:53Z",
          "updatedAt": "2019-08-02T16:49:53Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c20c3f462178b3dc010eaffb8cff99dcccfae648",
      "headRepository": "dret/http-extensions",
      "headRefName": "patch-1",
      "headRefOid": "666387e4d6a19cb717429885d02df2d43a846cf6",
      "mergeCommit": {
        "oid": "f4b5ef3344c0f85c55f60125fb3de6cc7ab4849b"
      }
    },
    {
      "number": 890,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1OTE1NTIy",
      "title": "Fix: #886. Align title with document name.",
      "url": "https://github.com/httpwg/http-extensions/pull/890",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nAlign the I-D title with the .md file name suggested by @mnot before the adoption.",
      "createdAt": "2019-08-09T09:40:13Z",
      "updatedAt": "2019-09-06T10:26:11Z",
      "closedAt": "2019-08-18T08:46:23Z",
      "mergedAt": "2019-08-18T08:46:23Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjczNDkzOTgz",
          "commit": {
            "abbreviatedOid": "4000650"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-12T01:59:32Z",
          "updatedAt": "2019-08-12T01:59:32Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c313264d8a538fb94ca8696e1e4e132ac0791315",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "886-change-title",
      "headRefOid": "400065040e052135355a29518149a3122544daf6",
      "mergeCommit": {
        "oid": "e98e7bd53b94cab88b78a6f294387023c0c23ae3"
      }
    },
    {
      "number": 891,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1OTQ3Nzgz",
      "title": "Update CRC32C value in iana table. Related to: #828.",
      "url": "https://github.com/httpwg/http-extensions/pull/891",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nUpdates the IANA digest-algorithms table with the reference to CRC32C\r\n\r\n",
      "createdAt": "2019-08-09T11:18:18Z",
      "updatedAt": "2019-10-09T08:50:15Z",
      "closedAt": "2019-10-09T08:50:15Z",
      "mergedAt": "2019-10-09T08:50:15Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "032840d0fd3f834e2312199a8af46c37c2d4b70e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-828-crc32c",
      "headRefOid": "4590748b8e9bcac1633d903c72c82e48abb3564f",
      "mergeCommit": {
        "oid": "d0dc68b3a8a53b4f057964f5c4194c8baddd297e"
      }
    },
    {
      "number": 892,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA2NzU2MDkw",
      "title": "Allow dictionary members to have parameters.",
      "url": "https://github.com/httpwg/http-extensions/pull/892",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #842.",
      "createdAt": "2019-08-13T05:56:01Z",
      "updatedAt": "2019-08-19T08:55:09Z",
      "closedAt": "2019-08-19T08:55:04Z",
      "mergedAt": "2019-08-19T08:55:04Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f18d4119e0d7de11cad306c5613e42d36a1e4c10",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-842",
      "headRefOid": "79c13753dd848c367fa5ff96fd90deec1c79bc6b",
      "mergeCommit": {
        "oid": "ff818d26a8206a5366b9f85159c3b048008a41a2"
      }
    },
    {
      "number": 893,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA2NzU4MzE3",
      "title": "Clamp floats",
      "url": "https://github.com/httpwg/http-extensions/pull/893",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Fixes #848 ",
      "createdAt": "2019-08-13T06:06:34Z",
      "updatedAt": "2019-08-20T01:24:31Z",
      "closedAt": "2019-08-20T01:24:27Z",
      "mergedAt": "2019-08-20T01:24:27Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this PR meant to include #892?",
          "createdAt": "2019-08-13T06:21:28Z",
          "updatedAt": "2019-08-13T06:21:28Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yeah, oops. Need more coffee.",
          "createdAt": "2019-08-13T06:30:06Z",
          "updatedAt": "2019-08-13T06:30:06Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Try now.",
          "createdAt": "2019-08-13T06:41:54Z",
          "updatedAt": "2019-08-13T06:41:54Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Otherwise, looks alright to me.",
          "createdAt": "2019-08-13T07:05:47Z",
          "updatedAt": "2019-08-13T07:05:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc0MDkwNzEz",
          "commit": {
            "abbreviatedOid": "e88f3e7"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-13T06:55:53Z",
          "updatedAt": "2019-08-13T06:55:54Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Close enough",
              "createdAt": "2019-08-13T06:55:53Z",
              "updatedAt": "2019-08-20T01:22:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc1MjkyNzcy",
          "commit": {
            "abbreviatedOid": "e88f3e7"
          },
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-15T07:27:19Z",
          "updatedAt": "2019-08-15T07:27:20Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Not sure I agree with this one, what if the value is 1/3 ?",
              "createdAt": "2019-08-15T07:27:19Z",
              "updatedAt": "2019-08-20T01:22:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc1NzgwOTMw",
          "commit": {
            "abbreviatedOid": "e88f3e7"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-16T05:36:01Z",
          "updatedAt": "2019-08-16T05:36:01Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Perhaps something like:\r\n\r\n> Append up to six digits of input_float's decimal component...",
              "createdAt": "2019-08-16T05:36:01Z",
              "updatedAt": "2019-08-20T01:22:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2MjI4NTI5",
          "commit": {
            "abbreviatedOid": "e88f3e7"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-17T08:01:40Z",
          "updatedAt": "2019-08-17T08:01:41Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "1/3 doesn't match \"integers with a fractional part, which can be at most six digits of precision.\" This isn't the algorithm for serialising an IEEE-754 float, nor an arbitrary rational number.\r\n\r\nAlthough maybe guidance for converting those to an SH-float data object could be useful.",
              "createdAt": "2019-08-17T08:01:40Z",
              "updatedAt": "2019-08-20T01:22:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2MjI4NzIy",
          "commit": {
            "abbreviatedOid": "e88f3e7"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-17T08:07:14Z",
          "updatedAt": "2019-08-17T08:07:14Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Might be an idea to say \"decimal digits\" here.",
              "createdAt": "2019-08-17T08:07:14Z",
              "updatedAt": "2019-08-20T01:22:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2MjY2ODY4",
          "commit": {
            "abbreviatedOid": "e88f3e7"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-18T08:28:04Z",
          "updatedAt": "2019-08-18T08:28:04Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "> Floats are integers with a fractional part\r\n\r\nI would prefer \"floats are numbers with a fractional part\" or \"integers plus a fractional part\". ",
              "createdAt": "2019-08-18T08:28:04Z",
              "updatedAt": "2019-08-20T01:22:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2MzQ3MDY1",
          "commit": {
            "abbreviatedOid": "e88f3e7"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-19T05:30:14Z",
          "updatedAt": "2019-08-19T05:30:14Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Or \"numbers with integer and fractional parts\"\r\n\r\nI still think saying \"decimal digits\" would help, too.",
              "createdAt": "2019-08-19T05:30:14Z",
              "updatedAt": "2019-08-20T01:22:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NDIxNjQ3",
          "commit": {
            "abbreviatedOid": "9322a8e"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-19T08:55:21Z",
          "updatedAt": "2019-08-19T08:55:22Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "LGTM",
              "createdAt": "2019-08-19T08:55:22Z",
              "updatedAt": "2019-08-20T01:22:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NjUyNzI3",
          "commit": {
            "abbreviatedOid": "900c22e"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-19T15:50:42Z",
          "updatedAt": "2019-08-19T15:50:43Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Q: here we use fractional component, above we use fractional part. Is that ok?\r\n\r\n",
              "createdAt": "2019-08-19T15:50:42Z",
              "updatedAt": "2019-08-20T01:22:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2ODg5NTcz",
          "commit": {
            "abbreviatedOid": "585e310"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-20T01:22:50Z",
          "updatedAt": "2019-08-20T01:22:50Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Good catch.",
              "createdAt": "2019-08-20T01:22:50Z",
              "updatedAt": "2019-08-20T01:22:50Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "49673809135efc1ec47fecf9c10c320d54667446",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-848",
      "headRefOid": "585e310c8d47fedd776fafc02ae753120fd466bb",
      "mergeCommit": {
        "oid": "80c548c346ec493924b4687f978c037e6218ddef"
      }
    },
    {
      "number": 906,
      "id": "MDExOlB1bGxSZXF1ZXN0MzExNzAwMDY2",
      "title": "Mixed dictionary typos.",
      "url": "https://github.com/httpwg/http-extensions/pull/906",
      "state": "MERGED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Inner list values are space-separated.",
      "createdAt": "2019-08-28T07:13:45Z",
      "updatedAt": "2019-08-30T07:34:37Z",
      "closedAt": "2019-08-30T07:34:36Z",
      "mergedAt": "2019-08-30T07:34:36Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "While you're there, Booleans are `?1` not `?T` now, aren't they?",
          "createdAt": "2019-08-28T07:20:47Z",
          "updatedAt": "2019-08-28T07:20:47Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "@phluid61: Indeed! Thank you. :)",
          "createdAt": "2019-08-28T07:27:34Z",
          "updatedAt": "2019-08-28T07:27:34Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "How did that get in?\r\n\r\nThanks.",
          "createdAt": "2019-08-30T07:34:30Z",
          "updatedAt": "2019-08-30T07:34:30Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a8d80e62c9426460fcd6268d220f6b188025c3a6",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mikewest-patch-1",
      "headRefOid": "01f6797b8e565820671a7e7946d008ebd953bfef",
      "mergeCommit": {
        "oid": "ce0910f49004245a686f3395ae1652d6e399d9c2"
      }
    },
    {
      "number": 910,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEyNjIwNzkx",
      "title": "Use payload body.",
      "url": "https://github.com/httpwg/http-extensions/pull/910",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bcp56bis"
      ],
      "body": "## This PR\r\n\r\nUses payload body as iiuc:\r\n\r\n- we want to be transparent to transfer-coding;\r\n- rfc 7540 doesn't seem to use `message body`\r\n\r\n## Note\r\n\r\nIf you agree I can replace elsewhere too.",
      "createdAt": "2019-08-30T07:40:07Z",
      "updatedAt": "2020-10-17T04:14:54Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "da67208c034fc53dae221b254489664d97578d34",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-patch-1",
      "headRefOid": "de2de274fc59e73608a5700a00f0ed8513c51c95",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODgzNDEw",
          "commit": {
            "abbreviatedOid": "de2de27"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-17T04:14:53Z",
          "updatedAt": "2020-10-17T04:14:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 919,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEzMDkzMjY5",
      "title": "[SH] add reference for UTF-8",
      "url": "https://github.com/httpwg/http-extensions/pull/919",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #917",
      "createdAt": "2019-09-02T02:53:48Z",
      "updatedAt": "2019-09-02T02:56:16Z",
      "closedAt": "2019-09-02T02:55:48Z",
      "mergedAt": "2019-09-02T02:55:48Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "thx",
          "createdAt": "2019-09-02T02:55:52Z",
          "updatedAt": "2019-09-02T02:55:52Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6df7d4eb3338b4a6fdb19ba6dab891cdd019ae79",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "SH/917_UTF8",
      "headRefOid": "22d716063bd35a8f219a42a8ddbccc7e4fdc4e21",
      "mergeCommit": {
        "oid": "154ac7ae850f1ee24886d7dc9c1493ed1da1085e"
      }
    },
    {
      "number": 920,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEzMDk0OTgy",
      "title": "[SH] say 1=true, 0=false",
      "url": "https://github.com/httpwg/http-extensions/pull/920",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #916",
      "createdAt": "2019-09-02T03:08:44Z",
      "updatedAt": "2019-09-02T03:10:18Z",
      "closedAt": "2019-09-02T03:10:00Z",
      "mergedAt": "2019-09-02T03:10:00Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "thx!",
          "createdAt": "2019-09-02T03:10:05Z",
          "updatedAt": "2019-09-02T03:10:05Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "154ac7ae850f1ee24886d7dc9c1493ed1da1085e",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "SH/916_booleans",
      "headRefOid": "8cca427b4fd2fa830f9a4b9a9e8f501f6418b843",
      "mergeCommit": {
        "oid": "04e4c55297f8dd2f447b44b1e2a6d402b1bbe3e2"
      }
    },
    {
      "number": 921,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEzMzk4Mjgx",
      "title": "[SH] reference IEEE 754-2019",
      "url": "https://github.com/httpwg/http-extensions/pull/921",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Incidentally fixes in #918 by removing the annotation.\r\n\r\nAccording to IEEE's site and references the target should be <https://ieeexplore.ieee.org/servlet/opac?punumber=8766227> but I've kept the equivalent of the current address.",
      "createdAt": "2019-09-03T02:22:45Z",
      "updatedAt": "2019-09-03T02:26:19Z",
      "closedAt": "2019-09-03T02:25:58Z",
      "mergedAt": "2019-09-03T02:25:58Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "ta!",
          "createdAt": "2019-09-03T02:26:03Z",
          "updatedAt": "2019-09-03T02:26:03Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "04e4c55297f8dd2f447b44b1e2a6d402b1bbe3e2",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "SH/918_IEEE754",
      "headRefOid": "6eeaf0003886733affc732753dc394247672f13a",
      "mergeCommit": {
        "oid": "1ae5faa28b7d1f4609d8cd8f47543d8c0b99f4e9"
      }
    },
    {
      "number": 922,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE0NjAyMjUy",
      "title": "digest: fix various references",
      "url": "https://github.com/httpwg/http-extensions/pull/922",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-09-05T16:40:00Z",
      "updatedAt": "2019-09-06T08:24:35Z",
      "closedAt": "2019-09-06T08:24:34Z",
      "mergedAt": "2019-09-06T08:24:34Z",
      "mergedBy": "ioggstream",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @reschke !",
          "createdAt": "2019-09-06T08:24:17Z",
          "updatedAt": "2019-09-06T08:24:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg0Mzk1Njg0",
          "commit": {
            "abbreviatedOid": "1bdb034"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-09-05T16:41:32Z",
          "updatedAt": "2019-09-05T16:41:32Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f25cd1c803a7a7717286a889c419817df3457d66",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-dig-refs",
      "headRefOid": "1bdb03457ea99331882a0a9425dfaee2556568bb",
      "mergeCommit": {
        "oid": "8729a2d9981e37a7fa060ca6993a4f78dd5e81a4"
      }
    },
    {
      "number": 923,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE0ODc5MTI1",
      "title": "Fix #853. Use when acting on resources",
      "url": "https://github.com/httpwg/http-extensions/pull/923",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nClarifies the relations b/w Digest,  PATCH and POST:\r\n\r\n- PATCH and POST does not convey partial representations;\r\n- they instead specify actions on resources\r\n\r\nIn requests:\r\n- Digest should refer to the representation-data of the action\r\n\r\nIn responses:\r\n- if the enclosed representation refers to the status of the action, then it's complete and Digest is computed on it;\r\n- if the enclosed representation referers to another resource (eg. via content-location), Digest is computed on the selected representation of that resource;\r\n- the above is true even in case of an empty payload body.\r\n",
      "createdAt": "2019-09-06T09:47:28Z",
      "updatedAt": "2019-11-02T18:32:21Z",
      "closedAt": "2019-11-02T18:32:20Z",
      "mergedAt": "2019-11-02T18:32:20Z",
      "mergedBy": "ioggstream",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue main refactoring with examples. Still needs a lot of work but seems more understandable.\r\n\r\nAdded python snippets for creating examples in FAQ.",
          "createdAt": "2019-09-23T22:33:50Z",
          "updatedAt": "2019-09-23T22:33:50Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke could you PTAL :)",
          "createdAt": "2019-10-31T09:32:58Z",
          "updatedAt": "2019-10-31T09:32:58Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">I haven't looked at the details; in general, this looks right.\r\n\r\nThat's generally great :)\r\n\r\n> My main concern is that this is written as if POST and PATCH are special. They are not.\r\n> Shouldn't the rules be the same for any HTTP request that has a request payload?\r\n\r\nAs we just investigated on PATCH and POST, we didn't want to extend to other cases.\r\nFor example, `an hypothetical method where the request body contains a\r\npartial representation` would behave differently.\r\n\r\nMy proposal is the following:\r\n\r\n- if you think this PR is valid for POST/PATCH, I suggest to approve this so that it's ready for IETF106\r\n- for the next IETF107 cutoff we will work to generalize the behavior to generic requests-with-body\r\n\r\nWDYT? @LPardue @reschke ",
          "createdAt": "2019-10-31T15:21:16Z",
          "updatedAt": "2019-10-31T15:28:28Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's ok.\r\n\r\nI just don't think that it would be a good idea to vary the semantics based on the request method. But go ahead with the changes you have...",
          "createdAt": "2019-10-31T17:20:51Z",
          "updatedAt": "2019-10-31T17:20:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg0Nzk1NjA2",
          "commit": {
            "abbreviatedOid": "3c2c07b"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I've suggested mainly editorial changes to improve the readability of the section based on my comprehension of it. I might have interpreted things wrongly.",
          "createdAt": "2019-09-06T11:01:03Z",
          "updatedAt": "2019-09-06T11:19:58Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Alternative suggestion:\r\n\r\nA representation-data-digest is calculated on the selected representation, which requires complete representation metadata.",
              "createdAt": "2019-09-06T11:01:03Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            },
            {
              "originalPosition": 30,
              "body": "Alternative suggestion for above 4 pargraphs:\r\n\r\nMethods such as PATCH or POST may appear to convey partial representations but are semantically acting on resources. In these cases the representation-data-digest MUST be computed on the action of the payload. The response to such requests can convey the representation-data-digest.\r\n\r\nIn the case of PATCH a request conveys representation metadata that applies to the patch document and not the target resource (see ,Section 2 of {{?RFC5789}}). \r\n\r\nThe following example shows a PATCH request (using a valid content-type defined in {{?RFC7396}} and a response that contains the representation-data-digest of the patched representation.",
              "createdAt": "2019-09-06T11:17:24Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            },
            {
              "originalPosition": 58,
              "body": "I think we can remove all of Q3 because it has been covered in the new section.",
              "createdAt": "2019-09-06T11:19:03Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg2MTI4MjI0",
          "commit": {
            "abbreviatedOid": "1e3af47"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looking good but still a few questions I think we want to answer before merging.",
          "createdAt": "2019-09-10T12:54:59Z",
          "updatedAt": "2019-09-10T13:03:42Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\r\n  HTTP/1.1 200 OK\r\n```",
              "createdAt": "2019-09-10T12:54:59Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            },
            {
              "originalPosition": 86,
              "body": "```suggestion\r\n   See {{acting-on-resources}}.\r\n```",
              "createdAt": "2019-09-10T12:55:18Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            },
            {
              "originalPosition": 67,
              "body": "I think this sentence comes from me on some earlier thread and I'm not really sure what you're aiming to achieve by including it in this context.\r\n\r\nLets figure out the core intent and write a clear message (I'll help), or just remove it because the new section \"Use of Digest when acting on resources\" does the job now.",
              "createdAt": "2019-09-10T13:00:00Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            },
            {
              "originalPosition": 65,
              "body": "What about other status codes? Perhaps we can give an example that failed and that returns the Digest and etag of the unpatch item (if that is what happens).",
              "createdAt": "2019-09-10T13:01:04Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkyMDkwNDk0",
          "commit": {
            "abbreviatedOid": "3f7b984"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-23T22:34:47Z",
          "updatedAt": "2019-09-23T22:34:47Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This statement seems to me the best way to introduce the vision.",
              "createdAt": "2019-09-23T22:34:47Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkyMDkwNjEz",
          "commit": {
            "abbreviatedOid": "3f7b984"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-23T22:35:06Z",
          "updatedAt": "2019-09-23T22:35:06Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "We may remove this line if it's redundant.",
              "createdAt": "2019-09-23T22:35:06Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkyNTI3NzU3",
          "commit": {
            "abbreviatedOid": "3f7b984"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "A few suggestions made. I don't feel like you need to address them all but please ping me again once ready for another round of review",
          "createdAt": "2019-09-24T15:50:55Z",
          "updatedAt": "2019-09-24T16:07:03Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "```suggestion\r\nResponse:\r\n```",
              "createdAt": "2019-09-24T15:50:55Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            },
            {
              "originalPosition": 102,
              "body": "```suggestion\r\nResponse:\r\n```",
              "createdAt": "2019-09-24T15:51:16Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            },
            {
              "originalPosition": 83,
              "body": "```suggestion\r\n- with the representation digest of the enclosed payload.\r\n```\r\n\r\n",
              "createdAt": "2019-09-24T15:53:12Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            },
            {
              "originalPosition": 147,
              "body": "Editorial suggestion:\r\n\r\nIt would be nice to split the line after the question, and provide a little bit more decription in the. For example\r\n\r\n```\r\n8. How can I generate and validate the Digest values shown in the examples throughout this document?\r\n\r\nThe following python3 script can be used to generate digests using SHA algorithms for a range of encodings. Note that these are formatted as base64. This function could be adapted to other algorithms and should take into account their specific formatting rules.",
              "createdAt": "2019-09-24T16:04:15Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            },
            {
              "originalPosition": 165,
              "body": "why does this example use a temporary dict rather than `item`?",
              "createdAt": "2019-09-24T16:05:30Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkyNjkxODQz",
          "commit": {
            "abbreviatedOid": "76f1b11"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-24T20:35:49Z",
          "updatedAt": "2019-09-24T20:35:49Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "moved to PR",
              "createdAt": "2019-09-24T20:35:49Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzMDE1MTkz",
          "commit": {
            "abbreviatedOid": "76f1b11"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-25T11:47:20Z",
          "updatedAt": "2019-09-25T11:47:20Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "addressing in #938 ",
              "createdAt": "2019-09-25T11:47:20Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MzM3MDg0",
          "commit": {
            "abbreviatedOid": "54f87e1"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good, thanks!",
          "createdAt": "2019-09-27T13:48:28Z",
          "updatedAt": "2019-09-27T13:48:28Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5ODQ2MjM0",
          "commit": {
            "abbreviatedOid": "7c5202f"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I haven't looked at the details; in general, this looks right.\r\n\r\nMy main concern is that this is written as if POST and PATCH are special. They are not.\r\n\r\nShouldn't the rules be the same for *any* HTTP request that has a request payload?",
          "createdAt": "2019-10-31T12:38:40Z",
          "updatedAt": "2019-10-31T12:38:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMDMxMDI3",
          "commit": {
            "abbreviatedOid": "7c5202f"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T16:50:25Z",
          "updatedAt": "2019-10-31T16:50:25Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Further reasoning moved to a new issue #958 ",
              "createdAt": "2019-10-31T16:50:25Z",
              "updatedAt": "2019-11-02T10:25:05Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5564a21c6f55efa7b25167dd130dfb4c4ca06f98",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-853-digest-patch",
      "headRefOid": "29d5a589ccd4b84187f826bd7986ce8bc912d81f",
      "mergeCommit": {
        "oid": "b7228f54f9ed561af545cfb4a782a54b60be5224"
      }
    },
    {
      "number": 924,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE0ODk1ODMw",
      "title": "Fixing typos",
      "url": "https://github.com/httpwg/http-extensions/pull/924",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\n- removes trailing spaces\r\n- links rfcs",
      "createdAt": "2019-09-06T10:33:59Z",
      "updatedAt": "2019-09-06T10:49:08Z",
      "closedAt": "2019-09-06T10:49:07Z",
      "mergedAt": "2019-09-06T10:49:07Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "fca731ac11fc9fcf240fb181c82b37ec0d2789a9",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-typo-1",
      "headRefOid": "8649f92faa0033add11ccfcc2bd900a23ce02c80",
      "mergeCommit": {
        "oid": "7a6a7cb97d71d1348d31b1e07ab52a165ca1950b"
      }
    },
    {
      "number": 926,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE0OTA1MTY2",
      "title": "Fix: #925. Example with PUT+204.",
      "url": "https://github.com/httpwg/http-extensions/pull/926",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nAdds an example with PUT + 204 No Content.\r\n\r\nResponse contains a Digest computed on the selected representation.\r\n\r\nRelated to #853\r\nFixes #925 ",
      "createdAt": "2019-09-06T11:02:48Z",
      "updatedAt": "2019-09-23T16:23:41Z",
      "closedAt": "2019-09-23T16:23:12Z",
      "mergedAt": "2019-09-23T16:23:11Z",
      "mergedBy": "ioggstream",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @reschke, your feedback on this would be great as this is related to https://github.com/httpwg/http-core/issues/255",
          "createdAt": "2019-09-23T07:52:27Z",
          "updatedAt": "2019-09-23T07:52:27Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Questions:\r\n> \r\n> 1. is the Digest in the request supposed to match the payload? (it doesn't seem to, but maybe I'm doing something wrong)\r\n\r\nI used the following (the request uses the `identity` content coding, the response uses `br`\r\n```\r\npython3 -c '\r\nimport base64, json, hashlib\r\ns = json.dumps(dict(hello=\"world\")).encode()\r\nprint(s)\r\n\r\nh = hashlib.sha256(s).digest()\r\nprint(base64.encodebytes(h))\r\n'\r\n```\r\n\r\nIf it's not ok let me know and I'll fix it.\r\n\r\n> 2. please put request and response into different artwork sections\r\n\r\n```\r\nRequest:\r\n\r\n~~~\r\n...\r\n\r\n~~~\r\n\r\n\r\nResponse:\r\n\r\n~~~\r\n...\r\n\r\n~~~\r\n\r\n```\r\n\r\nthanks++",
          "createdAt": "2019-09-23T10:50:45Z",
          "updatedAt": "2019-09-23T10:50:45Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe it's the JSON serializer. I tried\r\n\r\n~~~\r\necho -n '{\"hello\": \"world\"}' | od -cx\r\n0000000   {   \"   h   e   l   l   o   \"   :       \"   w   o   r   l   d\r\n           227b    6568    6c6c    226f    203a    7722    726f    646c\r\n0000020   \"   }\r\n           7d22\r\n0000022\r\n~~~\r\n\r\n~~~\r\necho -n '{\"hello\": \"world\"}' | sha256sum.exe | cut -d ' ' -f1\r\n5f8f04f6a3a892aaabbddb6cf273894493773960d4a325b105fee46eef4304f1\r\n~~~\r\n\r\n~~~\r\necho -n '{\"hello\": \"world\"}' | sha256sum.exe | cut -d ' ' -f1 | tr -d \"\\n\" | base64\r\nNWY4ZjA0ZjZhM2E4OTJhYWFiYmRkYjZjZjI3Mzg5NDQ5Mzc3Mzk2MGQ0YTMyNWIxMDVmZWU0NmVl\r\nZjQzMDRmMQ==\r\n~~~\r\n",
          "createdAt": "2019-09-23T11:02:36Z",
          "updatedAt": "2019-09-23T11:02:36Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke it seems you're base64-encoding the `hexdigest` instead of the `bytes`.\r\n\r\n> echo -n '{\"hello\": \"world\"}' | sha256sum.exe | cut -d ' ' -f1\r\n> 5f8f04f6a3a892aaabbddb6cf273894493773960d4a325b105fee46eef4304f1\r\n\r\nYour output is the one of:\r\n\r\n```\r\npython>>>hex_digest = h.hexdigest().encode()\r\nb'5f8f04f6a3a892aaabbddb6cf273894493773960d4a325b105fee46eef4304f1'\r\n\r\npython>>>base64.encodebytes(hex_digest)                                                                                                                                                                                         \r\nb'NWY4ZjA0ZjZhM2E4OTJhYWFiYmRkYjZjZjI3Mzg5NDQ5Mzc3Mzk2MGQ0YTMyNWIxMDVmZWU0NmVl\\nZjQzMDRmMQ=='\r\n```\r\n\r\nWhile afaik you should \r\n```\r\n>>> byte_digest = h.digest()                                                                                                                                                                                                                         \r\nb'_\\x8f\\x04\\xf6\\xa3\\xa8\\x92\\xaa\\xab\\xbd\\xdbl\\xf2s\\x89D\\x93w9`\\xd4\\xa3%\\xb1\\x05\\xfe\\xe4n\\xefC\\x04\\xf1'\r\n>>> base64.encode(byte_digest)\r\nX48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=\r\n```\r\n\r\nDoes it sound right to you?",
          "createdAt": "2019-09-23T12:00:51Z",
          "updatedAt": "2019-09-23T12:00:51Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Indeed:\r\n\r\n~~~\r\n$ echo -n '{\"hello\": \"world\"}' | sha256sum| cut -d ' ' -f1|xxd -r -p|base64\r\nX48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=\r\n~~~",
          "createdAt": "2019-09-23T12:57:34Z",
          "updatedAt": "2019-09-23T12:57:34Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> 1. I think you should actually state that the Digest in the request is for the enclosed payload.\r\n\r\nDone\r\n\r\n> 2. The artwork should match the actual HTTP/1.1 request; so no leading and trailing blank lines (the latter would imply that there is a line break in the payload).\r\n\r\nI'll address all other occurencies in a new PR. Thanks!\r\n",
          "createdAt": "2019-09-23T14:11:55Z",
          "updatedAt": "2019-09-23T14:11:55Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": ":heart: @reschke @LPardue for all the guidance!",
          "createdAt": "2019-09-23T16:23:41Z",
          "updatedAt": "2019-09-23T16:23:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg0ODEwOTcy",
          "commit": {
            "abbreviatedOid": "2a5670b"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good",
          "createdAt": "2019-09-06T11:39:44Z",
          "updatedAt": "2019-09-06T11:39:44Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkxNjEzNTUz",
          "commit": {
            "abbreviatedOid": "2a5670b"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Questions:\r\n\r\n1) is the Digest in the request supposed to match the payload? (it doesn't seem to, but maybe I'm doing something wrong)\r\n2) please put request and response into different artwork sections\r\n",
          "createdAt": "2019-09-23T08:06:01Z",
          "updatedAt": "2019-09-23T08:06:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkxNzcxODMw",
          "commit": {
            "abbreviatedOid": "ca87b15"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "1. I think you should actually state that the Digest in the request is for the enclosed payload.\r\n\r\n2. The artwork should match the actual HTTP/1.1 request; so no leading and trailing blank lines (the latter would imply that there is a line break in the payload).",
          "createdAt": "2019-09-23T13:23:39Z",
          "updatedAt": "2019-09-23T13:23:39Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkxODEwMjk3",
          "commit": {
            "abbreviatedOid": "cac2e8b"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-23T14:17:20Z",
          "updatedAt": "2019-09-23T14:17:42Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nResponse `Digest` value depends on the representation metadata header fields,\r\n```\r\n\r\njust for consistency",
              "createdAt": "2019-09-23T14:17:21Z",
              "updatedAt": "2019-09-23T15:55:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkxODI0NjYx",
          "commit": {
            "abbreviatedOid": "cac2e8b"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Almost. The response is actually terminated by a blank line (sorry for not being clear in the first place).",
          "createdAt": "2019-09-23T14:36:10Z",
          "updatedAt": "2019-09-23T14:36:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkxODYzMjM5",
          "commit": {
            "abbreviatedOid": "b86dea5"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "For clarify, I'd also add \"Content-Length: 18\" to the request example.\r\n\r\nAnd yet another question: the digest in the response is different because the selected representation uses \"br\" encoding? If so, it might be good to state that.",
          "createdAt": "2019-09-23T15:26:35Z",
          "updatedAt": "2019-09-23T15:27:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkxODk1NTk1",
          "commit": {
            "abbreviatedOid": "5fb6096"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-23T16:15:30Z",
          "updatedAt": "2019-09-23T16:15:30Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7a6a7cb97d71d1348d31b1e07ab52a165ca1950b",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-925",
      "headRefOid": "5fb609657417428ec34ae6a3aca99252380b5f58",
      "mergeCommit": {
        "oid": "f7b2f5ac00ce34fa4afc1bd88c7cd04e74b9a2b7"
      }
    },
    {
      "number": 928,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE1MjE3MTc2",
      "title": "Fix: #927. Unnumbered section should be the lasts",
      "url": "https://github.com/httpwg/http-extensions/pull/928",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nFixes #927",
      "createdAt": "2019-09-07T18:51:41Z",
      "updatedAt": "2019-09-22T16:15:10Z",
      "closedAt": "2019-09-22T16:15:09Z",
      "mergedAt": "2019-09-22T16:15:09Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7a6a7cb97d71d1348d31b1e07ab52a165ca1950b",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-927",
      "headRefOid": "6d5aabe39335f582871ca2f9ef65ff402811fe4e",
      "mergeCommit": {
        "oid": "190093e8b9b54ad446158af4d703708c9f7b00f0"
      }
    },
    {
      "number": 929,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE2Njg0NDk5",
      "title": "http2-tls13: Address feedback from list",
      "url": "https://github.com/httpwg/http-extensions/pull/929",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses feedback from the list:\r\nhttps://lists.w3.org/Archives/Public/ietf-http-wg/2019JulSep/0266.html\r\nhttps://lists.w3.org/Archives/Public/ietf-http-wg/2019JulSep/0271.html\r\n\r\n@martinthomson @MikeBishop, does this look good to you?",
      "createdAt": "2019-09-12T00:33:55Z",
      "updatedAt": "2019-09-13T15:56:56Z",
      "closedAt": "2019-09-13T15:56:55Z",
      "mergedAt": "2019-09-13T15:56:55Z",
      "mergedBy": "davidben",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg3MTQ3Mjkx",
          "commit": {
            "abbreviatedOid": "e3eeac4"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Very nice, thanks.\r\n\r\nYou almost managed to do this with a net reduction in total lines.  The only additions here are my fault.  Respect.",
          "createdAt": "2019-09-12T00:59:31Z",
          "updatedAt": "2019-09-12T00:59:31Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7a6a7cb97d71d1348d31b1e07ab52a165ca1950b",
      "headRepository": "davidben/http-extensions",
      "headRefName": "http2-tls13-update",
      "headRefOid": "e3eeac4a7dc3943d87b39b0e451a0877658f4b6f",
      "mergeCommit": {
        "oid": "8f70ac05db5289d72215608c878b2c95c1247256"
      }
    },
    {
      "number": 932,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE3NjMzMDE5",
      "title": "h2tls13: fix section references",
      "url": "https://github.com/httpwg/http-extensions/pull/932",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-09-15T12:16:00Z",
      "updatedAt": "2019-09-20T20:03:01Z",
      "closedAt": "2019-09-16T20:42:17Z",
      "mergedAt": "2019-09-16T20:42:17Z",
      "mergedBy": "davidben",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(Should I go ahead and stamp a -02 now, or wait a bit? Not sure how one usually handles such things.)",
          "createdAt": "2019-09-16T20:43:10Z",
          "updatedAt": "2019-09-16T20:43:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "WGLC ends on Thursday, so let's wait until then to see if there's any other feedback. ",
          "createdAt": "2019-09-17T00:36:43Z",
          "updatedAt": "2019-09-17T00:36:43Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is Friday, so I've now pushed -02. It just contains this PR.\r\nhttps://www.ietf.org/rfcdiff?url2=draft-ietf-httpbis-http2-tls13-02",
          "createdAt": "2019-09-20T20:03:01Z",
          "updatedAt": "2019-09-20T20:03:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg4Mzg2ODY3",
          "commit": {
            "abbreviatedOid": "d7ba51c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-15T23:12:54Z",
          "updatedAt": "2019-09-15T23:12:54Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg4ODg4MzUw",
          "commit": {
            "abbreviatedOid": "d7ba51c"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-16T20:42:10Z",
          "updatedAt": "2019-09-16T20:42:10Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8f70ac05db5289d72215608c878b2c95c1247256",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-h2tls13",
      "headRefOid": "d7ba51c914f763d637aadfd21d12ae2a6ee7536f",
      "mergeCommit": {
        "oid": "99a8dda1bf740326cab54e5ab7a841904830bd10"
      }
    },
    {
      "number": 935,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIwMzM0NDY0",
      "title": "Fix: #934. Reformat artworks.",
      "url": "https://github.com/httpwg/http-extensions/pull/935",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers",
        "editorial"
      ],
      "body": "## This PR\r\n\r\nFixes artwork formatting.",
      "createdAt": "2019-09-23T14:50:42Z",
      "updatedAt": "2019-09-23T16:52:53Z",
      "closedAt": "2019-09-23T16:52:52Z",
      "mergedAt": "2019-09-23T16:52:52Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f7b2f5ac00ce34fa4afc1bd88c7cd04e74b9a2b7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-934",
      "headRefOid": "7e739b3477c8e6d4240c9a01299731fffd2cc748",
      "mergeCommit": {
        "oid": "36067f445af93aa36c194e3d380d38b2f8c3b6cf"
      }
    },
    {
      "number": 937,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIwODUyOTc1",
      "title": "Fix: #936. Cache semantics impacts on Digest and on the representation.",
      "url": "https://github.com/httpwg/http-extensions/pull/937",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nClarifies the following points:\r\n\r\n- resource identification is inherited from SEMANTICS\r\n- validator fields (ETags & Last Modified) which apply to the identified resource, apply to Digest too.",
      "createdAt": "2019-09-24T16:15:32Z",
      "updatedAt": "2020-08-26T13:22:31Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5af1520b6f163d3601178a1249f2213c0bd3469d",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-936",
      "headRefOid": "945809a8b266f3294fe22ccd81c2090cf3470083",
      "closedAt": "2020-08-26T13:22:30Z",
      "mergedAt": "2020-08-26T13:22:30Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "54472b0c7e9f1c66dbef5bf79b8db00c7e058e39"
      },
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'll merge the content-location stuff and leave the resource identification to this issue (which is the hard part). This will push forward the ongoing work on POST/PATCH.",
          "createdAt": "2019-10-09T15:55:24Z",
          "updatedAt": "2019-10-09T15:55:24Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke @LPardue PTAL :)",
          "createdAt": "2020-08-17T13:13:38Z",
          "updatedAt": "2020-08-17T13:13:38Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Consider me confused.\r\n\r\nCurrently, the draft says:\r\n\r\n\"The resource is specified by the effective request URI and any validator field contained in the message.\"\r\n\r\n...and then, in that section, doesn't mention \"resource\" anymore.\r\n\r\nWhat was the intent of that statement? Can't it be just removed?",
          "createdAt": "2020-08-17T13:28:43Z",
          "updatedAt": "2020-08-17T13:28:43Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Currently, the draft says:\r\n> \r\n> \"The resource is specified by the effective request URI and any validator field contained in the message.\"\r\n> \r\n> ...and then, in that section, doesn't mention \"resource\" anymore.\r\n> \r\n> What was the intent of that statement?\r\n\r\nThe statement originates from https://tools.ietf.org/html/rfc3230#section-4.3.2 . \r\nMy understanding is that the original author stated explicitly that Digest must be aligned with  Last-Modified & co.\r\nThis could be trivial though...\r\n\r\n> Can't it be just removed?\r\n\r\nIt is reasonable to me to remove the whole statement \r\n\r\n```\r\n\ufffc The resource is specified by the effective request URI and any validator field contained in the message\r\n```\r\n\r\nand delegate the resource specification to https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#target.resource\r\n\r\n@LPardue  @mnot WDYT?\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2020-08-17T14:19:11Z",
          "updatedAt": "2020-08-17T14:19:11Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My bad, Mark replied https://github.com/httpwg/http-extensions/issues/949#issuecomment-673931768 with the above proposal. Let's do it then!",
          "createdAt": "2020-08-17T14:59:47Z",
          "updatedAt": "2020-08-17T14:59:47Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Current wording integrates @reschke and @mnot suggestion (iiuc).",
          "createdAt": "2020-08-17T16:05:22Z",
          "updatedAt": "2020-08-17T16:05:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah I forgot about the clash with 850. Let's land this and I see you've made a signpost back to my editorial suggestion so we don't lose it.",
          "createdAt": "2020-08-18T11:16:34Z",
          "updatedAt": "2020-08-18T11:16:34Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok, to me this is complete. I'll leave to @LPardue  the decision to merge or to wait for further feedback.",
          "createdAt": "2020-08-18T11:32:47Z",
          "updatedAt": "2020-08-18T11:32:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkyNTQ2Mzkw",
          "commit": {
            "abbreviatedOid": "131f25f"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-24T16:19:36Z",
          "updatedAt": "2019-09-24T16:19:37Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "`201 OK` ??",
              "createdAt": "2019-09-24T16:19:36Z",
              "updatedAt": "2020-08-18T08:02:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkyNjcyNDgw",
          "commit": {
            "abbreviatedOid": "131f25f"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-24T20:00:37Z",
          "updatedAt": "2019-09-24T20:00:37Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "@LPardue I need some guidance here:\r\n\r\n- iiuc cache validators are ETags & Last Modified [RFC2616 s. 13.3.3 ](https://tools.ietf.org/html/rfc2616#section-13.3.3)\r\n\r\nit's not clear to me:\r\n\r\n* how a cache validator specify a resource;\r\n* I stubbed a translation to RFC723x in #940 ",
              "createdAt": "2019-09-24T20:00:37Z",
              "updatedAt": "2020-08-18T08:02:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk4MjYyNTIz",
          "commit": {
            "abbreviatedOid": "0bb4cc0"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-07T16:40:57Z",
          "updatedAt": "2019-10-07T16:40:57Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "sorry, not a caching expert so my opinion might not help much here.",
              "createdAt": "2019-10-07T16:40:57Z",
              "updatedAt": "2020-08-18T08:02:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5MzQyNDM1",
          "commit": {
            "abbreviatedOid": "906049b"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-09T11:29:43Z",
          "updatedAt": "2019-10-09T11:29:44Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "As @reschke had similar considerations in https://github.com/httpwg/http-extensions/pull/940#pullrequestreview-299297863\r\n\r\nI asked his help.",
              "createdAt": "2019-10-09T11:29:43Z",
              "updatedAt": "2020-08-18T08:02:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5NTA2Mjk3",
          "commit": {
            "abbreviatedOid": "011eafe"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-09T15:35:32Z",
          "updatedAt": "2019-10-09T15:35:32Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Can that work?\r\n```\r\nselected representation-data is identified accordingly to Section 3.1.4.1 of [RFC7231].\r\nhttps://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#identifying.payload\r\n```",
              "createdAt": "2019-10-09T15:35:32Z",
              "updatedAt": "2020-08-18T08:02:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5NjMwMDkx",
          "commit": {
            "abbreviatedOid": "4edb97e"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-09T19:01:26Z",
          "updatedAt": "2019-10-09T19:01:26Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I thought twice. Probably rfc 3230 refers to receiving a cached `Digest`.\r\n\r\n`validators` do not identify the resource on the origin server \r\n but it's cached representation. Let me know, R.",
              "createdAt": "2019-10-09T19:01:26Z",
              "updatedAt": "2020-08-18T08:02:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1ODY1MTgz",
          "commit": {
            "abbreviatedOid": "4edb97e"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-17T09:28:55Z",
          "updatedAt": "2020-03-17T09:28:56Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n`Digest` field-value can be cached by intermediaries.\r\n```",
              "createdAt": "2020-03-17T09:28:55Z",
              "updatedAt": "2020-08-18T08:02:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4NTkzNjg5",
          "commit": {
            "abbreviatedOid": "0dd657c"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-17T15:59:45Z",
          "updatedAt": "2020-08-17T15:59:46Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n(see Section 7 of {{SEMANTICS}}) of a resource identified according to Section 7.3.2 of {{SEMANTICS}}\r\n```",
              "createdAt": "2020-08-17T15:59:45Z",
              "updatedAt": "2020-08-18T08:02:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4NTk0Nzk2",
          "commit": {
            "abbreviatedOid": "0dd657c"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-17T16:01:04Z",
          "updatedAt": "2020-08-17T16:01:04Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nDigest MAY be cached and the freshness information of the resource, eventually conveyed by validator\r\n header fields or other cache headers, apply to its value too.\r\n```",
              "createdAt": "2020-08-17T16:01:04Z",
              "updatedAt": "2020-08-18T08:02:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTQ0MDIw",
          "commit": {
            "abbreviatedOid": "85a2951"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T02:10:52Z",
          "updatedAt": "2020-08-18T02:10:52Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Generally, we try to avoid re-stating requirements in other specs, or constraining how they're interpreted, because that makes the composition of the specs more brittle -- there's more chance of misinterpretation or unintentional misalignment (either as written or after some future change in the dependency).\r\n\r\nSo if you say anything at all, it shouldn't be a RFC2119 requirement; just some prose about the relationship for reader convenience.",
              "createdAt": "2020-08-18T02:10:52Z",
              "updatedAt": "2020-08-18T08:02:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5MDgyNTM2",
          "commit": {
            "abbreviatedOid": "85a2951"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T07:59:34Z",
          "updatedAt": "2020-08-18T07:59:34Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Thanks @mnot. Let's drop those lines then! ",
              "createdAt": "2020-08-18T07:59:34Z",
              "updatedAt": "2020-08-18T08:02:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5MDgzNjYw",
          "commit": {
            "abbreviatedOid": "85a2951"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T08:00:59Z",
          "updatedAt": "2020-08-18T08:00:59Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-08-18T08:00:59Z",
              "updatedAt": "2020-08-18T08:02:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5MTE4NzUz",
          "commit": {
            "abbreviatedOid": "945809a"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T08:45:59Z",
          "updatedAt": "2020-08-18T08:58:48Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "This new text look technically fine but the sentence is a bit long winded now, especially with the\r\nparameter comment in brackets. How about some editorializing like this, which intentially avoids saying anything about parameters.\r\n\r\n```\r\nA representation digest consists of a `digest-algorithm` followed by an `encoded digest output`.\r\n\r\n~~~ abnf\r\n   representation-data-digest = digest-algorithm \"=\"\r\n                                <encoded digest output>\r\n~~~\r\n\r\nThe `digest-algorithm` identifies both an algorithm and output encoding format which are applied\r\nto a representation. A checksum value is first computed on the entire selected `representation data`\r\n(see Section 7 of {{SEMANTICS}}) of a resource identified according to Section 7.3.2 of {{SEMANTICS}}.\r\nThis is then encoded using the required format.\r\n\r\nThe list of defined `digest-algorithms` is provided in {{algorithms}}.\r\n\r\nThe example below shows the `sha-256` digest-algorithm which uses base64 encoding.\r\n\r\n~~~ example\r\n   sha-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=\r\n~~~\r\n```",
              "createdAt": "2020-08-18T08:45:59Z",
              "updatedAt": "2020-08-18T08:58:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5MjIxNzk5",
          "commit": {
            "abbreviatedOid": "945809a"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T11:07:34Z",
          "updatedAt": "2020-08-18T11:07:34Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "If this is technically ok, I suggest to:\r\n\r\n- merge and close the issue;\r\n- resolve #850 (parameters);\r\n- rewording in another PR.\r\n\r\nIn the rewording, we could even avoid mentioning the \"encoding\" part as I think it should only be mentioned in the `digest-algorithm` section.\r\n\r\nWDYT?",
              "createdAt": "2020-08-18T11:07:34Z",
              "updatedAt": "2020-08-18T11:07:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NDU2NzUx",
          "commit": {
            "abbreviatedOid": "945809a"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-26T12:54:08Z",
          "updatedAt": "2020-08-26T12:54:09Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "sgtm",
              "createdAt": "2020-08-26T12:54:09Z",
              "updatedAt": "2020-08-26T12:54:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NDU3MzQ0",
          "commit": {
            "abbreviatedOid": "945809a"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-26T12:54:54Z",
          "updatedAt": "2020-08-26T12:54:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 939,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIxMjEwMDMy",
      "title": "Fix: #938. Add code samples.",
      "url": "https://github.com/httpwg/http-extensions/pull/939",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nAdd code samples.",
      "createdAt": "2019-09-25T12:02:10Z",
      "updatedAt": "2019-09-27T17:20:36Z",
      "closedAt": "2019-09-27T17:20:35Z",
      "mergedAt": "2019-09-27T17:20:35Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0MzM1NjMx",
          "commit": {
            "abbreviatedOid": "20dd05c"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-09-27T13:46:17Z",
          "updatedAt": "2019-09-27T13:46:17Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1b1ea5e9711c8925e5e280521d8b568cd987b858",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-938",
      "headRefOid": "20dd05c0306d4afaf9312b1fb4a8efea1557da79",
      "mergeCommit": {
        "oid": "246d3cdd4208eb169ae0dcc2f7c0d0363d6cc80b"
      }
    },
    {
      "number": 940,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIxNDY3MTQx",
      "title": "Replace cache-validator with validator (rfc 7231 section 7.2)",
      "url": "https://github.com/httpwg/http-extensions/pull/940",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## I expect\r\n\r\nto use the new \"validator\" name. See: \r\n\r\n- https://tools.ietf.org/html/rfc7231#section-7.2\r\n- https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#response.validator",
      "createdAt": "2019-09-25T22:40:58Z",
      "updatedAt": "2019-10-09T11:55:05Z",
      "closedAt": "2019-10-09T11:55:04Z",
      "mergedAt": "2019-10-09T11:55:04Z",
      "mergedBy": "ioggstream",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke I'm quite weak on that side: is this PR correct? If not feel free to fix at will :)",
          "createdAt": "2019-10-09T08:58:15Z",
          "updatedAt": "2019-10-09T08:58:15Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke I agree... this comes from the original RFC 3230. \r\n\r\nMerging the change as a simple terminology update.\r\n\r\nThe relation b/w validators and the resource is discussed in #937, where I tagged you as  your guidance will be great. See #936 too.",
          "createdAt": "2019-10-09T10:04:32Z",
          "updatedAt": "2019-10-09T11:54:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5Mjk3ODYz",
          "commit": {
            "abbreviatedOid": "ddd9492"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "The change itself looks right.\r\n\r\nI wonder however about the whole paragraph: what does it mean to say \"resource is specified\"? Doesn't that also need request header fields upon which the returned representation varies?",
          "createdAt": "2019-10-09T09:57:41Z",
          "updatedAt": "2019-10-09T09:57:41Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "06c1bf0ba1d41782484a6b562cb60eafae4c4d76",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-936-pre",
      "headRefOid": "74d620e12717b4ba037b74a61eba9a73403d7184",
      "mergeCommit": {
        "oid": "67859250f0bca8adafc41c5f923ed11169867be8"
      }
    },
    {
      "number": 941,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIyOTY5ODc5",
      "title": "Specify recommended HTTP status code for connnection_limit_reached",
      "url": "https://github.com/httpwg/http-extensions/pull/941",
      "state": "MERGED",
      "author": "ghedo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "proxy-status"
      ],
      "body": "Rationale for 503 is that the service is unavailable due to too many\r\nconnections.\r\n\r\n429 could potentially be an option as well, but that seems more specific to a single user hitting a rate limit, while `connnection_limit_reached` seems more related to a global limit.\r\n\r\n/cc @mnot @PiotrSikora ",
      "createdAt": "2019-09-30T20:53:03Z",
      "updatedAt": "2019-10-18T18:44:36Z",
      "closedAt": "2019-10-18T18:44:35Z",
      "mergedAt": "2019-10-18T18:44:35Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "246d3cdd4208eb169ae0dcc2f7c0d0363d6cc80b",
      "headRepository": "ghedo/http-extensions",
      "headRefName": "connnection_limit_reached_status_code",
      "headRefOid": "76c6233b6e7741e8772cd6a995a0b4edcff6b382",
      "mergeCommit": {
        "oid": "2b3e22a512e154af67345350219e09437581b84f"
      }
    },
    {
      "number": 944,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIzOTcyODk1",
      "title": "Try to set country",
      "url": "https://github.com/httpwg/http-extensions/pull/944",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ioggstream"
      ],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nAdd country author",
      "createdAt": "2019-10-02T22:36:12Z",
      "updatedAt": "2019-10-02T22:42:12Z",
      "closedAt": "2019-10-02T22:42:11Z",
      "mergedAt": "2019-10-02T22:42:11Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "246d3cdd4208eb169ae0dcc2f7c0d0363d6cc80b",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-test-country",
      "headRefOid": "1607a06807d5f62eed2d07261f51d283311d3a67",
      "mergeCommit": {
        "oid": "f45fc1bcb1a073524cd388b1f4502ddfdc2bcfa9"
      }
    },
    {
      "number": 946,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI1MDAzMTI3",
      "title": "[WIP] EU Cookie Law Mechanisms",
      "url": "https://github.com/httpwg/http-extensions/pull/946",
      "state": "OPEN",
      "author": "ttacker",
      "authorAssociation": "FIRST_TIME_CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "* Add attributes to Set-Cookie syntax\r\n* Update Set-Cookie semantics\r\n* Add subcomponent algorithms and todo throughout\r\n\r\nI had started work on this PR to address issue #945 before it was closed. I thought other people might like to see my initial thoughts, so I created this PR as a WIP. I'm not requesting it be merged, and it can be closed; but if anyone wants to provide feedback, that would be welcome. Thanks!",
      "createdAt": "2019-10-06T05:42:08Z",
      "updatedAt": "2019-10-16T07:31:53Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "petkivim",
          "authorAssociation": "NONE",
          "body": "It might me a good idea to include the action in the Consent attribute's value or alternatively, define separate attributes for the action and time, e.g.:\r\n```\r\nconsent-av        = \"Consent=\" consent-action \";\" consent-date\r\nconsent-action    = \"Unconfirmed\" / \"Granted\" / \"Revoked\"\r\nconsent-date      = <IMF-fixdate>\r\n                      ; IMF-fixdate defined in [RFC7231], Section 7.1.1.1\r\n```\r\n\r\nOR\r\n\r\n```\r\nconsent-action-av  = \"ConsentAction=\" consent-action\r\nconsent-action     = \"Unconfirmed\" / \"Granted\" / \"Revoked\"\r\nconsent-date-av    = \"ConsentDate=\" consent-date\r\nconsent-date       = <IMF-fixdate>\r\n                      ; IMF-fixdate defined in [RFC7231], Section 7.1.1.1\r\n```\r\n\r\nIn this way it is possible to prove that consent occurred, even if subsequently withdrawn. In case the Consent attribute is just unset when consent is withdrawn, there's no trace that consent occurred earlier.",
          "createdAt": "2019-10-12T06:01:42Z",
          "updatedAt": "2019-10-12T06:38:51Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As suggested by @mnot I propose to create a new draft for addressing this, which could be easily integrated or extend current one.\r\n\r\nI'm volunteering as co-editor and I can setup the repo with an automatic draft build in minutes. @ttacker\r\n\r\n",
          "createdAt": "2019-10-14T06:18:17Z",
          "updatedAt": "2019-10-15T07:01:07Z"
        },
        {
          "author": "awwright",
          "authorAssociation": "NONE",
          "body": "Doesn't consent occur when the user-agent saves the cookie to storage? Saving cookies is something the user-agent must opt into on behalf of the user; not by the server.\r\n\r\nThe one thing that seems to be missing is a way to link to the cookie policy; but didn't P3P already standardize a way to do this?",
          "createdAt": "2019-10-16T03:06:27Z",
          "updatedAt": "2019-10-16T03:06:27Z"
        },
        {
          "author": "pbowyer",
          "authorAssociation": "NONE",
          "body": "> Doesn't consent occur when the user-agent saves the cookie to storage? Saving cookies is something the user-agent must opt into on behalf of the user; not by the server.\r\n\r\nYes that is correct.",
          "createdAt": "2019-10-16T07:17:18Z",
          "updatedAt": "2019-10-16T07:17:18Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> didn't P3P already standardize a way to do this?\r\n\r\nafaik P3P is somewhat deprecated, see https://bugzilla.mozilla.org/show_bug.cgi?id=225287#c12",
          "createdAt": "2019-10-16T07:31:53Z",
          "updatedAt": "2019-10-16T07:31:53Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f45fc1bcb1a073524cd388b1f4502ddfdc2bcfa9",
      "headRepository": "ttacker/http-extensions",
      "headRefName": "945-eu-cookie-law-mechanisms",
      "headRefOid": "0a691c1465bfcb1224ff469c698b9aa42a464fe1",
      "mergeCommit": null
    },
    {
      "number": 950,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI2MTU3OTk5",
      "title": "Ioggstream typos 1",
      "url": "https://github.com/httpwg/http-extensions/pull/950",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nfixes typos and split lines",
      "createdAt": "2019-10-09T09:35:01Z",
      "updatedAt": "2019-10-09T09:37:33Z",
      "closedAt": "2019-10-09T09:37:32Z",
      "mergedAt": "2019-10-09T09:37:32Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d0dc68b3a8a53b4f057964f5c4194c8baddd297e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-typos-1",
      "headRefOid": "ebffdb0b16ac5afd40cbbbfb077483d8ad7e93b0",
      "mergeCommit": {
        "oid": "06c1bf0ba1d41782484a6b562cb60eafae4c4d76"
      }
    },
    {
      "number": 951,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI2MjEyMjIz",
      "title": "Refresh validator definition. #936",
      "url": "https://github.com/httpwg/http-extensions/pull/951",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nReplaces the old `cache-validator` with `validator` from https://tools.ietf.org/html/rfc7231#section-7.2\r\n\r\n## Note\r\n\r\nThe relations of Last-Modified and ETag with Digest are examined in #937 ",
      "createdAt": "2019-10-09T11:49:51Z",
      "updatedAt": "2019-10-09T11:55:06Z",
      "closedAt": "2019-10-09T11:55:05Z",
      "mergedAt": "2019-10-09T11:55:05Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "06c1bf0ba1d41782484a6b562cb60eafae4c4d76",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-936-notations",
      "headRefOid": "74d620e12717b4ba037b74a61eba9a73403d7184",
      "mergeCommit": {
        "oid": "74d620e12717b4ba037b74a61eba9a73403d7184"
      }
    },
    {
      "number": 953,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI2MzM3NzY3",
      "title": "Fix: #952. Content-Location impacts on digest",
      "url": "https://github.com/httpwg/http-extensions/pull/953",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\n- Adds further HTTP semantics impacts on the representation.\r\n- Add security considerations for content-location.",
      "createdAt": "2019-10-09T16:17:23Z",
      "updatedAt": "2020-03-01T20:55:59Z",
      "closedAt": "2020-03-01T20:55:52Z",
      "mergedAt": "2020-03-01T20:55:52Z",
      "mergedBy": "ioggstream",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue ping :)",
          "createdAt": "2019-10-31T09:30:41Z",
          "updatedAt": "2019-10-31T09:30:41Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue did I address all your comments?",
          "createdAt": "2019-12-04T14:56:39Z",
          "updatedAt": "2019-12-04T14:56:39Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merge PR as per https://github.com/httpwg/http-extensions/pull/953#discussion_r385100059",
          "createdAt": "2020-03-01T20:55:59Z",
          "updatedAt": "2020-03-01T20:55:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA0MTkyMjAy",
          "commit": {
            "abbreviatedOid": "e682295"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "The comments I made and seemingly lost, seem to have got cached by Github! I'm submitting them as they were at the time",
          "createdAt": "2019-10-19T02:48:37Z",
          "updatedAt": "2019-10-31T11:21:00Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Nit: \"header field explicit that the representation\" is a weird language construct, would be better to record this",
              "createdAt": "2019-10-19T02:48:38Z",
              "updatedAt": "2020-03-01T20:38:57Z"
            },
            {
              "originalPosition": 41,
              "body": "I dont understand this change. I thought Request-URI is a proper term and thus the change is breaking. But I could be wrong.",
              "createdAt": "2019-10-19T02:50:36Z",
              "updatedAt": "2020-03-01T20:38:57Z"
            },
            {
              "originalPosition": 50,
              "body": "Do we need the comma? What is the intent for this change?",
              "createdAt": "2019-10-19T02:51:24Z",
              "updatedAt": "2020-03-01T20:38:57Z"
            },
            {
              "originalPosition": 61,
              "body": "Do we need `metadata` here? It seems superfluous ",
              "createdAt": "2019-10-19T02:52:25Z",
              "updatedAt": "2020-03-01T20:38:57Z"
            },
            {
              "originalPosition": 81,
              "body": "The paragraph seems orphaned - standalone I don't think it helps the reader.",
              "createdAt": "2019-10-19T02:54:30Z",
              "updatedAt": "2020-03-01T20:38:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5ODEwNzI0",
          "commit": {
            "abbreviatedOid": "925f352"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T11:29:23Z",
          "updatedAt": "2019-10-31T11:29:23Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "afaik:\r\n\r\n- \"request URI\" is RFC 7230 https://tools.ietf.org/html/rfc7230#section-5.5 \"effective request URI\"\r\n- \"Request-URI\" is RFC 2616 https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html\r\n\r\n",
              "createdAt": "2019-10-31T11:29:23Z",
              "updatedAt": "2020-03-01T20:38:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5ODEyMzY2",
          "commit": {
            "abbreviatedOid": "925f352"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T11:32:33Z",
          "updatedAt": "2019-10-31T11:32:34Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "that has been moved in another PR though.",
              "createdAt": "2019-10-31T11:32:33Z",
              "updatedAt": "2020-03-01T20:38:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5ODEyOTc0",
          "commit": {
            "abbreviatedOid": "925f352"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T11:33:45Z",
          "updatedAt": "2019-10-31T11:33:45Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nWhen a state-changing method returns the `Content-Location` header field,\r\n```",
              "createdAt": "2019-10-31T11:33:45Z",
              "updatedAt": "2020-03-01T20:38:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5ODIwMjU4",
          "commit": {
            "abbreviatedOid": "758535a"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T11:48:17Z",
          "updatedAt": "2019-10-31T11:48:18Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Fixed in the latest commit. Please let me know if that's ok or feel free to put in a better form :)",
              "createdAt": "2019-10-31T11:48:18Z",
              "updatedAt": "2020-03-01T20:38:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5ODIwOTAy",
          "commit": {
            "abbreviatedOid": "758535a"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T11:49:32Z",
          "updatedAt": "2019-10-31T11:49:33Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "fixed in the last PR.",
              "createdAt": "2019-10-31T11:49:33Z",
              "updatedAt": "2020-03-01T20:38:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI2OTE2OTg3",
          "commit": {
            "abbreviatedOid": "01d8f34"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-04T15:08:25Z",
          "updatedAt": "2019-12-04T15:08:26Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "I'm not 100% sure what \"external resource\" means in this consideration, nor what the malicious intermediary can achieve by this type of attack. \r\n\r\nIt might help to be a little more specific here, by my understanding we might want to say something like the candidate text - but maybe I'm completely off?\r\n\r\n```\r\nA malicious intermediary may add a `Content-Location` header field containing an absolute URL that references\r\na resource on a different host than the original request. This would assert that the enclosed representation and its `Digest` relate to the third-party resource. The effect on a client attempting to validate the `Digest` is [insert here].\r\n```",
              "createdAt": "2019-12-04T15:08:25Z",
              "updatedAt": "2020-03-01T20:38:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxMDE0Nzc0",
          "commit": {
            "abbreviatedOid": "01d8f34"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-19T10:52:46Z",
          "updatedAt": "2020-02-19T10:52:46Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "@LPardue wdyt about removing lines 1066-1069? They are a repetition of the RFC 7231 and \r\nit's probably better to remove them.",
              "createdAt": "2020-02-19T10:52:46Z",
              "updatedAt": "2020-03-01T20:38:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NjQ2MzYw",
          "commit": {
            "abbreviatedOid": "01d8f34"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-27T12:38:27Z",
          "updatedAt": "2020-02-27T12:38:28Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Let's drop it and merge the PR",
              "createdAt": "2020-02-27T12:38:27Z",
              "updatedAt": "2020-03-01T20:38:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2ODg0ODcx",
          "commit": {
            "abbreviatedOid": "01d8f34"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-01T20:38:05Z",
          "updatedAt": "2020-03-01T20:38:05Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "```suggestion\r\n```\r\n\r\nRemoved as agreed above.",
              "createdAt": "2020-03-01T20:38:05Z",
              "updatedAt": "2020-03-01T20:38:57Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "02cfd3070f140e2870eb0847661cfd0b042e7e36",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-952",
      "headRefOid": "2b23886461d55896c500446ac91379d86bf93107",
      "mergeCommit": {
        "oid": "0f8062eb3718d7ef4eff41fa5f8e13a38c42281e"
      }
    },
    {
      "number": 954,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI2NDg1OTI0",
      "title": "Allow parameters on Items and Inner Lists",
      "url": "https://github.com/httpwg/http-extensions/pull/954",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "For #907",
      "createdAt": "2019-10-09T23:18:21Z",
      "updatedAt": "2019-10-25T04:32:22Z",
      "closedAt": "2019-10-25T04:32:21Z",
      "mergedAt": "2019-10-25T04:32:21Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm having some other issues with my roughed-in implementation, but I think the algorithm to parse parameters aggressively consumes leading OWS, so when you have an inner-list it consumes the spaces between items.",
          "createdAt": "2019-10-14T02:45:18Z",
          "updatedAt": "2019-10-14T02:45:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Ah, that makes sense, will have a look.",
          "createdAt": "2019-10-14T16:46:27Z",
          "updatedAt": "2019-10-14T16:46:27Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe removing the 'SP or )' check from the bottom of the inner-list parsing algorithm also lets you change the ABNF to `RWS`.",
          "createdAt": "2019-10-14T23:10:39Z",
          "updatedAt": "2019-10-14T23:10:39Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I can't think of a way around it without adding a delimiter (comma?) in inner-lists. Or being super strict about whitespace and cutting down on OWS.",
          "createdAt": "2019-10-16T20:21:24Z",
          "updatedAt": "2019-10-16T20:26:55Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I was playing around with a regular expression parser to check the ABNF, and noticed this:\r\n\r\n```\r\nparameter     = OWS \";\" OWS param-name [ \"=\" param-value ]\r\nparam-value   = sh-item\r\nsh-item   = bare-item *parameter\r\n```\r\n\r\n`param-value` should be a `bare-item`",
          "createdAt": "2019-10-22T23:56:39Z",
          "updatedAt": "2019-10-22T23:56:39Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Weird; I'd seen that and thought I'd fixed it; huh.\r\n\r\nFixed; thanks.",
          "createdAt": "2019-10-23T07:04:38Z",
          "updatedAt": "2019-10-23T07:04:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "It's the `OWS` before `;`, isn't it?\r\n\r\nI'm kinda fine ditching that; WDYT?",
          "createdAt": "2019-10-23T07:15:13Z",
          "updatedAt": "2019-10-23T07:15:13Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh yeah, that's right. I'm happy removing it.\r\n\r\nIt invalidates the ABNF slightly, but I think that's easy enough to resolve.",
          "createdAt": "2019-10-25T01:48:11Z",
          "updatedAt": "2019-10-25T01:48:11Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OK, that's in. I'm going to take one more look over this, merge it, and clean up a few other things, then get another draft out.",
          "createdAt": "2019-10-25T03:49:21Z",
          "updatedAt": "2019-10-25T03:49:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5NzUyOTgx",
          "commit": {
            "abbreviatedOid": "01d1e89"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-09T23:34:20Z",
          "updatedAt": "2019-10-09T23:34:20Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Not related to this PR per se, but I just realised the ABNF for inner list says exactly `SP` between items, but the parsing algorithm accepts `SP` followed by any other `OWS`",
              "createdAt": "2019-10-09T23:34:20Z",
              "updatedAt": "2019-10-25T03:47:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5NzUzNTg5",
          "commit": {
            "abbreviatedOid": "01d1e89"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-09T23:36:40Z",
          "updatedAt": "2019-10-09T23:36:41Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Hm. IIRC my thinking when I wrote this was that the ABNF was illustrating the \"correct\" on-wire form, rather than being a way to write a parser. Still, we could import `RWS` and use that...",
              "createdAt": "2019-10-09T23:36:40Z",
              "updatedAt": "2019-10-25T03:47:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5NzU3MDY4",
          "commit": {
            "abbreviatedOid": "2160827"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-09T23:49:46Z",
          "updatedAt": "2019-10-09T23:49:47Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I've absolutely no doubt someone will assume the ABNF and the algorithms match, and write a regexp parser based on the former.\r\n\r\n(_sotto voce_) `RWS` still doesn't work, because it must start with `SP`",
              "createdAt": "2019-10-09T23:49:47Z",
              "updatedAt": "2019-10-25T03:47:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5NzU3NTcw",
          "commit": {
            "abbreviatedOid": "2160827"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-09T23:51:40Z",
          "updatedAt": "2019-10-09T23:51:40Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "So maybe we should make the parsing algorithm more strict, either `SP` or `1*SP`",
              "createdAt": "2019-10-09T23:51:40Z",
              "updatedAt": "2019-10-25T03:47:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5NzU4NjA4",
          "commit": {
            "abbreviatedOid": "2160827"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-09T23:55:38Z",
          "updatedAt": "2019-10-09T23:55:38Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Just `SP` works for me. That way it couldn't mask something like a null value that gets written as a zero-length string, for example.",
              "createdAt": "2019-10-09T23:55:38Z",
              "updatedAt": "2019-10-25T03:47:25Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "67859250f0bca8adafc41c5f923ed11169867be8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-907",
      "headRefOid": "71b98dcc474aa9443733be1b9e8e154935040937",
      "mergeCommit": {
        "oid": "d5faf9864dc45eeb87193f6a42662b390a3d4979"
      }
    },
    {
      "number": 955,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI5NDI0Nzg1",
      "title": "Address IESG comments",
      "url": "https://github.com/httpwg/http-extensions/pull/955",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-10-17T19:28:22Z",
      "updatedAt": "2019-10-17T19:53:26Z",
      "closedAt": "2019-10-17T19:53:25Z",
      "mergedAt": "2019-10-17T19:53:25Z",
      "mergedBy": "davidben",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAzNTA1NjQ1",
          "commit": {
            "abbreviatedOid": "6dff4f8"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-17T19:52:17Z",
          "updatedAt": "2019-10-17T19:52:17Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "67859250f0bca8adafc41c5f923ed11169867be8",
      "headRepository": "davidben/http-extensions",
      "headRefName": "http2-tls13-iesg",
      "headRefOid": "6dff4f8dfdc4c901ac06248aa63bcbcc64288859",
      "mergeCommit": {
        "oid": "4a2c65ea8a66e2448ad557a11e54f52548ffb364"
      }
    },
    {
      "number": 959,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMwODcyMDU3",
      "title": "Fix typo: Request-URI.",
      "url": "https://github.com/httpwg/http-extensions/pull/959",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nfixes a typo.",
      "createdAt": "2019-10-22T08:42:41Z",
      "updatedAt": "2019-10-22T08:45:43Z",
      "closedAt": "2019-10-22T08:45:42Z",
      "mergedAt": "2019-10-22T08:45:42Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "26f29e097b8729e0cff00fe610a18ce204d9682e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-fix-1",
      "headRefOid": "df7255d79ee5096ce8a1238c673e60831ebb0679",
      "mergeCommit": {
        "oid": "63e6c86f685f04592db24d645d0a9ea8fe284c58"
      }
    },
    {
      "number": 964,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMzMDM1MDYw",
      "title": "Update circle config for better caching",
      "url": "https://github.com/httpwg/http-extensions/pull/964",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The caching in the old setup was broken.  Mike fixed it for me in QUIC and I ported that along.  It should help quite a bit with build times when things get busy.",
      "createdAt": "2019-10-28T09:56:10Z",
      "updatedAt": "2019-10-28T10:31:46Z",
      "closedAt": "2019-10-28T10:31:45Z",
      "mergedAt": "2019-10-28T10:31:45Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6550bc2710b91fe606a72749decbd00012569ef1",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "circle-update",
      "headRefOid": "1c97cf5675feba5b74de7073815d3a85199164b5",
      "mergeCommit": {
        "oid": "09b2464afc2b2659794fb9aca9247c79894013ad"
      }
    },
    {
      "number": 965,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM0NjA1MDE3",
      "title": "Stop over-caching",
      "url": "https://github.com/httpwg/http-extensions/pull/965",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think that narrowing this to `.git` should suffice.  A copy of the i-d-template and Julian's XSLT repositories are cached in the docker image.",
      "createdAt": "2019-10-31T01:27:53Z",
      "updatedAt": "2019-10-31T01:33:08Z",
      "closedAt": "2019-10-31T01:33:06Z",
      "mergedAt": "2019-10-31T01:33:06Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "bce31391ac030e38052abb5e5451a6bb3a5ed9af",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "fix-circle-cache",
      "headRefOid": "eaa6f59a0c4c737a411905657853c909a2df4d29",
      "mergeCommit": {
        "oid": "bffaf95f8c98002069c6ebbfc107f656e3e1795a"
      }
    },
    {
      "number": 966,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM0OTI0OTk1",
      "title": "digest: fix partial content example",
      "url": "https://github.com/httpwg/http-extensions/pull/966",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "",
      "createdAt": "2019-10-31T14:14:11Z",
      "updatedAt": "2019-11-03T11:17:08Z",
      "closedAt": "2019-10-31T16:21:52Z",
      "mergedAt": "2019-10-31T16:21:52Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMDEwNjY0",
          "commit": {
            "abbreviatedOid": "8bf7df5"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2019-10-31T16:21:08Z",
          "updatedAt": "2019-10-31T16:21:08Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "bffaf95f8c98002069c6ebbfc107f656e3e1795a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "lucas/digest-content-range",
      "headRefOid": "8bf7df58a1ce295f564aaf7a1fda8270cc5a41b2",
      "mergeCommit": {
        "oid": "33d16ae4964a33907f41e4a96932eb8756fb94f8"
      }
    },
    {
      "number": 969,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1MDA3MjE4",
      "title": "Fix: #967. Clarify the _returned value_ expression.",
      "url": "https://github.com/httpwg/http-extensions/pull/969",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nClarifies the \"returned value\" expression.\r\n\r\nFixes: #967 ",
      "createdAt": "2019-10-31T16:19:36Z",
      "updatedAt": "2019-11-03T11:02:52Z",
      "closedAt": "2019-11-03T11:02:51Z",
      "mergedAt": "2019-11-03T11:02:51Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMDkzNTAz",
          "commit": {
            "abbreviatedOid": "13fcc82"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks. Longer term, I'd like to do an broad editorial sweep to tighten up document and this is an enabling step that I think this takes us most of the way there. I made some suggestions to move words around a bit.\r\n\r\n",
          "createdAt": "2019-10-31T18:24:17Z",
          "updatedAt": "2019-10-31T18:37:29Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nThe request contains a `Digest` header field\r\n```",
              "createdAt": "2019-10-31T18:24:17Z",
              "updatedAt": "2019-11-03T10:58:03Z"
            },
            {
              "originalPosition": 18,
              "body": "Here I would highlight the `Accept-Encoding` header and then reword the next paragraph slightly e.g. \r\n\r\n\"It also includes an `Accept-Encoding: br` header field that advertises the client supports brotli encoding\"",
              "createdAt": "2019-10-31T18:26:05Z",
              "updatedAt": "2019-11-03T10:58:03Z"
            },
            {
              "originalPosition": 24,
              "body": "Then reword this as something like:\r\n\r\n\"The response includes a `Content-Encoding:br` that indicates the selected representation is brotli encoded. The `Digest` field-value is therefore different compared to the request.\r\n\r\n",
              "createdAt": "2019-10-31T18:30:32Z",
              "updatedAt": "2019-11-03T10:58:03Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b7228f54f9ed561af545cfb4a782a54b60be5224",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-967",
      "headRefOid": "5e0ce7dd65b5b5b9227f967f7ef411e712757296",
      "mergeCommit": {
        "oid": "4f964033c7daed3bdbf188f6e18f3dcd4cfb3d86"
      }
    },
    {
      "number": 971,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1MTAwMzcz",
      "title": "digest: editorial sweep and address use cases and SRI",
      "url": "https://github.com/httpwg/http-extensions/pull/971",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "My intention of this PR was to fix #868 (relationship to SRI) and #872 (use case).\r\n\r\nHaving reviewed the I-D, IMO it already explained a few general use cases, so I did some word smithing to make them jump out some more. We can expand on these further if needs be.\r\n\r\nI wanted to break out the SRI stuff, but ran out of time today to fully complete that so the PR is WIP.\r\n\r\nFinally, the usage in signatures section seemed to benefit from some tidy up too. I don't think we've fully completed the ask on #851 and I'm inclined to leave it that way for the time being.",
      "createdAt": "2019-10-31T19:16:42Z",
      "updatedAt": "2019-11-03T11:21:48Z",
      "closedAt": "2019-11-02T09:41:57Z",
      "mergedAt": "2019-11-02T09:41:56Z",
      "mergedBy": "ioggstream",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks, I think the wording is significantly improved! I would split the editorial changes from the rest to be able to merge it soon.",
          "createdAt": "2019-10-31T19:57:20Z",
          "updatedAt": "2019-10-31T19:57:20Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks. To be clear I plan to close this out tomorrow, subject to review.",
          "createdAt": "2019-10-31T20:19:29Z",
          "updatedAt": "2019-10-31T20:19:29Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is now ready to be reviewed. The changeset relies on changes throughout the document but IMO these are quality of life improvements to the document and I'd be a lot happier with them in.\r\n\r\nThe most controversial changes are some slight shuffling of the example section titles, if I really have to I can break them out but I'd prefer not to.",
          "createdAt": "2019-11-01T19:34:35Z",
          "updatedAt": "2019-11-01T19:35:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzYzNTUy",
          "commit": {
            "abbreviatedOid": "17bd396"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM, perfect!",
          "createdAt": "2019-11-02T09:41:48Z",
          "updatedAt": "2019-11-02T09:41:48Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "33d16ae4964a33907f41e4a96932eb8756fb94f8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "lucas/digest-editorial-1",
      "headRefOid": "17bd3968620c504de495e5fac696c7437817437a",
      "mergeCommit": {
        "oid": "5564a21c6f55efa7b25167dd130dfb4c4ca06f98"
      }
    },
    {
      "number": 972,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1MjY0NTk4",
      "title": "Fix caching for tags by fetching them first",
      "url": "https://github.com/httpwg/http-extensions/pull/972",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The caching of `.git` leads to interesting issues on circle, which has a bug in its checkout logic for tags.  This works around that by pulling instead.  That's complicated by the fact that circle insists on using SSH for pulls.  That is great for ensuring that they can pull private repos, but this workaround - which runs before the circle key is available - can't use that and the origin is configured poorly.",
      "createdAt": "2019-11-01T03:28:04Z",
      "updatedAt": "2019-11-01T03:36:46Z",
      "closedAt": "2019-11-01T03:36:45Z",
      "mergedAt": "2019-11-01T03:36:45Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "23985581d6592e7bb8e09ecec87e0e465126d96f",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "fix-circle-tag-checkout",
      "headRefOid": "a4e100cc418d8f6081e0119097435424163c41c7",
      "mergeCommit": {
        "oid": "81d682ebe498b8855fc40fcbb362a97c6f453e77"
      }
    },
    {
      "number": 974,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2MDE0NTgz",
      "title": "Split sentences on multiple lines.",
      "url": "https://github.com/httpwg/http-extensions/pull/974",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nSplits sentence over multiple lines.",
      "createdAt": "2019-11-03T11:13:39Z",
      "updatedAt": "2019-11-03T11:21:49Z",
      "closedAt": "2019-11-03T11:14:05Z",
      "mergedAt": "2019-11-03T11:14:05Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4f964033c7daed3bdbf188f6e18f3dcd4cfb3d86",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-editorial-1",
      "headRefOid": "8238913ac92d9ee3c6a5d50fab95533ce804679c",
      "mergeCommit": {
        "oid": "17833d4a0c295a8af96f1245cd2850fb68acb6b7"
      }
    },
    {
      "number": 975,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2MDE1NjE3",
      "title": "Add changelog for acting on resources and SRI.",
      "url": "https://github.com/httpwg/http-extensions/pull/975",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nAdd changelog for acting on resources and SRI.",
      "createdAt": "2019-11-03T11:28:22Z",
      "updatedAt": "2019-11-03T11:30:55Z",
      "closedAt": "2019-11-03T11:30:55Z",
      "mergedAt": "2019-11-03T11:30:55Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "17833d4a0c295a8af96f1245cd2850fb68acb6b7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-changelog-1",
      "headRefOid": "d7e18799d16586dd1f62c60ebd2eba0be23debb7",
      "mergeCommit": {
        "oid": "bd3d7ce647c1c5a941f1224a37f60ac9c53e278a"
      }
    },
    {
      "number": 976,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2MDE2NzMx",
      "title": "Fix typo in address.",
      "url": "https://github.com/httpwg/http-extensions/pull/976",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-03T11:44:02Z",
      "updatedAt": "2019-11-03T11:45:07Z",
      "closedAt": "2019-11-03T11:45:06Z",
      "mergedAt": "2019-11-03T11:45:06Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "bd3d7ce647c1c5a941f1224a37f60ac9c53e278a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-fix-address",
      "headRefOid": "39c34e9aef1379079065ab17017ed5562f410acf",
      "mergeCommit": {
        "oid": "30c857a3e0988183e649aceb6ba2a3d1ba98ac73"
      }
    },
    {
      "number": 977,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2MDgyNjM1",
      "title": "fix inner-list in ListListParam example",
      "url": "https://github.com/httpwg/http-extensions/pull/977",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "contributes to #961\r\n",
      "createdAt": "2019-11-03T23:34:29Z",
      "updatedAt": "2019-11-03T23:54:19Z",
      "closedAt": "2019-11-03T23:52:54Z",
      "mergedAt": "2019-11-03T23:52:54Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks.",
          "createdAt": "2019-11-03T23:53:09Z",
          "updatedAt": "2019-11-03T23:53:09Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "30c857a3e0988183e649aceb6ba2a3d1ba98ac73",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "961-invalid-header",
      "headRefOid": "5b8518215214ebb70c739a4f224a97d04ccacba6",
      "mergeCommit": {
        "oid": "e27f7dc037c6329df883b230e525e6a651f1459a"
      }
    },
    {
      "number": 979,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2MTc2NjY5",
      "title": "Adding whitespace to correct formatting",
      "url": "https://github.com/httpwg/http-extensions/pull/979",
      "state": "CLOSED",
      "author": "thpts",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This will now correctly render the unordered lists.\r\nBefore:\r\n![image](https://user-images.githubusercontent.com/38018420/68110299-8fcbaf80-fee4-11e9-99f9-b695766b3cbb.png)\r\n\r\nAfter:\r\n![image](https://user-images.githubusercontent.com/38018420/68110307-965a2700-fee4-11e9-98b8-2a16c8892074.png)\r\n",
      "createdAt": "2019-11-04T09:15:15Z",
      "updatedAt": "2019-11-04T23:32:23Z",
      "closedAt": "2019-11-04T23:32:22Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2019-11-04T23:32:22Z",
          "updatedAt": "2019-11-04T23:32:22Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "69050608ecbcee068f3906e221af864e6558f551",
      "headRepository": "thpts/http-extensions",
      "headRefName": "cache01_nits",
      "headRefOid": "26ed5c2f815c5fcfcf24cbc744a88ae44573d76a",
      "mergeCommit": null
    },
    {
      "number": 981,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2NjgxOTM1",
      "title": "[Client Hints] Cleanups for publishing",
      "url": "https://github.com/httpwg/http-extensions/pull/981",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I want to republish the CH draft as it expired, and the change logs didn't include a bunch of the recent changes.\r\n\r\n@igrigorik @mnot - Can you take a look? ",
      "createdAt": "2019-11-05T09:36:54Z",
      "updatedAt": "2019-11-05T15:32:09Z",
      "closedAt": "2019-11-05T15:32:08Z",
      "mergedAt": "2019-11-05T15:32:08Z",
      "mergedBy": "igrigorik",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExODE5MDg0",
          "commit": {
            "abbreviatedOid": "9dca989"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "\ud83d\udc4d ",
          "createdAt": "2019-11-05T15:31:55Z",
          "updatedAt": "2019-11-05T15:31:55Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9ee9c9bce98e3ef2f153d5d51ba7f0bcbc0f404d",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "cleanup_for_publishing",
      "headRefOid": "9dca98961c375c14b9a7ad500d4e9d0d73d0c3c5",
      "mergeCommit": {
        "oid": "907c698d3f843fb92ff0fd2de6e9ec500f52861e"
      }
    },
    {
      "number": 983,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM4MzE3NDQ3",
      "title": "[SH] use RWS in inner-list",
      "url": "https://github.com/httpwg/http-extensions/pull/983",
      "state": "CLOSED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "* update ABNF for inner-list to use RWS\r\n* update parsing algorithm to accept HTAB\r\n* update imports to include RWS and HTAB\r\n\r\nFor #961",
      "createdAt": "2019-11-08T01:27:22Z",
      "updatedAt": "2019-12-11T04:57:07Z",
      "closedAt": "2019-12-11T04:04:11Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "RWS implies \"required\". Is that really the intent?",
          "createdAt": "2019-11-08T04:41:15Z",
          "updatedAt": "2019-11-08T04:41:15Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. We require spaces between the items in an inner-list, otherwise they can abut.",
          "createdAt": "2019-11-08T05:00:14Z",
          "updatedAt": "2019-11-08T05:00:14Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "*imho* RWS and TABs make things error-prone and difficult to debug.",
          "createdAt": "2019-12-04T11:39:58Z",
          "updatedAt": "2019-12-04T11:39:58Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Just so we're aware, this PR was to address [an issue identified in #961](https://github.com/httpwg/http-extensions/issues/961#issuecomment-549968307) where the ABNF says `OWS` (including htab) but the reference algorithm requires `SP` before `OWS` after an sh-item.\r\n\r\nSo changing the ABNF to match the algorithm gives:\r\n```\r\ninner-list = \"(\" OWS [ sh-item *( SP OWS sh-item ) [ SP OWS ] ] \")\" *parameter\r\n```\r\n\r\nAlternatively, by extending the algorithm to also accept a htab immediately after an item (this PR), the ABNF becomes:\r\n\r\n```\r\ninner-list = \"(\" OWS [ sh-item *( RWS sh-item ) OWS \")\" *parameter\r\n```\r\n\r\nAn alternative is to remove the htab altogether, which removes OWS, so we're left with:\r\n\r\n```\r\ninner-list = \"(\" *SP [ sh-item *( 1*SP sh-item ) *SP \")\" *parameter\r\n```\r\n\r\nWhich is fine by me, but removing all OWS is a bigger change.",
          "createdAt": "2019-12-04T12:45:08Z",
          "updatedAt": "2019-12-04T12:46:05Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we should retain the use of OWS, rather than removing them or changing (some of) them to RWS.\r\n\r\nNot all SH header fields would be generated by a serializer that understands SH. Rather, I'd assume that most of SH header fields would be written by hand, or generated by concatenating strings (in various programming languages).\r\n\r\nI do not think we can easily enforce everyone to insert whitespaces is a particular way (or drop them).",
          "createdAt": "2019-12-05T02:54:50Z",
          "updatedAt": "2019-12-05T02:54:59Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@kazuho I'm not as worried about that; tabs in existing headers are _extremely_ uncommon, IME (looking at things like the HTTP Archive dump). If SH implementations are consistent (and they should be if we test well), this will get caught early.\r\n",
          "createdAt": "2019-12-05T03:03:31Z",
          "updatedAt": "2019-12-05T03:03:31Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot I'm not worried about tabs. I think it would be fine if the change is going to be either or both of the following and nothing more.\r\n* `OWS` -> `*SP`\r\n* `RWS` -> `1*SP`\r\n",
          "createdAt": "2019-12-05T03:58:21Z",
          "updatedAt": "2019-12-05T03:58:21Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@kazuho yep +1",
          "createdAt": "2019-12-05T04:35:27Z",
          "updatedAt": "2019-12-05T04:35:27Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a new branch (with PR) to see what sort of change is involved replacing `OWS` with `*SP`. It's not as invasive as I'd thought it might be.",
          "createdAt": "2019-12-05T08:43:24Z",
          "updatedAt": "2019-12-05T08:43:24Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "OBE",
          "createdAt": "2019-12-11T04:04:11Z",
          "updatedAt": "2019-12-11T04:04:11Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b2c64a6c3c02dbd3fd7111a8b484be554c0856ca",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "961-RWS-inner-list",
      "headRefOid": "0c1f1111a4787b4b0af14ee251f26286bf7530e0",
      "mergeCommit": null
    },
    {
      "number": 985,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxODIwOTY2",
      "title": "Describe the bytesize cost of hints",
      "url": "https://github.com/httpwg/http-extensions/pull/985",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #962 \r\n\r\n@martinthomson - Took a first stab at describing the cost of hints and the fact that servers should not overuse them. Let me know what you think.\r\n\r\n/cc @igrigorik ",
      "createdAt": "2019-11-17T05:16:47Z",
      "updatedAt": "2019-11-19T15:53:47Z",
      "closedAt": "2019-11-19T15:53:47Z",
      "mergedAt": "2019-11-19T15:53:47Z",
      "mergedBy": "igrigorik",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added that features MAY restrict hints to certain destinations to close #963 ",
          "createdAt": "2019-11-17T05:54:36Z",
          "updatedAt": "2019-11-17T05:54:36Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson Thanks for reviewing! :)\r\n\r\nCan you commit this? (I don't have permissions)",
          "createdAt": "2019-11-19T09:55:38Z",
          "updatedAt": "2019-11-19T09:55:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4MTA3Mjkw",
          "commit": {
            "abbreviatedOid": "e3d8a54"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-18T05:36:30Z",
          "updatedAt": "2019-11-18T05:36:31Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Worth linking to Fetch dfn of `destination`? Figure most folks won't make the connection.",
              "createdAt": "2019-11-18T05:36:31Z",
              "updatedAt": "2019-11-19T10:14:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4MjAxNDM2",
          "commit": {
            "abbreviatedOid": "afbeef6"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-18T09:43:03Z",
          "updatedAt": "2019-11-18T09:43:03Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Yup!",
              "createdAt": "2019-11-18T09:43:03Z",
              "updatedAt": "2019-11-19T10:14:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4OTAzNzc5",
          "commit": {
            "abbreviatedOid": "afbeef6"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-19T09:51:00Z",
          "updatedAt": "2019-11-19T09:51:06Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Maybe\r\n\r\n```suggestion\r\n# Cost of Sending Hints\r\n```",
              "createdAt": "2019-11-19T09:51:00Z",
              "updatedAt": "2019-11-19T10:14:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE5MTQ2NTky",
          "commit": {
            "abbreviatedOid": "8c498d9"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "\ud83d\udc4d ",
          "createdAt": "2019-11-19T15:53:37Z",
          "updatedAt": "2019-11-19T15:53:37Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "93d6748cddc41f2be327b995742b551c8e3f4e14",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "hints_not_free",
      "headRefOid": "8c498d923a8334a0e800363705fea37a8657e03e",
      "mergeCommit": {
        "oid": "7db7fd59c9b64d52eafc4e5c2e5229e797d0be69"
      }
    },
    {
      "number": 987,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ0OTI1NzA1",
      "title": "[SH] Missing negation",
      "url": "https://github.com/httpwg/http-extensions/pull/987",
      "state": "MERGED",
      "author": "essen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-24T16:44:35Z",
      "updatedAt": "2019-11-24T23:13:28Z",
      "closedAt": "2019-11-24T23:13:24Z",
      "mergedAt": "2019-11-24T23:13:23Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2019-11-24T23:13:28Z",
          "updatedAt": "2019-11-24T23:13:28Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7db7fd59c9b64d52eafc4e5c2e5229e797d0be69",
      "headRepository": "essen/http-extensions",
      "headRefName": "patch-1",
      "headRefOid": "3cfbee2abe20dc10cb0d6de4ebd26035f854da04",
      "mergeCommit": {
        "oid": "02cfd3070f140e2870eb0847661cfd0b042e7e36"
      }
    },
    {
      "number": 988,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ1MTEzMjAw",
      "title": "Variants dictionary keys must be lowercase",
      "url": "https://github.com/httpwg/http-extensions/pull/988",
      "state": "OPEN",
      "author": "essen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "variants"
      ],
      "body": "The `Variants` header is a dictionary and in the current version of\r\nstructured headers member names are `key` which only accepts\r\nlowercase letters:\r\n\r\n* https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-14#section-3.2\r\n* https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-14#section-3.1.2",
      "createdAt": "2019-11-25T09:39:58Z",
      "updatedAt": "2019-11-28T00:41:11Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "02cfd3070f140e2870eb0847661cfd0b042e7e36",
      "headRepository": "essen/http-extensions",
      "headRefName": "patch-2",
      "headRefOid": "1c308b7b6a7e4630eb5bba3e54f6084e908c947d",
      "mergeCommit": null
    },
    {
      "number": 989,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ1MTIwMTU3",
      "title": "[SH] Remove repetition",
      "url": "https://github.com/httpwg/http-extensions/pull/989",
      "state": "CLOSED",
      "author": "essen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Not an English native so might not be the best wording but it sounds better than repeating `within` twice.",
      "createdAt": "2019-11-25T09:55:13Z",
      "updatedAt": "2019-12-04T01:20:04Z",
      "closedAt": "2019-12-04T01:20:04Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Might be better to swap them the other way. (in the scope...occur within)",
          "createdAt": "2019-11-25T12:22:38Z",
          "updatedAt": "2019-11-25T12:22:38Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Fixed in source, thanks for the report.",
          "createdAt": "2019-12-04T01:20:04Z",
          "updatedAt": "2019-12-04T01:20:04Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "02cfd3070f140e2870eb0847661cfd0b042e7e36",
      "headRepository": "essen/http-extensions",
      "headRefName": "patch-3",
      "headRefOid": "392f80203d1646b776bb44902a55c4c73c11ddad",
      "mergeCommit": null
    },
    {
      "number": 990,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ1MTU1MDQy",
      "title": "Fix: #980. Clarify binary payload is b64 encoded",
      "url": "https://github.com/httpwg/http-extensions/pull/990",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nclarify editorial rendering of binary payloads",
      "createdAt": "2019-11-25T11:08:09Z",
      "updatedAt": "2019-11-25T14:22:41Z",
      "closedAt": "2019-11-25T14:04:00Z",
      "mergedAt": "2019-11-25T14:04:00Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMjA0ODgz",
          "commit": {
            "abbreviatedOid": "bfa42b0"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-11-25T11:19:11Z",
          "updatedAt": "2019-11-25T11:26:43Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "same as above comment, lets add this to the response description at the start of section. e.g.\r\n\r\n```\r\nThe response includes a `Content-Encoding: br` that indicates the selected representation is brotli encoded, the payload body is displayed as base64. There are two `Digest` field-values:\r\n\r\n<bullets as they are> \r\n```",
              "createdAt": "2019-11-25T11:19:11Z",
              "updatedAt": "2019-11-25T12:22:00Z"
            },
            {
              "originalPosition": 13,
              "body": "Lets add this to the response description at the start of section. e.g.\r\n\r\n```\r\nThe response includes a `Content-Encoding: br` that indicates the selected representation is brotli encoded, the payload body is displayed as base64.\r\n```",
              "createdAt": "2019-11-25T11:23:46Z",
              "updatedAt": "2019-11-25T12:22:00Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nit is shown as a base64-encoded string.\r\n```\r\nmaybe better?",
              "createdAt": "2019-11-25T11:26:34Z",
              "updatedAt": "2019-11-25T12:22:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMjQ1Njkx",
          "commit": {
            "abbreviatedOid": "e068cf2"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T12:37:06Z",
          "updatedAt": "2019-11-25T12:37:07Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I prefer to separate the sentence because of the `therefore` in line 721. @LPardue ",
              "createdAt": "2019-11-25T12:37:06Z",
              "updatedAt": "2019-11-25T12:37:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMjcxNjE0",
          "commit": {
            "abbreviatedOid": "e068cf2"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T13:23:27Z",
          "updatedAt": "2019-11-25T13:23:28Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I can live with the sentence order but there is no need to split the paragraph IMO.\r\n\r\nThis is an example where I think the general document readability can be improved with another editorial pass over all examples. However, we can tackle that in a separate PR once design issues are closed out.",
              "createdAt": "2019-11-25T13:23:27Z",
              "updatedAt": "2019-11-25T13:23:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMjcxNzc5",
          "commit": {
            "abbreviatedOid": "e068cf2"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-25T13:23:43Z",
          "updatedAt": "2019-11-25T13:23:43Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMjk3Njc2",
          "commit": {
            "abbreviatedOid": "e068cf2"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T14:02:56Z",
          "updatedAt": "2019-11-25T14:02:57Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Sure! We can schedule it one month before Vancouver: wdyt?",
              "createdAt": "2019-11-25T14:02:56Z",
              "updatedAt": "2019-11-25T14:02:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyMzEyMDA5",
          "commit": {
            "abbreviatedOid": "e068cf2"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-25T14:22:41Z",
          "updatedAt": "2019-11-25T14:22:41Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "SGTM",
              "createdAt": "2019-11-25T14:22:41Z",
              "updatedAt": "2019-11-25T14:22:41Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "02cfd3070f140e2870eb0847661cfd0b042e7e36",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-980-editorial",
      "headRefOid": "e068cf2447a8141db4fcee4bb70ce5a075996413",
      "mergeCommit": {
        "oid": "a720ea8448ae33cfdac28c5e3d2c56017990e5b6"
      }
    },
    {
      "number": 993,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ2NDczOTUy",
      "title": "Make dictionary values optional.",
      "url": "https://github.com/httpwg/http-extensions/pull/993",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "For #992.\r\n\r\nNote that this makes missing values `True`; if we like that approach, I think we should do it for missing parameter values too (currently they use `null`, which isn't part of our type system).\r\n\r\nI used `True` because it aligns with the semantics of current uses nicely.\r\n",
      "createdAt": "2019-11-28T00:36:10Z",
      "updatedAt": "2019-12-04T02:59:34Z",
      "closedAt": "2019-12-04T01:18:08Z",
      "mergedAt": "2019-12-04T01:18:08Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK with me.",
          "createdAt": "2019-12-02T13:21:03Z",
          "updatedAt": "2019-12-02T13:21:03Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson \r\n> It will make some instantiations of a sh-dictionary indistinguishable from sh-list, but I don't see a problem. If you don't know the type of the header field, there's not much you can do with it anyway. It only affects schema-free generic parsers that might want to offer up parsed header fields without any prior knowledge of the content model.\r\n\r\nThis is a keen observation.\r\n\r\nAssuming that we are fine with requiring that knowledge on what the top type is, maybe we should also consider adding support for #1 rule. It has been my understanding that the only reason we do not support #1 rule in SH is because #1 can only be applied for certain top types (but we are now requiring that knowledge).",
          "createdAt": "2019-12-03T02:18:05Z",
          "updatedAt": "2019-12-03T02:18:05Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "We've discussed requiring knowledge of top-level types extensively, and I think we have agreement that it's OK.\r\n\r\nI\"m not sure what you want regarding support for `#1`; can you give an example (or open a new issue)?",
          "createdAt": "2019-12-03T04:27:10Z",
          "updatedAt": "2019-12-03T04:27:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0MDA1OTgw",
          "commit": {
            "abbreviatedOid": "c8372b8"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Good idea.  It will make some instantiations of a sh-dictionary indistinguishable from sh-list, but I don't see a problem.  If you don't know the type of the header field, there's not much you can do with it anyway.  It only affects schema-free generic parsers that might want to offer up parsed header fields without any prior knowledge of the content model.",
          "createdAt": "2019-11-28T00:45:19Z",
          "updatedAt": "2019-11-28T00:45:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0MDU2NDY1",
          "commit": {
            "abbreviatedOid": "c8372b8"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM modulo the point below.",
          "createdAt": "2019-11-28T05:04:16Z",
          "updatedAt": "2019-11-28T05:05:01Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Is the omission a MAY, SHOULD, or MUST?\r\n\r\nThe decoder logic seems to imply that it is not a MUST, but I think it would be a good idea to clarify what is valid and not.",
              "createdAt": "2019-11-28T05:04:16Z",
              "updatedAt": "2019-12-03T04:25:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0ODgyNDMz",
          "commit": {
            "abbreviatedOid": "c8372b8"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-30T08:22:26Z",
          "updatedAt": "2019-11-30T08:22:26Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I think it's MAY.",
              "createdAt": "2019-11-30T08:22:26Z",
              "updatedAt": "2019-12-03T04:25:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0OTEzNTIx",
          "commit": {
            "abbreviatedOid": "c8372b8"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-30T23:47:58Z",
          "updatedAt": "2019-11-30T23:47:59Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "It should be a MUST if we want to use this to back port existing headers (e.g., `Cache-Control`).",
              "createdAt": "2019-11-30T23:47:58Z",
              "updatedAt": "2019-12-03T04:25:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0OTEzNTUy",
          "commit": {
            "abbreviatedOid": "c8372b8"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-30T23:49:01Z",
          "updatedAt": "2019-11-30T23:49:01Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Also, I'm wondering if we can allow parameters on one of these values; e.g., `baz;thing=1`",
              "createdAt": "2019-11-30T23:49:01Z",
              "updatedAt": "2019-12-03T04:25:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0OTE2NzYz",
          "commit": {
            "abbreviatedOid": "c8372b8"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-01T02:09:44Z",
          "updatedAt": "2019-12-01T02:09:45Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "If it's a MUST then you introduce a really weird constraint on the parser, to detect and raise an exception on an otherwise valid input. The finite state machine essentially has parse-bare-item-excluding-true and parse-bare-item-including-true routines.\r\n\r\nI think I missed the decision to make back-porting existing headers a goal. Last I heard it was out of scope. Has that switched around?",
              "createdAt": "2019-12-01T02:09:44Z",
              "updatedAt": "2019-12-03T04:25:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0OTIxNzI3",
          "commit": {
            "abbreviatedOid": "c8372b8"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-01T06:06:15Z",
          "updatedAt": "2019-12-01T06:06:15Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Sorry, I meant MUST encode, not decode.",
              "createdAt": "2019-12-01T06:06:15Z",
              "updatedAt": "2019-12-03T04:25:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI1ODE2ODA4",
          "commit": {
            "abbreviatedOid": "c8372b8"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-02T23:42:02Z",
          "updatedAt": "2019-12-02T23:42:02Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "There's a smell. It's a MUST that is syntactically valid, and not caught as an explicit exception by the machinery.\r\n\r\nThe requirement is on the backported headers themselves \u2013 are they allowed to constrain the serialisation beyond the core spec?",
              "createdAt": "2019-12-02T23:42:02Z",
              "updatedAt": "2019-12-03T04:25:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI1ODYwMjc5",
          "commit": {
            "abbreviatedOid": "c8372b8"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-03T02:14:44Z",
          "updatedAt": "2019-12-03T02:14:45Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "My two cents go to either:\r\n* encoder MUST omit & decoder MUST enforce\r\n* encoder SHOULD omit\r\n\r\nStructured Headers is something new, and I think we can start with a strict rule.",
              "createdAt": "2019-12-03T02:14:44Z",
              "updatedAt": "2019-12-03T04:25:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI1ODc2Njg4",
          "commit": {
            "abbreviatedOid": "c8372b8"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-03T03:23:38Z",
          "updatedAt": "2019-12-03T03:23:38Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I would be more inclined toward \"MUST omit\" if `x=?0` and absence of `x` were always semantically equivalent.  Is it reasonable to say that Boolean-valued parameters have to default to `?0` in their absence?",
              "createdAt": "2019-12-03T03:23:38Z",
              "updatedAt": "2019-12-03T04:25:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI1ODgzMTQ4",
          "commit": {
            "abbreviatedOid": "c8372b8"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-03T03:53:58Z",
          "updatedAt": "2019-12-03T03:53:58Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "@martinthomson I'm not sure if I like the idea of switching to a binary logic from the ternary logic that we have now (i.e. true, false or absent).\r\n\r\nIn case of [priority \"response\" header](https://kazuho.github.io/draft-kazuho-httpbis-priority/draft-kazuho-httpbis-priority.html#rfc.section.6), absence of `i` parameter is different from `i=?0`. Absence means \"refer to what client has suggested,\" false means \"not incremental.\"\r\n\r\nThe issue can be solved by having different terms for referring to a \"incremental\" response and a \"non-incremental\" response, much like we do with the Cache-Control header field. IIUC, Cache-Control has \"pubilc\", \"private\", and absence of both means default.\r\n\r\nThough I am not sure if that is a good design pattern, good enough so that it can be enforced across all the users of SH.",
              "createdAt": "2019-12-03T03:53:58Z",
              "updatedAt": "2019-12-03T04:25:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI1ODg5NDYy",
          "commit": {
            "abbreviatedOid": "c8372b8"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-03T04:25:53Z",
          "updatedAt": "2019-12-03T04:25:53Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "It's quite common to have stricter requirements on serialisation than on parsers; e.g., see how we handle whitespace in various places. The requirement here is very specifically targeted to allow the back port, just as with whitespace handling.\r\n\r\n`x=?0` and absence of `x` are different things; if we want to make them equivalent, that's a different issue, I think (effectively, any value not present is false -- which IMO would be weird). \r\n\r\nI'm about to push an update, PTAL.",
              "createdAt": "2019-12-03T04:25:53Z",
              "updatedAt": "2019-12-03T04:25:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI1ODkyMDUx",
          "commit": {
            "abbreviatedOid": "0e3a5ed"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-03T04:39:41Z",
          "updatedAt": "2019-12-03T04:39:42Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "It still feels kind of strange, but I can implement it. (And probably would have anyway, if that's the \"canonical\" form.)",
              "createdAt": "2019-12-03T04:39:41Z",
              "updatedAt": "2019-12-03T04:39:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI1ODkyNDkw",
          "commit": {
            "abbreviatedOid": "0e3a5ed"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-03T04:42:11Z",
          "updatedAt": "2019-12-03T04:42:12Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "BTW True with parameters is currently serialised as `x=?1;foo=bar`. Are folks OK with making it consistent so that would be `x;foo=bar`?",
              "createdAt": "2019-12-03T04:42:11Z",
              "updatedAt": "2019-12-03T04:42:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI1ODkyOTA0",
          "commit": {
            "abbreviatedOid": "0e3a5ed"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-03T04:44:27Z",
          "updatedAt": "2019-12-03T04:44:27Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Ah, I remember why I didn't do that; it would require pretty major surgery on the algorithms. Given that we don't need to back port anything for that, I'm inclined to leave it; never mind.",
              "createdAt": "2019-12-03T04:44:27Z",
              "updatedAt": "2019-12-03T04:44:27Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a720ea8448ae33cfdac28c5e3d2c56017990e5b6",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-992",
      "headRefOid": "0e3a5ed3d4caf03230cef0bf18e3ac04d06b225d",
      "mergeCommit": {
        "oid": "37b462bacf03d8970cc033afa8015ac945d45e8c"
      }
    },
    {
      "number": 996,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ4NjM5ODM3",
      "title": "Change byte sequence delimiters from \"*\" to \":\"",
      "url": "https://github.com/httpwg/http-extensions/pull/996",
      "state": "CLOSED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Fixes #991.",
      "createdAt": "2019-12-04T01:24:57Z",
      "updatedAt": "2019-12-11T03:45:51Z",
      "closedAt": "2019-12-11T03:38:48Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "fyi @jyasskin impacts on https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#section-3.1",
          "createdAt": "2019-12-04T11:47:55Z",
          "updatedAt": "2019-12-04T11:47:55Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b6d3da4b5016ba65b55f3633897bc5b76c7c8c82",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-991",
      "headRefOid": "2589647de97d4819bf4b446a514775504193f0c5",
      "mergeCommit": null
    },
    {
      "number": 999,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ4NjcxNzA5",
      "title": "Let's try this again.",
      "url": "https://github.com/httpwg/http-extensions/pull/999",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I'm really not sure what happened there, but don't have time to investigate.\r\nI suspect GitHub didn't actually merge.",
      "createdAt": "2019-12-04T03:12:10Z",
      "updatedAt": "2019-12-04T03:12:40Z",
      "closedAt": "2019-12-04T03:12:39Z",
      "mergedAt": "2019-12-04T03:12:39Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "22ea0626b859e482173998d25fb2aed81c9f74b8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-992",
      "headRefOid": "4f3252bbc73844559bf7bc8891424de08531f7da",
      "mergeCommit": {
        "oid": "ccb5d0832951bb5c7bd51f7f8a213a41afb3fdee"
      }
    },
    {
      "number": 1000,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ4NjczNTYz",
      "title": "Change value of omitted parameter value to True",
      "url": "https://github.com/httpwg/http-extensions/pull/1000",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Fixes #995",
      "createdAt": "2019-12-04T03:17:07Z",
      "updatedAt": "2019-12-09T00:03:49Z",
      "closedAt": "2019-12-09T00:03:48Z",
      "mergedAt": "2019-12-09T00:03:48Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI2NjExODgw",
          "commit": {
            "abbreviatedOid": "dae7c06"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-04T05:39:01Z",
          "updatedAt": "2019-12-04T05:39:01Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ccb5d0832951bb5c7bd51f7f8a213a41afb3fdee",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-995",
      "headRefOid": "dae7c062910658f38a1b312da6fd1c0cbab08554",
      "mergeCommit": {
        "oid": "b6d3da4b5016ba65b55f3633897bc5b76c7c8c82"
      }
    },
    {
      "number": 1001,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ4ODM1NzA0",
      "title": "Clear CH persistence when session cookies are cleared",
      "url": "https://github.com/httpwg/http-extensions/pull/1001",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Closes #957 \r\n\r\n@igrigorik - can you review?",
      "createdAt": "2019-12-04T11:22:28Z",
      "updatedAt": "2019-12-05T06:52:11Z",
      "closedAt": "2019-12-04T23:29:30Z",
      "mergedAt": "2019-12-04T23:29:30Z",
      "mergedBy": "igrigorik",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI2OTI2ODI2",
          "commit": {
            "abbreviatedOid": "7f69b77"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-04T15:20:34Z",
          "updatedAt": "2019-12-04T15:20:34Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Sanity check: session cookie, or cookie? Why session cookie?",
              "createdAt": "2019-12-04T15:20:34Z",
              "updatedAt": "2019-12-04T22:16:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI2OTc2Njc4",
          "commit": {
            "abbreviatedOid": "7f69b77"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-04T16:22:48Z",
          "updatedAt": "2019-12-04T16:22:49Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "There are two distinct cookie related scenarios in which I think we want to clear CH persistence:\r\n1) User clears their cookies by an explicit action. I think this is already covered by \"site data\".\r\n2) Session cookies are cleared because the user restarted their browser. IIRC, our reasoning to remove ACHL was that we could tie the hints to a session cookie lifetime, and this is where I was going with this change. \r\n\r\nDoes that clarify things? Or would it be better to spell that out further in the text?",
              "createdAt": "2019-12-04T16:22:48Z",
              "updatedAt": "2019-12-04T22:16:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI3MTAxMDk1",
          "commit": {
            "abbreviatedOid": "7f69b77"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-04T19:36:11Z",
          "updatedAt": "2019-12-04T19:36:11Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "(1) makes sense. What I'm after is to clarify (2): do we have a clear definition of what a session cookie is? E.g. [Wikipedia](https://en.wikipedia.org/wiki/HTTP_cookie#Session_cookie)..\r\n\r\n> A session cookie, also known as an in-memory cookie, transient cookie or non-persistent cookie, exists only in temporary memory while the user navigates the website.[18] Web browsers normally delete session cookies when the user closes the browser.[19] Unlike other cookies, session cookies do not have an expiration date assigned to them, which is how the browser knows to treat them as session cookies.\r\n\r\nOne way to read the above is that opt-in should be cleared anytime the user navigates away from the site... Is that what we intend to imply here? ",
              "createdAt": "2019-12-04T19:36:11Z",
              "updatedAt": "2019-12-04T22:16:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI3MTE1ODcz",
          "commit": {
            "abbreviatedOid": "7f69b77"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-04T20:00:31Z",
          "updatedAt": "2019-12-04T20:00:32Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I was thinking more of \"session cookies\" as  the term is used by (but not strictly defined in) [RFC 6265](https://tools.ietf.org/html/rfc6265#section-4.1.2.2). Cookies that have user agent defined lifetime, and in practical term only get cleared on browser restarts (when the session is not restored).",
              "createdAt": "2019-12-04T20:00:32Z",
              "updatedAt": "2019-12-04T22:16:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI3MTU0NDY4",
          "commit": {
            "abbreviatedOid": "7f69b77"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-04T21:08:42Z",
          "updatedAt": "2019-12-04T21:08:43Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Would it be clearer if we omit \"session\" and just talk about cookies, since that's what RFC is referring to? That would address concerns from my end.",
              "createdAt": "2019-12-04T21:08:42Z",
              "updatedAt": "2019-12-04T22:16:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI3MTkxMDg2",
          "commit": {
            "abbreviatedOid": "08ad464"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-04T22:14:54Z",
          "updatedAt": "2019-12-04T22:14:54Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done",
              "createdAt": "2019-12-04T22:14:54Z",
              "updatedAt": "2019-12-04T22:16:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI3MjI0NTUz",
          "commit": {
            "abbreviatedOid": "ecf7b8b"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "\ud83d\udc4d ",
          "createdAt": "2019-12-04T23:29:17Z",
          "updatedAt": "2019-12-04T23:29:17Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ccb5d0832951bb5c7bd51f7f8a213a41afb3fdee",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "ch_session_cookies",
      "headRefOid": "ecf7b8b59365e148a038a827031d83d4938d468c",
      "mergeCommit": {
        "oid": "a982692cbb04a418f2c3bf7a0c996a76bdd79700"
      }
    },
    {
      "number": 1002,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ5MzE4NDM1",
      "title": "[SH] replace OWS with *SP",
      "url": "https://github.com/httpwg/http-extensions/pull/1002",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "An alternative to #983 - removes HTAB everywhere, replaces `OWS` with `*SP`.\r\n\r\nResolves #998 ",
      "createdAt": "2019-12-05T08:39:26Z",
      "updatedAt": "2019-12-11T09:01:07Z",
      "closedAt": "2019-12-11T04:05:03Z",
      "mergedAt": "2019-12-11T04:05:03Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI4MDI4Mzk5",
          "commit": {
            "abbreviatedOid": "cca92ad"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for working on this. LGTM.",
          "createdAt": "2019-12-06T07:11:26Z",
          "updatedAt": "2019-12-06T07:11:26Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMwMzgyMzE5",
          "commit": {
            "abbreviatedOid": "48bb6af"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2019-12-11T09:01:07Z",
          "updatedAt": "2019-12-11T09:01:07Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "cb76bf13f91001b64e8ed1ecd37f7edec7db03aa",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "998-no-tabs",
      "headRefOid": "48bb6af577f79c7c22eae04c8df5c5fc373831a3",
      "mergeCommit": {
        "oid": "f3608ec2f20e3f1047ae5db1f58bea4e0fd97843"
      }
    },
    {
      "number": 1004,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUwMDk1ODg5",
      "title": "Fix: #973. Error response is unrelated to the effective request URI",
      "url": "https://github.com/httpwg/http-extensions/pull/1004",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nAdds an example of error response. Digest is computed\r\non the enclosed representation of the error.\r\n\r\n## Note\r\n\r\nimho this example is inferred from the current normative part, clarifies the expected behavior and does not require a change in the normative part.",
      "createdAt": "2019-12-06T16:47:19Z",
      "updatedAt": "2020-01-19T14:47:38Z",
      "closedAt": "2020-01-19T14:47:37Z",
      "mergedAt": "2020-01-19T14:47:37Z",
      "mergedBy": "ioggstream",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PTAL @LPardue ",
          "createdAt": "2020-01-09T22:02:18Z",
          "updatedAt": "2020-01-09T22:02:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5ODczMTI0",
          "commit": {
            "abbreviatedOid": "0370118"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Looks good but I have a readability improvement suggestion",
          "createdAt": "2019-12-10T14:27:02Z",
          "updatedAt": "2019-12-10T14:29:50Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Lets describe the example a little more, something like the following would help me understand better e.g.\r\n\r\nIn the following example a client attempts to patch the resource located at /books/123. However, the resource does not exist and the server generates a 404 response with a body that describes the error in accordance with {{?RFC7807}}. The digest of the response is computed on this enclosed representation.",
              "createdAt": "2019-12-10T14:27:02Z",
              "updatedAt": "2019-12-10T16:27:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5OTcxNzY3",
          "commit": {
            "abbreviatedOid": "4139190"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T16:29:02Z",
          "updatedAt": "2019-12-10T16:29:02Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "thx++. fixed",
              "createdAt": "2019-12-10T16:29:02Z",
              "updatedAt": "2019-12-10T16:29:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTQ5NjU3",
          "commit": {
            "abbreviatedOid": "4139190"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-01-18T15:59:38Z",
          "updatedAt": "2020-01-18T15:59:38Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a982692cbb04a418f2c3bf7a0c996a76bdd79700",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-973",
      "headRefOid": "413919065fe5103e0099251710672c7d558e04d2",
      "mergeCommit": {
        "oid": "1d64105618944ca0d9f0c92b6ce46830fa7e2119"
      }
    },
    {
      "number": 1006,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUxNzExNzM2",
      "title": "Change byte sequence delimiters from \"*\" to \":\"",
      "url": "https://github.com/httpwg/http-extensions/pull/1006",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "... and allow token to start with \"*\".\r\n\r\nFixes #991.",
      "createdAt": "2019-12-11T03:46:02Z",
      "updatedAt": "2019-12-11T05:40:55Z",
      "closedAt": "2019-12-11T05:40:54Z",
      "mergedAt": "2019-12-11T05:40:54Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f3608ec2f20e3f1047ae5db1f58bea4e0fd97843",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-991a",
      "headRefOid": "79206ecac699a9f8a0f05ced162a9c05aa4ea803",
      "mergeCommit": {
        "oid": "cb337466a0e3ecf2f9ab4f78ae2092050082ef4e"
      }
    },
    {
      "number": 1008,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUxNzM5OTE3",
      "title": "Float -> Decimal",
      "url": "https://github.com/httpwg/http-extensions/pull/1008",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #982",
      "createdAt": "2019-12-11T05:56:59Z",
      "updatedAt": "2020-01-08T00:14:50Z",
      "closedAt": "2020-01-08T00:14:48Z",
      "mergedAt": "2020-01-08T00:14:48Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMwMzEzNTg3",
          "commit": {
            "abbreviatedOid": "c65dc50"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-11T06:02:40Z",
          "updatedAt": "2019-12-11T06:02:48Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "Your algorithm doesn't explicitly mark the placement of the \".\" or count characters.  I think that's OK, it's just imprecise.",
              "createdAt": "2019-12-11T06:02:40Z",
              "updatedAt": "2020-01-06T03:07:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyMzM1NDQz",
          "commit": {
            "abbreviatedOid": "c65dc50"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-16T04:28:28Z",
          "updatedAt": "2019-12-16T04:28:29Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "It's not clear whether `1234567890123.0` or `0034567890123.0` should fail.",
              "createdAt": "2019-12-16T04:28:28Z",
              "updatedAt": "2020-01-06T03:07:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4NDc0NTU2",
          "commit": {
            "abbreviatedOid": "15ab073"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-06T05:37:31Z",
          "updatedAt": "2020-01-06T05:37:31Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "Right now they don't. Separate issue?",
              "createdAt": "2020-01-06T05:37:31Z",
              "updatedAt": "2020-01-06T05:37:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5NTY4MTEy",
          "commit": {
            "abbreviatedOid": "15ab073"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-07T23:17:59Z",
          "updatedAt": "2020-01-07T23:18:00Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "Yeah, they both fail now with 087d6b1, and the second one is a bit silly anyway.",
              "createdAt": "2020-01-07T23:17:59Z",
              "updatedAt": "2020-01-07T23:18:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5NTgxMjQz",
          "commit": {
            "abbreviatedOid": "15ab073"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-07T23:59:11Z",
          "updatedAt": "2020-01-07T23:59:11Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "cb337466a0e3ecf2f9ab4f78ae2092050082ef4e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-982",
      "headRefOid": "15ab073e685728f33dec6b1523f8e1c566960468",
      "mergeCommit": {
        "oid": "50056068fee3043f2ebab100a3bf01aedaa91830"
      }
    },
    {
      "number": 1009,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUxNzUzOTQ5",
      "title": "change parsing of bare item to handle * and : correctly",
      "url": "https://github.com/httpwg/http-extensions/pull/1009",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Missed in #1006\r\nFixes #991",
      "createdAt": "2019-12-11T06:48:53Z",
      "updatedAt": "2019-12-11T21:33:00Z",
      "closedAt": "2019-12-11T09:32:03Z",
      "mergedAt": "2019-12-11T09:32:03Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "cb337466a0e3ecf2f9ab4f78ae2092050082ef4e",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "991-fix_bare_item",
      "headRefOid": "a570e9258f4163ce4372c4f3f6912b63eac09225",
      "mergeCommit": {
        "oid": "58ded85c7313c431e110038b37f8537bad5d2c41"
      }
    },
    {
      "number": 1010,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUzMzUwNDY1",
      "title": "add priority draft",
      "url": "https://github.com/httpwg/http-extensions/pull/1010",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Based on the up-to-date version on https://github.com/kazuho/draft-kazuho-httpbis-priority/.",
      "createdAt": "2019-12-16T02:42:42Z",
      "updatedAt": "2019-12-23T16:00:23Z",
      "closedAt": "2019-12-23T16:00:23Z",
      "mergedAt": "2019-12-23T16:00:23Z",
      "mergedBy": "tfpauly",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks for the comments @ioggstream. Since this is the PR to enact the WG adoption as draft-ietf-http-priorities-00, we probably want to minimize any changes. Then we can consider addressing your suggestions in draft 01.",
          "createdAt": "2019-12-23T14:10:40Z",
          "updatedAt": "2019-12-23T14:10:54Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  .. we probably want to minimize any changes. Then we can consider addressing your suggestions in draft 01.\r\n\r\nOk, review reverted. Dunno if there's a way to \"backup\" the edits, but they are not that many :)\r\n",
          "createdAt": "2019-12-23T14:28:21Z",
          "updatedAt": "2019-12-23T14:29:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyNDcxODYy",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM, thanks @kazuho ",
          "createdAt": "2019-12-16T10:33:27Z",
          "updatedAt": "2019-12-16T10:33:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1Nzc4MTYx",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T09:25:55Z",
          "updatedAt": "2019-12-23T09:25:56Z",
          "comments": [
            {
              "originalPosition": 243,
              "body": "```suggestion\r\nFor example, when a user navigates with a web browser to a new HTML document,\r\n```",
              "createdAt": "2019-12-23T09:25:55Z",
              "updatedAt": "2019-12-23T09:25:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1Nzc4Nzgx",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T09:27:25Z",
          "updatedAt": "2019-12-23T09:27:25Z",
          "comments": [
            {
              "originalPosition": 245,
              "body": "We're using SHOULD in an example: is that ok?",
              "createdAt": "2019-12-23T09:27:25Z",
              "updatedAt": "2019-12-23T09:27:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1Nzc5NzYy",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T09:29:46Z",
          "updatedAt": "2019-12-23T09:29:47Z",
          "comments": [
            {
              "originalPosition": 269,
              "body": "```suggestion\r\nClients SHOULD NOT use the boundary values 2 and 6.  Servers MAY use these values to\r\n```",
              "createdAt": "2019-12-23T09:29:47Z",
              "updatedAt": "2019-12-23T09:29:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1Nzg2MDgy",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T09:46:34Z",
          "updatedAt": "2019-12-23T09:46:34Z",
          "comments": [
            {
              "originalPosition": 272,
              "body": "it's not clear to me if clients MAY use `4`.",
              "createdAt": "2019-12-23T09:46:34Z",
              "updatedAt": "2019-12-23T09:46:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1Nzk0ODE5",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T10:09:37Z",
          "updatedAt": "2019-12-23T10:09:38Z",
          "comments": [
            {
              "originalPosition": 295,
              "body": "Q: won't we use something like that?\r\n\r\n```\r\n~~~\r\nincremental = sh-boolean\r\n~~~\r\n```",
              "createdAt": "2019-12-23T10:09:38Z",
              "updatedAt": "2019-12-23T10:09:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1Nzk2MjQz",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T10:12:59Z",
          "updatedAt": "2019-12-23T10:12:59Z",
          "comments": [
            {
              "originalPosition": 197,
              "body": "Q: why not something like\r\n\r\n```\r\n~~~\r\nurgency = sh-integer\r\n~~~\r\n```",
              "createdAt": "2019-12-23T10:12:59Z",
              "updatedAt": "2019-12-23T10:12:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1Nzk3Mzgz",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T10:15:48Z",
          "updatedAt": "2019-12-23T10:15:48Z",
          "comments": [
            {
              "originalPosition": 334,
              "body": "iiuc: if it's `end-to-end`, I'd use \"user-agent\" and \"origin server\" instead of client and server.",
              "createdAt": "2019-12-23T10:15:48Z",
              "updatedAt": "2019-12-23T10:15:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1Nzk3OTUx",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T10:17:14Z",
          "updatedAt": "2019-12-23T10:17:14Z",
          "comments": [
            {
              "originalPosition": 339,
              "body": "Q: is \"Priority response header field\"  different from \"Priority header field\"?",
              "createdAt": "2019-12-23T10:17:14Z",
              "updatedAt": "2019-12-23T10:17:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1ODY2MDc1",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T13:46:30Z",
          "updatedAt": "2019-12-23T13:46:30Z",
          "comments": [
            {
              "originalPosition": 347,
              "body": "Do we want to reference https://www.w3.org/TR/resource-hints/ or some related resource?",
              "createdAt": "2019-12-23T13:46:30Z",
              "updatedAt": "2019-12-23T13:46:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1ODY3Njgx",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T13:51:12Z",
          "updatedAt": "2019-12-23T13:51:13Z",
          "comments": [
            {
              "originalPosition": 364,
              "body": "For readability we can alias RFC7540 to HTTP2 and I-D.ietf-quic-http to QUIC\r\n\r\n```suggestion\r\n({{!HTTP2=RFC7540}}) and HTTP/3 ({{!QUIC=I-D.ietf-quic-http}}) which enables\r\n```",
              "createdAt": "2019-12-23T13:51:13Z",
              "updatedAt": "2019-12-23T13:52:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1ODcyMjYw",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T14:04:05Z",
          "updatedAt": "2019-12-23T14:04:05Z",
          "comments": [
            {
              "originalPosition": 523,
              "body": "```suggestion\r\none HTTP/2 or HTTP/3 connection going to the origin server, requests that\r\n```",
              "createdAt": "2019-12-23T14:04:05Z",
              "updatedAt": "2019-12-23T14:04:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1ODcyNDQw",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T14:04:34Z",
          "updatedAt": "2019-12-23T14:04:35Z",
          "comments": [
            {
              "originalPosition": 527,
              "body": "```suggestion\r\nIt is sometimes beneficial for the origin server running behind an intermediary to obey\r\n```",
              "createdAt": "2019-12-23T14:04:34Z",
              "updatedAt": "2019-12-23T14:04:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1ODcyNzcx",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T14:05:22Z",
          "updatedAt": "2019-12-23T14:05:22Z",
          "comments": [
            {
              "originalPosition": 532,
              "body": "```suggestion\r\nto one user agent to be delayed totally after those going to another.\r\n```",
              "createdAt": "2019-12-23T14:05:22Z",
              "updatedAt": "2019-12-23T14:05:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1ODczNzM5",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T14:07:46Z",
          "updatedAt": "2019-12-23T14:07:46Z",
          "comments": [
            {
              "originalPosition": 534,
              "body": "The explanation can be improved.",
              "createdAt": "2019-12-23T14:07:46Z",
              "updatedAt": "2019-12-23T14:07:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1ODc0NDkz",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T14:09:41Z",
          "updatedAt": "2019-12-23T14:09:41Z",
          "comments": [
            {
              "originalPosition": 542,
              "body": "```suggestion\r\nconfiguration, or by checking if the request contains one of the following\r\n```",
              "createdAt": "2019-12-23T14:09:41Z",
              "updatedAt": "2019-12-23T14:09:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1ODc0NzU4",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T14:10:21Z",
          "updatedAt": "2019-12-23T14:10:21Z",
          "comments": [
            {
              "originalPosition": 551,
              "body": "```suggestion\r\nuser agent, as the intermediary would be buffering the responses and then be\r\n```",
              "createdAt": "2019-12-23T14:10:21Z",
              "updatedAt": "2019-12-23T14:10:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1ODc1ODQz",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-23T14:13:08Z",
          "updatedAt": "2019-12-23T14:13:08Z",
          "comments": [
            {
              "originalPosition": 568,
              "body": "that's not clear to me",
              "createdAt": "2019-12-23T14:13:08Z",
              "updatedAt": "2019-12-23T14:13:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1ODc5NjEx",
          "commit": {
            "abbreviatedOid": "760d1ae"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "editorial: iiuc `priority` is an end-to-end header. In this case I'd replace the terms `client` and `server` with `user-agent` and `origin server` https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#operation when appropriate.\r\nOtherwise, please ignore this review :)\r\n\r\nSee the other comments in the PR too.",
          "createdAt": "2019-12-23T14:23:36Z",
          "updatedAt": "2019-12-23T14:23:36Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "58ded85c7313c431e110038b37f8537bad5d2c41",
      "headRepository": "kazuho/http-extensions",
      "headRefName": "kazuho/adopt-priority",
      "headRefOid": "760d1ae4f7c8e409e0f8caf958e6a061812faed4",
      "mergeCommit": {
        "oid": "8da8adb324175e978a9b1c614df0dec7001a4dff"
      }
    },
    {
      "number": 1011,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUzMzc1NjI4",
      "title": "make #parse-number algorithm fail on bad decimals",
      "url": "https://github.com/httpwg/http-extensions/pull/1011",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Explicitly disallow thirteen digits before the dot.",
      "createdAt": "2019-12-16T05:01:43Z",
      "updatedAt": "2020-01-06T03:34:20Z",
      "closedAt": "2020-01-06T03:07:00Z",
      "mergedAt": "2020-01-06T03:07:00Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "@mnot I think this is the right way to validate the number of digits in a decimal.",
          "createdAt": "2019-12-16T05:51:21Z",
          "updatedAt": "2019-12-16T05:51:21Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "mnot-982",
      "baseRefOid": "c65dc50072ac50f53bc314453db82037b3d080fe",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "mnot-982",
      "headRefOid": "087d6b1d225a92de8a70ac12189f7608dbb83a4e",
      "mergeCommit": {
        "oid": "15ab073e685728f33dec6b1523f8e1c566960468"
      }
    },
    {
      "number": 1012,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU0ODMwMzMw",
      "title": "Update authors section",
      "url": "https://github.com/httpwg/http-extensions/pull/1012",
      "state": "CLOSED",
      "author": "johnwilander",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "Add John Wilander as an editor, mark Mike West as an editor, and move Adam Barth from authors to the acknowledgement section.",
      "createdAt": "2019-12-18T21:39:58Z",
      "updatedAt": "2020-01-12T23:21:58Z",
      "closedAt": "2020-01-12T23:21:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Ping?",
          "createdAt": "2020-01-10T07:43:06Z",
          "updatedAt": "2020-01-10T07:43:06Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm failing to rebase and amend this thing. Will try to create a new pull request instead.",
          "createdAt": "2020-01-12T23:21:49Z",
          "updatedAt": "2020-01-12T23:21:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM0NDMwMzE4",
          "commit": {
            "abbreviatedOid": "bbe3b6a"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-19T06:32:33Z",
          "updatedAt": "2019-12-19T06:32:33Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "This doesn't seem like enough. :) Would you mind reformulating this section to be something similar to RFC7159's https://tools.ietf.org/html/rfc7159#section-14?",
              "createdAt": "2019-12-19T06:32:33Z",
              "updatedAt": "2019-12-19T06:32:33Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "58ded85c7313c431e110038b37f8537bad5d2c41",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "UpdateAuthors",
      "headRefOid": "bbe3b6a27cd98ded915f0056db10d0272de1495f",
      "mergeCommit": null
    },
    {
      "number": 1013,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU0ODU1Njc5",
      "title": "Clarified the ways cookies may be ignored.",
      "url": "https://github.com/httpwg/http-extensions/pull/1013",
      "state": "OPEN",
      "author": "johnwilander",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "This change introduces the notion of a user agent's cookie policy, briefly explains it, and refers to it in how cookies may be ignored and in user controls. Before this change, a few sections indicated that the user agent MUST accept set-cookie headers while later relaxing that with a reference to privacy/security settings and user controls.",
      "createdAt": "2019-12-18T22:51:55Z",
      "updatedAt": "2020-02-03T12:42:25Z",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Ping?",
          "createdAt": "2020-01-10T07:43:11Z",
          "updatedAt": "2020-01-10T07:43:11Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "@johnwilander: Ping?",
          "createdAt": "2020-02-03T12:42:25Z",
          "updatedAt": "2020-02-03T12:42:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM0NDMzMTcy",
          "commit": {
            "abbreviatedOid": "7b811b9"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-19T06:42:40Z",
          "updatedAt": "2019-12-19T12:14:04Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I didn't read this paragraph to be about ignoring cookies, but about enforcing rules different than those laid out below when parsing `Set-Cookie` or generating `Cookie` headers. I guess it isn't necessary to keep, as the previous paragraph talks about interop with servers. \ud83e\udd37\u200d\u2642 ",
              "createdAt": "2019-12-19T06:42:40Z",
              "updatedAt": "2019-12-19T12:14:04Z"
            },
            {
              "originalPosition": 34,
              "body": "I'd suggest moving this down into the privacy considerations section, rather than making it the first user agent requirement. It seems strange to start a description of the parsing algorithms by suggesting that UAs ignore them. :)",
              "createdAt": "2019-12-19T06:43:33Z",
              "updatedAt": "2019-12-19T12:14:04Z"
            },
            {
              "originalPosition": 100,
              "body": "I wonder if it's reasonable to take this out. I don't think we actually want to encourage any browser to ask users to individually approve writes to the cookie jar.",
              "createdAt": "2019-12-19T12:14:00Z",
              "updatedAt": "2019-12-19T12:14:04Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "58ded85c7313c431e110038b37f8537bad5d2c41",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "UserAgentCookiePolicy",
      "headRefOid": "7b811b9972fcace60f22361d2e4516182727511c",
      "mergeCommit": null
    },
    {
      "number": 1017,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU3MTkzMjU2",
      "title": "[RFC6265bis, EDITORIAL]: Use `.example` TLD for examples.",
      "url": "https://github.com/httpwg/http-extensions/pull/1017",
      "state": "MERGED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This patch replaces `example.com` with `site.example`, and corrects\r\ninadvertant usage of non-example domains in the hopes of avoiding\r\nconfusion.\r\n\r\nCloses httpwg/http-extensions#706.",
      "createdAt": "2019-12-27T10:25:55Z",
      "updatedAt": "2020-01-14T05:27:39Z",
      "closedAt": "2020-01-10T07:41:56Z",
      "mergedAt": "2020-01-10T07:41:56Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "@johnwilander, mind taking a look?",
          "createdAt": "2019-12-27T10:26:29Z",
          "updatedAt": "2019-12-27T10:26:29Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Landing this. @johnwilander, if you object, let me know.",
          "createdAt": "2020-01-10T07:41:50Z",
          "updatedAt": "2020-01-10T07:41:50Z"
        },
        {
          "author": "triple-underscore",
          "authorAssociation": "NONE",
          "body": "There are still com TLD remaining:\r\n\r\n> For example, site.example\u2019s public suffix is com. (example?)\r\nand\r\n> projects.com (projects.example?)",
          "createdAt": "2020-01-14T05:27:39Z",
          "updatedAt": "2020-01-14T05:27:39Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "2f9798e9260a711dc3c50f452fd95db013db2260",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "example-tld",
      "headRefOid": "4858d27e430023f5589441f4e578ba592d759b72",
      "mergeCommit": {
        "oid": "c43cdae4540d23c04fba2e94cba68677a807f408"
      }
    },
    {
      "number": 1018,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU4OTcxNDkz",
      "title": "[RFC6265bis] Accept nameless cookies.",
      "url": "https://github.com/httpwg/http-extensions/pull/1018",
      "state": "MERGED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This patch alters the cookie parsing algorithm to treat\r\n`Set-Cookie: token` as creating a cookie with an empty name and a value\r\nof \"token\". It also rejects cookies with neither names nor values (e.g.\r\n`Set-Cookie:` and `Set-Cookie: =`.\r\n\r\nTests in web-platform-tests/wpt#21093.\r\n\r\nCloses httpwg/http-extensions#159.",
      "createdAt": "2020-01-03T12:21:49Z",
      "updatedAt": "2020-01-14T05:23:09Z",
      "closedAt": "2020-01-10T07:44:07Z",
      "mergedAt": "2020-01-10T07:44:07Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "@johnwilander: Ping?",
          "createdAt": "2020-01-09T12:36:36Z",
          "updatedAt": "2020-01-09T12:36:36Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Landing this based on the discussion in #159. @johnwilander: If the wording needs more cleanup, I'd appreciate feedback!",
          "createdAt": "2020-01-10T07:44:02Z",
          "updatedAt": "2020-01-10T07:44:02Z"
        },
        {
          "author": "triple-underscore",
          "authorAssociation": "NONE",
          "body": "The cookie-pair ABNF rule still requires presence of `=`.\r\nIs it intentional?\r\n",
          "createdAt": "2020-01-14T05:23:08Z",
          "updatedAt": "2020-01-14T05:23:08Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "2f9798e9260a711dc3c50f452fd95db013db2260",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "empty-name",
      "headRefOid": "f6dee1a78eb09bf2e7fdc73696bce2bdc23874b5",
      "mergeCommit": {
        "oid": "0178223fb44fb194930f53181c5852954890e233"
      }
    },
    {
      "number": 1019,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYwMjMxNzgx",
      "title": "Overwrite duplicate dictionary values",
      "url": "https://github.com/httpwg/http-extensions/pull/1019",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Fixes #997",
      "createdAt": "2020-01-08T00:32:37Z",
      "updatedAt": "2020-01-14T03:48:25Z",
      "closedAt": "2020-01-14T03:48:24Z",
      "mergedAt": "2020-01-14T03:48:24Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@kazuho thanks for the review, see latest commit.\r\n\r\n3.2 is talking about the abstract model for dictionaries, so they are required to be unique. I've removed \"required to be\" so that people don't misread this.",
          "createdAt": "2020-01-08T04:36:06Z",
          "updatedAt": "2020-01-08T04:36:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5NjQwMTA4",
          "commit": {
            "abbreviatedOid": "ca88f5b"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "The changes to the logic look good to me, though I think we need to also change the following:\r\n\r\n* \"their names are required to be unique in the scope of the dictionary they occur within\" ([section 3.2](https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#rfc.section.3.2)),\r\n\r\nand also the following, assuming that we'd apply the same rule for parameters:\r\n* \"The keys are required to be unique within the scope of a map of parameters\" ([section 3.1.2](https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#rfc.section.3.1.2))\r\n* the logic in [section 4.2.3.2](https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#rfc.section.4.2.3.2)",
          "createdAt": "2020-01-08T04:22:22Z",
          "updatedAt": "2020-01-08T04:22:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM5NjQ2NDg2",
          "commit": {
            "abbreviatedOid": "dca957e"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for the changes. Looks good to me now.\r\n\r\nFWIW, I was bit surprised to learn that we do not mention how a duplicate is processed alongside the type definitions in [section 3](https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#types). I checked [section 1.1](https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#strict) and now I understand that the formal definition is provided in section 4.",
          "createdAt": "2020-01-08T04:58:40Z",
          "updatedAt": "2020-01-08T04:59:26Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "50056068fee3043f2ebab100a3bf01aedaa91830",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-997",
      "headRefOid": "dca957ef5f08898e85a0bf8f757cd392baba767a",
      "mergeCommit": {
        "oid": "8269d5e526ea37dcd20c54138368505bc8b16c1f"
      }
    },
    {
      "number": 1028,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYxODg0NDIw",
      "title": "Add Wilander as editor and move Barth from Authors to Acknowledgements.",
      "url": "https://github.com/httpwg/http-extensions/pull/1028",
      "state": "CLOSED",
      "author": "johnwilander",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "",
      "createdAt": "2020-01-12T23:29:42Z",
      "updatedAt": "2020-01-12T23:34:14Z",
      "closedAt": "2020-01-12T23:34:11Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "0178223fb44fb194930f53181c5852954890e233",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "UpdateAuthors2",
      "headRefOid": "a5ec35c0e41c2b777d07aee76d4a470481c37cd4",
      "mergeCommit": null
    },
    {
      "number": 1029,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYxODg1MzAw",
      "title": "Add Wilander as editor and move Barth from Authors to Acknowledgements.",
      "url": "https://github.com/httpwg/http-extensions/pull/1029",
      "state": "CLOSED",
      "author": "johnwilander",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "Ugh. This process is killing me.",
      "createdAt": "2020-01-12T23:39:09Z",
      "updatedAt": "2020-01-15T13:01:59Z",
      "closedAt": "2020-01-13T00:00:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't understand the failed check. Do you, Mike?",
          "createdAt": "2020-01-12T23:40:07Z",
          "updatedAt": "2020-01-12T23:40:07Z"
        },
        {
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't understand the failed check. Do you, Mike?\r\n\r\nI'm probably not the Mike you meant, but it appears to be about references in `-priorities`.  Nothing to do with this change.\r\n\r\n> - No link definition for link ID '-1,6' found on line 855\r\n> - No link definition for link ID '0,7' found on line 855",
          "createdAt": "2020-01-13T20:16:48Z",
          "updatedAt": "2020-01-13T20:16:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNjA5MTEx",
          "commit": {
            "abbreviatedOid": "55e517f"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-12T23:50:48Z",
          "updatedAt": "2020-01-12T23:50:49Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n  -\r\n```\r\nidentation problem perhaps",
              "createdAt": "2020-01-12T23:50:48Z",
              "updatedAt": "2020-01-12T23:50:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNjA5NTc4",
          "commit": {
            "abbreviatedOid": "55e517f"
          },
          "author": "johnwilander",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-12T23:58:14Z",
          "updatedAt": "2020-01-12T23:58:14Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This is exactly the thing I tried to address. Maybe I failed.",
              "createdAt": "2020-01-12T23:58:14Z",
              "updatedAt": "2020-01-12T23:58:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMjAxMjY0",
          "commit": {
            "abbreviatedOid": "55e517f"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "was the intention to have role=editor for both current editors?",
          "createdAt": "2020-01-15T13:01:59Z",
          "updatedAt": "2020-01-15T13:01:59Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "0178223fb44fb194930f53181c5852954890e233",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "UpdateAuthors3",
      "headRefOid": "55e517f4ecc66778912c627b2bcb25b80bf52288",
      "mergeCommit": null
    },
    {
      "number": 1030,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYxODg3MDQ5",
      "title": "Add Wilander as editor and move Barth from Authors to Acknowledgements.",
      "url": "https://github.com/httpwg/http-extensions/pull/1030",
      "state": "MERGED",
      "author": "johnwilander",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "",
      "createdAt": "2020-01-13T00:01:26Z",
      "updatedAt": "2020-01-20T13:42:24Z",
      "closedAt": "2020-01-20T13:42:23Z",
      "mergedAt": "2020-01-20T13:42:23Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I'll land this and tweak some nits in a followup.",
          "createdAt": "2020-01-20T13:42:18Z",
          "updatedAt": "2020-01-20T13:42:18Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "0178223fb44fb194930f53181c5852954890e233",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "UpdateAuthors",
      "headRefOid": "b46fd406792ad383a181d14f2e95266fe0ee78ac",
      "mergeCommit": {
        "oid": "7d2ad9892f99f5e4058588f8ecd571864f9a71fc"
      }
    },
    {
      "number": 1035,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1Mjk3OTM2",
      "title": "[RFC6265bis, Editorial]: Actually use `example` TLD.",
      "url": "https://github.com/httpwg/http-extensions/pull/1035",
      "state": "MERGED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/httpwg/http-extensions/pull/1017 was incomplete,\r\nleaving a number of inadvertant references to `*.com` sites, or the\r\n`com` TLD. This patch, hopefully, is less incomplete.\r\n\r\nh/t @triple-underscore and @bagder for pointing this out.",
      "createdAt": "2020-01-21T13:13:18Z",
      "updatedAt": "2020-01-21T13:22:41Z",
      "closedAt": "2020-01-21T13:22:40Z",
      "mergedAt": "2020-01-21T13:22:40Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "WDYT, @bagder?",
          "createdAt": "2020-01-21T13:13:36Z",
          "updatedAt": "2020-01-21T13:13:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1ODY5OTMy",
          "commit": {
            "abbreviatedOid": "b16108c"
          },
          "author": "bagder",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-21T13:21:14Z",
          "updatedAt": "2020-01-21T13:21:14Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "65d6fd334dbe3d0cc13030dea9ae220695b05fd1",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "typos",
      "headRefOid": "b16108cbaa932ec8ec7e1a2f14bd83939a50e5d0",
      "mergeCommit": {
        "oid": "e170e90e7db369e2080166c4fbd5496eb2a67f68"
      }
    },
    {
      "number": 1036,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1NjAwNDM1",
      "title": "[SH] allow \".\" in key",
      "url": "https://github.com/httpwg/http-extensions/pull/1036",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Allow \".\" in `key`. Also consistently reorders character lists for key.",
      "createdAt": "2020-01-22T00:19:33Z",
      "updatedAt": "2020-01-24T02:30:57Z",
      "closedAt": "2020-01-24T02:30:22Z",
      "mergedAt": "2020-01-24T02:30:22Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e170e90e7db369e2080166c4fbd5496eb2a67f68",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "1027-key-dot",
      "headRefOid": "778ace52dee3c7b38fd02eb8a568af0d8d7e61fe",
      "mergeCommit": {
        "oid": "3bae4571fd0caf44584ca60b35f30d594bd85109"
      }
    },
    {
      "number": 1038,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY1NzQ3MDI3",
      "title": "[RFC6265bis, Editorial]: Define \"public suffix\" in the terminology section.",
      "url": "https://github.com/httpwg/http-extensions/pull/1038",
      "state": "MERGED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #1033.",
      "createdAt": "2020-01-22T09:23:41Z",
      "updatedAt": "2020-01-29T07:53:10Z",
      "closedAt": "2020-01-28T12:46:56Z",
      "mergedAt": "2020-01-28T12:46:55Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Would you mind taking a look, @reschke?",
          "createdAt": "2020-01-22T09:23:55Z",
          "updatedAt": "2020-01-22T09:23:55Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I think this document has the conceptual conceit that it might be possible to have distinct understandings of public suffixes. Browsers certainly have coalesced around https://publicsuffix.org/, but it's not clear to me that it's \"normative\" in any sense other than practice. A _de facto_ standard, not _de jure_.\r\n\r\nI'm happy to just say \"Use the PSL\", as that's most likely to be most compatible?",
          "createdAt": "2020-01-22T09:50:56Z",
          "updatedAt": "2020-01-22T09:50:56Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, if we have normative requirements attached to whether something is a public suffix, then we need to define how to decide that.\r\n\r\nIf there's a risk that the list ever moves, we could introduce an indirection through a new IANA registry (just holding the location of the public list, not the list itself).",
          "createdAt": "2020-01-22T10:02:17Z",
          "updatedAt": "2020-01-22T10:02:17Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "The current normative requirements boil down to \"Hey, user agent. Go figure out which suffixes you think are public. The PSL might be helpful. Have fun!\" I'm happy to make that suggestion normative by bringing in the PSL in the same way URL does (https://url.spec.whatwg.org/#host-public-suffix). Would you be happy with that outcome?",
          "createdAt": "2020-01-22T10:05:44Z",
          "updatedAt": "2020-01-22T10:05:44Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, this seems to be needed (maybe not in the same words, but...).",
          "createdAt": "2020-01-22T12:09:24Z",
          "updatedAt": "2020-01-22T12:09:24Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "@reschke I've update the patch to more explicitly point to the PSL's algorithm, and switched from \"registered domain\" to \"registrable domain\" to match URL. WDYT?",
          "createdAt": "2020-01-28T07:34:05Z",
          "updatedAt": "2020-01-28T07:34:05Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Works for me...",
          "createdAt": "2020-01-28T12:35:17Z",
          "updatedAt": "2020-01-28T12:35:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDUwNTY5",
          "commit": {
            "abbreviatedOid": "f1b4893"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "that certainly fixes the original issue; I wonder whether there's a way to be more precise but it seems in the end it's what the list says, right? It probably would be good if we could say that the Mozilla list is somehow normative. Is it?",
          "createdAt": "2020-01-22T09:37:41Z",
          "updatedAt": "2020-01-22T09:37:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4Mzg5Njk5",
          "commit": {
            "abbreviatedOid": "f1b4893"
          },
          "author": "gibson042",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-26T16:18:23Z",
          "updatedAt": "2020-01-26T16:18:23Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Would it be worth making a comparison to \"delegation-centric zone\" from [RFC 8499](https://tools.ietf.org/html/rfc8499#page-26)? It's certainly possible for a public suffix to not be delegation-centric (e.g., `github.io`) and there are some delegation-centric zones that are not public suffixes (most notably the DNS root zone itself), but there is nevertheless substantial overlap in both concept (different authority between parent and child domain) and contents.",
              "createdAt": "2020-01-26T16:18:23Z",
              "updatedAt": "2020-01-28T07:33:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5MTY4NTcz",
          "commit": {
            "abbreviatedOid": "f1b4893"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-28T07:23:43Z",
          "updatedAt": "2020-01-28T07:23:44Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I'm not sure that bringing another concept in would clarify, especially given the discrepancies you note between \"delegation-centric zone\" and existing user agent understanding of \"public suffix\". I think I'd prefer to continue using the term that user agents have generally applied to cookies.",
              "createdAt": "2020-01-28T07:23:44Z",
              "updatedAt": "2020-01-28T07:33:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5ODY1NTE4",
          "commit": {
            "abbreviatedOid": "1485088"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-29T05:17:04Z",
          "updatedAt": "2020-01-29T05:17:05Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "registrable*",
              "createdAt": "2020-01-29T05:17:04Z",
              "updatedAt": "2020-01-29T05:17:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5OTE0Mjc1",
          "commit": {
            "abbreviatedOid": "1485088"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-29T07:53:10Z",
          "updatedAt": "2020-01-29T07:53:10Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Gah. Thank you. :) Fixed in https://github.com/httpwg/http-extensions/commit/6f299dd3386c2126682c744d53db3e9c6a5f5340.",
              "createdAt": "2020-01-29T07:53:10Z",
              "updatedAt": "2020-01-29T07:53:11Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3519d4fdb99947567c58320416f1992d03cf715e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "psl",
      "headRefOid": "148508897cd82488889afadd22f18f0a1df86ad4",
      "mergeCommit": {
        "oid": "c4f610929f67ec7ea417438070cc7dc6557d78d7"
      }
    },
    {
      "number": 1039,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2NjgyMTgw",
      "title": "Encourage end-to-end grease by applications",
      "url": "https://github.com/httpwg/http-extensions/pull/1039",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Fixes #1015",
      "createdAt": "2020-01-24T05:10:19Z",
      "updatedAt": "2020-01-29T04:52:17Z",
      "closedAt": "2020-01-29T04:52:16Z",
      "mergedAt": "2020-01-29T04:52:16Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3519d4fdb99947567c58320416f1992d03cf715e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-1015",
      "headRefOid": "2bf8be62b9b9ff0a15543db50ab210edf330b51d",
      "mergeCommit": {
        "oid": "e0cd0f2d936a32ceb31b6ebee695635c41e555eb"
      }
    },
    {
      "number": 1040,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2NzA0NjEw",
      "title": "[RFC6265bis, Editorial] Consistently use 'last-access-time'.",
      "url": "https://github.com/httpwg/http-extensions/pull/1040",
      "state": "MERGED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #1032.\r\n\r\n@johnwilander @bagder, mind taking a look? John, in particular, you noted \"But we should also have an explicit reference in my opinion.\", which I didn't really understand. Do you want more than this patch?",
      "createdAt": "2020-01-24T06:59:28Z",
      "updatedAt": "2020-01-29T07:54:13Z",
      "closedAt": "2020-01-29T07:54:12Z",
      "mergedAt": "2020-01-29T07:54:12Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "@johnwilander: Ping.",
          "createdAt": "2020-01-28T07:34:38Z",
          "updatedAt": "2020-01-28T07:34:38Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I'm just going to land this and close #1032, @johnwilander. If you have concerns, I'd love to review a PR!",
          "createdAt": "2020-01-29T07:54:07Z",
          "updatedAt": "2020-01-29T07:54:07Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3519d4fdb99947567c58320416f1992d03cf715e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "last-access-time",
      "headRefOid": "2cbed1dabfa9c2bab92983de59d3fcadcac75693",
      "mergeCommit": {
        "oid": "7dbfa86ae55a54e6ce95e76a898a020816fbf37c"
      }
    },
    {
      "number": 1041,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY4MDQ5MjE2",
      "title": "Fixes: #1016. Use Origin Server and User Agent",
      "url": "https://github.com/httpwg/http-extensions/pull/1041",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "## This PR\r\n\r\nAs `priority` header is end-to-end, where applicable\r\nI used \"origin server\" and \"user agent\".\r\n\r\nFixes: #1016 \r\n\r\n## Notes\r\n\r\nThere might be other occurrencies to replace. Let me know if the current ones are correct.",
      "createdAt": "2020-01-28T14:37:27Z",
      "updatedAt": "2020-08-05T00:17:03Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c4f610929f67ec7ea417438070cc7dc6557d78d7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1016",
      "headRefOid": "cb3130409bbe145432ccf1802e783c44df769a37",
      "closedAt": "2020-05-26T20:18:03Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We can probably close :)",
          "createdAt": "2020-05-26T20:18:03Z",
          "updatedAt": "2020-05-26T20:18:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5NDIzNzI3",
          "commit": {
            "abbreviatedOid": "e7a2e0c"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-28T14:38:20Z",
          "updatedAt": "2020-01-28T14:38:20Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "`representation` is an http keyword. I'd use \"presentation\" or something similar.",
              "createdAt": "2020-01-28T14:38:20Z",
              "updatedAt": "2020-01-28T15:08:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NjkzNDU1",
          "commit": {
            "abbreviatedOid": "cb31304"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thank you for the PR, sorry for my belated response.\r\n\r\nI've cherry-picked the changes that seem to be editorial in #1095. For other changes, I've left my comment below. WDYT?",
          "createdAt": "2020-03-04T11:14:44Z",
          "updatedAt": "2020-03-04T11:18:56Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I am not sure if we should use \"origin\" here. Assuming that we would not forbid an intermediary from setting the priority header field, I think just saying \"server\" (or maybe \"upstream\") might be sufficient.\r\n\r\nThe same goes to the proposed change from \"client\" to \"user agent.\"",
              "createdAt": "2020-03-04T11:14:44Z",
              "updatedAt": "2020-03-04T11:18:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODI3MjYy",
          "commit": {
            "abbreviatedOid": "cb31304"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T14:34:08Z",
          "updatedAt": "2020-03-04T14:34:08Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "> we would not forbid an intermediary from setting the priority header field\r\nI agree.\r\n\r\nI interpreted the end-to-end section as \"UA -> Origin Server\" https://github.com/kazuho/http-extensions/blob/master/draft-ietf-httpbis-priority.md#why-use-an-end-to-end-header-field\r\n\r\n:)",
              "createdAt": "2020-03-04T14:34:08Z",
              "updatedAt": "2020-03-04T14:34:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODY2NDcz",
          "commit": {
            "abbreviatedOid": "cb31304"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T15:18:56Z",
          "updatedAt": "2020-03-04T15:18:57Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "@kazuho here and elsewhere \"origin server\" disambiguates from HTTP \"origin\" RFC6454 https://www.rfc-editor.org/rfc/rfc6454.html",
              "createdAt": "2020-03-04T15:18:57Z",
              "updatedAt": "2020-03-04T15:18:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1044,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY4ODUzNTEy",
      "title": "make serialise decimal algo round early, fail fast",
      "url": "https://github.com/httpwg/http-extensions/pull/1044",
      "state": "MERGED",
      "author": "phluid61",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Round to three decimal places first, then check the domain, then do all the actual serialising.\r\n\r\nIt's potentially not very l13n-friendly; feel free to change \"decimal point\" or \"to the left\" etc., if something is more appropriate.\r\n\r\nFixes #1043",
      "createdAt": "2020-01-30T02:04:43Z",
      "updatedAt": "2020-02-12T12:27:30Z",
      "closedAt": "2020-02-11T14:22:31Z",
      "mergedAt": "2020-02-11T14:22:31Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0NTY1NDQ3",
          "commit": {
            "abbreviatedOid": "3088529"
          },
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T15:57:30Z",
          "updatedAt": "2020-02-06T15:57:31Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "This should probably just be \"number\", or \"real number\" to be extra pedantic.\r\n\r\n(If we wanted to restrict to `Decimals`, as defined in [Section 3.3.2](https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-15#section-3.3.2), then the previous algorithm is probably correct, since rounding isn't even an issue.)",
              "createdAt": "2020-02-06T15:57:31Z",
              "updatedAt": "2020-02-11T14:22:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTUwNTY5",
          "commit": {
            "abbreviatedOid": "3088529"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-07T06:21:46Z",
          "updatedAt": "2020-02-07T06:21:46Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "That's a bigger issue than just removing the underscore. It potentially has far-reaching implications, too. (What is a 'key' if not an SH-key? Why is Boolean written with a capital? etc.)",
              "createdAt": "2020-02-07T06:21:46Z",
              "updatedAt": "2020-02-11T14:22:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NDEyMDQ5",
          "commit": {
            "abbreviatedOid": "3088529"
          },
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-07T20:16:58Z",
          "updatedAt": "2020-02-07T20:16:59Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Does this algorithm even accept input that is not a valid \"Decimal\", as defined in the spec? If not, then there's no reason to consider rounding at all. Decimals can have at most 3 fractional digits. If it needs rounding, it's not a Decimal.\r\n\r\nBut you're right, those questions do have bigger impact. I'll open a different issue to ask that question.",
              "createdAt": "2020-02-07T20:16:59Z",
              "updatedAt": "2020-02-11T14:22:09Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "bce94a3fb6d686262e8fcd247e1dcb39d845199d",
      "headRepository": "phluid61/http-extensions",
      "headRefName": "1043-fail-faster-serialising-decimal",
      "headRefOid": "1bb2d0ba71f6412bcbd7b01edc0e52f83d825563",
      "mergeCommit": {
        "oid": "41581cf754f939105a4abc8eff56d1f52c3d9320"
      }
    },
    {
      "number": 1045,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY5NTU1ODA5",
      "title": "Fix \"is can be\" (header structure)",
      "url": "https://github.com/httpwg/http-extensions/pull/1045",
      "state": "MERGED",
      "author": "essen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Small editorial fix.\r\n\r\nI'm also not comfortable with \"a integer\", maybe remove \"a\"? Anyway that's a nitpick.",
      "createdAt": "2020-01-31T12:19:34Z",
      "updatedAt": "2020-02-01T13:55:54Z",
      "closedAt": "2020-02-01T13:55:24Z",
      "mergedAt": "2020-02-01T13:55:24Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks @essen.",
          "createdAt": "2020-02-01T13:55:54Z",
          "updatedAt": "2020-02-01T13:55:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxNDg5MDY3",
          "commit": {
            "abbreviatedOid": "dd84a41"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-01-31T13:01:11Z",
          "updatedAt": "2020-01-31T13:01:11Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b60be9d99fce305bc97f7d9033d49aff43ad8159",
      "headRepository": "essen/http-extensions",
      "headRefName": "patch-4",
      "headRefOid": "dd84a41d4203606529f797b80c94b5c5e6942779",
      "mergeCommit": {
        "oid": "1c64d80c9abfe75b4dd10bf831d0e29aa643cb7d"
      }
    },
    {
      "number": 1047,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcxMjQxNTE5",
      "title": "[RFC6265bis, Editorial] Typo'd a section number.",
      "url": "https://github.com/httpwg/http-extensions/pull/1047",
      "state": "MERGED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #1046.",
      "createdAt": "2020-02-05T08:25:11Z",
      "updatedAt": "2020-02-05T11:45:44Z",
      "closedAt": "2020-02-05T08:26:49Z",
      "mergedAt": "2020-02-05T08:26:48Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "@johnwilander I'm just going to land this (as it's trivial), and roll an -05 today.",
          "createdAt": "2020-02-05T08:26:05Z",
          "updatedAt": "2020-02-05T08:26:05Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This should use a named section reference, no? Otherwise it can break again when section numbers change.",
          "createdAt": "2020-02-05T11:45:44Z",
          "updatedAt": "2020-02-05T11:45:44Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1c64d80c9abfe75b4dd10bf831d0e29aa643cb7d",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "same-site-section",
      "headRefOid": "5d0e72f398674758a035d0f3b26467831f8b4dfe",
      "mergeCommit": {
        "oid": "b55d1e7663fcd5812ca92b1013b1601a2e5f8fcc"
      }
    },
    {
      "number": 1048,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcxMjQ0NDMy",
      "title": "Minimize the semantics of urgency",
      "url": "https://github.com/httpwg/http-extensions/pull/1048",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "Based on our side meeting during QUIC interim, this PR makes following changes:\r\n* Reduce semantics associated to urgency levels. Clients can now use the 8 levels in the way they like, with the only restrictions being: default=3, background=7.\r\n* Stop using upper-case keywords for how the responses should be prioritized, or how server-provided parameters should be incorporated.",
      "createdAt": "2020-02-05T08:33:07Z",
      "updatedAt": "2020-03-04T06:09:14Z",
      "closedAt": "2020-02-10T10:53:25Z",
      "mergedAt": "2020-02-10T10:53:25Z",
      "mergedBy": "LPardue",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ianswett @afrind @LPardue @martinthomson @lnicco I'd appreciate it if you could check that the changes  reflect what we discussed.",
          "createdAt": "2020-02-05T08:42:19Z",
          "updatedAt": "2020-02-05T08:42:36Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue I think this PR is becoming ready. Would you mind taking a look (and merge it if looks okay to you)?",
          "createdAt": "2020-02-10T02:58:31Z",
          "updatedAt": "2020-02-10T02:58:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNjk4MzU4",
          "commit": {
            "abbreviatedOid": "bbd0187"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I made some editorial comments on this design change. Overall looks good.",
          "createdAt": "2020-02-05T13:05:08Z",
          "updatedAt": "2020-02-05T13:19:35Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I see that the HTTP response case is mentioned later but I think it might help to explicitly mention that it here e.g. a response with the parameters SHOULD NOT be interpreted as if default were specified.",
              "createdAt": "2020-02-05T13:05:08Z",
              "updatedAt": "2020-02-10T02:56:01Z"
            },
            {
              "originalPosition": 93,
              "body": "```suggestion\r\nconvention allows servers to refine the urgency using\r\n```\r\nsuggestion to make the text more assertive",
              "createdAt": "2020-02-05T13:08:32Z",
              "updatedAt": "2020-02-10T02:56:01Z"
            },
            {
              "originalPosition": 187,
              "body": "```suggestion\r\nan HTTP response should be prioritized. When forwarding an HTTP response with\r\n```",
              "createdAt": "2020-02-05T13:18:07Z",
              "updatedAt": "2020-02-10T02:56:01Z"
            },
            {
              "originalPosition": 212,
              "body": "```suggestion\r\nthe intermediary might alter its understanding of the urgency from `5` to `2`,\r\n```",
              "createdAt": "2020-02-05T13:18:42Z",
              "updatedAt": "2020-02-10T02:56:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzOTY0OTYx",
          "commit": {
            "abbreviatedOid": "2840055"
          },
          "author": "tombergan",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T19:03:22Z",
          "updatedAt": "2020-02-05T19:03:39Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Sorry I missed the meeting. Can you explain the rationale for this? Since there is no resource more urgent than the main resource, this effectively reserves priorities 0-2 for the server.",
              "createdAt": "2020-02-05T19:03:22Z",
              "updatedAt": "2020-02-10T02:56:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjUwMjE2",
          "commit": {
            "abbreviatedOid": "c08b31a"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T07:47:18Z",
          "updatedAt": "2020-02-06T07:47:18Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Sorry if you felt left alone. I have written down my understanding of the outcome of the meeting at https://github.com/httpwg/http-extensions/issues/1026#issuecomment-582776695, I think we might want to consider discussing there.",
              "createdAt": "2020-02-06T07:47:18Z",
              "updatedAt": "2020-02-10T02:56:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0Njc1MTk1",
          "commit": {
            "abbreviatedOid": "c08b31a"
          },
          "author": "tombergan",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T18:30:00Z",
          "updatedAt": "2020-02-06T18:30:01Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "No worries and thanks for the context. The examples make sense. I think it's fine to say that 7 should be reserved for background downloads and it's fine to say that the main HTML should use level X, for some X, but I'm not sure why X=3 was chosen. It seems like this could work just as well with X=0 or X=1.\r\n\r\nNote that Chrome (and WebKit/Safari?) use 6 priority levels currently. With X = 3, there are 5 levels available which means that Chrome (and WebKit/Safari?) need to fold two levels into one. This is not a dealbreaker but IMO there should at least be a good reason why levels 0-2 need to be reserved for the server when clients have a demonstrated use for 6 of 8 levels. Ideally someone from Firefox (and Safari) should chime in as well.\r\n\r\nIt's also worth mentioning that this pull request doesn't have enough information to do everything that [this comment](https://github.com/httpwg/http-extensions/issues/1026#issuecomment-582776695) wants to do. For example: \"a server might demote them to the same level as asynchronously fetched JavaScript files, or to somewhere even below, but above background downloads.\" It's not possible to demote to the same level as async JS, because the level of async JS is not specified. Also, it's not trivial to set a priority \"above background downloads\" because the pull request merely states that level 7 is reserved for background downloads, not anything about level 6 (perhaps some client has many background downloads and wants to partition those into two levels). I wouldn't change this pull request though -- this pull request seems like the right level of detail.\r\n\r\nTo summarize, this looks good but I would suggest changing the level of mainframe requests to 0 or 1.",
              "createdAt": "2020-02-06T18:30:00Z",
              "updatedAt": "2020-02-10T02:56:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0Njc3NTAx",
          "commit": {
            "abbreviatedOid": "2840055"
          },
          "author": "tombergan",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T18:33:37Z",
          "updatedAt": "2020-02-06T18:35:22Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "It might be worth specifying which urgency level should be used for server push streams. I think the \"optimal\" solution is to default to 7, then rely on the client to reprioritize the pushed stream when it matches an actual requests. Assuming no bufferbloat, this ensures that the server does not waste any high-priority bandwidth on pushes that won't be used.",
              "createdAt": "2020-02-06T18:33:38Z",
              "updatedAt": "2020-02-10T02:56:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0ODIzMDAx",
          "commit": {
            "abbreviatedOid": "c08b31a"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T22:39:14Z",
          "updatedAt": "2020-02-06T22:40:26Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "There are non-browser use-cases of push where background might not be the best level for pushed resources, but as long as we are not too prescriptive about it I don't object to saying that background is recommended.",
              "createdAt": "2020-02-06T22:39:14Z",
              "updatedAt": "2020-02-10T02:56:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0ODM4ODg1",
          "commit": {
            "abbreviatedOid": "c08b31a"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T23:13:44Z",
          "updatedAt": "2020-02-06T23:13:45Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "I think @tombergen's suggestion is a sensible one. We can support @afrind case by applying the server signal to the push; absence of server signal means default (in this case background), presence of signal prioritizes at a different level and, if passed back to the client, is an explicit signal of the push priority. If this matches the priority the client would have reprioritized to (because it is more important) you save the client from sending a pointless reprioritization. ",
              "createdAt": "2020-02-06T23:13:44Z",
              "updatedAt": "2020-02-10T02:56:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTM2MzA1",
          "commit": {
            "abbreviatedOid": "c08b31a"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-07T05:22:52Z",
          "updatedAt": "2020-02-07T05:22:53Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Thank you for sharing your thoughts.\r\n\r\nRegarding background, you are right! I hadn't thought about that, but the new design does not forbid a client from using level(s) above 7 for background tasks too. That said, I agree with you that we do not need to be more strict.\r\n\r\nRegarding the default level, based on your comments, I am going to change it to 1. I think it would be a good idea to provide one level above default, considering the fact that Firefox prioritizes JavaScript and CSS files above HTML. But I do not think we need more than one.\r\n\r\nThen, if people prefer having symmetry (i.e. having same number of urgency levels above and below the default), we can consider increasing the number of levels to 10 (or maybe 12) so that there would be sufficient number of levels below the default.",
              "createdAt": "2020-02-07T05:22:52Z",
              "updatedAt": "2020-02-10T02:56:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTQyMzQ5",
          "commit": {
            "abbreviatedOid": "c08b31a"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-07T05:49:32Z",
          "updatedAt": "2020-02-07T05:49:33Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "IMO, the default should (can) be 7 only when all the following conditions are met:\r\n* 1. There is no bufferbloat.\r\n* 2. If the specification retains the definition of a reprioritization frame.\r\n* 3. If the browser correctly uses that.\r\n\r\nFor point 1, while there would likely be no bufferbloat in HTTP/3, there will be in HTTP/2. For point 2, the discussion is ongoing in #1021, and I am not sure if we can be certain that browsers would reprioritize pushed assets even in case of it being specified.\r\n\r\nConsidering these aspects, I tend to think that the correct thing for a server to do by default would be prioritize the pushed response right after the response that initiated the push. In terms of the specification, we can either state to use the same urgency level with i=false, or the next urgency level.\r\n\r\nSuch a design would give us what we have now in HTTP/2.\r\n\r\nIn case of HTTP/3, there would be negligible negative impact, assuming that there would be no bufferbloat. This is because URLs of pushed responses and the HTML would reach clients before the pushed resources do. Clients would be possible to cancel / reprioritize the pushed resources when or before when it discovers and issues requests for the non-pushed resources that it needs; i.e. the resources that would be competing against those being pushed.",
              "createdAt": "2020-02-07T05:49:32Z",
              "updatedAt": "2020-02-10T02:56:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTc1NzA3",
          "commit": {
            "abbreviatedOid": "c08b31a"
          },
          "author": "tombergan",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-07T07:44:15Z",
          "updatedAt": "2020-02-07T07:44:17Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "I think it's fine to punt this question to #1021. You are right that this becomes problematic without reprioritization. If repriotization goes away, perhaps we'll need to say something like \"servers should not push resources unless they are confident they can assign a suitable priority for that resource\". \r\n\r\n> I tend to think that the correct thing for a server to do by default would be prioritize the pushed response right after the response that initiated the push\r\n\r\nWe have observed that H2 push can be a serious footgun. It's easy to hurt performance by over-pushing, such as by pushing low priority resources or cached resources. A level 7 default reduces the potential impact of this footgun. As @LPardue said, this is just a default; the server can always do something different when it believes it knows better.\r\n\r\n> Clients would be possible to cancel the pushed resources when or before when it discovers\r\n\r\nIt's difficult for the client to know whether or not they should cancel a pushed resource. Maybe they will need the resource soon, they just don't know yet.\r\n\r\n> I am not sure if we can be certain that browsers would reprioritize pushed assets even in case of it being specified.\r\n\r\nFWIW, Chrome already does this for H2. Not sure about other browsers.",
              "createdAt": "2020-02-07T07:44:16Z",
              "updatedAt": "2020-02-10T02:56:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NjY3Njg0",
          "commit": {
            "abbreviatedOid": "bc04fea"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-10T02:42:50Z",
          "updatedAt": "2020-02-10T02:42:50Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Created #1056 so that we do not miss it.",
              "createdAt": "2020-02-10T02:42:50Z",
              "updatedAt": "2020-02-10T02:56:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NjY3Nzk3",
          "commit": {
            "abbreviatedOid": "bc04fea"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-10T02:43:28Z",
          "updatedAt": "2020-02-10T02:43:29Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Done in bc04fea.",
              "createdAt": "2020-02-10T02:43:29Z",
              "updatedAt": "2020-02-10T02:56:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NjcwMTkz",
          "commit": {
            "abbreviatedOid": "146fd30"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-10T02:56:44Z",
          "updatedAt": "2020-02-10T02:56:44Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Done in 146fd30. PTAL.",
              "createdAt": "2020-02-10T02:56:44Z",
              "updatedAt": "2020-02-10T02:56:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1ODQzOTQx",
          "commit": {
            "abbreviatedOid": "146fd30"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "We had some healthy discussion on this PR, I think the current text is accurate to our present understanding. We'll handle further work on the linked issues (or related ones).\r\n\r\nApproving ang merging.",
          "createdAt": "2020-02-10T10:52:22Z",
          "updatedAt": "2020-02-10T10:52:22Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b55d1e7663fcd5812ca92b1013b1601a2e5f8fcc",
      "headRepository": "kazuho/http-extensions",
      "headRefName": "kazuho/priority-less-semantics",
      "headRefOid": "146fd301b5945eea9908b4c539612d87b3b87fef",
      "mergeCommit": {
        "oid": "5c386e8114209d9610814c09810e05dab12f08f4"
      }
    },
    {
      "number": 1049,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcxMjQ1ODQx",
      "title": "Update `SUBMITTING.md` to note email address requirements.",
      "url": "https://github.com/httpwg/http-extensions/pull/1049",
      "state": "MERGED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Closes #1031",
      "createdAt": "2020-02-05T08:37:18Z",
      "updatedAt": "2020-02-05T09:04:32Z",
      "closedAt": "2020-02-05T09:04:31Z",
      "mergedAt": "2020-02-05T09:04:31Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b55d1e7663fcd5812ca92b1013b1601a2e5f8fcc",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mikewest-patch-1",
      "headRefOid": "97c6e1e78bde067cff1b5af47c3abf20d622f467",
      "mergeCommit": {
        "oid": "d1de1e6d7a5d892214158afd5486159b9acc3e87"
      }
    },
    {
      "number": 1050,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcxMzMxNzU0",
      "title": "really fix #1046",
      "url": "https://github.com/httpwg/http-extensions/pull/1050",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-05T11:51:43Z",
      "updatedAt": "2020-03-05T09:06:15Z",
      "closedAt": "2020-03-05T09:06:14Z",
      "mergedAt": "2020-03-05T09:06:14Z",
      "mergedBy": "mikewest",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5Mzk1MjA4",
          "commit": {
            "abbreviatedOid": "60ec49b"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "\ud83d\udc4d ",
          "createdAt": "2020-03-05T09:06:07Z",
          "updatedAt": "2020-03-05T09:06:07Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d1de1e6d7a5d892214158afd5486159b9acc3e87",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-1046",
      "headRefOid": "60ec49bea025d89f820edd7c9c4ce6317d75b7ed",
      "mergeCommit": {
        "oid": "60c7316bc8c3f5089ee06eeb7b6963c84de1dd3c"
      }
    },
    {
      "number": 1052,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcyMDMyMDcy",
      "title": "Minor structured header nits",
      "url": "https://github.com/httpwg/http-extensions/pull/1052",
      "state": "MERGED",
      "author": "clelland",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "* Change \"removing the first character\" to \"consuming the first character\" in `#parse-key`\r\n* Add \"as\" for consistency in `#ser-item`\r\n* Correct `parameter-name` to `param_name` in `#ser-params`",
      "createdAt": "2020-02-06T17:53:24Z",
      "updatedAt": "2020-03-04T03:53:13Z",
      "closedAt": "2020-03-03T22:42:38Z",
      "mergedAt": "2020-03-03T22:42:38Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Found one more - step 2 of {{ser-key}} reads\r\n\r\n    2. If the first character of input_key is not lcalpha, fail parsing.\r\n\r\nIt should say \"fail serialisation\"",
          "createdAt": "2020-03-03T12:18:53Z",
          "updatedAt": "2020-03-03T12:18:53Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Many thanks!",
          "createdAt": "2020-03-03T22:42:26Z",
          "updatedAt": "2020-03-03T22:42:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTQ4ODU2",
          "commit": {
            "abbreviatedOid": "a8ed69f"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-07T06:15:23Z",
          "updatedAt": "2020-02-07T06:15:24Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I think this was right. Otherwise it would be \"Given an item as base_item and parameters as item_parameters as input ...\"",
              "createdAt": "2020-02-07T06:15:24Z",
              "updatedAt": "2020-03-03T12:18:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MTk0MDM1",
          "commit": {
            "abbreviatedOid": "a8ed69f"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good with one change.",
          "createdAt": "2020-02-07T14:31:12Z",
          "updatedAt": "2020-02-07T14:31:23Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I tend to agree; that's the style we're using elsewhere. ",
              "createdAt": "2020-02-07T14:31:12Z",
              "updatedAt": "2020-03-03T12:18:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MzM1NTY4",
          "commit": {
            "abbreviatedOid": "a8ed69f"
          },
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-07T18:03:08Z",
          "updatedAt": "2020-02-07T18:03:08Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Ahh, I didn't read this sentence correctly.\r\n\r\nI read it as \"GIven (an item named bare_item) and (parameters named item_parameters) as input to this function, ...\"\r\n\r\nbut it's actually saying \"Given an item (which is a tuple made up of bare_item and (parameters named item_parameters)) named input, ...\"\r\n\r\nThe name \"input\" isn't used in the algorithm, which I think threw my parser off. Maybe the style used in #ser-dict would be appropriate here:\r\n\r\n\"Given an item (having a bare_item and item_parameters), return an ASCII string...\"",
              "createdAt": "2020-02-07T18:03:08Z",
              "updatedAt": "2020-03-03T12:18:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NDk5Nzcx",
          "commit": {
            "abbreviatedOid": "a8ed69f"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-07T23:45:59Z",
          "updatedAt": "2020-02-07T23:46:00Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I've just realised the other algorithms use \"as\" to mean \"named\", and don't say \"as input\". For example, bare item:\r\n\r\n> Given an item as input_item, return...\r\n\r\nThe right fix would probably be:\r\n\r\n> Given an item as bare_item and parameters as item_parameters, return... ",
              "createdAt": "2020-02-07T23:46:00Z",
              "updatedAt": "2020-03-03T12:18:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MjUxMTY3",
          "commit": {
            "abbreviatedOid": "a8ed69f"
          },
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-10T20:48:04Z",
          "updatedAt": "2020-02-10T20:48:05Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Yeah, \"as input\" isn't used at all elsewhere.\r\n\r\n> Given an item as bare_item and parameters as item_parameters, return...\r\n\r\nThat would work, except that an item already has parameters, according to `{#item}`, I think.\r\nBut then again, `{#ser-bare-item}` also claims to take an item, so maybe it just works.",
              "createdAt": "2020-02-10T20:48:04Z",
              "updatedAt": "2020-03-03T12:18:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTE3Njgx",
          "commit": {
            "abbreviatedOid": "a8ed69f"
          },
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-02T20:51:11Z",
          "updatedAt": "2020-03-02T20:51:12Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Fixed now.",
              "createdAt": "2020-03-02T20:51:12Z",
              "updatedAt": "2020-03-03T12:18:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NjY3MzY4",
          "commit": {
            "abbreviatedOid": "33572d6"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-03T02:35:46Z",
          "updatedAt": "2020-03-03T02:35:47Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Needs to be \"field value\", not \"header value\".",
              "createdAt": "2020-03-03T02:35:46Z",
              "updatedAt": "2020-03-03T12:18:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NjY3NDc1",
          "commit": {
            "abbreviatedOid": "33572d6"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Almost there, one nit...",
          "createdAt": "2020-03-03T02:36:09Z",
          "updatedAt": "2020-03-03T02:36:09Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "998e7ad8e582780c5a380cb79464972a56331a98",
      "headRepository": "clelland/http-extensions",
      "headRefName": "patch-1",
      "headRefOid": "1df376fb6e88264f4d4d399e4ee43792f5cdb97c",
      "mergeCommit": {
        "oid": "c913cd4d82b9ee85c5acf0226d66e72f3b096baf"
      }
    },
    {
      "number": 1054,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcyMDM3NzYz",
      "title": "Replace COMMA with \",\"",
      "url": "https://github.com/httpwg/http-extensions/pull/1054",
      "state": "MERGED",
      "author": "clelland",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The term COMMA is not defined anywhere in this document, or in any of the documents it imports. But we can just use the literal `\",\"` instead.\r\n\r\nFixes: #1053",
      "createdAt": "2020-02-06T18:06:43Z",
      "updatedAt": "2020-02-07T14:26:58Z",
      "closedAt": "2020-02-07T14:26:53Z",
      "mergedAt": "2020-02-07T14:26:52Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks.",
          "createdAt": "2020-02-07T14:26:58Z",
          "updatedAt": "2020-02-07T14:26:58Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d1de1e6d7a5d892214158afd5486159b9acc3e87",
      "headRepository": "clelland/http-extensions",
      "headRefName": "patch-2",
      "headRefOid": "ebb55fcfd2997815be2e8e0dfe71f8a8e4b91fe4",
      "mergeCommit": {
        "oid": "45c675473ff714b437eecac0a97ccebffb47bbe9"
      }
    },
    {
      "number": 1058,
      "id": "MDExOlB1bGxSZXF1ZXN0MzczNTAyMDc2",
      "title": "rfced recommended section reference format",
      "url": "https://github.com/httpwg/http-extensions/pull/1058",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "",
      "createdAt": "2020-02-11T07:01:19Z",
      "updatedAt": "2020-07-08T17:46:04Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5c386e8114209d9610814c09810e05dab12f08f4",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-prio-1",
      "headRefOid": "45852f908237b14733db134d51664617a54876f5",
      "closedAt": "2020-07-08T17:45:57Z",
      "mergedAt": "2020-07-08T17:45:57Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "6be5ead90c20fb13a818cf65e5badeacec911df3"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks",
          "createdAt": "2020-07-08T17:46:04Z",
          "updatedAt": "2020-07-08T17:46:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NjQ4MjI4",
          "commit": {
            "abbreviatedOid": "45852f9"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-05-26T20:18:52Z",
          "updatedAt": "2020-05-26T20:18:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1060,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc0OTc0MjUw",
      "title": "[RFC6265bis] Add a cookie attribute registry.",
      "url": "https://github.com/httpwg/http-extensions/pull/1060",
      "state": "MERGED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This could allow us to register 'priority' in a separate document\r\nwithout angering the Powers That Be.\r\n\r\n@mnot: Does this more or less match what you were expecting?",
      "createdAt": "2020-02-13T16:41:21Z",
      "updatedAt": "2020-02-24T07:38:24Z",
      "closedAt": "2020-02-24T07:38:23Z",
      "mergedAt": "2020-02-24T07:38:23Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I'm going to merge this to keep things rolling, and we can address anything I missed in future patches.",
          "createdAt": "2020-02-24T07:38:11Z",
          "updatedAt": "2020-02-24T07:38:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5OTgwNzY3",
          "commit": {
            "abbreviatedOid": "703aaa4"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-02-17T21:57:55Z",
          "updatedAt": "2020-02-17T22:03:54Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "obsoleted by rfc8126",
              "createdAt": "2020-02-17T21:57:55Z",
              "updatedAt": "2020-02-24T07:37:17Z"
            },
            {
              "originalPosition": 120,
              "body": "Go ahead and propose a URL on lana.org.",
              "createdAt": "2020-02-17T21:58:18Z",
              "updatedAt": "2020-02-24T07:37:17Z"
            },
            {
              "originalPosition": 119,
              "body": "s/set/name space/",
              "createdAt": "2020-02-17T21:58:27Z",
              "updatedAt": "2020-02-24T07:37:17Z"
            },
            {
              "originalPosition": 125,
              "body": "A link to requirements on syntax would help. Make sure it defines whether or not they're compared case-insensitively.",
              "createdAt": "2020-02-17T21:59:21Z",
              "updatedAt": "2020-02-24T07:37:17Z"
            },
            {
              "originalPosition": 127,
              "body": "So, Standards Action is pretty much the highest bar, and would preclude a document submitted on the Independent Stream (since it requires IETF Stream), and as an Internet Standard.\r\n\r\nIETF Review would still require IETF Stream, but would allow e.g., the HTTP WG to publish it as Informational.\r\n\r\nRFC Required would allow any RFC from any stream. \r\n\r\nThe other option would be Expert Review, but that would mean you'd need to define the review criteria for the expert. \r\n\r\nI'd recommend one of the latter two.\r\n",
              "createdAt": "2020-02-17T22:03:10Z",
              "updatedAt": "2020-02-24T07:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMTQ4MTM0",
          "commit": {
            "abbreviatedOid": "703aaa4"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Thanks, @mnot. WDYT?",
          "createdAt": "2020-02-18T08:35:43Z",
          "updatedAt": "2020-02-18T08:40:41Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "And `s/names //`, I assume?",
              "createdAt": "2020-02-18T08:35:43Z",
              "updatedAt": "2020-02-24T07:37:17Z"
            },
            {
              "originalPosition": 125,
              "body": "The next paragraph points to `extension-av` as governing the syntax, and I've added a note about case.",
              "createdAt": "2020-02-18T08:38:30Z",
              "updatedAt": "2020-02-24T07:37:17Z"
            },
            {
              "originalPosition": 127,
              "body": "Thank you for the clarification. RFC Required sounds reasonable to me. I've switched this to point to that mechanism.",
              "createdAt": "2020-02-18T08:39:08Z",
              "updatedAt": "2020-02-24T07:37:17Z"
            },
            {
              "originalPosition": 120,
              "body": "`https://www.iana.org/assignments/cookie-attribute-names` it is!",
              "createdAt": "2020-02-18T08:39:52Z",
              "updatedAt": "2020-02-24T07:37:17Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b3eb517b2f4a3d3b68602594667603d167271555",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "registry",
      "headRefOid": "593b6fa12bb31bda65ac72262973b38fce3451dc",
      "mergeCommit": {
        "oid": "9b13e1acc359f1f23b148b9d491ee1ec0a8e5a38"
      }
    },
    {
      "number": 1063,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc2NjQwMDc3",
      "title": "Change Client Hints revision to 09",
      "url": "https://github.com/httpwg/http-extensions/pull/1063",
      "state": "CLOSED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-18T14:13:13Z",
      "updatedAt": "2020-02-19T07:25:02Z",
      "closedAt": "2020-02-18T20:53:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> \ud83d\udc4d ... but didn't you just push -10?\r\n\r\nIndeed. 09 had some merge issues. Abandoning this one",
          "createdAt": "2020-02-18T20:53:12Z",
          "updatedAt": "2020-02-18T20:53:12Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You should be able to use \"-latest\" instead of a specific version number in the document. That might save some of this type of messing around. ",
          "createdAt": "2020-02-19T02:10:06Z",
          "updatedAt": "2020-02-19T02:10:06Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> You should be able to use \"-latest\" instead of a specific version number in the document. That might save some of this type of messing around.\r\n\r\nTIL - thanks! :)",
          "createdAt": "2020-02-19T07:25:02Z",
          "updatedAt": "2020-02-19T07:25:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNTYyNDU2",
          "commit": {
            "abbreviatedOid": "b708b7b"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "\ud83d\udc4d ... but didn't you just push -10?",
          "createdAt": "2020-02-18T18:14:32Z",
          "updatedAt": "2020-02-18T18:14:32Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c522a8ee953a421fcf4fa1b61da320ac2909c66e",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "revision_09",
      "headRefOid": "b708b7b1f284f867fb1f4a6c3cbc4313bc7e8ece",
      "mergeCommit": null
    },
    {
      "number": 1064,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc2NjUyMzY3",
      "title": "Fix merge issues with \"cost of adding hints\" section",
      "url": "https://github.com/httpwg/http-extensions/pull/1064",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "When merging the different PRs, the \"Cost of adding hints\" section was misplaced and it wound up in the middle of the security section. This fixes that (and bumps the revision number).",
      "createdAt": "2020-02-18T14:35:59Z",
      "updatedAt": "2020-02-18T16:05:22Z",
      "closedAt": "2020-02-18T16:05:22Z",
      "mergedAt": "2020-02-18T16:05:22Z",
      "mergedBy": "yoavweiss",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNDY1MzYw",
          "commit": {
            "abbreviatedOid": "62e7d9d"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-18T16:04:55Z",
          "updatedAt": "2020-02-18T16:04:55Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c522a8ee953a421fcf4fa1b61da320ac2909c66e",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "fix_merge_issues_with_cost_section",
      "headRefOid": "62e7d9df8632c516b0090d6624d3d8321c9a1124",
      "mergeCommit": {
        "oid": "784d320cce84bb7442430220181a65c208128e30"
      }
    },
    {
      "number": 1065,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc2NjkzMjc0",
      "title": "priorities: remove last vestiges of override",
      "url": "https://github.com/httpwg/http-extensions/pull/1065",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "We still had usage of the term override, so while thinking how to address that I took the opportunity to state explicitly that no guidance is provided for how an intermediary might merge.",
      "createdAt": "2020-02-18T15:48:38Z",
      "updatedAt": "2020-02-27T13:41:29Z",
      "closedAt": "2020-02-27T13:41:28Z",
      "mergedAt": "2020-02-27T13:41:28Z",
      "mergedBy": "LPardue",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwODA5Mjgy",
          "commit": {
            "abbreviatedOid": "f9519e4"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thank you for the PR!",
          "createdAt": "2020-02-19T02:40:51Z",
          "updatedAt": "2020-02-19T02:41:10Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "To a non-native speaker, \"As a non-normative example\" sounds more natural, though I am not sure if it's actually better.",
              "createdAt": "2020-02-19T02:40:51Z",
              "updatedAt": "2020-02-27T12:51:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1Njc4ODI5",
          "commit": {
            "abbreviatedOid": "328da39"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2020-02-27T13:29:19Z",
          "updatedAt": "2020-02-27T13:29:19Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c522a8ee953a421fcf4fa1b61da320ac2909c66e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "merging-language-tweaks",
      "headRefOid": "328da39ac969c971e3a713db372d04db1930821e",
      "mergeCommit": {
        "oid": "5824fb8aba9ba0df46fd2fa63821160fc65ecdb7"
      }
    },
    {
      "number": 1066,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc2NzIxNjgy",
      "title": "priority: remove mention of CDN-loop",
      "url": "https://github.com/httpwg/http-extensions/pull/1066",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "Fixes #1062 \r\n\r\ncc: @mnot ",
      "createdAt": "2020-02-18T16:42:36Z",
      "updatedAt": "2020-03-04T05:20:11Z",
      "closedAt": "2020-03-04T05:20:04Z",
      "mergedAt": "2020-03-04T05:20:03Z",
      "mergedBy": "kazuho",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for the fix.",
          "createdAt": "2020-03-04T05:20:11Z",
          "updatedAt": "2020-03-04T05:20:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NTEwNDQ1",
          "commit": {
            "abbreviatedOid": "4588711"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-04T05:19:57Z",
          "updatedAt": "2020-03-04T05:19:57Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "784d320cce84bb7442430220181a65c208128e30",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "1062-no-cdn-loop",
      "headRefOid": "4588711e9a228b31b17937ef51dc8575234559ac",
      "mergeCommit": {
        "oid": "86812858d5ff9360ae520653076d8cc3c3362a2c"
      }
    },
    {
      "number": 1069,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4MzI3Njcz",
      "title": "SHOULD check DNS for secondary if you would have for primary",
      "url": "https://github.com/httpwg/http-extensions/pull/1069",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "Fixes #869.  The intent here is to say that your requirements for trusting a secondary certificate should be at least as strict as for trusting additional names in the primary certificate.",
      "createdAt": "2020-02-21T15:06:15Z",
      "updatedAt": "2020-04-14T19:08:07Z",
      "closedAt": "2020-04-14T19:08:06Z",
      "mergedAt": "2020-04-14T19:08:06Z",
      "mergedBy": "MikeBishop",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "20f21d10b4d7a9b30258a0219434dd609bd8015f",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "sc/dns_check",
      "headRefOid": "86d33920d010cf196678989da23bcf6676779677",
      "mergeCommit": {
        "oid": "c74ef1288e0eca6c156a560ba1775a7cd460aba8"
      }
    },
    {
      "number": 1070,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4MzMxNDM0",
      "title": "Client privacy",
      "url": "https://github.com/httpwg/http-extensions/pull/1070",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "secondary-certs"
      ],
      "body": "Fixes #870.  I believe that @davidben's comment on that issue is already covered by the following section on Denial of Service.",
      "createdAt": "2020-02-21T15:14:12Z",
      "updatedAt": "2020-04-14T19:09:08Z",
      "closedAt": "2020-04-14T19:09:06Z",
      "mergedAt": "2020-04-14T19:09:06Z",
      "mergedBy": "MikeBishop",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "20f21d10b4d7a9b30258a0219434dd609bd8015f",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "sc/client_fingerprinting",
      "headRefOid": "9578b5a42e9c63fd0587c990ddf16f765c2ebbae",
      "mergeCommit": {
        "oid": "29fff7f850ad9f4930d0cdd935523c5b7d190df6"
      }
    },
    {
      "number": 1071,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4NjY1NTM4",
      "title": "http2-tls13: apply changes done during AUTH48",
      "url": "https://github.com/httpwg/http-extensions/pull/1071",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-23T05:26:26Z",
      "updatedAt": "2020-02-23T06:09:38Z",
      "closedAt": "2020-02-23T06:09:33Z",
      "mergedAt": "2020-02-23T06:09:33Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks.",
          "createdAt": "2020-02-23T06:09:38Z",
          "updatedAt": "2020-02-23T06:09:38Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "0309121387c4b8e95b95c3ddf3af61c15877eb06",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "http-tls13-auth48",
      "headRefOid": "465631dbca7d794ef353875a2db1c3609c27953e",
      "mergeCommit": {
        "oid": "96561739cd10571461b9c92daf929ba63a35a443"
      }
    },
    {
      "number": 1072,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4ODUzODI0",
      "title": "[client hints] LC feedback from @reschke",
      "url": "https://github.com/httpwg/http-extensions/pull/1072",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "This PR addresses Client Hints [LC feedback](https://lists.w3.org/Archives/Public/ietf-http-wg/2020JanMar/0141.html) from @reschke.",
      "createdAt": "2020-02-24T07:58:20Z",
      "updatedAt": "2020-02-24T10:30:37Z",
      "closedAt": "2020-02-24T10:30:31Z",
      "mergedAt": "2020-02-24T10:30:31Z",
      "mergedBy": "yoavweiss",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke - I'm assuming you were referring to the xref. It creates a link in the HTML version that looks like \"considerations outlined in the Security Considerations (Section 4) section of this document\" where \"Section 4\" is linking to the right section.\r\n\r\nI'm also happy to change it if you have an example of a better way to link.",
          "createdAt": "2020-02-24T10:08:05Z",
          "updatedAt": "2020-02-24T10:08:05Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In that case, fine.\r\n\r\n(I personally prefer consistency in these references; we ususally say \"...outlined in the Security Considerations (Section x)...\" which would translate to simpler MD.\r\n\r\nBut this is your choice :-)",
          "createdAt": "2020-02-24T10:12:14Z",
          "updatedAt": "2020-02-24T10:12:14Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the feedback and for reviewing! :)",
          "createdAt": "2020-02-24T10:30:19Z",
          "updatedAt": "2020-02-24T10:30:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjM3NjMz",
          "commit": {
            "abbreviatedOid": "98ed792"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM. Not sure whether the <xref> will do the right thing after MD conversion, though.",
          "createdAt": "2020-02-24T09:02:07Z",
          "updatedAt": "2020-02-24T09:02:07Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9b13e1acc359f1f23b148b9d491ee1ec0a8e5a38",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "lc_feedback",
      "headRefOid": "98ed792c013abac70a32646217ec4f55a8c2727d",
      "mergeCommit": {
        "oid": "9accb7128feca7c1acfaef5ab4f56093e475b02a"
      }
    },
    {
      "number": 1076,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgwODU2MjQ2",
      "title": "editorial tidyup around urgency meanings",
      "url": "https://github.com/httpwg/http-extensions/pull/1076",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "We landed a change to remove the semantic meanings\r\nof urgency levels but neglected to remove a considerations\r\nsection that discussed this.\r\n\r\nThis PR moves some of the still relevant text out of the section\r\nand nukes the stuff no longer needed.",
      "createdAt": "2020-02-27T13:39:30Z",
      "updatedAt": "2020-03-04T06:00:50Z",
      "closedAt": "2020-03-04T06:00:49Z",
      "mergedAt": "2020-03-04T06:00:49Z",
      "mergedBy": "kazuho",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "oops, this will need a rebase...",
          "createdAt": "2020-02-27T13:43:11Z",
          "updatedAt": "2020-02-27T13:43:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NTIxNzg4",
          "commit": {
            "abbreviatedOid": "3fdb07c"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-04T06:00:42Z",
          "updatedAt": "2020-03-04T06:00:42Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5824fb8aba9ba0df46fd2fa63821160fc65ecdb7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "lucas/urgency-meaning-cleanup",
      "headRefOid": "3fdb07cd17c32a3a177013703441d9abe980d51c",
      "mergeCommit": {
        "oid": "744cd1a6e1490758c594ad2ec0a9be337d83a1ce"
      }
    },
    {
      "number": 1077,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgwODg0ODE3",
      "title": "fix some priority doc nits",
      "url": "https://github.com/httpwg/http-extensions/pull/1077",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "Address some build warnings and fix typos.",
      "createdAt": "2020-02-27T14:28:43Z",
      "updatedAt": "2020-03-04T05:18:51Z",
      "closedAt": "2020-03-04T05:18:36Z",
      "mergedAt": "2020-03-04T05:18:35Z",
      "mergedBy": "kazuho",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "fixes #1024 and #1025",
          "createdAt": "2020-02-27T15:25:45Z",
          "updatedAt": "2020-02-27T15:37:22Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for the fix. Merged.",
          "createdAt": "2020-03-04T05:18:51Z",
          "updatedAt": "2020-03-04T05:18:51Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5824fb8aba9ba0df46fd2fa63821160fc65ecdb7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "lucas/priority-nits",
      "headRefOid": "362cbdb333641035b99c92dd4ea4248efa2ce55f",
      "mergeCommit": {
        "oid": "f0eb5241c6dd387c153f73072852345e599936c8"
      }
    },
    {
      "number": 1078,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgwOTEzNjU0",
      "title": "add priority discussion note",
      "url": "https://github.com/httpwg/http-extensions/pull/1078",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "",
      "createdAt": "2020-02-27T15:28:08Z",
      "updatedAt": "2020-03-04T06:01:41Z",
      "closedAt": "2020-03-04T06:01:39Z",
      "mergedAt": "2020-03-04T06:01:39Z",
      "mergedBy": "kazuho",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NTIyMDIy",
          "commit": {
            "abbreviatedOid": "e1e4aa5"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-04T06:01:33Z",
          "updatedAt": "2020-03-04T06:01:33Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5824fb8aba9ba0df46fd2fa63821160fc65ecdb7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "lucas/discussion-note",
      "headRefOid": "e1e4aa5a828665d96f052cc980974b67ecfd3fb1",
      "mergeCommit": {
        "oid": "c431f8afb5f345841c113ca6cdea27fa6715666c"
      }
    },
    {
      "number": 1080,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgwOTUxNjIx",
      "title": "Fix list style based on comment from @reschke",
      "url": "https://github.com/httpwg/http-extensions/pull/1080",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "@reschke - here's the nicer list style you ordered :)",
      "createdAt": "2020-02-27T16:37:10Z",
      "updatedAt": "2020-03-10T14:12:55Z",
      "closedAt": "2020-03-10T11:38:08Z",
      "mergedAt": "2020-03-10T11:38:08Z",
      "mergedBy": "yoavweiss",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke - friendly ping! :)",
          "createdAt": "2020-03-01T20:26:02Z",
          "updatedAt": "2020-03-01T20:26:02Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Abandoning as this doesn't seem critical",
          "createdAt": "2020-03-10T07:54:02Z",
          "updatedAt": "2020-03-10T07:54:02Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, please don't ask for a change if you're not planning to use it... See <https://lists.w3.org/Archives/Public/ietf-http-wg/2020JanMar/0157.html>",
          "createdAt": "2020-03-10T08:20:41Z",
          "updatedAt": "2020-03-10T08:21:24Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Apologies. Happy to land this if you're willing to review",
          "createdAt": "2020-03-10T09:47:58Z",
          "updatedAt": "2020-03-10T09:47:58Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "### Before:\r\n\r\n<img width=\"622\" alt=\"Screenshot 2020-03-10 at 12 00 46\" src=\"https://user-images.githubusercontent.com/786187/76306222-cec0a600-62c6-11ea-99ab-c4fcd33386d5.png\">\r\n\r\n### After:\r\n\r\n<img width=\"622\" alt=\"Screenshot 2020-03-10 at 11 55 23\" src=\"https://user-images.githubusercontent.com/786187/76305788-1b57b180-62c6-11ea-9827-ff405c7d2787.png\">\r\n",
          "createdAt": "2020-03-10T11:01:24Z",
          "updatedAt": "2020-03-10T11:01:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxODQzMjM4",
          "commit": {
            "abbreviatedOid": "0683dd7"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I don't think it needs review; just check whether xml2rfc's output is improved.",
          "createdAt": "2020-03-10T10:43:20Z",
          "updatedAt": "2020-03-10T10:43:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxOTAyNzg5",
          "commit": {
            "abbreviatedOid": "0683dd7"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-10T12:22:40Z",
          "updatedAt": "2020-03-10T12:22:53Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Do you really need the extra indentation?  The extra space above is distracting.  Dropping the '>' might be nicer.",
              "createdAt": "2020-03-10T12:22:40Z",
              "updatedAt": "2020-03-10T12:23:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxOTg4NDQ4",
          "commit": {
            "abbreviatedOid": "0683dd7"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-10T14:12:55Z",
          "updatedAt": "2020-03-10T14:12:55Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Maybe a better option is to get rid of the nested lists altogether and go with something like:\r\n<img width=\"638\" alt=\"Screenshot 2020-03-10 at 15 11 55\" src=\"https://user-images.githubusercontent.com/786187/76320866-895da200-62e1-11ea-9afa-21646a6e7fa6.png\">\r\n",
              "createdAt": "2020-03-10T14:12:55Z",
              "updatedAt": "2020-03-10T14:12:55Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5824fb8aba9ba0df46fd2fa63821160fc65ecdb7",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "list_style",
      "headRefOid": "0683dd71a9b6a6a79d7a6d2b2fbf20f2feee5689",
      "mergeCommit": {
        "oid": "7106bb2ea86c5a72e882244ee900cabdb97c3baa"
      }
    },
    {
      "number": 1082,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgyMDk5MTQ5",
      "title": "[client-hints] Move Variants reference to the Variants draft",
      "url": "https://github.com/httpwg/http-extensions/pull/1082",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "This is moving the Variants-Client Hints interaction section from the Client Hints draft to the Variants one, as [requested](https://lists.w3.org/Archives/Public/ietf-http-wg/2020JanMar/0158.html)",
      "createdAt": "2020-03-01T21:45:31Z",
      "updatedAt": "2020-03-05T22:12:18Z",
      "closedAt": "2020-03-05T22:12:14Z",
      "mergedAt": "2020-03-05T22:12:13Z",
      "mergedBy": "yoavweiss",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot  - friendly ping :)",
          "createdAt": "2020-03-04T22:05:11Z",
          "updatedAt": "2020-03-04T22:05:11Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't think CH needs to be mentioned explicitly in Variants.\r\n\r\nRemoved the reference from Variants, so this is just deleting the Variants ref from the CH draft.",
          "createdAt": "2020-03-05T05:49:02Z",
          "updatedAt": "2020-03-05T05:49:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2ODg5MjUy",
          "commit": {
            "abbreviatedOid": "097b990"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-01T21:46:18Z",
          "updatedAt": "2020-03-01T21:46:18Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The {{CLIENT-HINTS}} reference fails to build for me locally, but I'm not sure why...",
              "createdAt": "2020-03-01T21:46:18Z",
              "updatedAt": "2020-03-05T05:48:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTc5NTQ5",
          "commit": {
            "abbreviatedOid": "097b990"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "I don't think CH needs to be mentioned explicitly in Variants.",
          "createdAt": "2020-03-04T22:44:22Z",
          "updatedAt": "2020-03-04T22:44:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTM0MTY0",
          "commit": {
            "abbreviatedOid": "eb377ed"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-05T21:39:10Z",
          "updatedAt": "2020-03-05T21:39:10Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "0f8062eb3718d7ef4eff41fa5f8e13a38c42281e",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "move_variants_ref",
      "headRefOid": "eb377ed38b9c1fe2ceaf42ddf2f466622734decc",
      "mergeCommit": {
        "oid": "58df45933e4bf5dea4f7b4b834c38bb8d802ca21"
      }
    },
    {
      "number": 1084,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgyOTE2OTUx",
      "title": "Allow \"*\" for sh-dict member and parameter names",
      "url": "https://github.com/httpwg/http-extensions/pull/1084",
      "state": "MERGED",
      "author": "clelland",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "This change to the key syntax allows dictionaries and parameters to use \"*\" as a starting character for names, allowing keys like\r\n\r\n    *\r\n    *value*\r\n    *my*god*its*full*of*stars*\r\n\r\nCloses: #1068",
      "createdAt": "2020-03-03T12:14:33Z",
      "updatedAt": "2020-03-04T07:17:04Z",
      "closedAt": "2020-03-04T07:17:04Z",
      "mergedAt": "2020-03-04T07:17:04Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "LGTM. Do you want to add the change note, or shall I do that after merging?",
          "createdAt": "2020-03-03T22:44:18Z",
          "updatedAt": "2020-03-03T22:44:18Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "BTW - would take a PR with an example key that looks like the last one above :)",
          "createdAt": "2020-03-03T22:44:50Z",
          "updatedAt": "2020-03-03T22:44:50Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "`*8J+Rhg==*=:8J+RjQ==:;*4pi6*`",
          "createdAt": "2020-03-04T07:02:24Z",
          "updatedAt": "2020-03-04T07:02:24Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c913cd4d82b9ee85c5acf0226d66e72f3b096baf",
      "headRepository": "clelland/http-extensions",
      "headRefName": "patch-3",
      "headRefOid": "99bb5ee26ec3698bae2004b90753bac8391f7c30",
      "mergeCommit": {
        "oid": "10e1aaa432d3317f303393cd2f1ae5a3d9a1b742"
      }
    },
    {
      "number": 1086,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgzMTA2ODIx",
      "title": "digest: reflow text and examples to quell warnings",
      "url": "https://github.com/httpwg/http-extensions/pull/1086",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "@ioggstream I was tired of the warnings of line too long, so I've reflowed a lot of the examples and also most of the text while I was at it. The Python code example was tricky, please pay attention to that as I may have mangled it.",
      "createdAt": "2020-03-03T18:28:42Z",
      "updatedAt": "2020-03-04T14:50:02Z",
      "closedAt": "2020-03-04T14:50:00Z",
      "mergedAt": "2020-03-04T14:50:00Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODQwNTAw",
          "commit": {
            "abbreviatedOid": "0e89ddd"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-03-04T14:49:44Z",
          "updatedAt": "2020-03-04T14:49:44Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "998e7ad8e582780c5a380cb79464972a56331a98",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "lucas/digest-80-column-reflow",
      "headRefOid": "0e89ddda6eaa3a3c84562d7bb7350c6477b1f03e",
      "mergeCommit": {
        "oid": "42716db25ac219a1d8e17a347f8f639317ded1c9"
      }
    },
    {
      "number": 1091,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgzMTY5MDIz",
      "title": "digest: editorial reordering",
      "url": "https://github.com/httpwg/http-extensions/pull/1091",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "@ioggstream I've taken an editorial stab at juggling the document a bit in order to improve its presentation and readability. It's still a bit WIP.\r\n\r\nThis is mainly just borrowing text from different places, and eliding some duplication. However, I may have inadvertently made changes or ommissions so PTAL and tell me.\r\n\r\nNote it builds on top of #1086, so you might find it easier to compare the single commit https://github.com/httpwg/http-extensions/commit/43529457c31d4d660027d782ec2fff2b0466e767",
      "createdAt": "2020-03-03T20:50:55Z",
      "updatedAt": "2020-08-05T00:17:06Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "2f0c688218ae2b933c4abd04cc587192ba0f94e3",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "lucas/editorial-reordering",
      "headRefOid": "40499050840fc76b770c39d735bdf24cfcc459c3",
      "closedAt": "2020-03-08T20:16:01Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the feedback. I think the big question here is about the order of presentation of information. Personally, having come back to read the spec back-to-front with fresh eyes, starting with Resource Representation really didn't help to inform me what Digest Header was. I can imagine I am not alone in this and that it might cause kind individuals who review this document to bounce off. \r\n\r\nThe Resource Representation and Digest Algorithm Values sections contain useful content, especially the text in early paragraphs, but the rest of the text boils down to lists of stuff with little normative text. Draft 01 spends 10 pages before it introduces the Digest header - compare that to RFC 3230 which in its entirety is only 10 pages. This is weird given that one premise for adopting the update update is that we can rely on core draft definitions now and things should be simpler.\r\n\r\nLooking at contemporary drafts, they tend to bubble up the \"meat\" of the specification early on. So with the restructure, what I was trying to do is to say \"Here's a way to carry an integrity checksum, calculating that checksum is dependent on a bunch on non-obvious stuff; you should read the background and check out the examples later in the document.\".\r\n\r\nRFC 3230 was written in a different era and we shouldn't follow its structure too much. So while it is logical to present Want-digest first, in practice I'm not convinced that many people care about it\r\n",
          "createdAt": "2020-03-04T18:35:29Z",
          "updatedAt": "2020-03-04T18:35:29Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> starting with Resource Representation really didn't help to inform me what Digest Header was.\r\n> and [reviewers] to bounce off.\r\n> contemporary drafts, [..] bubble up the \"meat\" of the specification early on. \r\n\r\nDo you prefer an approach like this one https://github.com/httpwg/http-extensions/blob/master/draft-ietf-httpbis-cache-header.md\r\n\r\n> The Resource Representation and Digest Algorithm Values sections contain useful content, \r\n> but [..] with little normative text.\r\n\r\nThat's true.\r\n\r\n> Draft 01 spends 10 pages before it introduces the Digest header -\r\n> compare that to RFC 3230 which in its entirety is only 10 pages.\r\n> RFC 3230 was written in a different era and we shouldn't follow its structure too much.\r\n\r\n:D Yes, RFC3230 structure defined Digest at pg. 9 and \r\nI agree we can do better. \r\n\r\n> I was trying to [..] say \"Here's a way to carry an integrity checksum, \r\n> calculating that checksum is dependent on a bunch on non-obvious stuff; \r\n> you should read the background and check out the examples later in the document.\".\r\n\r\nI think we can achieve the goal with multiple PRs moving one part at a time:\r\ndoes it sound reasonable to you?",
          "createdAt": "2020-03-04T19:24:36Z",
          "updatedAt": "2020-03-04T19:25:17Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Definitely sounds reasonable, let me see how to pick this apart a bit",
          "createdAt": "2020-03-04T19:30:08Z",
          "updatedAt": "2020-03-04T19:30:08Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cherry-picking stuff progressively using #1103 and a bunch of patch. ",
          "createdAt": "2020-03-06T00:00:16Z",
          "updatedAt": "2020-03-06T00:00:16Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed with a series of patches described in #1103",
          "createdAt": "2020-03-08T20:16:01Z",
          "updatedAt": "2020-03-08T20:16:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4OTEwMTM3",
          "commit": {
            "abbreviatedOid": "4352945"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Hi @LPardue. I added some comments.\r\nI'd split this in multiple PRs.\r\nWDYT?",
          "createdAt": "2020-03-04T16:06:18Z",
          "updatedAt": "2020-03-04T17:17:12Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I like moving the {#computing} part under `Digest`\r\nbut I'd retain the current order as it introduces one concept at a time.\r\n\r\nThe result would be:\r\n  2. Resource Representation\r\n  3. Digest Algorithm Values\r\n  4. The Digest Header Field\r\n  5. The Want-Digest Header Field\r\n \r\nWDYT?",
              "createdAt": "2020-03-04T16:06:19Z",
              "updatedAt": "2020-03-05T18:36:54Z"
            },
            {
              "originalPosition": 47,
              "body": "I like this section here.",
              "createdAt": "2020-03-04T16:18:55Z",
              "updatedAt": "2020-03-05T18:36:54Z"
            },
            {
              "originalPosition": 166,
              "body": "+1",
              "createdAt": "2020-03-04T16:27:22Z",
              "updatedAt": "2020-03-05T18:36:54Z"
            },
            {
              "originalPosition": 213,
              "body": "+1 for removal",
              "createdAt": "2020-03-04T16:28:12Z",
              "updatedAt": "2020-03-05T18:36:54Z"
            },
            {
              "originalPosition": 199,
              "body": "+1 for merging this",
              "createdAt": "2020-03-04T16:28:56Z",
              "updatedAt": "2020-03-05T18:36:54Z"
            },
            {
              "originalPosition": 55,
              "body": "A shallow reader may understand from this sentence that `digest` computation depends on transfer-coding or range-requests. \r\n\r\nWe should find a way to express in layman's term all the complexities of {#resource-representation}\r\nbut my experience with implementors suggests to address this kind of issues in separate and isolated PRs.",
              "createdAt": "2020-03-04T16:58:35Z",
              "updatedAt": "2020-03-05T18:36:54Z"
            },
            {
              "originalPosition": 62,
              "body": "I suggest to:\r\n\r\n- add L283:L300 to {#resource-representation}\r\n- eventually integrate the description in the examples\r\n\r\nAnd here just say that \r\n\r\n```\r\nRead carefully  {{resource-representation}} before implementing Digest.\r\nThe {{examples-unsolicited}} and {{examples-solicited}} sections show how representation metadata, http method, partial representations and other transformations\r\nalter the payload body and in which cases digest is affected.\r\n```",
              "createdAt": "2020-03-04T17:13:03Z",
              "updatedAt": "2020-03-05T18:36:54Z"
            },
            {
              "originalPosition": 128,
              "body": "Ok for top-level section, but after \u00a75.",
              "createdAt": "2020-03-04T17:15:33Z",
              "updatedAt": "2020-03-05T18:36:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1094,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgzMzMzODQ5",
      "title": "Omitted True dictionary value can have parameters",
      "url": "https://github.com/httpwg/http-extensions/pull/1094",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Fixes #1083.",
      "createdAt": "2020-03-04T04:33:36Z",
      "updatedAt": "2020-03-04T14:08:44Z",
      "closedAt": "2020-03-04T07:16:31Z",
      "mergedAt": "2020-03-04T07:16:30Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Ping @clelland ",
          "createdAt": "2020-03-04T04:33:45Z",
          "updatedAt": "2020-03-04T04:33:45Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM from here, thanks!",
          "createdAt": "2020-03-04T14:08:44Z",
          "updatedAt": "2020-03-04T14:08:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NTM1MTky",
          "commit": {
            "abbreviatedOid": "fa0d3b0"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Tantalizingly close to making Dictionary a superset of List.\r\n\r\nI can't think of anything that would break.",
          "createdAt": "2020-03-04T06:42:32Z",
          "updatedAt": "2020-03-04T06:42:32Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c913cd4d82b9ee85c5acf0226d66e72f3b096baf",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-1083",
      "headRefOid": "fa0d3b0ea2412154747b63736ad041b9177b2b50",
      "mergeCommit": {
        "oid": "5b4988c8a9b8e242e6a37975cc0db51267b10a42"
      }
    },
    {
      "number": 1095,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgzNDg3MTc3",
      "title": "Cherry-pick editorial improvements from #1041",
      "url": "https://github.com/httpwg/http-extensions/pull/1095",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "See also #1041.",
      "createdAt": "2020-03-04T11:12:24Z",
      "updatedAt": "2020-03-04T11:20:40Z",
      "closedAt": "2020-03-04T11:20:40Z",
      "mergedAt": "2020-03-04T11:20:39Z",
      "mergedBy": "LPardue",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4Njk2NDUx",
          "commit": {
            "abbreviatedOid": "3b16a4a"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-03-04T11:19:51Z",
          "updatedAt": "2020-03-04T11:19:51Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "bf9016cef7b74ad0bced27236709e60cecb7997c",
      "headRepository": "kazuho/http-extensions",
      "headRefName": "kazuho/1041",
      "headRefOid": "3b16a4a525544add32b21fb03687e7a99c7ebc7f",
      "mergeCommit": {
        "oid": "7877e1675c358e171537abeef3100efb25cdf3e4"
      }
    },
    {
      "number": 1097,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgzNTUzMDc4",
      "title": "[client-hints] Editorial feedback",
      "url": "https://github.com/httpwg/http-extensions/pull/1097",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Closes #1093 ",
      "createdAt": "2020-03-04T13:24:27Z",
      "updatedAt": "2020-03-10T08:01:21Z",
      "closedAt": "2020-03-05T06:43:17Z",
      "mergedAt": "2020-03-05T06:43:17Z",
      "mergedBy": "yoavweiss",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "LGTM! thx",
          "createdAt": "2020-03-05T05:52:36Z",
          "updatedAt": "2020-03-05T05:52:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTMwNzYz",
          "commit": {
            "abbreviatedOid": "c489da1"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T21:19:57Z",
          "updatedAt": "2020-03-04T21:19:57Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "! makes it a normative ref",
              "createdAt": "2020-03-04T21:19:57Z",
              "updatedAt": "2020-03-05T05:46:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTMwOTgw",
          "commit": {
            "abbreviatedOid": "c489da1"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "LGTM, except for one note",
          "createdAt": "2020-03-04T21:20:18Z",
          "updatedAt": "2020-03-04T21:20:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTU3ODUx",
          "commit": {
            "abbreviatedOid": "c489da1"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T22:04:28Z",
          "updatedAt": "2020-03-04T22:04:29Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Oops. So your comment was to remove the reference altogether? Or can I keep it as informative?",
              "createdAt": "2020-03-04T22:04:28Z",
              "updatedAt": "2020-03-05T05:46:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTU4NTEz",
          "commit": {
            "abbreviatedOid": "c489da1"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T22:05:31Z",
          "updatedAt": "2020-03-04T22:05:32Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Informative is probably OK.",
              "createdAt": "2020-03-04T22:05:31Z",
              "updatedAt": "2020-03-05T05:46:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MzA5MzEx",
          "commit": {
            "abbreviatedOid": "1de9e4b"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T05:50:59Z",
          "updatedAt": "2020-03-05T05:51:00Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Done!",
              "createdAt": "2020-03-05T05:51:00Z",
              "updatedAt": "2020-03-05T05:51:00Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7877e1675c358e171537abeef3100efb25cdf3e4",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "last_call_editorial_feedback",
      "headRefOid": "1de9e4bfeaeafff463b44e4fda61e272a15c30f9",
      "mergeCommit": {
        "oid": "7c7670154b66f91cfc8168a3a9a0cb31465339b3"
      }
    },
    {
      "number": 1098,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgzNTkyMzIy",
      "title": "Standardi{sz}e on US English spelling",
      "url": "https://github.com/httpwg/http-extensions/pull/1098",
      "state": "MERGED",
      "author": "clelland",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Changes:\r\n  behaviour -> behavior (and related words)\r\n  parameterised -> parameterized\r\n  serialise -> serialize (and related words)\r\n  unrecognised -> unrecognized\r\n\r\nCloses: #1085",
      "createdAt": "2020-03-04T14:28:29Z",
      "updatedAt": "2020-03-05T13:11:50Z",
      "closedAt": "2020-03-04T21:53:30Z",
      "mergedAt": "2020-03-04T21:53:30Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2020-03-04T21:53:36Z",
          "updatedAt": "2020-03-04T21:53:36Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Looks alright, with two caveats: 1. Ugh; and 2. I haven't checked myself so I'm assuming you got all of them. But more fixes is more good, so :+1:\r\n\r\n1. Half-agreed -- Canadian English is somewhere in the middle, so I had a hard time getting rid of the \"u\" in \"behaviour\", though I don't mind the zed's. :smile:\r\n\r\n2. I grepped the spec against a list of some 1700 words with spelling differences, and those were all of the ones which were caught. I changed them all, except those in the changelog, in case they had historical significance. (And that'll be dropped in the RFC in any case)",
          "createdAt": "2020-03-05T13:11:50Z",
          "updatedAt": "2020-03-05T13:11:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTUwMTU4",
          "commit": {
            "abbreviatedOid": "cf725f6"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks alright, with two caveats: 1. Ugh; and 2. I haven't checked myself so I'm assuming you got all of them. But more fixes is more good, so :+1:",
          "createdAt": "2020-03-04T21:51:53Z",
          "updatedAt": "2020-03-04T21:51:53Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7877e1675c358e171537abeef3100efb25cdf3e4",
      "headRepository": "clelland/http-extensions",
      "headRefName": "us-english",
      "headRefOid": "cf725f6e44e9c804d699248be33c25f0806133a3",
      "mergeCommit": {
        "oid": "fed38e329da341e0a0b50bd1e1893a3e594774fe"
      }
    },
    {
      "number": 1100,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgzNjMxNjUx",
      "title": "fix some editorial hangovers",
      "url": "https://github.com/httpwg/http-extensions/pull/1100",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "A few editorial tweaks to improve readability, including some x-refs to the Header / frames.\r\n\r\nThe most contentious change is at L262, the sentence read a bit weird so I juggled it around to make the intent (as I understand it) clearer.",
      "createdAt": "2020-03-04T15:17:54Z",
      "updatedAt": "2020-03-05T00:03:05Z",
      "closedAt": "2020-03-05T00:03:04Z",
      "mergedAt": "2020-03-05T00:03:04Z",
      "mergedBy": "kazuho",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MjEyNzA2",
          "commit": {
            "abbreviatedOid": "93687c8"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for the changes.\r\n\r\nL262 reads better now. Thank you.",
          "createdAt": "2020-03-05T00:02:57Z",
          "updatedAt": "2020-03-05T00:02:57Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "42716db25ac219a1d8e17a347f8f639317ded1c9",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "lucas/priority-editorial-bis",
      "headRefOid": "93687c8817da34715490e4632034bfdaa8ffbb46",
      "mergeCommit": {
        "oid": "4da5288ef2438b2546d5a805ca9f0a5380ae54ca"
      }
    },
    {
      "number": 1101,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgzNjM0Mjky",
      "title": "changelog for priority-00",
      "url": "https://github.com/httpwg/http-extensions/pull/1101",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "We made some design changes and closed issues, lets now capture that in the changelog.",
      "createdAt": "2020-03-04T15:21:10Z",
      "updatedAt": "2020-03-05T16:55:12Z",
      "closedAt": "2020-03-05T16:55:11Z",
      "mergedAt": "2020-03-05T16:55:10Z",
      "mergedBy": "LPardue",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MjEzMzk5",
          "commit": {
            "abbreviatedOid": "ff0793a"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thank you LGTM modulo the point below.",
          "createdAt": "2020-03-05T00:04:49Z",
          "updatedAt": "2020-03-05T00:05:10Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Maybe change \"remove\" to \"reduce\" or \"miminize\"? Levels 1 and 7 have meanings.",
              "createdAt": "2020-03-05T00:04:49Z",
              "updatedAt": "2020-03-05T16:51:35Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "42716db25ac219a1d8e17a347f8f639317ded1c9",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "lucas/priority-00-changelog",
      "headRefOid": "15186b3c44fb8a127f50025dbb65942ef56dada2",
      "mergeCommit": {
        "oid": "2f0c688218ae2b933c4abd04cc587192ba0f94e3"
      }
    },
    {
      "number": 1104,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0MDgwMDU1",
      "title": "sh: fix overlong ABNF lines",
      "url": "https://github.com/httpwg/http-extensions/pull/1104",
      "state": "CLOSED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-05T05:47:30Z",
      "updatedAt": "2020-03-05T16:11:52Z",
      "closedAt": "2020-03-05T05:47:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NjAxNzY5",
          "commit": {
            "abbreviatedOid": "4260e82"
          },
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T14:15:45Z",
          "updatedAt": "2020-03-05T14:15:45Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "This looks like some non-ASCII slipped in. I'll send a PR to fix that.",
              "createdAt": "2020-03-05T14:15:45Z",
              "updatedAt": "2020-03-05T14:15:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5Njk5NDg5",
          "commit": {
            "abbreviatedOid": "4260e82"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T16:03:56Z",
          "updatedAt": "2020-03-05T16:03:56Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "My bad. @mnot was too quick in merging :-). See also https://github.com/httpwg/http-extensions/pull/1105/.",
              "createdAt": "2020-03-05T16:03:56Z",
              "updatedAt": "2020-03-05T16:03:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NzA2NDAz",
          "commit": {
            "abbreviatedOid": "4260e82"
          },
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T16:11:51Z",
          "updatedAt": "2020-03-05T16:11:52Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Fixed with #1108",
              "createdAt": "2020-03-05T16:11:52Z",
              "updatedAt": "2020-03-05T16:11:52Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "eda473c0388b58f0af5a6b5163e293706455ece7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "sh-abnf-long-lines",
      "headRefOid": "4260e82a835b419a977c1325724b93525ee45dde",
      "mergeCommit": null
    },
    {
      "number": 1105,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0MDgwMzk3",
      "title": "sh: fix long ABNF lines",
      "url": "https://github.com/httpwg/http-extensions/pull/1105",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-05T05:48:45Z",
      "updatedAt": "2020-03-05T05:49:53Z",
      "closedAt": "2020-03-05T05:49:48Z",
      "mergedAt": "2020-03-05T05:49:47Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks",
          "createdAt": "2020-03-05T05:49:53Z",
          "updatedAt": "2020-03-05T05:49:53Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "eda473c0388b58f0af5a6b5163e293706455ece7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "sh-abnf-long-lines",
      "headRefOid": "6813832b6967dd93f5f4a57745c80ec9cdfc3b06",
      "mergeCommit": {
        "oid": "75ade9f0b26a5dabcfdb943906fdee8c86e9d9ee"
      }
    },
    {
      "number": 1106,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0MDgyMjQ2",
      "title": "6265bis: fix reference to IANA procedures",
      "url": "https://github.com/httpwg/http-extensions/pull/1106",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-05T05:55:19Z",
      "updatedAt": "2020-03-05T06:22:07Z",
      "closedAt": "2020-03-05T06:22:06Z",
      "mergedAt": "2020-03-05T06:22:06Z",
      "mergedBy": "mikewest",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MzE5MjQw",
          "commit": {
            "abbreviatedOid": "326a179"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2020-03-05T06:22:00Z",
          "updatedAt": "2020-03-05T06:22:00Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "75ade9f0b26a5dabcfdb943906fdee8c86e9d9ee",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "6265bis-iana-procs",
      "headRefOid": "326a1792f5345192069c1f6b75aadcbf8a66a3be",
      "mergeCommit": {
        "oid": "0511c569573e7346ab061e7f8d9f4316196296b8"
      }
    },
    {
      "number": 1107,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0MDg0NjQ1",
      "title": "6256bis: remove unused reference",
      "url": "https://github.com/httpwg/http-extensions/pull/1107",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-05T06:04:02Z",
      "updatedAt": "2020-03-05T06:21:40Z",
      "closedAt": "2020-03-05T06:21:34Z",
      "mergedAt": "2020-03-05T06:21:34Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2020-03-05T06:21:40Z",
          "updatedAt": "2020-03-05T06:21:40Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "75ade9f0b26a5dabcfdb943906fdee8c86e9d9ee",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "6265bis-unused-ref",
      "headRefOid": "ed75995cf3c6305b6a1d986dde20e04aeeab6cc6",
      "mergeCommit": {
        "oid": "0f8eb7bc6040b34ebbc44eea26ab7baec72756c5"
      }
    },
    {
      "number": 1108,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0MzY2NzEx",
      "title": "sh: Remove non-ASCII chars",
      "url": "https://github.com/httpwg/http-extensions/pull/1108",
      "state": "MERGED",
      "author": "clelland",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-05T16:10:38Z",
      "updatedAt": "2020-03-05T21:38:24Z",
      "closedAt": "2020-03-05T21:38:24Z",
      "mergedAt": "2020-03-05T21:38:24Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This just fixes a couple of non-ASCII U+2212 MINUS-SIGN characters that crept in with #1104.",
          "createdAt": "2020-03-05T16:13:33Z",
          "updatedAt": "2020-03-05T16:13:33Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Actually, they've been there before. What #1104 broke was the encoding.",
          "createdAt": "2020-03-05T16:19:57Z",
          "updatedAt": "2020-03-05T16:19:57Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ahh -- I thought that was GitHub just exposing the UTF8-ness in the diff when I looked at it.\r\n\r\nI'll leave it to editors to decide whether non-ASCII is appropriate in the markdown version of the spec; I'm sure that the IETF has a process for dealing with it when it needs to be a text RFC.",
          "createdAt": "2020-03-05T16:41:27Z",
          "updatedAt": "2020-03-05T16:41:27Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No, this really should be an ASCII minus.",
          "createdAt": "2020-03-05T16:47:41Z",
          "updatedAt": "2020-03-05T16:47:41Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://mailarchive.ietf.org/arch/msg/rfc-interest/hWOHbgqeEj0vRRoj-qsFcI10_jQ/",
          "createdAt": "2020-03-05T16:48:02Z",
          "updatedAt": "2020-03-05T16:48:02Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "60c7316bc8c3f5089ee06eeb7b6963c84de1dd3c",
      "headRepository": "clelland/http-extensions",
      "headRefName": "fix-non-ascii",
      "headRefOid": "3a087575bf6529873055f93a212e5cd29d2a4622",
      "mergeCommit": {
        "oid": "3de42525374179d0e4cf31cce1526037a7eb4d10"
      }
    },
    {
      "number": 1109,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0NTA1NzMx",
      "title": "Refactor deprecated algorithms. See #1103.",
      "url": "https://github.com/httpwg/http-extensions/pull/1109",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers",
        "editorial"
      ],
      "body": "## This PR\r\n\r\nMoves deprecated algorithms in the iana table.",
      "createdAt": "2020-03-05T21:19:21Z",
      "updatedAt": "2020-03-05T23:28:32Z",
      "closedAt": "2020-03-05T23:28:30Z",
      "mergedAt": "2020-03-05T23:28:30Z",
      "mergedBy": "ioggstream",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue I'm merging as all typos are fixed.",
          "createdAt": "2020-03-05T23:28:32Z",
          "updatedAt": "2020-03-05T23:28:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTI3Mjg4",
          "commit": {
            "abbreviatedOid": "aa7d268"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T21:28:08Z",
          "updatedAt": "2020-03-05T21:34:45Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "seem to have lost digest-algorithm value and the sentence is broken.",
              "createdAt": "2020-03-05T21:28:08Z",
              "updatedAt": "2020-03-05T23:16:56Z"
            },
            {
              "originalPosition": 22,
              "body": "The trailing whitespace is actually needed after all of these colons in order to make the list line up all nicely (I discovered this yesterday). I think that requiring trailing whitespace is a smell that something is broken but I don't know how to fix the root cause.",
              "createdAt": "2020-03-05T21:29:37Z",
              "updatedAt": "2020-03-05T23:16:56Z"
            },
            {
              "originalPosition": 10,
              "body": "how about this?\r\n```suggestion\r\nSome algorithms, although registered, have since been found vulnerable:\r\nthe MD5 algorithm MUST NOT be used due to collision attacks\r\n[CMU-836068] and the SHA algorithm is NOT RECOMMENDED due to\r\ncollision attacks [IACR-2019-459].\r\n```",
              "createdAt": "2020-03-05T21:32:19Z",
              "updatedAt": "2020-03-05T23:16:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTgwMjY5",
          "commit": {
            "abbreviatedOid": "aa7d268"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T23:14:38Z",
          "updatedAt": "2020-03-05T23:14:38Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Yep. The editor removes them every time and I've to `vim` to avoid that.",
              "createdAt": "2020-03-05T23:14:38Z",
              "updatedAt": "2020-03-05T23:16:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTgwNzgz",
          "commit": {
            "abbreviatedOid": "1365ee3"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T23:15:58Z",
          "updatedAt": "2020-03-05T23:15:58Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Updated the PR with this text, thanks!",
              "createdAt": "2020-03-05T23:15:58Z",
              "updatedAt": "2020-03-05T23:16:56Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "58df45933e4bf5dea4f7b4b834c38bb8d802ca21",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1103-move-deprecated-algorithms",
      "headRefOid": "9b503ef82de01939c26707f590f016a3cdee1ff8",
      "mergeCommit": {
        "oid": "503477b5a3102595aaa0c4d5d3eec5d99c43c5fd"
      }
    },
    {
      "number": 1110,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0NTEwMzc1",
      "title": "Merge encoding examples. See #1103.",
      "url": "https://github.com/httpwg/http-extensions/pull/1110",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers",
        "editorial"
      ],
      "body": "## This PR\r\n\r\nMerges encoding examples.\r\n\r\nSee #1103 ",
      "createdAt": "2020-03-05T21:30:19Z",
      "updatedAt": "2020-03-06T11:31:52Z",
      "closedAt": "2020-03-06T11:31:51Z",
      "mergedAt": "2020-03-06T11:31:50Z",
      "mergedBy": "ioggstream",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Prerequisite for https://github.com/httpwg/http-extensions/pull/1091/files#diff-6bbabd8fc4618ce0a89bda8cc52a4054R262",
          "createdAt": "2020-03-06T11:13:03Z",
          "updatedAt": "2020-03-06T11:13:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjUyNTEw",
          "commit": {
            "abbreviatedOid": "6d96956"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-06T11:20:39Z",
          "updatedAt": "2020-03-06T11:20:39Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "39001c63c63f4eed22dc45b8588b3e5786f2de27",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1103-merge-encoding-examples",
      "headRefOid": "a16c9cdb88f4da6240d98b31e0df793ebd260fee",
      "mergeCommit": {
        "oid": "4ade940487c4663e8ac7961c5bf9aa51d6bc9d99"
      }
    },
    {
      "number": 1111,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0NTEyMzA4",
      "title": "Promote header field. See #1103.",
      "url": "https://github.com/httpwg/http-extensions/pull/1111",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers",
        "editorial"
      ],
      "body": "## This PR\r\n\r\nMoves header definitions on top level",
      "createdAt": "2020-03-05T21:35:04Z",
      "updatedAt": "2020-03-05T21:43:51Z",
      "closedAt": "2020-03-05T21:43:50Z",
      "mergedAt": "2020-03-05T21:43:50Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTM1NDYx",
          "commit": {
            "abbreviatedOid": "a755840"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-05T21:41:28Z",
          "updatedAt": "2020-03-05T21:41:28Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "2f0c688218ae2b933c4abd04cc587192ba0f94e3",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1103-promote-header-spec",
      "headRefOid": "a7558407700551740cc3ef04f65c116b4d3f8999",
      "mergeCommit": {
        "oid": "f9ee3b0c7bd9ad64c198f3a1f66c1371b23cce5b"
      }
    },
    {
      "number": 1112,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0NTE0Mzk3",
      "title": "Move algos down. See #1103.",
      "url": "https://github.com/httpwg/http-extensions/pull/1112",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers",
        "editorial"
      ],
      "body": "## This PR\r\n\r\nMoves Digest Algorithms down",
      "createdAt": "2020-03-05T21:40:19Z",
      "updatedAt": "2020-03-05T23:40:07Z",
      "closedAt": "2020-03-05T23:40:06Z",
      "mergedAt": "2020-03-05T23:40:06Z",
      "mergedBy": "ioggstream",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I verified the formatting here https://httpwg.org/http-extensions/ioggstream-1103-move-digest-algorithms-down/draft-ietf-httpbis-digest-headers.html#algorithms",
          "createdAt": "2020-03-05T23:39:55Z",
          "updatedAt": "2020-03-05T23:39:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTM2NjAx",
          "commit": {
            "abbreviatedOid": "f1c7dd0"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This looks good but note the similar comment I made elsewhere about the trailing spaces after colons\r\n\r\ne.g. we need\r\n\r\n`:  ` \r\n\r\nor else the formatting seems to get screwed up",
          "createdAt": "2020-03-05T21:43:22Z",
          "updatedAt": "2020-03-05T21:43:22Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "503477b5a3102595aaa0c4d5d3eec5d99c43c5fd",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1103-move-digest-algorithms-down",
      "headRefOid": "3e1bcfba8ff04c70e679b7039e045ac47e6f0590",
      "mergeCommit": {
        "oid": "aace468df2619cb5a1a4ae4edaa857846a7ed191"
      }
    },
    {
      "number": 1113,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0NTYzMTY2",
      "title": "Add headings for examples",
      "url": "https://github.com/httpwg/http-extensions/pull/1113",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers",
        "editorial"
      ],
      "body": "## This PR\r\n\r\njust add headings to sections",
      "createdAt": "2020-03-06T00:10:13Z",
      "updatedAt": "2020-03-06T10:24:52Z",
      "closedAt": "2020-03-06T00:11:39Z",
      "mergedAt": "2020-03-06T00:11:39Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "aace468df2619cb5a1a4ae4edaa857846a7ed191",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1103-add-headings",
      "headRefOid": "feb4cac57348ea41b9119ebc965cff3ce596c49b",
      "mergeCommit": {
        "oid": "99e16009b281402a2d7e0f5fd122499c8720b41f"
      }
    },
    {
      "number": 1114,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0NTY4Mzky",
      "title": "Integrate an example without content coding.",
      "url": "https://github.com/httpwg/http-extensions/pull/1114",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nadds an example without content coding",
      "createdAt": "2020-03-06T00:26:06Z",
      "updatedAt": "2020-04-15T14:23:35Z",
      "closedAt": "2020-04-15T14:23:12Z",
      "mergedAt": "2020-04-15T14:23:12Z",
      "mergedBy": "LPardue",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do we still need it?",
          "createdAt": "2020-03-17T09:22:41Z",
          "updatedAt": "2020-03-17T09:22:41Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The change affects a section that was moved toward the end of the document. So rebasing will address my earlier comment. I see the utility in the example but I'll leave it up to you if you want to merge or not.",
          "createdAt": "2020-03-17T14:05:16Z",
          "updatedAt": "2020-03-17T14:05:16Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue we moved this part below, so merge is straightforward. Feel free to press the button :)",
          "createdAt": "2020-04-15T14:14:45Z",
          "updatedAt": "2020-04-15T14:14:45Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cheers!\r\n",
          "createdAt": "2020-04-15T14:23:35Z",
          "updatedAt": "2020-04-15T14:23:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjMxMjMy",
          "commit": {
            "abbreviatedOid": "ddfb589"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "On the one hand, this proposed change does improve the readability of the sequence but on the other hand, I'm a little reluctant to add yet more text to an already long section.\r\n\r\nI'm willing to accept this on condition that we might move or majorly rewrite this section during a later editorial activity. How does that sound?",
          "createdAt": "2020-03-06T10:42:39Z",
          "updatedAt": "2020-03-06T10:47:53Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nA request with a json object without any content coding\r\n```",
              "createdAt": "2020-03-06T10:42:39Z",
              "updatedAt": "2020-04-15T14:12:56Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4467941efe15f87e3c995e3e22ad8b9901c34f28",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1103-integrate-examples",
      "headRefOid": "9149eb6c8c9c4e59021c83949d387b86e3bf6d9a",
      "mergeCommit": {
        "oid": "4178324c374fd1e75acda09df6d7b2afb232de07"
      }
    },
    {
      "number": 1115,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0NjQ4ODQ2",
      "title": "priority: fix external section reference format",
      "url": "https://github.com/httpwg/http-extensions/pull/1115",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "...according to RFC Style Guide.",
      "createdAt": "2020-03-06T06:00:22Z",
      "updatedAt": "2020-03-06T06:09:15Z",
      "closedAt": "2020-03-06T06:09:08Z",
      "mergedAt": "2020-03-06T06:09:08Z",
      "mergedBy": "kazuho",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you!",
          "createdAt": "2020-03-06T06:09:15Z",
          "updatedAt": "2020-03-06T06:09:15Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "bb8e76f278b01c319dc05a7116316a21922c4483",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "prio-7540-ref",
      "headRefOid": "a2b7a4366aa54476d7ba7a3549e776e87dc1cae2",
      "mergeCommit": {
        "oid": "e0a1d2aa989e111094324a101ae07dcbc5f86190"
      }
    },
    {
      "number": 1116,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0NzY5NDI0",
      "title": "Shift Want-Digest down. See #1103.",
      "url": "https://github.com/httpwg/http-extensions/pull/1116",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers",
        "editorial"
      ],
      "body": "## This PR\r\n\r\nMoves Want-Digest after Digest.\ufeff\r\n",
      "createdAt": "2020-03-06T11:21:47Z",
      "updatedAt": "2020-03-06T11:25:49Z",
      "closedAt": "2020-03-06T11:25:48Z",
      "mergedAt": "2020-03-06T11:25:48Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjU0ODQy",
          "commit": {
            "abbreviatedOid": "4beb25e"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-06T11:25:16Z",
          "updatedAt": "2020-03-06T11:25:16Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e0a1d2aa989e111094324a101ae07dcbc5f86190",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1103-reorder",
      "headRefOid": "4beb25eca4e1c76052fc4396fe89a66644b069e3",
      "mergeCommit": {
        "oid": "39001c63c63f4eed22dc45b8588b3e5786f2de27"
      }
    },
    {
      "number": 1117,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0Nzg0NTMw",
      "title": "Move digest computation under Digest. See #1103",
      "url": "https://github.com/httpwg/http-extensions/pull/1117",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\n\nmoves the computation part under Digest\ufeff\n",
      "createdAt": "2020-03-06T11:59:43Z",
      "updatedAt": "2020-03-06T13:00:38Z",
      "closedAt": "2020-03-06T13:00:37Z",
      "mergedAt": "2020-03-06T13:00:37Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjkxNzcw",
          "commit": {
            "abbreviatedOid": "372c18a"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T12:39:17Z",
          "updatedAt": "2020-03-06T12:39:18Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "I think there is an opportunity to merge this art with the art for the definition of Digest Header. That way it becomes clear exactly what composes the Digest header, rather than needing to flick back and forth.",
              "createdAt": "2020-03-06T12:39:17Z",
              "updatedAt": "2020-03-06T12:39:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjk5NzY4",
          "commit": {
            "abbreviatedOid": "372c18a"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T12:53:55Z",
          "updatedAt": "2020-03-06T12:53:55Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Yes, that's in another PR :D",
              "createdAt": "2020-03-06T12:53:55Z",
              "updatedAt": "2020-03-06T12:53:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMzAxNTQ5",
          "commit": {
            "abbreviatedOid": "372c18a"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-06T12:57:07Z",
          "updatedAt": "2020-03-06T12:57:07Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4ade940487c4663e8ac7961c5bf9aa51d6bc9d99",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1103-move-computation",
      "headRefOid": "372c18a2973dfeac644435e3a18e6073d8be2044",
      "mergeCommit": {
        "oid": "6a9487b9772a10f38a515aed99ed4915aafcd030"
      }
    },
    {
      "number": 1118,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0ODIyMzY0",
      "title": "WIP: editorial juggling in Digest. See #1103",
      "url": "https://github.com/httpwg/http-extensions/pull/1118",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nContains a main editorial rewording and reodering under the Digest section.",
      "createdAt": "2020-03-06T13:31:24Z",
      "updatedAt": "2020-08-05T00:17:08Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6a9487b9772a10f38a515aed99ed4915aafcd030",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1103-refactor-header",
      "headRefOid": "07f7ddc67c92309818a6a18b61473e3dd498151d",
      "closedAt": "2020-03-06T18:10:01Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1120,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0ODM0NDMy",
      "title": "rfc6265bis: markup example artwork",
      "url": "https://github.com/httpwg/http-extensions/pull/1120",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-06T13:57:05Z",
      "updatedAt": "2020-03-06T14:51:19Z",
      "closedAt": "2020-03-06T14:51:18Z",
      "mergedAt": "2020-03-06T14:51:18Z",
      "mergedBy": "mikewest",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMzc3ODgz",
          "commit": {
            "abbreviatedOid": "00b202e"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-03-06T14:51:12Z",
          "updatedAt": "2020-03-06T14:51:12Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6a9487b9772a10f38a515aed99ed4915aafcd030",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "rfc6265bis-examples",
      "headRefOid": "00b202e43ccab39e5d59e7a1e778d1dd9613fb18",
      "mergeCommit": {
        "oid": "47a4a965efe1bae6eaf4331553cf2db7b960aa42"
      }
    },
    {
      "number": 1121,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0OTA0ODgw",
      "title": "Showcase #1103",
      "url": "https://github.com/httpwg/http-extensions/pull/1121",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\njust shows an hypothesis",
      "createdAt": "2020-03-06T16:16:16Z",
      "updatedAt": "2020-08-05T00:17:09Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "47a4a965efe1bae6eaf4331553cf2db7b960aa42",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1103-test",
      "headRefOid": "22f7d01320c13fb9391c6c310bc474da14ed9922",
      "closedAt": "2020-03-06T18:10:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1122,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0OTUxOTc5",
      "title": "Put representation-data examples in Annex B. See #1103.",
      "url": "https://github.com/httpwg/http-extensions/pull/1122",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nPostpone the representation-data in Annex B.\r\nThis is because this section explains the http semantics but does not contain normative information.\r\n\r\nNB: I retained the initial statement, which we will refactor lately.",
      "createdAt": "2020-03-06T18:03:42Z",
      "updatedAt": "2020-03-07T00:19:32Z",
      "closedAt": "2020-03-07T00:19:31Z",
      "mergedAt": "2020-03-07T00:19:31Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNTc2MTg3",
          "commit": {
            "abbreviatedOid": "ac8a496"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-06T19:36:17Z",
          "updatedAt": "2020-03-06T19:36:17Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "47a4a965efe1bae6eaf4331553cf2db7b960aa42",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1103-postpone-resource-representation",
      "headRefOid": "ac8a4962cfa67ccf39e4f9da44e3d5b2c20e8aba",
      "mergeCommit": {
        "oid": "0dfe6e94cfe6406eec70bad4bb5b67fab8b03825"
      }
    },
    {
      "number": 1123,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0OTY4OTI5",
      "title": "Introduce resource digest #1103",
      "url": "https://github.com/httpwg/http-extensions/pull/1123",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nIntroduces properly Representation Digest, which is the core concept of the spec.\r\n\r\nThe original draft name was in fact `Representation Digest`.\r\n\r\nSee #1103",
      "createdAt": "2020-03-06T18:50:30Z",
      "updatedAt": "2020-03-07T21:38:46Z",
      "closedAt": "2020-03-07T21:38:45Z",
      "mergedAt": "2020-03-07T21:38:45Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNTk5NTIz",
          "commit": {
            "abbreviatedOid": "390beb6"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T20:15:38Z",
          "updatedAt": "2020-03-06T20:15:39Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "This still reads a bit disjointed to me, so how about something like the below, although it maybe has some errors\r\n\r\n\" The representation digest is an integrity mechanism for HTTP resources which uses a checksum that is calculated independently of the payload body and message body. It is calculated using the representation data (see [RFC7231]), can be fully or partially contained in the message body, or not contained at all:\r\n\r\n~~~\r\n   representation-data := Content-Encoding( Content-Type( bits ) )\r\n~~~\r\n\r\nIt is prudent to consider the effect HTTP semantics in relation to resources. For example, the message body can be affected by range-requests or different methods such as HEAD, while the payload body is dependent on Transfer encoding or other transformations. {{resource-representation}} contains several examples to help illustrate the effects.\"",
              "createdAt": "2020-03-06T20:15:39Z",
              "updatedAt": "2020-03-07T16:49:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNjk3Mjgy",
          "commit": {
            "abbreviatedOid": "390beb6"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-07T00:15:44Z",
          "updatedAt": "2020-03-07T00:15:45Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Sounds good, I updated the PR! Thanks being so patient with a non-native speaker!",
              "createdAt": "2020-03-07T00:15:44Z",
              "updatedAt": "2020-03-07T16:49:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzM4Mzk3",
          "commit": {
            "abbreviatedOid": "ed84dd0"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-07T11:09:50Z",
          "updatedAt": "2020-03-07T11:09:50Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nThis takes into account the effect of the HTTP semantics on the messages;\r\n```\r\n@LPardue We are not giving implementors the freedom to be imprudent. Please commit suggestion if you agree.",
              "createdAt": "2020-03-07T11:09:50Z",
              "updatedAt": "2020-03-07T16:49:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzcwNTI3",
          "commit": {
            "abbreviatedOid": "4c4f816"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-03-07T16:49:55Z",
          "updatedAt": "2020-03-07T16:49:55Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "0dfe6e94cfe6406eec70bad4bb5b67fab8b03825",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1103-introduce-resource-digest",
      "headRefOid": "4c4f8162a78802ea466f4921a839065a29a073c1",
      "mergeCommit": {
        "oid": "25d5bdd48a1f750b035555727b5e07dbd995e866"
      }
    },
    {
      "number": 1124,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0OTc2MTQx",
      "title": "Fixes: #1103. Complete editorial reordering of Digest",
      "url": "https://github.com/httpwg/http-extensions/pull/1124",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nReorder Digest section. Cumulative PR of:\r\n\r\n- #1122 \r\n- #1123 \r\n\r\n@LPardue this patch ends the reordering [preview](https://httpwg.org/http-extensions/ioggstream-1103-cleanup-digest/draft-ietf-httpbis-digest-headers.html) \r\n\r\nand achieves:\r\n\r\n- Digest header defined at \u00a73 (pag. 7)\r\n- Non-normative section moved in Annex\r\n\r\n\r\n## Note\r\n\r\nFixes #1103. Replaces #1091 ",
      "createdAt": "2020-03-06T19:08:58Z",
      "updatedAt": "2020-03-08T19:55:14Z",
      "closedAt": "2020-03-08T19:55:13Z",
      "mergedAt": "2020-03-08T19:55:12Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzc2NDE3",
          "commit": {
            "abbreviatedOid": "2582b3e"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-07T16:52:54Z",
          "updatedAt": "2020-03-07T16:54:29Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Moves the fragment sentence from below into this paragrah\r\n```suggestion\r\nas defined in {{representation-digest}}. It can be used in both request and response.\r\n```",
              "createdAt": "2020-03-07T16:52:54Z",
              "updatedAt": "2020-03-08T15:59:44Z"
            },
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n```\r\n",
              "createdAt": "2020-03-07T16:53:24Z",
              "updatedAt": "2020-03-08T15:59:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwODQ5MDk5",
          "commit": {
            "abbreviatedOid": "50440c7"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-08T18:28:17Z",
          "updatedAt": "2020-03-08T18:28:17Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "25d5bdd48a1f750b035555727b5e07dbd995e866",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1103-cleanup-digest",
      "headRefOid": "50440c7bf55f9371f8cf29828a2808f0d5539ae1",
      "mergeCommit": {
        "oid": "26bbdd49a63b7a6473c857eea1ba6630e19cf572"
      }
    },
    {
      "number": 1125,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1MTM3MjQ1",
      "title": "Avoid errors on EOL trimming.",
      "url": "https://github.com/httpwg/http-extensions/pull/1125",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers",
        "editorial"
      ],
      "body": "## This PR\r\n\r\nFixes formatting issue in digest-algorithms [preview](https://httpwg.org/http-extensions/ioggstream-editorial-2/draft-ietf-httpbis-digest-headers.html)\r\n\r\n## It is done\r\n\r\nusing vspace from here https://github.com/cabo/kramdown-rfc2629#experimental-features\r\neg.\r\n\r\n\r\n```\r\n{: vspace=\"0\"}\r\nterm\r\n:  * bullet\r\n   * list\r\n```\r\n\r\n```",
      "createdAt": "2020-03-07T11:52:40Z",
      "updatedAt": "2020-03-08T20:13:01Z",
      "closedAt": "2020-03-08T20:13:00Z",
      "mergedAt": "2020-03-08T20:13:00Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwODQ5MTk2",
          "commit": {
            "abbreviatedOid": "5adf609"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-08T18:30:04Z",
          "updatedAt": "2020-03-08T18:30:04Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "0dfe6e94cfe6406eec70bad4bb5b67fab8b03825",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-editorial-2",
      "headRefOid": "5adf609b644441a6a393de4c76a76220b9327d38",
      "mergeCommit": {
        "oid": "6b7c99b85e26fc7a7e805fc7f93a4109eb9fcf6e"
      }
    },
    {
      "number": 1126,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1NTI3MzM5",
      "title": "Add changelog to digest-headers.",
      "url": "https://github.com/httpwg/http-extensions/pull/1126",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers",
        "editorial"
      ],
      "body": "## This PR\r\n\r\nAdds changelog to Digest Headers.\r\n\r\nRelated to: #1103 \r\n\r\n",
      "createdAt": "2020-03-09T11:23:52Z",
      "updatedAt": "2020-03-09T13:12:02Z",
      "closedAt": "2020-03-09T13:12:01Z",
      "mergedAt": "2020-03-09T13:12:01Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMTAwNDIw",
          "commit": {
            "abbreviatedOid": "f77b327"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-03-09T11:50:47Z",
          "updatedAt": "2020-03-09T11:50:47Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6b7c99b85e26fc7a7e805fc7f93a4109eb9fcf6e",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1103-add-changelog",
      "headRefOid": "f77b327de229c13bddc446a79344eb023608f894",
      "mergeCommit": {
        "oid": "258c513c499d23e1d31fa634a50e35d51dad2c03"
      }
    },
    {
      "number": 1127,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1NjAwMjIz",
      "title": "Digest Headers: fix typos",
      "url": "https://github.com/httpwg/http-extensions/pull/1127",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nFixes various typos along the document.",
      "createdAt": "2020-03-09T13:50:33Z",
      "updatedAt": "2020-03-09T15:12:55Z",
      "closedAt": "2020-03-09T15:12:53Z",
      "mergedAt": "2020-03-09T15:12:53Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMjIyODg1",
          "commit": {
            "abbreviatedOid": "da7dea8"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-09T14:20:26Z",
          "updatedAt": "2020-03-09T14:20:26Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "258c513c499d23e1d31fa634a50e35d51dad2c03",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-typos",
      "headRefOid": "da7dea80c7165e5dd5a11a775ef673e69a33216c",
      "mergeCommit": {
        "oid": "ec9ec0c5597f59b6fe804e5acb3ab2f082dcb701"
      }
    },
    {
      "number": 1128,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1OTAwNDc5",
      "title": "Some suggestions for forward compatibility",
      "url": "https://github.com/httpwg/http-extensions/pull/1128",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "header-structure"
      ],
      "body": "Some of this is rewording.\r\n\r\nThere are two new paragraphs talking about extensions: one deals with dictionaries, the other deals\r\nwith extensions to a SH definition.\r\n\r\nI also removed the \"starts with 'h'\" example for greasing.  We know that X- lead to all sorts of\r\nmess, so choosing a bad example here could be just as bad.  I'm happy to split that out or be talked\r\ninto backing it out, of course.",
      "createdAt": "2020-03-10T02:11:58Z",
      "updatedAt": "2020-03-11T05:29:30Z",
      "closedAt": "2020-03-11T05:29:29Z",
      "mergedAt": "2020-03-11T05:29:29Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNDYzNjMy",
          "commit": {
            "abbreviatedOid": "96e320f"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-03-11T04:03:08Z",
          "updatedAt": "2020-03-11T04:05:39Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I agree with the sentiment, but I think this better expresses it:\r\n\r\nSpecifications that use Dictionaries can also allow for forward compatibility by requiring that the presence of -- as well as value and type associated with -- unknown members be ignored. Later specifications can then add additional members, specifying constraints on them as appropriate.\r\n\r\n```suggestion\r\nSpecifications that use Dictionaries can also allow for forward compatibility by requiring that the presence of -- as well as value and type associated with -- unknown members be ignored. Later specifications can then add additional members, specifying constraints on them as appropriate.\r\n```",
              "createdAt": "2020-03-11T04:03:08Z",
              "updatedAt": "2020-03-11T05:26:06Z"
            },
            {
              "originalPosition": 11,
              "body": "s/set/defined/, perhaps?\r\n\r\n```suggestion\r\nTo further assure that this extensibility is available in the future, and to encourage consumers to use a complete parser implementation, a field definition can specify that \"grease\" Parameters be added by senders. A specification could stipulate that all Parameters that fit a defined pattern are reserved for this use and then encourage them to be sent on some portion of requests. This helps to discourage recipients from writing a parser that does not account for Parameters.\r\n```",
              "createdAt": "2020-03-11T04:03:27Z",
              "updatedAt": "2020-03-11T05:26:06Z"
            },
            {
              "originalPosition": 16,
              "body": "Just to align with language elsewhere:\r\n\r\nAn extension to a structured field can then require that an entire field value be ignored by a recipient that understands the extension if constraints on the value it defines are not met.\r\n\r\n```suggestion\r\nAn extension to a structured field can then require that an entire field value be ignored by a recipient that understands the extension if constraints on the value it defines are not met.\r\n```",
              "createdAt": "2020-03-11T04:05:30Z",
              "updatedAt": "2020-03-11T05:26:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNDgxNzE0",
          "commit": {
            "abbreviatedOid": "96e320f"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-11T05:21:08Z",
          "updatedAt": "2020-03-11T05:21:08Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nSpecifications that use Dictionaries can also allow for forward compatibility by requiring that the presence of -- as well as value and type associated with -- unknown members be ignored. Later specifications can then add additional members, specifying constraints on them as appropriate.\r\n```",
              "createdAt": "2020-03-11T05:21:08Z",
              "updatedAt": "2020-03-11T05:26:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNDgxNzkz",
          "commit": {
            "abbreviatedOid": "96e320f"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-11T05:21:28Z",
          "updatedAt": "2020-03-11T05:21:28Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nTo further assure that this extensibility is available in the future, and to encourage consumers to use a complete parser implementation, a field definition can specify that \"grease\" Parameters be added by senders. A specification could stipulate that all Parameters that fit a defined pattern are reserved for this use and then encourage them to be sent on some portion of requests. This helps to discourage recipients from writing a parser that does not account for Parameters.\r\n```",
              "createdAt": "2020-03-11T05:21:28Z",
              "updatedAt": "2020-03-11T05:26:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNDgxODM0",
          "commit": {
            "abbreviatedOid": "96e320f"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-11T05:21:39Z",
          "updatedAt": "2020-03-11T05:21:39Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nAn extension to a structured field can then require that an entire field value be ignored by a recipient that understands the extension if constraints on the value it defines are not met.\r\n```",
              "createdAt": "2020-03-11T05:21:39Z",
              "updatedAt": "2020-03-11T05:26:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNDgyNDg3",
          "commit": {
            "abbreviatedOid": "96e320f"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "@mnot has suggestions, but does not use the feature.  I try to use the feature and get blocked.  Gah.  Now I just need to abuse my powers...",
          "createdAt": "2020-03-11T05:24:00Z",
          "updatedAt": "2020-03-11T05:24:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNDgzODk1",
          "commit": {
            "abbreviatedOid": "fd2e2b0"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-11T05:29:19Z",
          "updatedAt": "2020-03-11T05:29:19Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e8b603e32c36f5a825322990a427045f4495436d",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "editorial-sh",
      "headRefOid": "fd2e2b046c5e16b77ee1cf7fea1b0d3e40bfdfb2",
      "mergeCommit": {
        "oid": "b389cb31b94b08a546aa2bb4891476748a4d9468"
      }
    },
    {
      "number": 1130,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1OTg5MTEw",
      "title": "[Client Hints] Add latest PRs to changes",
      "url": "https://github.com/httpwg/http-extensions/pull/1130",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "",
      "createdAt": "2020-03-10T08:04:03Z",
      "updatedAt": "2020-03-12T15:45:59Z",
      "closedAt": "2020-03-10T11:40:40Z",
      "mergedAt": "2020-03-10T11:40:40Z",
      "mergedBy": "yoavweiss",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is a simple editorial change of the \"changes\" section, to add the latest PRs.\r\n",
          "createdAt": "2020-03-10T08:07:55Z",
          "updatedAt": "2020-03-10T08:07:55Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Landing as this change is not substantive",
          "createdAt": "2020-03-10T11:40:36Z",
          "updatedAt": "2020-03-10T11:40:36Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e8b603e32c36f5a825322990a427045f4495436d",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "client_hints_prs",
      "headRefOid": "ecf7c4bf8d6b65d41001e60989543eaabfbe0399",
      "mergeCommit": {
        "oid": "27e9bd3a2eb46d9769b18ade10ed475f650dd97a"
      }
    },
    {
      "number": 1131,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg2MDg1ODM4",
      "title": "[Client Hints] Remove unused references",
      "url": "https://github.com/httpwg/http-extensions/pull/1131",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-10T11:45:04Z",
      "updatedAt": "2020-03-10T11:46:50Z",
      "closedAt": "2020-03-10T11:46:50Z",
      "mergedAt": "2020-03-10T11:46:50Z",
      "mergedBy": "yoavweiss",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Landing as this change is not substantive",
          "createdAt": "2020-03-10T11:46:45Z",
          "updatedAt": "2020-03-10T11:46:45Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "27e9bd3a2eb46d9769b18ade10ed475f650dd97a",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "unused_refs",
      "headRefOid": "bf978de54fb1f5036d004d1ea6a2725a765b66ef",
      "mergeCommit": {
        "oid": "f4b84c9e64c60ef8373be1a86cf6e0670b192e50"
      }
    },
    {
      "number": 1132,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg2NTMzNDYw",
      "title": "[Client Hints] Remove nested list",
      "url": "https://github.com/httpwg/http-extensions/pull/1132",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Non substantive change to improve the list's style, after feedback on https://github.com/httpwg/http-extensions/pull/1080#discussion_r390275413",
      "createdAt": "2020-03-11T07:49:30Z",
      "updatedAt": "2020-03-11T08:01:54Z",
      "closedAt": "2020-03-11T08:01:46Z",
      "mergedAt": "2020-03-11T08:01:45Z",
      "mergedBy": "yoavweiss",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Landing, as this is non-substantive",
          "createdAt": "2020-03-11T08:01:40Z",
          "updatedAt": "2020-03-11T08:01:40Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b389cb31b94b08a546aa2bb4891476748a4d9468",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "remove_nested_list",
      "headRefOid": "29e15dffaa3726efb00d082790a43b19adb8f033",
      "mergeCommit": {
        "oid": "eda3999094834e2f151ebfd0d9649dcc28c5c5b7"
      }
    },
    {
      "number": 1134,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg2NTU4NDkx",
      "title": "client-hints: re-insert back section (#1133)",
      "url": "https://github.com/httpwg/http-extensions/pull/1134",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "",
      "createdAt": "2020-03-11T08:53:38Z",
      "updatedAt": "2020-03-11T08:55:17Z",
      "closedAt": "2020-03-11T08:55:16Z",
      "mergedAt": "2020-03-11T08:55:16Z",
      "mergedBy": "yoavweiss",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNTY5MDE2",
          "commit": {
            "abbreviatedOid": "74972de"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM! Thanks for catching that :)",
          "createdAt": "2020-03-11T08:55:10Z",
          "updatedAt": "2020-03-11T08:55:10Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "eda3999094834e2f151ebfd0d9649dcc28c5c5b7",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-1133",
      "headRefOid": "74972dea294ad7f85f047ad7680863307f70f395",
      "mergeCommit": {
        "oid": "3f74d623fde2e925af2d7ecdfb5ee23f48e271af"
      }
    },
    {
      "number": 1135,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg2NTYyMTM1",
      "title": "[client hints] Add latest PR changes",
      "url": "https://github.com/httpwg/http-extensions/pull/1135",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "",
      "createdAt": "2020-03-11T09:01:50Z",
      "updatedAt": "2020-03-11T09:20:25Z",
      "closedAt": "2020-03-11T09:20:21Z",
      "mergedAt": "2020-03-11T09:20:20Z",
      "mergedBy": "yoavweiss",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Landing as this is not substantive",
          "createdAt": "2020-03-11T09:20:16Z",
          "updatedAt": "2020-03-11T09:20:16Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3f74d623fde2e925af2d7ecdfb5ee23f48e271af",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "changes_pr_1134",
      "headRefOid": "aeb4dbeaa4ce6fd1f8f915a6d3cda903e2052f17",
      "mergeCommit": {
        "oid": "56ca0feb2e35ad6982101c826b25a09204a1d296"
      }
    },
    {
      "number": 1140,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg3NTA4MzI4",
      "title": "Reference new HTTP core semenatics and use field terminology",
      "url": "https://github.com/httpwg/http-extensions/pull/1140",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "The PR is intended to fix #1137, which asks us to use updated terminology in HTTP core documents.\r\n\r\nI've attempted to update all references of RFC 7230 to draft-ietf-httpbis-semantics. A reference to RFC7231 remains but is demoted to informative.\r\n\r\nThe change converts `Digest` and `Want-Digest` into `fields` meaning they can appear in header or trailer field sections. As noted there is a clear case for Digest trailers, there seems no reason to restrict Want-Digest to request header fields but I can be easily persuaded.\r\n\r\nRemaining references to `header fields` relate to externally defined headers that are coined in draft-ietf-httpbis-semantics.\r\n\r\nFinally, the IANA registry handling is also updated.",
      "createdAt": "2020-03-12T22:43:38Z",
      "updatedAt": "2020-03-17T14:00:00Z",
      "closedAt": "2020-03-17T13:59:59Z",
      "mergedAt": "2020-03-17T13:59:59Z",
      "mergedBy": "LPardue",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I intentionally left out changing the title for fear of bike shedding. But now I realise failing to change makes this a non-atomic commit. So let me fix it.",
          "createdAt": "2020-03-13T00:08:30Z",
          "updatedAt": "2020-03-13T00:08:30Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We all need to respect editor discretion in this.  Maybe don't call it \"Hashing Stuff\" and we'll be good.",
          "createdAt": "2020-03-13T00:10:35Z",
          "updatedAt": "2020-03-13T00:10:35Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I asked explicitly about the title because this document was called \"Resource Digests\" before adoption. And we were asked to rename it to \"Digest headers\", which was fine. I do see the humor in yet another change, but I'd like to get it right and avoid another-another one!",
          "createdAt": "2020-03-13T00:17:06Z",
          "updatedAt": "2020-03-13T00:17:31Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I asked explicitly about the title because this document was called \"Resource Digests\"\r\n\r\nIMHO `Representation Digests` is a suitable name, though it's not explicative.\r\n\r\nProbably the same applies to many other specs referencing header names in the title. I think we can postpone this without great damages. I'd focus on the other issues instead.\r\n\r\n",
          "createdAt": "2020-03-17T09:04:09Z",
          "updatedAt": "2020-03-17T09:04:09Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't want this PR to bitrot by getting stuck behind a title bikeshed. Therefore I'm merging as is and I'll take the blame for the non-atomic change. We'll get the renaming fixed up soon anyhow.",
          "createdAt": "2020-03-17T13:58:49Z",
          "updatedAt": "2020-03-17T13:58:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczOTY3NjA1",
          "commit": {
            "abbreviatedOid": "0ed0608"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Did you want to fix the title also?",
          "createdAt": "2020-03-12T23:42:16Z",
          "updatedAt": "2020-03-12T23:44:33Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I would use `{{!SEMANTICS=I-D.ietf-httpbis-semantics}}`.  But that's just me.  I think that you can do something with the reference above to get a nicer symbolic reference as well, but I forget the syntax.",
              "createdAt": "2020-03-12T23:42:16Z",
              "updatedAt": "2020-03-13T14:54:37Z"
            },
            {
              "originalPosition": 76,
              "body": "```suggestion\r\nBasing `Digest` on the selected representation makes it more straightforward to\r\n```",
              "createdAt": "2020-03-12T23:43:11Z",
              "updatedAt": "2020-03-13T14:54:37Z"
            },
            {
              "originalPosition": 194,
              "body": "```suggestion\r\n# The Want-Digest Field {#want-digest}\r\n```",
              "createdAt": "2020-03-12T23:43:54Z",
              "updatedAt": "2020-03-13T14:54:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczOTc2MTkz",
          "commit": {
            "abbreviatedOid": "0ed0608"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-13T00:12:08Z",
          "updatedAt": "2020-03-13T00:12:08Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I take this on board. One problem I encountered was how to reference the core document in the abstract, which can't be a real reference othereise it triggers idnits IIUC\r\n\r\nI inclined to modify reference style separately in a single pass PR..",
              "createdAt": "2020-03-13T00:12:08Z",
              "updatedAt": "2020-03-13T14:54:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MzMxNDAw",
          "commit": {
            "abbreviatedOid": "0ed0608"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-13T14:12:45Z",
          "updatedAt": "2020-03-13T14:12:46Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Once we close this PR we can merge Martin's suggestion in a separate PR or in the final commit",
              "createdAt": "2020-03-13T14:12:45Z",
              "updatedAt": "2020-03-13T14:54:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MzMyNjAw",
          "commit": {
            "abbreviatedOid": "50ed71b"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-13T14:14:11Z",
          "updatedAt": "2020-03-13T14:14:12Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "```suggestion\r\nBasing `Digest` on the selected representation makes it straightforward to\r\n```",
              "createdAt": "2020-03-13T14:14:11Z",
              "updatedAt": "2020-03-13T14:54:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MzM3ODA2",
          "commit": {
            "abbreviatedOid": "50ed71b"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-13T14:20:39Z",
          "updatedAt": "2020-03-13T14:20:39Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Like above, the CRLF at line 268 doesn't break the line in HTML nor in the TXT\r\nso I won't reflow that.",
              "createdAt": "2020-03-13T14:20:39Z",
              "updatedAt": "2020-03-13T14:54:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MzQwMjY0",
          "commit": {
            "abbreviatedOid": "50ed71b"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-13T14:23:40Z",
          "updatedAt": "2020-03-13T14:23:41Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "Let's do what the other docs do.",
              "createdAt": "2020-03-13T14:23:40Z",
              "updatedAt": "2020-03-13T14:54:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MzQ5MDQy",
          "commit": {
            "abbreviatedOid": "50ed71b"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-13T14:34:31Z",
          "updatedAt": "2020-03-13T14:34:32Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "This is one paragraph. Having arbitrary line breaks in a contiguous block of text is counter intuitive, why would we want that?.\r\n\r\nText reflow in my editor applies to paragraphs, so if you want to maintain arbitrary line breaks that makes my life way harder and I just don't see the benefit. ",
              "createdAt": "2020-03-13T14:34:31Z",
              "updatedAt": "2020-03-13T14:54:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NzMwNTg0",
          "commit": {
            "abbreviatedOid": "50ed71b"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-14T14:29:39Z",
          "updatedAt": "2020-03-14T14:29:39Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "I generally try to isolate document lines that may be changed together - eg 'It can be used in request and response' - because I thought it simplifies editing.\r\n\r\nIf it doesn't and instead you find that makes things harder it's fine to let the editor reflow :)\r\n\r\n",
              "createdAt": "2020-03-14T14:29:39Z",
              "updatedAt": "2020-03-14T14:29:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1ODM4MTAw",
          "commit": {
            "abbreviatedOid": "eb597cf"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I removed my reflowing suggestions, so ok for reflowing & co :) LGTM.",
          "createdAt": "2020-03-17T08:50:42Z",
          "updatedAt": "2020-03-17T08:55:13Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "56ca0feb2e35ad6982101c826b25a09204a1d296",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "digest-fields-nu-semantics",
      "headRefOid": "eb597cfcdc83da36aba4d615a4a768bdaf2633b7",
      "mergeCommit": {
        "oid": "5f4762a22af487d2d64a8510dc047472f026e469"
      }
    },
    {
      "number": 1142,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg5NzM0NDA4",
      "title": "Replace validator -> validator fields",
      "url": "https://github.com/httpwg/http-extensions/pull/1142",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\n\r\n\"validator\" refers to validator fields used in preconditions. The term validator fields seems more faithful to the original cache-validators in RFC3230.\r\n\r\n## See\r\n\r\nhttps://github.com/httpwg/http-core/blob/master/draft-ietf-httpbis-semantics-latest.xml#L9288\r\n\r\nand\r\n\r\n\r\nhttps://tools.ietf.org/html/draft-ietf-httpbis-semantics-07#section-10.2",
      "createdAt": "2020-03-17T09:56:01Z",
      "updatedAt": "2020-04-15T14:15:07Z",
      "closedAt": "2020-04-15T14:15:06Z",
      "mergedAt": "2020-04-15T14:15:06Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2MDY2MTQy",
          "commit": {
            "abbreviatedOid": "740e448"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-17T14:06:27Z",
          "updatedAt": "2020-03-17T14:06:27Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4467941efe15f87e3c995e3e22ad8b9901c34f28",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-936-validators",
      "headRefOid": "6066cc89e3e9032e8714d951f3ed3bf9101bf22b",
      "mergeCommit": {
        "oid": "cf2de73924ab3b6a9afe8cfe86e79e4a446431a6"
      }
    },
    {
      "number": 1144,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk2Mzc3MzY1",
      "title": "[RFC2665bis] Fix nameless/valueless serialization.",
      "url": "https://github.com/httpwg/http-extensions/pull/1144",
      "state": "MERGED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Nameless cookies serialize as `value`. Valueless cookies serialize as\r\n`name=`. No, this isn't what we would have chosen if we were designing\r\ncookies from scratch, but it's Chromium and Firefox's shipping behavior,\r\nand it's reasonable to just accept.\r\n\r\nThis specification change is covered by 0021 and 0022 in the WPT\r\nrepository (see\r\nhttps://wpt.fyi/results/cookies/http-state/general-tests.html?label=master&label=experimental&aligned).\r\n\r\nCloses https://github.com/httpwg/http-extensions/issues/1081.",
      "createdAt": "2020-03-31T14:32:23Z",
      "updatedAt": "2020-04-01T06:13:27Z",
      "closedAt": "2020-04-01T06:13:25Z",
      "mergedAt": "2020-04-01T06:13:25Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "WDYT, @essen / @johnwilander ?",
          "createdAt": "2020-03-31T14:32:36Z",
          "updatedAt": "2020-03-31T14:32:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0ODAwMzU4",
          "commit": {
            "abbreviatedOid": "2a16534"
          },
          "author": "essen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Minor suggestion, OK for me either way.",
          "createdAt": "2020-03-31T14:38:31Z",
          "updatedAt": "2020-03-31T14:39:18Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Maybe just `2.  Output the cookie's value.` would be enough because if it's empty then nothing is output anyway.",
              "createdAt": "2020-03-31T14:38:31Z",
              "updatedAt": "2020-03-31T14:39:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0ODY0NDY3",
          "commit": {
            "abbreviatedOid": "2a16534"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-31T15:43:31Z",
          "updatedAt": "2020-03-31T15:43:31Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Thanks! I think I vaguely prefer being explicit about how an empty value would be serialized (e.g. not at all)... probably doesn't make much of a difference, but keeping it the same as the 1 above seems reasonable to me.",
              "createdAt": "2020-03-31T15:43:31Z",
              "updatedAt": "2020-03-31T15:43:31Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5f4762a22af487d2d64a8510dc047472f026e469",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "1081",
      "headRefOid": "2a16534c156a4ddaa7e44e2582c17665bc71d6bf",
      "mergeCommit": {
        "oid": "0f704afe0d54ece5733a0227159f791b92f06fec"
      }
    },
    {
      "number": 1145,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk2NDA5NTEw",
      "title": "[RFC6265bis] Fix ABNF.",
      "url": "https://github.com/httpwg/http-extensions/pull/1145",
      "state": "MERGED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This patch incorporates two ABNF changes:\r\n\r\n1.  Closes https://github.com/httpwg/http-extensions/issues/1074 by\r\n    adjusting the `cookie-pair` grammar to include optional spaces.\r\n    We test this behavior in a few distinct WPTs, including\r\n    chromium0014, name0018, value0006.\r\n\r\n2.  Closes https://github.com/httpwg/http-extensions/issues/1119\r\n    by removing OWS from the spec, as user agents generally follow\r\n    the \"SHOULD\" in the current text to limit themselves to a single\r\n    SP rather than serializing with OWS. It's reasonable to lock that\r\n    in, and it also happens to match all the `Cookie:` header tests\r\n    we have.\r\n\r\nThanks to both @reschke and @bakulf for paying attention to this.",
      "createdAt": "2020-03-31T15:22:27Z",
      "updatedAt": "2020-04-07T11:39:02Z",
      "closedAt": "2020-04-07T11:39:00Z",
      "mergedAt": "2020-04-07T11:39:00Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "@reschke and @bakulf: Would you mind taking a look at this patch?",
          "createdAt": "2020-03-31T15:23:12Z",
          "updatedAt": "2020-03-31T15:23:12Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Adding @johnwilander as well.",
          "createdAt": "2020-04-01T14:43:35Z",
          "updatedAt": "2020-04-01T14:43:35Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I'm planning on merging this tomorrow unless someone objects or has suggestions. :)",
          "createdAt": "2020-04-02T08:15:55Z",
          "updatedAt": "2020-04-02T08:15:55Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> if you made sure that the new places for OWS are actually working in practice\r\n\r\nI believe these are covered by the parsing tests in WPT (https://github.com/web-platform-tests/wpt/tree/master/cookies/http-state/resources/test-files)",
          "createdAt": "2020-04-03T07:11:31Z",
          "updatedAt": "2020-04-03T07:11:31Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "...alternative would be \"BWS\", if you want to allow but discourage.",
          "createdAt": "2020-04-03T07:34:11Z",
          "updatedAt": "2020-04-03T07:34:11Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Ah. That might be a reasonable idea. Does `BWS` have any normative text associated with it?",
          "createdAt": "2020-04-03T07:35:29Z",
          "updatedAt": "2020-04-03T07:35:29Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The BWS rule is used where the grammar allows optional whitespace only for historical reasons. A sender MUST NOT generate BWS in messages. A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.\r\n\r\nhttps://greenbytes.de/tech/webdav/rfc7230.html#rfc.section.3.2.3.p.4",
          "createdAt": "2020-04-03T07:44:56Z",
          "updatedAt": "2020-04-03T07:44:56Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "Merging this. Happy to take suggestions for further cleanup as we go.",
          "createdAt": "2020-04-07T11:38:39Z",
          "updatedAt": "2020-04-07T11:38:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NzM4OTAy",
          "commit": {
            "abbreviatedOid": "9d71640"
          },
          "author": "bakulf",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-02T19:40:05Z",
          "updatedAt": "2020-04-02T19:40:16Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "This is not enough.\r\nWhat about these:\r\n\r\n1. `Set-Cookie: a=b ;   sameSite=strict`\r\n2. `SetCookie: a=b ; sameSite = strict`\r\n3. `SameSite:  a=b; sameSite=lax ; path = /`",
              "createdAt": "2020-04-02T19:40:06Z",
              "updatedAt": "2020-04-03T07:55:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2OTMwMTY0",
          "commit": {
            "abbreviatedOid": "9d71640"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-03T04:31:13Z",
          "updatedAt": "2020-04-03T04:31:14Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "    *[WSP]\r\n\r\nis the same as\r\n\r\n    *WSP\r\n\r\n",
              "createdAt": "2020-04-03T04:31:14Z",
              "updatedAt": "2020-04-03T07:55:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2OTMwMzk4",
          "commit": {
            "abbreviatedOid": "9d71640"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "See comment about \"*[WSP]\"",
          "createdAt": "2020-04-03T04:32:07Z",
          "updatedAt": "2020-04-03T04:32:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2OTY1MjMy",
          "commit": {
            "abbreviatedOid": "8edffb2"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-03T06:28:30Z",
          "updatedAt": "2020-04-03T06:28:31Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Thanks to you both. I've replaced WSP with OWS (I'd mistakenly assumed RFC7230's OWS contained a wider character set than WSP), and added more flexibility around delimiters, in line with the WPT suite's tests.\r\n\r\nWDYT?",
              "createdAt": "2020-04-03T06:28:30Z",
              "updatedAt": "2020-04-03T07:55:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2OTgyODI3",
          "commit": {
            "abbreviatedOid": "8edffb2"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "...if you made sure that the new places for OWS are actually working in practice...",
          "createdAt": "2020-04-03T07:08:05Z",
          "updatedAt": "2020-04-03T07:08:05Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a21495133a8ee94c33dff203483b3ac72d935cda",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "1074",
      "headRefOid": "ac055d602e5bb81c588d9925dccbcd8ab91124c9",
      "mergeCommit": {
        "oid": "5469d515d8876196900078806d07813765aa9a49"
      }
    },
    {
      "number": 1146,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk2NDEzMzE1",
      "title": "[RFC6265bis] Fix 'secure-only-flag' processing.",
      "url": "https://github.com/httpwg/http-extensions/pull/1146",
      "state": "MERGED",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The 'secure-only-flag' is never \"not set\". It is either \"true\" or\r\n\"false\". This patch fixes two places where we should have been checking\r\nfor falsity.\r\n\r\nCloses https://github.com/httpwg/http-extensions/issues/1059.",
      "createdAt": "2020-03-31T15:28:28Z",
      "updatedAt": "2020-04-01T06:15:04Z",
      "closedAt": "2020-04-01T06:15:03Z",
      "mergedAt": "2020-04-01T06:15:03Z",
      "mergedBy": "mikewest",
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "@essen / @johnwilander WDYT?",
          "createdAt": "2020-03-31T15:28:43Z",
          "updatedAt": "2020-03-31T15:28:43Z"
        },
        {
          "author": "essen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good. I should have sent a PR. :-)",
          "createdAt": "2020-03-31T15:37:12Z",
          "updatedAt": "2020-03-31T15:37:12Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "0f704afe0d54ece5733a0227159f791b92f06fec",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "1059",
      "headRefOid": "fa14dd982680d318fc7dabcf83a465e82b7ed4d6",
      "mergeCommit": {
        "oid": "a21495133a8ee94c33dff203483b3ac72d935cda"
      }
    },
    {
      "number": 1150,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzMzY0Mzky",
      "title": "Add references to Structured Trailers",
      "url": "https://github.com/httpwg/http-extensions/pull/1150",
      "state": "MERGED",
      "author": "stephenmcgruer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "Editorial: add one reference to Structured Trailers in a list of the types, and\r\ncorrect what appears to be a typo of Structured Field --> Structured Trailer.",
      "createdAt": "2020-04-14T19:12:20Z",
      "updatedAt": "2020-04-15T02:22:56Z",
      "closedAt": "2020-04-15T02:22:56Z",
      "mergedAt": "2020-04-15T02:22:56Z",
      "mergedBy": "mnot",
      "comments": [
        {
          "author": "stephenmcgruer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Happened to spot these when perusing the structured headers spec; apologies if I've misread and the original text was correct.",
          "createdAt": "2020-04-14T19:13:37Z",
          "updatedAt": "2020-04-14T19:13:37Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2020-04-15T02:22:52Z",
          "updatedAt": "2020-04-15T02:22:52Z"
        }
      ],
      "reviews": [],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "29fff7f850ad9f4930d0cdd935523c5b7d190df6",
      "headRepository": "stephenmcgruer/http-extensions",
      "headRefName": "structured-trailers",
      "headRefOid": "893575f93d6f62083197841150d22b2e1df6fe45",
      "mergeCommit": {
        "oid": "4fe04acf1f885303c45b7271c295bd744cdc3ac6"
      }
    },
    {
      "number": 1151,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzMzgzMzMw",
      "title": "Split setting into client and server values",
      "url": "https://github.com/httpwg/http-extensions/pull/1151",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "Fixes #1087.  Instead of a four-byte exporter, uses an eight-byte exporter and splits into two values.  Support for exchanging server certificates and client certificates is now indicated separately.",
      "createdAt": "2020-04-14T19:55:30Z",
      "updatedAt": "2020-05-14T19:05:08Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "29fff7f850ad9f4930d0cdd935523c5b7d190df6",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "sc/split_settings",
      "headRefOid": "808d1f6d9c1862100193c78f4e8e4097cfc90355",
      "closedAt": "2020-05-14T19:05:06Z",
      "mergedAt": "2020-05-14T19:05:06Z",
      "mergedBy": "MikeBishop",
      "mergeCommit": {
        "oid": "d70c57fc564c87e4dd297609d078fb452a04ec77"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 1152,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzNDAwMDg1",
      "title": "Secondary Cert error handling",
      "url": "https://github.com/httpwg/http-extensions/pull/1152",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "Fixes #1088, though I'm not sure it's yet precise enough.  There are three general classes of errors:\r\n\r\n- The peer **did something wrong**.  There are relatively few of these possible -- indicating more certificates to use than were requested, or more than one unsolicited certificate; sending CERTIFICATE_NEEDED to a peer that didn't indicate support for this extension.\r\n- The **authenticator is corrupt**.  This might indicate a problem with the TLS connection.\r\n- The **certificate isn't acceptable**.  There are lots of reasons this might happen.\r\n\r\nThe first two should be at least stream and possibly connection errors.  The latter should be handled at the HTTP layer, but previously had error codes defined for them.  This PR removes several error codes and recommends handling at the HTTP layer if the certificate isn't accepted.",
      "createdAt": "2020-04-14T20:33:30Z",
      "updatedAt": "2020-05-14T19:14:09Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d70c57fc564c87e4dd297609d078fb452a04ec77",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "sc/non-nuclear",
      "headRefOid": "399d4b41386c4e7cd48dd6842b8694faf6de7640",
      "closedAt": "2020-05-14T19:14:08Z",
      "mergedAt": "2020-05-14T19:14:08Z",
      "mergedBy": "MikeBishop",
      "mergeCommit": {
        "oid": "db2a8b0432ff11276e3f5460a614c1c696a46f1f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 1153,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzNDA0NjIx",
      "title": "Confused deputy should be clear",
      "url": "https://github.com/httpwg/http-extensions/pull/1153",
      "state": "MERGED",
      "author": "MikeBishop",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "secondary-certs"
      ],
      "body": "Automatic use of client-proffered certificates was removed a while back; clients can indicate which certificate (if any) they want the server to consider by sending a `USE_CERTIFICATE` frame with the `UNSOLICITED` flag set.\r\n\r\nThere was text talking about automatic use of the server-proffered certificates, but there wasn't corresponding text disallowing that behavior for client certificates, simply the absence of permission.  This PR forbids considering \"available\" certificates until the client indicates which certificate to use.\r\n\r\nFixes #1090.",
      "createdAt": "2020-04-14T20:44:05Z",
      "updatedAt": "2020-05-14T19:21:59Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "29fff7f850ad9f4930d0cdd935523c5b7d190df6",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "sc/confused_deputy",
      "headRefOid": "d35f070c3795a0b88643c7064c45a96bab3a6754",
      "closedAt": "2020-05-14T19:21:58Z",
      "mergedAt": "2020-05-14T19:21:58Z",
      "mergedBy": "MikeBishop",
      "mergeCommit": {
        "oid": "062680fee8235cee9aa1fd1bdbd960d614932a88"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 1154,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzNzkzOTEz",
      "title": "Fix: #1020. Deprecate sha-1",
      "url": "https://github.com/httpwg/http-extensions/pull/1154",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nDeprecates SHA-1 as it's now vulnerable to collisions.\r\n\r\nFixes: #1020 ",
      "createdAt": "2020-04-15T14:27:22Z",
      "updatedAt": "2020-04-30T09:46:40Z",
      "closedAt": "2020-04-30T09:46:39Z",
      "mergedAt": "2020-04-30T09:46:39Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMzY0OTEz",
          "commit": {
            "abbreviatedOid": "83d33f8"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-04-30T09:45:54Z",
          "updatedAt": "2020-04-30T09:45:54Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4178324c374fd1e75acda09df6d7b2afb232de07",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1020-deprecate-sha-1",
      "headRefOid": "83d33f883069df8fe2c4e99a3c74acdd16f0be3d",
      "mergeCommit": {
        "oid": "316d75cc6ee86de586eb09ecf7049967ecf806c1"
      }
    },
    {
      "number": 1155,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzODIwNTY1",
      "title": "Fix: #1143. Example of an empty payload body.",
      "url": "https://github.com/httpwg/http-extensions/pull/1155",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\n- adds an example of a request with no payload body (eg. HEAD)\r\n- mention an use-case in the Signature section.\r\n\r\nFixes: #1143 ",
      "createdAt": "2020-04-15T15:10:15Z",
      "updatedAt": "2020-05-04T17:33:01Z",
      "closedAt": "2020-05-04T17:32:59Z",
      "mergedAt": "2020-05-04T17:32:59Z",
      "mergedBy": "ioggstream",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson do you think this is consistent with content-coding like aes128gcm?",
          "createdAt": "2020-04-15T15:11:37Z",
          "updatedAt": "2020-04-15T15:11:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMzc5MDI1",
          "commit": {
            "abbreviatedOid": "728deb3"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-30T10:05:36Z",
          "updatedAt": "2020-04-30T10:05:36Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I don't quite follow what this is trying to say. To rephrase it based on my understanding, is it this?\r\n\r\n\"Using signatures to protect the `Digest` of an empty representation allows receiving endpoints to detect if an eventual payload has been stripped or added.\"",
              "createdAt": "2020-04-30T10:05:36Z",
              "updatedAt": "2020-04-30T11:23:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNDI5NDAx",
          "commit": {
            "abbreviatedOid": "a346300"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-30T11:24:09Z",
          "updatedAt": "2020-04-30T11:24:09Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "done.",
              "createdAt": "2020-04-30T11:24:09Z",
              "updatedAt": "2020-04-30T11:24:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0OTk3MDcz",
          "commit": {
            "abbreviatedOid": "a346300"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-04T13:41:05Z",
          "updatedAt": "2020-05-04T13:41:05Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f40438f4582d1fdb5b894f382ce341686e38e7c3",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1143-no-payload",
      "headRefOid": "a346300f4d1fda2db329ea85c99a62724169516f",
      "mergeCommit": {
        "oid": "36de8d4802e3eee8712d90799d3cb4ea515213db"
      }
    },
    {
      "number": 1156,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzODI5MTU3",
      "title": "Update 7231->httpbis-semantics",
      "url": "https://github.com/httpwg/http-extensions/pull/1156",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nUpdates a reference 7231->httpbis-semantics",
      "createdAt": "2020-04-15T15:24:16Z",
      "updatedAt": "2020-04-30T10:10:25Z",
      "closedAt": "2020-04-30T10:10:24Z",
      "mergedAt": "2020-04-30T10:10:24Z",
      "mergedBy": "LPardue",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue merge if that's ok.",
          "createdAt": "2020-04-24T10:04:18Z",
          "updatedAt": "2020-04-24T10:04:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMzc5NjYw",
          "commit": {
            "abbreviatedOid": "da15689"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-30T10:06:29Z",
          "updatedAt": "2020-04-30T10:06:29Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4178324c374fd1e75acda09df6d7b2afb232de07",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-fix-reference",
      "headRefOid": "da156894ce598d811ff300572a827b7875be9ad9",
      "mergeCommit": {
        "oid": "54bd2df20d33e88490de32768cc0f0445b5b5c93"
      }
    },
    {
      "number": 1157,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzODQ0OTM2",
      "title": "Start mentioning trailers. See #884.",
      "url": "https://github.com/httpwg/http-extensions/pull/1157",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nMention trailers.\r\n\r\n```\r\nIf received in trailers, Digest MUST NOT be discarded; instead it MAY be merged in the header section (See Section 7.1.2 of {{!MESSAGING=I-D.ietf-httpbis-messaging}}).\r\n```\r\n\r\nSee #884",
      "createdAt": "2020-04-15T15:51:47Z",
      "updatedAt": "2020-04-30T11:01:50Z",
      "closedAt": "2020-04-30T11:01:48Z",
      "mergedAt": "2020-04-30T11:01:48Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMzg0ODc4",
          "commit": {
            "abbreviatedOid": "24ec64b"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-30T10:14:07Z",
          "updatedAt": "2020-04-30T10:14:08Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nDigest can be sent in a trailer section. When using incremental digest-algorithms\r\nthis allows the sender and the receiver to dynamically compute the digest value\r\nwhile streaming the content.\r\n```",
              "createdAt": "2020-04-30T10:14:08Z",
              "updatedAt": "2020-04-30T10:53:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMzg3NzYw",
          "commit": {
            "abbreviatedOid": "24ec64b"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-30T10:18:39Z",
          "updatedAt": "2020-04-30T10:18:40Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nInstead, data should only be processed after validating the Digest.\r\n```\r\n\r\ndo you want to make this should a normative requirement?",
              "createdAt": "2020-04-30T10:18:39Z",
              "updatedAt": "2020-04-30T10:53:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMzg4MzU3",
          "commit": {
            "abbreviatedOid": "24ec64b"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I have a couple of readability suggestions, and a question about normative requirements.",
          "createdAt": "2020-04-30T10:19:34Z",
          "updatedAt": "2020-04-30T10:19:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNDA5NTMx",
          "commit": {
            "abbreviatedOid": "c243b7f"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Lgtm",
          "createdAt": "2020-04-30T10:51:52Z",
          "updatedAt": "2020-04-30T10:51:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNDExODIy",
          "commit": {
            "abbreviatedOid": "a676661"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-30T10:55:31Z",
          "updatedAt": "2020-04-30T10:55:32Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "@LPardue sorry Lucas, could you please check this part I stumbled upon re-reading http-messaging-latest?\r\n\r\n",
              "createdAt": "2020-04-30T10:55:31Z",
              "updatedAt": "2020-04-30T10:55:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNDEzNTY0",
          "commit": {
            "abbreviatedOid": "a676661"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-30T10:58:23Z",
          "updatedAt": "2020-04-30T10:58:23Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "lgtm",
              "createdAt": "2020-04-30T10:58:23Z",
              "updatedAt": "2020-04-30T10:58:23Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "54bd2df20d33e88490de32768cc0f0445b5b5c93",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-884-trailers",
      "headRefOid": "a676661fbec3d57035fc5d3165d71074daa423dd",
      "mergeCommit": {
        "oid": "0b61fc890f13b3a24d5d0ce1f9e4ed6ea3fcab2a"
      }
    },
    {
      "number": 1160,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA0MzEzOTg3",
      "title": "[client hints] AD review comments",
      "url": "https://github.com/httpwg/http-extensions/pull/1160",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "A set of changes following comments as part of the AD review process.",
      "createdAt": "2020-04-16T11:56:51Z",
      "updatedAt": "2020-04-24T06:31:46Z",
      "closedAt": "2020-04-24T06:31:42Z",
      "mergedAt": "2020-04-24T06:31:42Z",
      "mergedBy": "yoavweiss",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot - could you take a look?",
          "createdAt": "2020-04-23T16:22:36Z",
          "updatedAt": "2020-04-23T16:22:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NTcxNzQ3",
          "commit": {
            "abbreviatedOid": "680fffd"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2020-04-24T00:50:48Z",
          "updatedAt": "2020-04-24T00:50:48Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4178324c374fd1e75acda09df6d7b2afb232de07",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "ad_review",
      "headRefOid": "680fffd2c4b380ad0f3049726ae5d540c9084f20",
      "mergeCommit": {
        "oid": "0a3cf3819ac1ab674709b617cb3857e9b49f8f10"
      }
    },
    {
      "number": 1162,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA2MDY0NzAz",
      "title": "rfc6265bis: reformat cookie-octet ABNF and fix comment (#1161)",
      "url": "https://github.com/httpwg/http-extensions/pull/1162",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-20T13:29:32Z",
      "updatedAt": "2020-04-27T14:36:02Z",
      "closedAt": "2020-04-27T14:36:01Z",
      "mergedAt": "2020-04-27T14:36:01Z",
      "mergedBy": "mikewest",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMDE1MTUx",
          "commit": {
            "abbreviatedOid": "81973eb"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM, thank you.",
          "createdAt": "2020-04-27T14:35:56Z",
          "updatedAt": "2020-04-27T14:35:56Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "e9b8dbcbe41bf4d5cfc5fa67eebdc929715664c8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-i1161",
      "headRefOid": "81973eb3e5931b2c2268ab657cab95d91de4e710",
      "mergeCommit": {
        "oid": "e40dbff4423abf163fb08a9024e9890f5d3b2578"
      }
    },
    {
      "number": 1165,
      "id": "MDExOlB1bGxSZXF1ZXN0NDExMzAzMjQx",
      "title": "Mention mid-stream trailers in the FAQ.",
      "url": "https://github.com/httpwg/http-extensions/pull/1165",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nmentions mid-stream trailers in the FAQ. They cannot be treated easily in this spec\r\nas they are an hypothesis for now. Future digest-algos may consider them.\r\n\r\n",
      "createdAt": "2020-04-30T09:52:47Z",
      "updatedAt": "2020-04-30T11:08:35Z",
      "closedAt": "2020-04-30T11:08:33Z",
      "mergedAt": "2020-04-30T11:08:33Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMzg5NjE0",
          "commit": {
            "abbreviatedOid": "be72b3e"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "looks good but I suggested a slight rewording",
          "createdAt": "2020-04-30T10:21:29Z",
          "updatedAt": "2020-04-30T10:29:18Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n   are interesting, since this specification is a rewrite of [RFC3230] we do not\r\n```",
              "createdAt": "2020-04-30T10:21:29Z",
              "updatedAt": "2020-04-30T11:06:04Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\n   think we should face that. As a first thought, nothing in this document \r\n   precludes future work that would find a use for mid-stream trailers, for \r\n   example an incremental digest-algorithm. A document defining such a\r\n   digest-algorithm is best positioned to describe how it is used.\r\n```",
              "createdAt": "2020-04-30T10:28:43Z",
              "updatedAt": "2020-04-30T11:06:04Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "316d75cc6ee86de586eb09ecf7049967ecf806c1",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-884-mid-stream-faq",
      "headRefOid": "aae6bc3077113ad602a58e7fab4f15076aad91b3",
      "mergeCommit": {
        "oid": "f40438f4582d1fdb5b894f382ce341686e38e7c3"
      }
    },
    {
      "number": 1166,
      "id": "MDExOlB1bGxSZXF1ZXN0NDExMzUxODE0",
      "title": "Create an inline reference to semantics.",
      "url": "https://github.com/httpwg/http-extensions/pull/1166",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nReferences I-D.httpbis-semantics using an inline referece to {{SEMANTICS}}.\r\nThis will ease the transition once SEMANTICS is updated to RFC.",
      "createdAt": "2020-04-30T11:05:15Z",
      "updatedAt": "2020-05-04T17:33:27Z",
      "closedAt": "2020-05-04T17:33:26Z",
      "mergedAt": "2020-05-04T17:33:26Z",
      "mergedBy": "ioggstream",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0OTk2NjAw",
          "commit": {
            "abbreviatedOid": "e5a4539"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-04T13:40:32Z",
          "updatedAt": "2020-05-04T13:40:32Z",
          "comments": []
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "0b61fc890f13b3a24d5d0ce1f9e4ed6ea3fcab2a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-editorial-4",
      "headRefOid": "e5a4539852002eb4f9a26b4022b2bf583df92dd8",
      "mergeCommit": {
        "oid": "5f27972cd18621951c5879ee23bc15074656e35d"
      }
    },
    {
      "number": 1167,
      "id": "MDExOlB1bGxSZXF1ZXN0NDExNTE0MTA5",
      "title": "PRIORITY_UPDATE can be used for initial priority, split H3 frames into two types",
      "url": "https://github.com/httpwg/http-extensions/pull/1167",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "This attempts to address #1096 and #1079. It might help towards overcoming the headers vs frames debate.\r\n\r\nI made the call to restrict the PRIORITY_UPDATE frame to only be sent by clients.\r\n\r\nIt replaces ASCII art with new QUIC-style frame definitions.",
      "createdAt": "2020-04-30T13:45:24Z",
      "updatedAt": "2020-09-09T21:13:56Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "01511073277183a21344e8a22ee59eacfb6e5777",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "priority-update-frames",
      "headRefOid": "fd1c710f5e03d0067bccfb63bce0707169630e80",
      "closedAt": "2020-09-09T21:13:55Z",
      "mergedAt": "2020-09-09T21:13:55Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "8eb70f80d60f02152f05996d96577df6b41ef59b"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Wouldn't it be easier to just define h2's stream zero as the control stream for h2 (at top of document)? \r\n\r\nIn my head that's what I call it. However, @kazuho has been quite particular with correcting me back use stream zero terminology in the past. \r\n\r\n@kazuho WDYT about Roy's suggestion to define stream zero as `control` in this document?",
          "createdAt": "2020-05-07T17:43:56Z",
          "updatedAt": "2020-05-07T17:43:56Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue \r\n> WDYT about Roy's suggestion to define stream zero as control in this document?\r\n\r\nI'd be fine with that, assuming that we'd have the definition somewhere (as @royfielding suggests).",
          "createdAt": "2020-05-14T01:14:39Z",
          "updatedAt": "2020-05-14T01:14:39Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This PR changes the HTTP/3 frame format in a breaking way, which is unfortunate because we don't have strong versioning in the extension. It's feasible that interop between endpoints that expect the frame could suffer because they parse them differently. \r\n\r\nOne idea is to link the priorities draft version to the HTTP/3 draft version. For example, agree that priorities-01 would be used with h3-28. However, the drafts will progress at different rates and we might get stuck.\r\n\r\n@Kazuho made a suggestion that would avoid this problem. We we pick a large frame type ID that  we change for each version of the priorities draft. The final draft that is ready for RFC can then switch back the \"nice\" lower values. I'll make a commit that actions this proposal in order to get review feedback.",
          "createdAt": "2020-05-15T12:03:19Z",
          "updatedAt": "2020-05-15T12:03:19Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/httpwg/http-extensions/pull/1167/commits/127f1490fb0654c4676d43f7eda76d084a02466b adds \"big numbers\" for the H3 frame types but leaves the H2 frame as `0xF`, mainly because H2's space is only 8 bit and I don't want to pollute it. Maybe others also want an experimental value there but IMO we can progress without it.",
          "createdAt": "2020-05-15T12:35:19Z",
          "updatedAt": "2020-05-15T12:35:19Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, I'm ok with changing the frame type value, but in our code it's just as easy(or easier) to switch by draft version.",
          "createdAt": "2020-05-15T13:26:49Z",
          "updatedAt": "2020-05-15T13:26:49Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> FWIW, I'm ok with changing the frame type value, but in our code it's just as easy(or easier) to switch by draft version.\r\n\r\nMy concern is that we'll see an uncoordinated staggered rollout of new HTTP/3 endpoints, and that clients talk something different than the server expects, causing the frame parsing to fail and generating a connection error.",
          "createdAt": "2020-05-15T13:33:08Z",
          "updatedAt": "2020-05-15T13:33:08Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Our servers will likely support draft 25, 27 and 28 at once.\r\n\r\nIs the concern that servers will support multiple drafts at once, and clients will typically only support a single version, but server connections won't be aware of what version they're speaking?\r\n\r\nI suspect this is a case of different implementations having very different ways of supporting multiple versions of QUIC at once?",
          "createdAt": "2020-05-15T18:00:31Z",
          "updatedAt": "2020-05-15T18:00:31Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I hope implementation know what draft they are speaking! I'm more worried about needed to rev the priority draft version multiple times; if we couple to draft 28 we get stuck unless there is a draft 29. I anticipate priorities could iterate more quickly than the specification and more quickly than people might be able to deploy different versions.\r\n\r\nUsing a unique big number for frame type would even allow implementations to retrofit it to draft 27, which might be more feasible to implement and test in the short term.",
          "createdAt": "2020-05-15T18:09:49Z",
          "updatedAt": "2020-05-15T18:09:49Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for clarifying @LPardue, that makes sense.  I was a bit confused about how one might not know what version they're speaking.",
          "createdAt": "2020-05-15T18:14:03Z",
          "updatedAt": "2020-05-15T18:14:03Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We also discussed this PR during the May 2020 virtual interim and the conversation segued into a discussion about reprioritization which is related but ultimately is tracked separately in #1021.\r\n\r\nAs editor, I believe this PR adds changes that better describe the protocol with the design it had when adopted by the WG. And therefore it can be merged independent of the WG finding consensus on reprioritization. \r\n\r\nI've received a lot of feedback on this PR (thanks) and believe I've addressed all but one comment. I aim to resolve that one soon and then plan to merge this PR unless I hear some pushback.\r\n",
          "createdAt": "2020-05-26T23:55:54Z",
          "updatedAt": "2020-05-26T23:55:54Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This issue got tied up with the discussion about reprioritization. Now that the chairs believe there is rough consensus on the matter, I'm giving fair warning that I'm aiming to land this change in the next day or two. I'll remind folks that this has had pretty substantial review already and I'm not looking for relitigation.\r\n\r\nI've just pushed two commits: 1) revert the H2 frame diagram format, we can tackle this later if we care. 2) fix an inconsistency in frame type values report by @guoye-zhang.\r\n\r\nThere is an open question about a servers ability to understand a safe limit of buffering, which might be subject to implementation API. I'd like to spin that off into it's issue so we can make progress here. ",
          "createdAt": "2020-09-07T22:36:13Z",
          "updatedAt": "2020-09-07T22:38:21Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FYI I had some feedback that the frame type values were a bit cumbersome so I've shortened them to 0xF0700 and 0xF0701. See https://github.com/httpwg/http-extensions/pull/1167/commits/b007e937c7c4572fe4bf2437ed38eb8a360696aa",
          "createdAt": "2020-09-08T13:13:00Z",
          "updatedAt": "2020-09-08T13:13:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDIwMzA0",
          "commit": {
            "abbreviatedOid": "b0976a6"
          },
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "It seems like there may be some opportunities for de-duplicating some text, but I don't have a specific suggestion.",
          "createdAt": "2020-05-05T17:50:00Z",
          "updatedAt": "2020-05-05T17:53:21Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nHaving two mechanisms to carry the initial priority signal brings the dilemma of\r\n```",
              "createdAt": "2020-05-05T17:50:00Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nof any other value MUST be treated as a connection error of type PROTOCOL_ERROR.\r\n```",
              "createdAt": "2020-05-05T17:51:18Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDMyMjM0",
          "commit": {
            "abbreviatedOid": "b0976a6"
          },
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T18:05:45Z",
          "updatedAt": "2020-05-05T18:05:46Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "+1",
              "createdAt": "2020-05-05T18:05:45Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2MDQ4MTM0",
          "commit": {
            "abbreviatedOid": "b0976a6"
          },
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T18:27:45Z",
          "updatedAt": "2020-05-05T18:34:26Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Should be more like\r\n\r\n```\r\n  Therefore, a client cannot reprioritize a response by\r\n  sending additional metadata (e.g., trailer fields) on the request stream.\r\n  We avoid interoperability failure by restricting PRIORITY_UPDATE\r\n  frames to the control stream, with each such frame explicitly identifying\r\n  the stream to which the new priority applies.\r\n```",
              "createdAt": "2020-05-05T18:27:45Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NTk3OTEw",
          "commit": {
            "abbreviatedOid": "3b5c4e9"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-06T13:13:38Z",
          "updatedAt": "2020-05-06T13:13:38Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Thanks. I tweaked the suggestion slightly and made cbcdc60cf5a92. PTAL.",
              "createdAt": "2020-05-06T13:13:38Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NjY3ODky",
          "commit": {
            "abbreviatedOid": "3b5c4e9"
          },
          "author": "royfielding",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-07T17:05:05Z",
          "updatedAt": "2020-05-07T17:05:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMzk2OTEy",
          "commit": {
            "abbreviatedOid": "3b5c4e9"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-14T01:00:08Z",
          "updatedAt": "2020-05-14T01:11:16Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "0x10?",
              "createdAt": "2020-05-14T01:00:08Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 11,
              "body": "How about stating that endpoints that do not want to expose an end-to-end signal MAY omit the header field, but send the PRIORITY_UPDATE frame at an early moment assuming that it would reach the server as early as the request headers? Would could go on to explain that in such case, all the responses that the server would send would have the priority in the frame being applied.\r\n\r\nThe benefit of phrasing that way is that we can get rid of the last paragraph of this section.",
              "createdAt": "2020-05-14T01:04:23Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 91,
              "body": "Seeing the definition of the frame _headers_ for H2 was surprising to me, though I understand that it reflects the change to the HTTP/3 draft. Maybe I should ask if the change in HTTP/3 is a good thing.",
              "createdAt": "2020-05-14T01:08:39Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNDAzNDIz",
          "commit": {
            "abbreviatedOid": "3b5c4e9"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-14T01:21:41Z",
          "updatedAt": "2020-05-14T01:21:41Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "As a personal opinion I prefer to see the frame in whole because it avoids having to cross reference to the frame headers, which are defined in some other document. \r\n\r\nBut I can drop them if people want. I see that as an editorial change so perhaps we can avoid blocking this and fix up later if needs be.",
              "createdAt": "2020-05-14T01:21:41Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNDA5NzI3",
          "commit": {
            "abbreviatedOid": "3b5c4e9"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-14T01:43:01Z",
          "updatedAt": "2020-05-14T01:43:01Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "I agree that this is an editorial issue, and that we need to ask the WG to resolve (because it is about the convention covering all H2 extensions, not just this one).",
              "createdAt": "2020-05-14T01:43:01Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExODc0ODI4",
          "commit": {
            "abbreviatedOid": "3b5c4e9"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-14T14:41:04Z",
          "updatedAt": "2020-05-14T14:41:05Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "FWIW, ALTSVC is the only extension to have reached RFC status previously.  It [does not include](https://tools.ietf.org/html/rfc7838#section-4) the frame header; only the payload.",
              "createdAt": "2020-05-14T14:41:04Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExODg2OTky",
          "commit": {
            "abbreviatedOid": "3b5c4e9"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-14T14:53:09Z",
          "updatedAt": "2020-05-14T14:53:09Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "You forgot ORIGIN frame https://tools.ietf.org/html/rfc8336#section-2.1 which also specifies the frame payload.\r\n\r\nNow that H2 and H3 have different frame format definitions, I think extensions applicable to both will hit this problem. I'd like to figure what people think is the most acceptable way to present things.",
              "createdAt": "2020-05-14T14:53:09Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExODkwMjEy",
          "commit": {
            "abbreviatedOid": "3b5c4e9"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-14T14:56:09Z",
          "updatedAt": "2020-05-14T14:56:10Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "One option would be to write documents that update RFC 7838 and RFC 8336 to use the new format and define the H3 frame at the same time...",
              "createdAt": "2020-05-14T14:56:10Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyNTc5NDYw",
          "commit": {
            "abbreviatedOid": "31afbf5"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-15T11:53:22Z",
          "updatedAt": "2020-05-15T11:53:22Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I've tried to incorporate this suggestion in https://github.com/httpwg/http-extensions/pull/1167/commits/f5ac92a045a3074e503c93d304a90799e387ab07 but found it trickier to write than I first thought it would be, so it ended up a little different in the end. Please take a look and add some further suggestions if I'm not hitting your mark.",
              "createdAt": "2020-05-15T11:53:22Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyODY2NTQ2",
          "commit": {
            "abbreviatedOid": "127f149"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-15T18:15:38Z",
          "updatedAt": "2020-05-15T18:15:39Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "True, I try to block that one out.\r\n\r\nThey have different frame format definitions, sure; the question is whether the payload needs to vary between H2/H3.  I think the real things you need to specify are:\r\n\r\n- What stream it's on (part of the header in H2, intrinsic property in H3)\r\n  - Control stream vs. stream zero language plays into this\r\n- Flags if used in H2; since H3 doesn't have flags, this might lead to a payload difference\r\n- Payload\r\n\r\nThe simplest path for dual-version extensions is not to use flags and only define the payload.",
              "createdAt": "2020-05-15T18:15:38Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyOTQwNTQy",
          "commit": {
            "abbreviatedOid": "127f149"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thank you for the changes. Looks good modulo one point below.",
          "createdAt": "2020-05-15T20:17:34Z",
          "updatedAt": "2020-05-15T20:22:59Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "How about changing the last sentence to something like: _The signal carried by a PRIORITY_UPDATE frame overrides that carried by the header, even when the frame was received before the request headers._\r\n\r\nNote that this PR recommends such a behavior; it states that a server SHOULD buffer and apply the content of PRIORITY_UPDATE frame that precedes the header field. For good reasons.\r\n\r\nConsider the case of an H3 client sending a HTTP request with a Priority header field, then changing its mind and sending a PRIORITY_UPDATE frame. As H3 does not guarantee delivery order across streams, the server might receive the frame before the header. I'd assume that we'd want servers to apply the value carried by the frame. Even when the protocol is H2, I am not sure if all the H2 stacks have the guarantee that the information across multiple streams are sent in the order they are issued, or that they are provided to the application in the order they are received.",
              "createdAt": "2020-05-15T20:17:34Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MjIwNTk3",
          "commit": {
            "abbreviatedOid": "a2579e7"
          },
          "author": "bencebeky",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-21T14:54:27Z",
          "updatedAt": "2020-05-21T14:54:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NjIxOTk2",
          "commit": {
            "abbreviatedOid": "a2579e7"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-22T03:13:28Z",
          "updatedAt": "2020-05-22T03:20:21Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "The important \"when\" here is \"before prioritization information is not useful to the server\".  That might be later than when the server receives the request.",
              "createdAt": "2020-05-22T03:13:28Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 112,
              "body": "SHOULD.  I don't think that I could guarantee that this could be enforced.\r\n\r\n```suggestion\r\nthis SHOULD be treated as a connection error of type PROTOCOL_ERROR.\r\n```\r\n\r\nWell, I guess that this is the h2 variant, but still.",
              "createdAt": "2020-05-22T03:14:24Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 202,
              "body": "This needs to be qualified; if the frame contains a Push ID, then this doesn't apply.",
              "createdAt": "2020-05-22T03:16:46Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 203,
              "body": "```suggestion\r\nID that is beyond the stream limits, this SHOULD be treated as a connection error\r\n```",
              "createdAt": "2020-05-22T03:16:55Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 213,
              "body": "This one could be a MUST.",
              "createdAt": "2020-05-22T03:17:17Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 231,
              "body": "I would skip a number here and let people use the low bit of the type as a flag if they want.  Otherwise, this is a tiny bit more awkward.",
              "createdAt": "2020-05-22T03:18:10Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 91,
              "body": "```suggestion\r\n  Stream Identifier (31) = 0,\r\n```",
              "createdAt": "2020-05-22T03:18:52Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 28,
              "body": "I just have to say that this \"do not want\" statement assumes a great deal without a whole lot of support.",
              "createdAt": "2020-05-22T03:20:04Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTUyMjYz",
          "commit": {
            "abbreviatedOid": "41432cb"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-22T14:24:32Z",
          "updatedAt": "2020-05-22T14:24:33Z",
          "comments": [
            {
              "originalPosition": 213,
              "body": "hmm yeah, the current text is actually a bit nasty because it doesn't restrict PRIORITY_UPDATE to be within MAX_PUSH_ID either. Combining those factors means the client has a bit too much sway over the amount of state a server needs to hold. Let me fix both things.",
              "createdAt": "2020-05-22T14:24:32Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NzUxNTM2",
          "commit": {
            "abbreviatedOid": "e1a5f17"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-26T23:45:14Z",
          "updatedAt": "2020-05-26T23:45:15Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "paging @kazuho who suggested this text",
              "createdAt": "2020-05-26T23:45:14Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NDE2MTE3",
          "commit": {
            "abbreviatedOid": "ca71a49"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-04T13:01:33Z",
          "updatedAt": "2020-06-04T13:01:34Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "should be fixed in https://github.com/httpwg/http-extensions/pull/1167/commits/ca71a499138f646c99fc1c57a72277f2db4fc1e0",
              "createdAt": "2020-06-04T13:01:33Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4NjIyMzEz",
          "commit": {
            "abbreviatedOid": "ca71a49"
          },
          "author": "guoye-zhang",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-15T04:35:35Z",
          "updatedAt": "2020-07-15T04:35:35Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "Is it 0x1CCB8BBF1F0700/0x1CCB8BBF1F0701 or 0x10/0x11?",
              "createdAt": "2020-07-15T04:35:35Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNzE2ODk4",
          "commit": {
            "abbreviatedOid": "ca71a49"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-07T22:09:28Z",
          "updatedAt": "2020-09-07T22:09:28Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Taking the feedback received here and elsewhere, I'm reverted the diagram back to our traditional format.",
              "createdAt": "2020-09-07T22:09:28Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNzE2OTc5",
          "commit": {
            "abbreviatedOid": "ca71a49"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-07T22:10:16Z",
          "updatedAt": "2020-09-07T22:10:17Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "In HTTP/3, the value should be the long 0x1CCB8BBF1F0700/0x1CCB8BBF1F0701, I'll fix this up.",
              "createdAt": "2020-09-07T22:10:17Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MTg2MDQz",
          "commit": {
            "abbreviatedOid": "b007e93"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "@LPardue Thank you for all the work. LGTM, just editorial suggestions.",
          "createdAt": "2020-09-08T14:16:40Z",
          "updatedAt": "2020-09-08T14:30:35Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nFurthermore, clients might omit the priority request header field, using\r\n```",
              "createdAt": "2020-09-08T14:16:40Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 51,
              "body": "```suggestion\r\nheader field, even when the frame was received before the request headers.\r\n```",
              "createdAt": "2020-09-08T14:17:45Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 179,
              "body": "This is about existing text, and we can defer the decision, but I think it might be better to say \"SHOULD be buffered and be applied once the stream is opened.\"\r\n\r\nThe problem with current text is that it does deal with servers sending responses _while_ they receive requests (i.e. early response).",
              "createdAt": "2020-09-08T14:27:34Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 83,
              "body": "```suggestion\r\nrequest message has been processed. Holding PRIORITY_UPDATEs consumes extra\r\n```",
              "createdAt": "2020-09-08T14:29:19Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjA3NjE3",
          "commit": {
            "abbreviatedOid": "f441d5f"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T14:37:58Z",
          "updatedAt": "2020-09-08T14:37:58Z",
          "comments": [
            {
              "originalPosition": 179,
              "body": "Agreed that is better.",
              "createdAt": "2020-09-08T14:37:58Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MjIzNTQ5",
          "commit": {
            "abbreviatedOid": "f441d5f"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T14:54:07Z",
          "updatedAt": "2020-09-08T14:54:07Z",
          "comments": [
            {
              "originalPosition": 179,
              "body": "At first I agrred but I've thought about a downside. So I've created https://github.com/httpwg/http-extensions/issues/1260 where we can discuss separately.",
              "createdAt": "2020-09-08T14:54:07Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDI0MzYy",
          "commit": {
            "abbreviatedOid": "c45f532"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "All of these are nits except for the \"within the stream limit\" conversation on the HTTP/2 piece.  Feel free to split that to a separate issue if needed.",
          "createdAt": "2020-09-08T19:16:29Z",
          "updatedAt": "2020-09-08T20:15:41Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nidentifier. In HTTP/2, this identifier is the Stream ID; in HTTP/3, the\r\nidentifier is either the Stream ID or Push ID. Unlike the Priority header field,\r\nthe PRIORITY_UPDATE frame is a hop-by-hop signal.\r\n```\r\nA comma-splice that should be a semicolon, but the semicolon looks awkward because it's already in a semicolon-delimited clause.  Just make a new sentence, even if it needs more words.",
              "createdAt": "2020-09-08T19:16:29Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 38,
              "body": "```suggestion\r\ncan be sent even after the sending part of the request stream is being closed. This\r\n```",
              "createdAt": "2020-09-08T19:17:16Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 39,
              "body": "```suggestion\r\nalso allows the PRIORITY_UPDATE frame to be sent as soon as the stream it\r\n```",
              "createdAt": "2020-09-08T19:17:42Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nFurthermore, clients might omit the Priority request header field, using\r\n```",
              "createdAt": "2020-09-08T19:18:18Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nrequest that has not yet been opened, the server buffers the priorities\r\n```",
              "createdAt": "2020-09-08T19:19:12Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\r\ncarried by the received frame and applies them once the request arrives.\r\n```",
              "createdAt": "2020-09-08T19:19:31Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 51,
              "body": "```suggestion\r\nPriority header field, even when the frame was received before the request\r\nheaders.\r\n```",
              "createdAt": "2020-09-08T19:20:12Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nsame representation as the Priority header field value.\r\n```",
              "createdAt": "2020-09-08T19:20:59Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 78,
              "body": "What does \"within the stream limit\" mean in this case?  HTTP/2 specifies a maximum number of concurrently active streams, with streams which are either \"open\" or \"half-open\" counting toward the limit regardless of the ID.  I think what you're saying here is that you're modifying the definition of the limit to also include \"idle\" streams where priority information has been received.  However, you're not explicitly calling this out as a modification to the 7540 concurrency logic.",
              "createdAt": "2020-09-08T19:33:03Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 91,
              "body": "So the frame has both a \"Stream Identifier\" and a \"Stream ID\" field; one field has a mandatory fixed value which is a protocol violation to use in the other.  That will _never_ confuse anyone.  \ud83d\ude09\r\n\r\nA more specific name for this field might be useful.  For example, the H3 frame uses \"Prioritized Element ID,\" so perhaps \"Prioritized Stream ID\"?",
              "createdAt": "2020-09-08T19:37:27Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 107,
              "body": "```suggestion\r\nused for request streams, while PRIORITY_UPDATE with a frame type of 0xF0701 is\r\nused for push streams.\r\n```",
              "createdAt": "2020-09-08T19:40:16Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 191,
              "body": "```suggestion\r\npush stream. If a server receives a PRIORITY_UPDATE (type=0xF0701) with a Push ID\r\nthat is greater than the maximum Push ID or which has not yet been promised, this\r\nMUST be treated as a connection error of type H3_ID_ERROR.\r\n```",
              "createdAt": "2020-09-08T20:11:54Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            },
            {
              "originalPosition": 193,
              "body": "```suggestion\r\nPRIORITY_UPDATE frames of either type are only sent by clients. If a client\r\n```",
              "createdAt": "2020-09-08T20:12:12Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDgzNTcy",
          "commit": {
            "abbreviatedOid": "805e5c5"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T20:50:44Z",
          "updatedAt": "2020-09-08T20:50:45Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "I agree that \"is being opened\" is ugly. However, I think substituting it for \"arrives\" in touching on https://github.com/httpwg/http-extensions/issues/1260\r\n\r\nFor consistency with other text in this PR, how about I use \"processed\" here and we can change it again in the resolution to #1260?",
              "createdAt": "2020-09-08T20:50:44Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDg1MDcx",
          "commit": {
            "abbreviatedOid": "805e5c5"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T20:53:16Z",
          "updatedAt": "2020-09-08T20:53:16Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Yes. I spotted this when used the HTTP/3 format to describe the full HTTP/2 frame (not just the payload). In that version I called it Prioritized Stream ID to avoid the ambiguation. I'd lost that change by reverting. Thanks for spotting it.",
              "createdAt": "2020-09-08T20:53:16Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTEzNTEx",
          "commit": {
            "abbreviatedOid": "01414f5"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T21:44:24Z",
          "updatedAt": "2020-09-08T21:44:24Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "This is an important observation, thanks for catching it. I think this is a side effect of applying H3's rules naively rather than an intentional action. I'm open to phrasing this differently but I fear that the scope of the problem is actually a bit large. We probably need a little bit more thought about what it means to receive PRIORITY_UPDATES for H2 idle or closed streams. Especially given the amount of text RFC 7540 spends on describing this.\r\n\r\nPerhaps the best action is to excise the entirety of this paragraph and create an issue to track this?",
              "createdAt": "2020-09-08T21:44:24Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MDc2NjA4",
          "commit": {
            "abbreviatedOid": "01414f5"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-09T14:35:50Z",
          "updatedAt": "2020-09-09T14:35:50Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "I'd also be okay keeping it, provided there's an issue to figure out the right language in 7540-land.",
              "createdAt": "2020-09-09T14:35:50Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MDc3MjQz",
          "commit": {
            "abbreviatedOid": "01414f5"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-09T14:36:26Z",
          "updatedAt": "2020-09-09T14:36:27Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "WFM.",
              "createdAt": "2020-09-09T14:36:26Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MjM3Mjkz",
          "commit": {
            "abbreviatedOid": "01414f5"
          },
          "author": "MikeBishop",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-09T17:17:06Z",
          "updatedAt": "2020-09-09T17:17:07Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Split out as #1261.",
              "createdAt": "2020-09-09T17:17:06Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1Mjc5MTg1",
          "commit": {
            "abbreviatedOid": "01414f5"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-09T18:15:37Z",
          "updatedAt": "2020-09-09T18:15:37Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "thanks! In that case I'm intending to keep the text",
              "createdAt": "2020-09-09T18:15:37Z",
              "updatedAt": "2020-09-09T20:43:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1168,
      "id": "MDExOlB1bGxSZXF1ZXN0NDExNTIyNzEx",
      "title": "Initial priority frame",
      "url": "https://github.com/httpwg/http-extensions/pull/1168",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "This is a follow up to the PRIORITY_UPDATE tweaks in https://github.com/httpwg/http-extensions/pull/1167\r\n\r\nIn this PR we acknowledge that some people would like to use a frame to signal the initial priority, so we define a new frame INITIAL_PRIORITY that is sent on the request or push stream.\r\n\r\nI can't recall if we thought this would work for HTTP/2, so I've only defined the frame in HTTP/3. Hoping to resolve that either in this PR or in later discussion.\r\n\r\nSomething to look out for, compared to the PRIORITY_UPDATE frame, I've allowed this to be sent by either endpoint, so that it mirrors the flexibility of the header.\r\n\r\nSince having two ways to do something means that there will inevitable be an endpoint that chooses to use both signals at the same time, I've added some text to discuss it. ",
      "createdAt": "2020-04-30T13:52:54Z",
      "updatedAt": "2020-08-05T00:17:11Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "f40438f4582d1fdb5b894f382ce341686e38e7c3",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "initial-priority-frame",
      "headRefOid": "02ca4f3eccaf5d116b17eb501c9d5c92cc6073d0",
      "closedAt": "2020-05-04T13:52:00Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I overlooked the discussion on https://lists.w3.org/Archives/Public/ietf-http-wg/2020JanMar/0171.html which implied we'd be happy enough just using a PRIORITY_UPDATE frame on the control stream.\r\n\r\nClosing this PR.",
          "createdAt": "2020-05-04T13:52:00Z",
          "updatedAt": "2020-05-04T13:52:00Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 1169,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEzMzAxNzgx",
      "title": "Correct indentation in ser-dictionary",
      "url": "https://github.com/httpwg/http-extensions/pull/1169",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #1164",
      "createdAt": "2020-05-05T04:39:12Z",
      "updatedAt": "2020-05-05T05:05:17Z",
      "closedAt": "2020-05-05T05:05:15Z",
      "mergedAt": "2020-05-05T05:05:15Z",
      "mergedBy": "mnot",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDg5OTE2",
          "commit": {
            "abbreviatedOid": "0bad85e"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Looks good to me.",
          "createdAt": "2020-05-05T04:47:17Z",
          "updatedAt": "2020-05-05T04:47:35Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "This is a pre-existing issue, but remain is a bit weird as \"for each\" is typically not an operation that immediately consumes, or maybe it is in languages I'm not familiar with?",
              "createdAt": "2020-05-05T04:47:17Z",
              "updatedAt": "2020-05-05T04:47:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDk0MjYz",
          "commit": {
            "abbreviatedOid": "61d7a2a"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-05T05:05:10Z",
          "updatedAt": "2020-05-05T05:05:10Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "There's language elsewhere that says that the functions consume input.",
              "createdAt": "2020-05-05T05:05:10Z",
              "updatedAt": "2020-05-05T05:05:10Z"
            }
          ]
        }
      ],
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "fdb6fbd47bc3ac7cc113aa4ae29571a96d4649e1",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-1164",
      "headRefOid": "61d7a2aa81781f0cc0477b982b957216e16ce1ea",
      "mergeCommit": {
        "oid": "54c21f0cbf6a0cbfae51275e2a879033645f4450"
      }
    },
    {
      "number": 1171,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEzOTMzODY3",
      "title": "[Client Hints] Address Genart review comments",
      "url": "https://github.com/httpwg/http-extensions/pull/1171",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "",
      "createdAt": "2020-05-06T07:51:37Z",
      "updatedAt": "2020-05-18T07:16:32Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "54c21f0cbf6a0cbfae51275e2a879033645f4450",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "genart_review",
      "headRefOid": "4eef7debf33cf343f94f39b7d80741e49ef8bc3e",
      "closedAt": "2020-05-18T07:16:20Z",
      "mergedAt": "2020-05-18T07:16:20Z",
      "mergedBy": "yoavweiss",
      "mergeCommit": {
        "oid": "883e104baf00080b244ce9a192bad56084e430a4"
      },
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Friendly ping! :)",
          "createdAt": "2020-05-07T23:05:52Z",
          "updatedAt": "2020-05-07T23:05:52Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Friendly ping! :) PTAL?",
          "createdAt": "2020-05-18T05:44:33Z",
          "updatedAt": "2020-05-18T05:44:33Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "LGTM",
          "createdAt": "2020-05-18T07:04:56Z",
          "updatedAt": "2020-05-18T07:04:56Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for reviewing!! :)",
          "createdAt": "2020-05-18T07:16:29Z",
          "updatedAt": "2020-05-18T07:16:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4OTMxOTky",
          "commit": {
            "abbreviatedOid": "b49ede6"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-11T07:41:17Z",
          "updatedAt": "2020-05-11T07:41:17Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Here and elsewhere, markdown references are with {{ }} , not [ ] ",
              "createdAt": "2020-05-11T07:41:17Z",
              "updatedAt": "2020-05-12T12:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4OTM1MDM2",
          "commit": {
            "abbreviatedOid": "b49ede6"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-11T07:45:55Z",
          "updatedAt": "2020-05-11T07:45:55Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Here and elsewhere, changing \"user agent\" to \"client\" implies that the scope of discussion -- including requirements -- includes intermediaries as well as UAs. Is that intentional?",
              "createdAt": "2020-05-11T07:45:55Z",
              "updatedAt": "2020-05-12T12:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4OTQ5Mjg0",
          "commit": {
            "abbreviatedOid": "4e04359"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-11T08:07:07Z",
          "updatedAt": "2020-05-11T08:07:07Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "That's a good point, I haven't considered intermediaries. One of the points raised in the review was to align on either \"client\" or \"user agent\". I guess it'd be more appropriate to align on the latter.",
              "createdAt": "2020-05-11T08:07:07Z",
              "updatedAt": "2020-05-12T12:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4OTUwMDI5",
          "commit": {
            "abbreviatedOid": "4e04359"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-11T08:08:18Z",
          "updatedAt": "2020-05-11T08:08:19Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Changed",
              "createdAt": "2020-05-11T08:08:19Z",
              "updatedAt": "2020-05-12T12:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4OTU4NDA0",
          "commit": {
            "abbreviatedOid": "5c2cae3"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-11T08:20:23Z",
          "updatedAt": "2020-05-11T08:20:23Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Aligned on user agent. Let me know if that works",
              "createdAt": "2020-05-11T08:20:23Z",
              "updatedAt": "2020-05-12T12:27:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1172,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE5NDQ5MjIw",
      "title": "Default urgency is 3",
      "url": "https://github.com/httpwg/http-extensions/pull/1172",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "When we discussed removing the semantics of urgency levels, we also\r\nthought it would be a good idea to change the default from 1 to 3.\r\n\r\nWe agreed to do this and landed a change that removed the semantic\r\ntext but unfortunately forgot to also change the default.\r\n\r\nThis change simple fixes the oversight.",
      "createdAt": "2020-05-18T11:50:00Z",
      "updatedAt": "2020-05-18T12:01:00Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7710d3caf643b8d1a54eb7fc0938a2c33ac392d2",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "priority-default-is-3",
      "headRefOid": "3aaeda952f626f00e931064f68fea750c644177e",
      "closedAt": "2020-05-18T12:00:59Z",
      "mergedAt": "2020-05-18T12:00:59Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "6a03eea1a43b32e19058ff618dd57477f23d2c0e"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See https://github.com/httpwg/http-extensions/issues/1026#issuecomment-582776695 for background",
          "createdAt": "2020-05-18T11:51:08Z",
          "updatedAt": "2020-05-18T11:51:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzNTIzODky",
          "commit": {
            "abbreviatedOid": "3aaeda9"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for the fix!",
          "createdAt": "2020-05-18T11:57:53Z",
          "updatedAt": "2020-05-18T11:57:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1173,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxMTU5MjMz",
      "title": "Allow Lists and Dictionaries to be delimited by OWS",
      "url": "https://github.com/httpwg/http-extensions/pull/1173",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "From Magnus's feedback",
      "createdAt": "2020-05-21T05:32:58Z",
      "updatedAt": "2020-06-04T04:25:32Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c23df1c8fa5e0eb09070d5a8d43b00678f4c0c2f",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-sf-tablists",
      "headRefOid": "d2b407f8eda0e1ac69e4196b0a429b57fe62f754",
      "closedAt": "2020-05-21T23:32:04Z",
      "mergedAt": "2020-05-21T23:32:04Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "aebe6eac02b909b9ffba3771cbbef1b534dddc28"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "also @clelland PTAL",
          "createdAt": "2020-05-21T05:33:10Z",
          "updatedAt": "2020-05-21T05:33:10Z"
        },
        {
          "author": "kaduk",
          "authorAssociation": "NONE",
          "body": "This does not instill much of a panicked reaction in me, which is probably a good sign.\r\nI trust it is intentional to not apply a similar treatment to inner lists (which also has a prose description I had commented on previously) on the grounds of them not resembling existing top-level header field structures?  That's certainly defensible, though I have to wonder whether someone will simply assume that it must be the same (not that we have much hope of changing such a person's behavior).",
          "createdAt": "2020-05-21T05:50:05Z",
          "updatedAt": "2020-05-21T05:50:05Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "How does this vibe with #998? I know we spent a bit of time on it, but it's long enough ago that I can't recall detail.",
          "createdAt": "2020-05-21T06:03:13Z",
          "updatedAt": "2020-05-21T06:03:13Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, right, I think I remember. Doing it this way means inner-list is different:\r\n\r\n~~~\r\ninner-list = \"(\" *SP [ sf-item *( 1*SP sf-item ) *SP ] \")\"\r\n             *parameter\r\n~~~\r\n\r\nThe original motivation to remove tabs was because the above was going to be\r\n\r\n~~~\r\n  \"(\" OWS [ sf-item *( RWS sf-item ) OWS ] \")\"\r\n~~~\r\n\r\nbut there was consternation about RWS. Most of the discussion is in #983 ",
          "createdAt": "2020-05-21T06:12:51Z",
          "updatedAt": "2020-05-21T06:12:51Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@phluid61 #988 was where my mind went first too, but that seems to be just about in inner lists (which makes sense). I think this is separate; intermediaries that don't know about the semantics and syntactic limitations of a given field shouldn't be meddling inside it (which inner list delimitation is).",
          "createdAt": "2020-05-21T07:45:26Z",
          "updatedAt": "2020-05-21T07:45:26Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke, I think so -- that's the only reason to allow this. Existing servers may already legitimately be using TAB when combining multiple field lines. And I suppose it makes sense, given the recent discussion about not breaking up individual list or dictionary members over multiple lines, that we don't need to replace *SP with OWS everywhere.\r\n\r\nI'm okay with this change -- does it warrant a note in the prose somewhere that this special case only exists to accommodate field concatenation?\r\n\r\n> Note that it says \"comma an optional whitespace\", not \"OWS\". Depending on how you read it, it might include other whitespace characters. I believe this needs to be fixed in the Semantics spec.\r\n\r\nLet's hope we don't need to add VTAB or FF to this, too :)\r\n\r\n",
          "createdAt": "2020-05-21T13:30:42Z",
          "updatedAt": "2020-05-21T13:30:42Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@reschke I don't know that that's necessary; we already [define whitespace](https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#whitespace) pretty clearly.\r\n\r\nIn SF, I looked at changing \"whitespace\", but in each case the ABNF and algorithms make it clear what we're talking about, so I don't see a strong need to disambiguate.",
          "createdAt": "2020-05-21T23:30:36Z",
          "updatedAt": "2020-05-21T23:30:36Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm ok with the change over here; that said, the Semantics spec could be clearer. Opened https://github.com/httpwg/http-core/issues/370.",
          "createdAt": "2020-05-22T03:02:29Z",
          "updatedAt": "2020-05-22T03:02:29Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@bsdphk and I have been talking about this, and have come to the conclusion that this change went too far. \r\n\r\nSpecifically, steps 1 and 5 in \"Parsing Structured Fields\" should just be SP, not OWS, because there isn't any risk of an intermediary inserting TAB before the first field line or after the last field line; it's only between List and Dictionary members that we need to be concerned.\r\n\r\nReverting that part of the change also makes writing the test cases considerably simpler.\r\n\r\nSee 6842793e. \r\n",
          "createdAt": "2020-06-04T04:25:32Z",
          "updatedAt": "2020-06-04T04:25:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1OTAyMzIy",
          "commit": {
            "abbreviatedOid": "d2b407f"
          },
          "author": "bsdphk",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I dont think I ever saw a TAB in a HTTP header in real life, but I am OK with this.",
          "createdAt": "2020-05-21T06:13:00Z",
          "updatedAt": "2020-05-21T06:13:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1OTM0MTc1",
          "commit": {
            "abbreviatedOid": "d2b407f"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-21T07:26:09Z",
          "updatedAt": "2020-05-21T07:26:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1OTQ5MDI5",
          "commit": {
            "abbreviatedOid": "d2b407f"
          },
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-21T07:54:42Z",
          "updatedAt": "2020-05-21T07:54:42Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MDgxNDE0",
          "commit": {
            "abbreviatedOid": "d2b407f"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This is so that field line combination as per the Semantics spec can happen, right?\r\n\r\nI note that <https://greenbytes.de/tech/webdav/draft-ietf-httpbis-semantics-latest.html#field.order> currently says:\r\n\r\n> A recipient MAY combine multiple field lines with the same field name into one field line, without changing the semantics of the message, by appending each subsequent field line value to the initial field line value in order, separated by a comma and optional whitespace. For consistency, use comma SP.\r\n\r\nNote that it says \"comma an optional whitespace\", not \"OWS\". Depending on how you read it, it might include other whitespace characters. I *believe* this needs to be fixed in the Semantics spec.",
          "createdAt": "2020-05-21T11:46:06Z",
          "updatedAt": "2020-05-21T11:46:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1175,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIyOTA1ODY0",
      "title": "Initial commit of message-signatures-00 draft, converted to Markdown.",
      "url": "https://github.com/httpwg/http-extensions/pull/1175",
      "state": "MERGED",
      "author": "richanna",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "Version -00 was published to the data tracker from an XML file. This is the first conversion to Markdown and commit to the WG repo. No changes to semantics, only minor formatting changes due to the conversion.",
      "createdAt": "2020-05-25T21:46:45Z",
      "updatedAt": "2020-06-29T13:38:15Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9e2bb280faa05fb9b7af494287ef5f5ce19bdb77",
      "headRepository": "richanna/http-extensions",
      "headRefName": "master",
      "headRefOid": "d5660b286070d185db5c92bff26ed5611633c249",
      "closedAt": "2020-06-28T17:53:12Z",
      "mergedAt": "2020-06-28T17:53:12Z",
      "mergedBy": "jricher",
      "mergeCommit": {
        "oid": "1d12d66824b0898c8c9b243e013cba80ab66ff93"
      },
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yahoo :) ",
          "createdAt": "2020-06-29T13:38:14Z",
          "updatedAt": "2020-06-29T13:38:14Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NDUwMjI5",
          "commit": {
            "abbreviatedOid": "d5660b2"
          },
          "author": "jricher",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-26T16:03:36Z",
          "updatedAt": "2020-05-26T16:03:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NjQ2NTI3",
          "commit": {
            "abbreviatedOid": "d5660b2"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-05-26T20:16:14Z",
          "updatedAt": "2020-05-26T20:16:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1199,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIzMTMxNTMx",
      "title": "digest-headers: remove non-ASCII characters from prose",
      "url": "https://github.com/httpwg/http-extensions/pull/1199",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers",
        "editorial"
      ],
      "body": "(inserted with https://github.com/httpwg/http-extensions/commit/4178324c374fd1e75acda09df6d7b2afb232de07)",
      "createdAt": "2020-05-26T10:53:18Z",
      "updatedAt": "2020-05-26T13:36:37Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9e2bb280faa05fb9b7af494287ef5f5ce19bdb77",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-digest-non-ascii",
      "headRefOid": "02861561f29fa00cf1aa2f19d9b427505cb913de",
      "closedAt": "2020-05-26T13:36:33Z",
      "mergedAt": "2020-05-26T13:36:33Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "022620b3a03f0f6520cf1d1186f4e273abfe587b"
      },
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the editorial work @reschke ! ",
          "createdAt": "2020-05-26T13:36:36Z",
          "updatedAt": "2020-05-26T13:36:36Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 1200,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIzMTM1Nzk2",
      "title": "rfc6265bis: fix broken internal links",
      "url": "https://github.com/httpwg/http-extensions/pull/1200",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-05-26T11:02:30Z",
      "updatedAt": "2020-05-26T11:49:14Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9e2bb280faa05fb9b7af494287ef5f5ce19bdb77",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-cookie-broken-links",
      "headRefOid": "51fef0350f7458b4af614daa1b1533813178379c",
      "closedAt": "2020-05-26T11:49:13Z",
      "mergedAt": "2020-05-26T11:49:13Z",
      "mergedBy": "mikewest",
      "mergeCommit": {
        "oid": "68b78457dabe97e9bbedd687ee1cbc3a4089cac0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4MjE5NjA2",
          "commit": {
            "abbreviatedOid": "51fef03"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM!",
          "createdAt": "2020-05-26T11:49:00Z",
          "updatedAt": "2020-05-26T11:49:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1201,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIzMTcyOTk2",
      "title": "header-structure: rephrase sentence in list parsing section",
      "url": "https://github.com/httpwg/http-extensions/pull/1201",
      "state": "CLOSED",
      "author": "undef1nd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "As I find this sentence from `Parsing a List` and `Parsing a Dictionary` sections a bit confusing, here's how I'd rephrase it.",
      "createdAt": "2020-05-26T12:24:34Z",
      "updatedAt": "2020-10-05T06:01:06Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "68b78457dabe97e9bbedd687ee1cbc3a4089cac0",
      "headRepository": "undef1nd/http-extensions",
      "headRefName": "header-structure-minor-change",
      "headRefOid": "7cb1c3835d0d46fb36e8f53e567f4f13f3e58116",
      "closedAt": "2020-10-05T06:01:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1202,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIzMTc3OTU2",
      "title": "digest-headers: use recommended reference format",
      "url": "https://github.com/httpwg/http-extensions/pull/1202",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers",
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-05-26T12:35:03Z",
      "updatedAt": "2020-05-26T13:35:23Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "68b78457dabe97e9bbedd687ee1cbc3a4089cac0",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-dh-semref",
      "headRefOid": "61d6f0a1ff939e11e89294e42c027f44c51370ce",
      "closedAt": "2020-05-26T13:35:22Z",
      "mergedAt": "2020-05-26T13:35:21Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "3ed2cc9c5a1cec9f6f9a03073e7c4d3b956fda8b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 1212,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1OTQ4MzU2",
      "title": "Fix __Host prefix example wording",
      "url": "https://github.com/httpwg/http-extensions/pull/1212",
      "state": "MERGED",
      "author": "danielgustafsson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis"
      ],
      "body": "Add what seems to be a missing word in the __Host example text.",
      "createdAt": "2020-06-01T12:27:14Z",
      "updatedAt": "2020-07-31T21:22:48Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d522c9ba75d7ac355c122276f5d801111cfc1fc0",
      "headRepository": "danielgustafsson/http-extensions",
      "headRefName": "dg-tyops",
      "headRefOid": "abe35eed1f31a59055c059933d3ca70dfe6ba910",
      "closedAt": "2020-07-24T06:56:07Z",
      "mergedAt": "2020-07-24T06:56:07Z",
      "mergedBy": "mikewest",
      "mergeCommit": {
        "oid": "a01b9d4abb116685fdad1061fd2f7ce6335c0748"
      },
      "comments": [
        {
          "author": "danielgustafsson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks!",
          "createdAt": "2020-07-31T21:22:48Z",
          "updatedAt": "2020-07-31T21:22:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NjY3NjQw",
          "commit": {
            "abbreviatedOid": "abe35ee"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2020-07-24T06:56:01Z",
          "updatedAt": "2020-07-24T06:56:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1213,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI2MDAwNjc1",
      "title": "Fix: #850. Support for parameters.",
      "url": "https://github.com/httpwg/http-extensions/pull/1213",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\ndefines a way to pass parameters to be used for digest computation.\r\n\r\n## It's done\r\n\r\nTaking into account the fact that RFC3230 references parameter in the definition of `instance-digest` https://tools.ietf.org/html/rfc3230#section-4.2\r\n\r\nConsidering that being `digest-algorithm` just a token,  we can't add parameters to it.\r\n\r\n```\r\nThis second example shows an hypotetical `bikeshed` digest algorithm using\r\ntwo parameters: `bs` and `offset`.\r\n\r\n~~~ example\r\n    bikeshed=8E9q0okq; bs=8; offset=2\r\n~~~\r\n```\r\n\r\n## Note\r\n\r\nfixes #850 ",
      "createdAt": "2020-06-01T14:03:14Z",
      "updatedAt": "2020-10-26T03:55:39Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d522c9ba75d7ac355c122276f5d801111cfc1fc0",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-850-digest-parameter",
      "headRefOid": "01b76af4d8112fa8238b709200fc6efc26f479ab",
      "closedAt": "2020-09-27T10:13:48Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This could work for passing parameters for mi-sha256 too. WDYT?",
          "createdAt": "2020-06-01T14:05:20Z",
          "updatedAt": "2020-06-01T14:05:20Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke is this syntax supported in structured-fields?",
          "createdAt": "2020-06-30T15:44:29Z",
          "updatedAt": "2020-06-30T15:44:29Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for this. I didn't notice before that Instance digest defined parameters as part of the digest-algorithm. As you point out, since digest-algorithm is defined as token, it seems wrong to say it can have a parameter. This proposal makes it clear that the parameters are part of the representation-data-digest and I support this. \r\n\r\nI'd be keen to get input from others on if they believe this is the intention of Digest parameters - do we know of any parameters used in the wild?\r\n\r\nI'm less concerned about the structured fields question since we are just documenting a legacy HTTP field.",
          "createdAt": "2020-06-30T16:16:34Z",
          "updatedAt": "2020-06-30T16:16:34Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe this really needs more motivation that the fact that RFC 3230 mentioned it in one sentence, and failed to define it properly.\r\n\r\nWhat's the use case?",
          "createdAt": "2020-06-30T16:43:02Z",
          "updatedAt": "2020-06-30T16:43:02Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue @reschke  I don't know of any parameter in the wild, but removing that will deviate from RFC 3230.\r\n\r\nIf we do that, we should explicit:\r\n\r\n- that we will deprecate that feature (eg. because parameters can make things less secure);\r\n- that parameters are forbidden;\r\n- that if you want to use a parameterized algorithm you should encode their values  in the digest-value and take care of the security considerations inside the definition of your digest-algorithm;\r\n\r\n~~~\r\nbikeshed=bs=8|offset=2|8E9q0okq\r\n~~~\r\n\r\n",
          "createdAt": "2020-06-30T19:53:01Z",
          "updatedAt": "2020-06-30T19:53:01Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Discussion should probably be on the issue, not the PR...",
          "createdAt": "2020-06-30T23:36:20Z",
          "updatedAt": "2020-06-30T23:36:20Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closed in favor of #1259 ",
          "createdAt": "2020-09-27T10:13:48Z",
          "updatedAt": "2020-09-27T10:13:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMTY4NTk4",
          "commit": {
            "abbreviatedOid": "c4f7def"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-30T16:04:55Z",
          "updatedAt": "2020-06-30T16:04:56Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nThis second example shows a hypothetical `bikeshed` digest algorithm using\r\n```",
              "createdAt": "2020-06-30T16:04:56Z",
              "updatedAt": "2020-06-30T16:10:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMTc4OTIx",
          "commit": {
            "abbreviatedOid": "01b76af"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-30T16:16:47Z",
          "updatedAt": "2020-06-30T16:16:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1219,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI4MjE3MTI4",
      "title": "Remove useless section",
      "url": "https://github.com/httpwg/http-extensions/pull/1219",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "priorities"
      ],
      "body": "",
      "createdAt": "2020-06-05T04:40:39Z",
      "updatedAt": "2020-07-08T17:42:28Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "252fcefe23107a60b11439bba129ccc4b76fe808",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "considerations-wat",
      "headRefOid": "3e134c0b18ffdcce35fea01d22f9818240fa2730",
      "closedAt": "2020-07-08T17:42:23Z",
      "mergedAt": "2020-07-08T17:42:23Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "6be5ead90c20fb13a818cf65e5badeacec911df3"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks",
          "createdAt": "2020-07-08T17:42:28Z",
          "updatedAt": "2020-07-08T17:42:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTkyMTUx",
          "commit": {
            "abbreviatedOid": "3e134c0"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-08T17:41:46Z",
          "updatedAt": "2020-07-08T17:41:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1220,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1Njk3OTQ0",
      "title": "[Client Hints] AD review comments",
      "url": "https://github.com/httpwg/http-extensions/pull/1220",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-17T08:44:44Z",
      "updatedAt": "2020-07-03T12:03:16Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "252fcefe23107a60b11439bba129ccc4b76fe808",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "client_hints_ad_review",
      "headRefOid": "ad874a8c5b3514df945421f1f9643781f7fa9d3d",
      "closedAt": "2020-07-03T12:03:10Z",
      "mergedAt": "2020-07-03T12:03:10Z",
      "mergedBy": "yoavweiss",
      "mergeCommit": {
        "oid": "b68e4ff766828bc23093753ddee9f48dbd69fe8e"
      },
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mnot - PTAL",
          "createdAt": "2020-06-26T12:43:52Z",
          "updatedAt": "2020-06-26T12:43:52Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Magnus' comment makes me wonder if we should mention that CH's that want to use Accept-CH need to have a field name that matches sf-token; possibly in the Deployment and Security Risks section.\r\n\r\nAdded \"A Client Hints request header negotiated using the Accept-CH opt-in mechanism MUST have a field name that matches sf-token (Section 3.3.4 of {{!I-D.ietf-httpbis-header-structure}}).\"",
          "createdAt": "2020-07-03T11:58:23Z",
          "updatedAt": "2020-07-03T11:58:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNjc2OTU3",
          "commit": {
            "abbreviatedOid": "34c4bec"
          },
          "author": "kaduk",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-17T18:44:31Z",
          "updatedAt": "2020-06-17T19:05:52Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "One of my colleagues has noted (elsewhere) that in some cases double negatives are confusing, and in general it's worth trying out a positive statement as an alternative to see if it works.  So, in this case, that might be \"user agents SHOULD require opt-in to send any hints that are not listed in the low-entropy hint table\".",
              "createdAt": "2020-06-17T18:44:31Z",
              "updatedAt": "2020-07-03T11:57:14Z"
            },
            {
              "originalPosition": 149,
              "body": "Thanks, this is a good way to frame the subsequent discussion to keep the relevant topics prominent.",
              "createdAt": "2020-06-17T19:05:43Z",
              "updatedAt": "2020-07-03T11:57:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMTY0MTI0",
          "commit": {
            "abbreviatedOid": "34c4bec"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T10:49:28Z",
          "updatedAt": "2020-06-18T10:49:29Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Done",
              "createdAt": "2020-06-18T10:49:28Z",
              "updatedAt": "2020-07-03T11:57:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMTY0Mzcx",
          "commit": {
            "abbreviatedOid": "34c4bec"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T10:49:52Z",
          "updatedAt": "2020-06-18T10:49:52Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "Thanks! :)",
              "createdAt": "2020-06-18T10:49:52Z",
              "updatedAt": "2020-07-03T11:57:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NjY2MjQx",
          "commit": {
            "abbreviatedOid": "ca921fd"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "LGTM.\r\n\r\nMagnus' comment makes me wonder if we should mention that CH's that want to use Accept-CH need to have a field name that matches sf-token; possibly in the Deployment and Security Risks section.",
          "createdAt": "2020-06-27T02:47:43Z",
          "updatedAt": "2020-06-27T02:47:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1223,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQyMTA2MzE0",
      "title": "\"identity\" is not a valid field value for \"Content-Encoding\"",
      "url": "https://github.com/httpwg/http-extensions/pull/1223",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "(it only exists in Accept-Encoding)",
      "createdAt": "2020-06-30T15:22:35Z",
      "updatedAt": "2020-07-01T10:53:02Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1d12d66824b0898c8c9b243e013cba80ab66ff93",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-digest-encoding-identity",
      "headRefOid": "2fb1cfcc7cec96fd4295ab76a9bb488f955a2dc9",
      "closedAt": "2020-07-01T10:53:00Z",
      "mergedAt": "2020-07-01T10:53:00Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "e8cfa0db6a702b7e74b6814b6b40c6f26638cd5d"
      },
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi Julian, thanks for your review! \r\n\r\nReading https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#field.content-encoding I understand that the `content-coding` allowed values are defined in this table https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#rfc.section.6.1.2.p.5\r\n\r\nReading the [`Accept-Encoding`](https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#field.accept-encoding) it seems that `identity` shouldn't be on that list, but iiuc it's there.\r\nIdeas?\r\n",
          "createdAt": "2020-06-30T15:40:40Z",
          "updatedAt": "2020-06-30T15:43:21Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "not that it is a canonical source of reference but the MDN article is also a bit weird wrt identity https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding",
          "createdAt": "2020-06-30T16:00:07Z",
          "updatedAt": "2020-06-30T16:00:07Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's in the registry because it has a special meaning in Accept-Encoding, and thus can not ever be defined as actual encoding.\r\n\r\nAnd yes, the comment in the registry table could be clearer.",
          "createdAt": "2020-06-30T16:33:57Z",
          "updatedAt": "2020-06-30T16:33:57Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke can we \"fix\" the Semantics document before changing Digest?",
          "createdAt": "2020-06-30T16:36:56Z",
          "updatedAt": "2020-06-30T16:36:56Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see why one is a precondition for the other...\r\n\r\n-> https://github.com/httpwg/http-core/issues/388",
          "createdAt": "2020-06-30T16:38:22Z",
          "updatedAt": "2020-06-30T16:39:35Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we are sure that there's an issue in semantics, it's ok. LGTM",
          "createdAt": "2020-07-01T10:50:38Z",
          "updatedAt": "2020-07-01T10:50:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNzYwNzY5",
          "commit": {
            "abbreviatedOid": "2fb1cfc"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "As per rfc7231, identity is only valid in Accept-Encoding",
          "createdAt": "2020-07-01T10:52:21Z",
          "updatedAt": "2020-07-01T10:52:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1224,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ2NDA4NzAx",
      "title": "move Fairness and client scheduling to top level",
      "url": "https://github.com/httpwg/http-extensions/pull/1224",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #1217 and #1218.\r\n\r\nI've left Security Consideration as TBD, I'll fill that out in a separate PR.",
      "createdAt": "2020-07-08T18:20:16Z",
      "updatedAt": "2020-07-13T00:23:40Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6be5ead90c20fb13a818cf65e5badeacec911df3",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "lucas/priority-fairbump",
      "headRefOid": "cf6962f96174d8a6cc48f05b8c7c9ee4d9ed9047",
      "closedAt": "2020-07-13T00:23:39Z",
      "mergedAt": "2020-07-13T00:23:38Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "9fbfa86e5bd10b61fe431282c0bf75a58e08ca6b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTIyMTQ4",
          "commit": {
            "abbreviatedOid": "cf6962f"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T00:04:19Z",
          "updatedAt": "2020-07-13T00:04:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1225,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ2NDM0MTUw",
      "title": "Rough in priorities security concerns",
      "url": "https://github.com/httpwg/http-extensions/pull/1225",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Since fairness is being moved out of security considerations, (https://github.com/httpwg/http-extensions/pull/1224) it makes the section empty.\r\n\r\nSeems reasonable to add some prose about the considerations of this scheme as compared to HTTP/2. However, this also depends on the outcome of the reprioritization discussion, so I'm being a little weasly with TBD and TODOs.\r\n\r\nMight want to just hold onto this for a while but WDYT @kazuho ?",
      "createdAt": "2020-07-08T19:15:30Z",
      "updatedAt": "2020-07-13T00:43:18Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9fbfa86e5bd10b61fe431282c0bf75a58e08ca6b",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "lucas/priority-seccon",
      "headRefOid": "f3098afbb624359444fe64fdebde3ffae2aad419",
      "closedAt": "2020-07-13T00:43:17Z",
      "mergedAt": "2020-07-13T00:43:17Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "9072bf1f0cc44a682e714dcf0896472f77732747"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTIyNTY4",
          "commit": {
            "abbreviatedOid": "8360f39"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thank you for working on this. LGTM modulo the point below.",
          "createdAt": "2020-07-13T00:08:23Z",
          "updatedAt": "2020-07-13T00:08:38Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Should this \"could\" be something like \"is required to\"?\r\n\r\nOr maybe, \"would be required to ... depending on how the clients use the PRIORITY_UPDATE frames\".",
              "createdAt": "2020-07-13T00:08:23Z",
              "updatedAt": "2020-07-13T00:28:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTI0MTA4",
          "commit": {
            "abbreviatedOid": "8360f39"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-13T00:22:34Z",
          "updatedAt": "2020-07-13T00:22:35Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I think simply \"is required to\" is the most straightforward thing for now. We can revisit when we circle back on the TODOs after reprioritization chat.\r\n",
              "createdAt": "2020-07-13T00:22:35Z",
              "updatedAt": "2020-07-13T00:28:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1226,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3ODY1MDAy",
      "title": "digest-headers: fix HTTP Semantics references",
      "url": "https://github.com/httpwg/http-extensions/pull/1226",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(for -09)",
      "createdAt": "2020-07-12T07:48:33Z",
      "updatedAt": "2020-07-13T18:57:30Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6be5ead90c20fb13a818cf65e5badeacec911df3",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-1",
      "headRefOid": "599ebb3e32363ff1a0b2804946f04aa3d643ed3a",
      "closedAt": "2020-07-13T18:57:29Z",
      "mergedAt": "2020-07-13T18:57:29Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "2ac69d32eb017af0bb86ff8593b1885cfead8956"
      },
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @reschke !",
          "createdAt": "2020-07-13T18:57:14Z",
          "updatedAt": "2020-07-13T18:57:14Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTIxMDk0",
          "commit": {
            "abbreviatedOid": "599ebb3"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-12T23:53:21Z",
          "updatedAt": "2020-07-12T23:53:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1235,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU2NTI1OTAz",
      "title": "Incorporating WG feedback",
      "url": "https://github.com/httpwg/http-extensions/pull/1235",
      "state": "MERGED",
      "author": "richanna",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "- Strengthened requirement for content identifiers for header fields to be lower-case (changed from SHOULD to MUST).\r\n- Relaxed guidance on processing Creation Time and Expiration Time to only require verifiers to examine them and test against the verifier\u2019s requirements.\r\n- Minor editorial corrections and readability improvements.\r\n\r\nResolves #1187, resolves #1188 ",
      "createdAt": "2020-07-24T23:14:24Z",
      "updatedAt": "2020-10-01T19:26:33Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a01b9d4abb116685fdad1061fd2f7ce6335c0748",
      "headRepository": "richanna/http-extensions",
      "headRefName": "master",
      "headRefOid": "97576096de20e9272e7752a98e6ba1b9a33d30bb",
      "closedAt": "2020-10-01T19:26:33Z",
      "mergedAt": "2020-10-01T19:26:33Z",
      "mergedBy": "jricher",
      "mergeCommit": {
        "oid": "ec43ebf7444441b4640a0f56d89ef331d5a46715"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NTM0NTM2",
          "commit": {
            "abbreviatedOid": "b60a4cd"
          },
          "author": "jricher",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-10T19:55:57Z",
          "updatedAt": "2020-08-10T19:55:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5MjExNDcw",
          "commit": {
            "abbreviatedOid": "b60a4cd"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I'd split the clock-skew part in a separate PR. The rest LGTM.",
          "createdAt": "2020-08-18T10:54:58Z",
          "updatedAt": "2020-08-18T10:55:43Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "I would split this passage in a separate PR and provide considerations. The rest LGTM.",
              "createdAt": "2020-08-18T10:54:59Z",
              "updatedAt": "2020-10-01T19:24:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNjUxNDEx",
          "commit": {
            "abbreviatedOid": "b60a4cd"
          },
          "author": "jricher",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T19:24:37Z",
          "updatedAt": "2020-10-01T19:24:37Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nA signature with a Creation Time that is in the future or an Expiration Time that is in the past MUST NOT be processed.  \r\n```",
              "createdAt": "2020-10-01T19:24:37Z",
              "updatedAt": "2020-10-01T19:24:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNjUxOTY4",
          "commit": {
            "abbreviatedOid": "9757609"
          },
          "author": "jricher",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-01T19:25:21Z",
          "updatedAt": "2020-10-01T19:25:22Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Done, now available in #1280 as a starting point",
              "createdAt": "2020-10-01T19:25:22Z",
              "updatedAt": "2020-10-01T19:25:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1236,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU3MjE3NjA3",
      "title": "Move empty cookie-name and empty cookie-value check from 5.3 to 5.4",
      "url": "https://github.com/httpwg/http-extensions/pull/1236",
      "state": "MERGED",
      "author": "DCtheTall",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes [#1234](https://github.com/httpwg/http-extensions/issues/1234).",
      "createdAt": "2020-07-27T14:55:35Z",
      "updatedAt": "2020-07-28T15:41:17Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a01b9d4abb116685fdad1061fd2f7ce6335c0748",
      "headRepository": null,
      "headRefName": "empty-name-empty-value",
      "headRefOid": "84f3551a2502c3c2b8c8f2232468e6565ca1d534",
      "closedAt": "2020-07-28T15:41:17Z",
      "mergedAt": "2020-07-28T15:41:17Z",
      "mergedBy": "mikewest",
      "mergeCommit": {
        "oid": "05573367e5f6cadf776afde48e137e2eacf477f7"
      },
      "comments": [
        {
          "author": "DCtheTall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> a changelog entry in a new -07 section\r\n\r\nDone",
          "createdAt": "2020-07-28T15:22:35Z",
          "updatedAt": "2020-07-28T15:22:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NzM4NjMz",
          "commit": {
            "abbreviatedOid": "9ce873b"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM % a changelog entry in a new -07 section like https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-06#appendix-A.7. Thanks!",
          "createdAt": "2020-07-28T15:14:07Z",
          "updatedAt": "2020-07-28T15:14:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NzU1Mjkw",
          "commit": {
            "abbreviatedOid": "fa08d65"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Minor change so that we won't break \"links\" if ordering changes, and to explain the change.",
          "createdAt": "2020-07-28T15:31:52Z",
          "updatedAt": "2020-07-28T15:32:18Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "```suggestion\r\n*  Moved instruction to ignore cookies with empty cookie-name and cookie-value\r\n   from {{set-cookie}} to {{storage-model}} to ensure that they apply to cookies\r\n   created without parsing a cookie string.\r\n```",
              "createdAt": "2020-07-28T15:31:52Z",
              "updatedAt": "2020-07-28T15:38:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NzU3NzU0",
          "commit": {
            "abbreviatedOid": "10f2331"
          },
          "author": "DCtheTall",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-28T15:34:34Z",
          "updatedAt": "2020-07-28T15:34:35Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Done.",
              "createdAt": "2020-07-28T15:34:34Z",
              "updatedAt": "2020-07-28T15:38:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1239,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYyNTMxOTQ4",
      "title": "Collapse TLS errors down to two.",
      "url": "https://github.com/httpwg/http-extensions/pull/1239",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #1227.",
      "createdAt": "2020-08-04T05:09:34Z",
      "updatedAt": "2020-08-11T02:22:31Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a8e1cdd7ceeb07c2c078629447e4a0ba10de9a05",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-1227",
      "headRefOid": "04284da1b9d4a155b82968342bfbeb80f35df23e",
      "closedAt": "2020-08-11T02:22:30Z",
      "mergedAt": "2020-08-11T02:22:30Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "1e62b7a358791f877b822a50e40f1791b9635bfa"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "PTAL @PiotrSikora @sleevi @davidben ",
          "createdAt": "2020-08-04T05:10:39Z",
          "updatedAt": "2020-08-04T05:10:39Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Looks reasonable to me! \ud83d\udc4d",
          "createdAt": "2020-08-06T02:05:17Z",
          "updatedAt": "2020-08-06T02:05:17Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@PiotrSikora PTAL; I'll merge tomorrow if I don't hear anything.",
          "createdAt": "2020-08-06T02:07:25Z",
          "updatedAt": "2020-08-06T02:07:25Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@PiotrSikora how do you distinguish between a proxy certificate and the certificate used for the next hop?",
          "createdAt": "2020-08-07T02:04:37Z",
          "updatedAt": "2020-08-07T02:04:37Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @PiotrSikora how do you distinguish between a proxy certificate and the certificate used for the next hop?\r\n\r\nBy \"proxy certificate\" I mean the certificate sent by the CDN (when acting as a client) to the origin server for the purpose of mutual authentication.\r\n\r\nIn contrast, `tls_certificate_error` would apply (at least in my mind) only to the certificate presented by the origin server.",
          "createdAt": "2020-08-07T02:19:03Z",
          "updatedAt": "2020-08-07T02:19:03Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "So, I think the argument is that `missing_proxy_certificate` is either a `tls_error_received` (i.e., the server you're connecting to gave you an error to the effect that you need to present a client certificate), or a `proxy_configuration_error` (i.e., you realised you need to present a certificate before connecting, but don't have one) depending on exactly how the error occurred. Is that sufficient?",
          "createdAt": "2020-08-07T02:57:13Z",
          "updatedAt": "2020-08-07T02:57:13Z"
        },
        {
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As someone who spent countless hours debugging connection issues to various origin servers, my main concern is that `tls_certificate_error` alone doesn't provide enough information as to why the connection failed, it only narrows it down to a TLS certificate issue, but for anything definitive that you would want to share with the customer, you'd still need to go and dig further into logs, or try to replicate the issue. Yes, I know that you could put more information in the \"details\" field, but I'm not a big fan of implementation-specific free-form text.\r\n\r\nHaving said that, I'm not going to oppose if you prefer to have only those 3 generic fields.",
          "createdAt": "2020-08-07T09:55:47Z",
          "updatedAt": "2020-08-07T09:55:47Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks. As Ryan points out, the problem is that implementations have different terminology and granularity of error reporting, and it's not the place of this specification to impose that on them.",
          "createdAt": "2020-08-11T02:21:39Z",
          "updatedAt": "2020-08-11T02:21:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDI3ODM1",
          "commit": {
            "abbreviatedOid": "d422fa7"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-04T17:36:27Z",
          "updatedAt": "2020-08-04T17:36:28Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "So in looking in context, this error stands out as being the only one that explicitly mentions `details`, which might cause some confusion. For example, `http_protocol_error` doesn't mention `details`, yet you use so as part of the illustrative example.\r\n\r\nFor what it's worth, you *could* split this into two: `tls_protocol_error` and `tls_certificate_error`. The former indicates something went wrong with the TLS protocol (which could include both handshake and ongoing use), while the latter indicates an error while verifying the certificate (for which `details` is useful). Similar to `http_protocol_error`, it serves as both the fallback (e.g. if the proxy doesn't expose certificate errors distinct from TLS errors and treats them just as handshake errors) and as a distinct state (errors sending that may not result in a peer alert - e.g. if it receives a malformed message *from* the peer)",
              "createdAt": "2020-08-04T17:36:28Z",
              "updatedAt": "2020-08-11T02:21:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyMTM3NTEx",
          "commit": {
            "abbreviatedOid": "414581c"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-06T02:03:23Z",
          "updatedAt": "2020-08-06T02:03:23Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Thanks, that's helpful. PTAL.",
              "createdAt": "2020-08-06T02:03:23Z",
              "updatedAt": "2020-08-11T02:21:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyOTg2NDQ5",
          "commit": {
            "abbreviatedOid": "414581c"
          },
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Sorry for the delay!\r\n\r\nTo be honest, I prefer the list suggested by @davidben, since this is pretty non-descriptive for an informational / debug header.",
          "createdAt": "2020-08-07T01:56:20Z",
          "updatedAt": "2020-08-07T02:00:57Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Would this be sent instead of `http_response_incomplete`, for example?",
              "createdAt": "2020-08-07T01:56:21Z",
              "updatedAt": "2020-08-11T02:21:00Z"
            },
            {
              "originalPosition": 44,
              "body": "I think this should still stay, since it applies to proxy certificate.",
              "createdAt": "2020-08-07T01:56:57Z",
              "updatedAt": "2020-08-11T02:21:00Z"
            },
            {
              "originalPosition": 51,
              "body": "I think this should still stay, since it applies to proxy certificate...\r\n\r\nAlthough, this could probably be reported as `tls_error_received ` in TLS 1.3.",
              "createdAt": "2020-08-07T01:57:55Z",
              "updatedAt": "2020-08-11T02:21:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyOTg5NDEw",
          "commit": {
            "abbreviatedOid": "414581c"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-07T02:06:44Z",
          "updatedAt": "2020-08-07T02:06:45Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Possibly, depending on how the implementation works. Note that we have an open issue regarding guidance for generating appropriate error codes.",
              "createdAt": "2020-08-07T02:06:44Z",
              "updatedAt": "2020-08-11T02:21:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMTg3NTQy",
          "commit": {
            "abbreviatedOid": "414581c"
          },
          "author": "PiotrSikora",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-07T09:56:24Z",
          "updatedAt": "2020-08-07T09:56:25Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Nit: `tls_alert_received` would be technically more correct.",
              "createdAt": "2020-08-07T09:56:24Z",
              "updatedAt": "2020-08-11T02:21:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzA0OTg3",
          "commit": {
            "abbreviatedOid": "414581c"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-11T02:20:59Z",
          "updatedAt": "2020-08-11T02:20:59Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Done.",
              "createdAt": "2020-08-11T02:20:59Z",
              "updatedAt": "2020-08-11T02:21:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1242,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY2MjY1ODU5",
      "title": "Fix typos.",
      "url": "https://github.com/httpwg/http-extensions/pull/1242",
      "state": "MERGED",
      "author": "PiotrSikora",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Signed-off-by: Piotr Sikora <piotrsikora@google.com>",
      "createdAt": "2020-08-11T18:03:57Z",
      "updatedAt": "2020-08-11T23:38:24Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9300074e9498eab0a7c56436654a76c305e83081",
      "headRepository": "PiotrSikora/http-extensions",
      "headRefName": "proxy_status-typos",
      "headRefOid": "23c524aaf2be1971e2d622084351145672eec9af",
      "closedAt": "2020-08-11T23:38:23Z",
      "mergedAt": "2020-08-11T23:38:23Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "e2756751a3db99fe3cf9a88648b2e58481584235"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2020-08-11T23:38:13Z",
          "updatedAt": "2020-08-11T23:38:13Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 1243,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY2ODA5ODAw",
      "title": "Remove requirement to clear Client Hint preferences on browser history clear",
      "url": "https://github.com/httpwg/http-extensions/pull/1243",
      "state": "OPEN",
      "author": "amtunlimited",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Fix: #1238 \r\n\r\n@yoavweiss \r\n@igrigorik \r\n@davidben ",
      "createdAt": "2020-08-12T14:29:56Z",
      "updatedAt": "2020-10-12T23:19:52Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a3c00db173ed74703dd0d0b6d16d72add63cd761",
      "headRepository": "amtunlimited/http-extensions",
      "headRefName": "ch-delete-better",
      "headRefOid": "b235271cbae0e586037a725f2b82930fa1b80ea9",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "amtunlimited",
          "authorAssociation": "NONE",
          "body": "Adjusted scope of change because the Client Hints proposal is further along in the process than I realized",
          "createdAt": "2020-08-13T12:22:46Z",
          "updatedAt": "2020-08-13T12:22:46Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This LGTM based on the discussion in #1238\r\n\r\n@mnot - thoughts on landing this at this point? Note that https://github.com/httpwg/http-extensions/pull/1282 means we'd probably need to republish a draft anyway.",
          "createdAt": "2020-10-05T09:52:57Z",
          "updatedAt": "2020-10-05T09:52:57Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "I think you can do both of these changes in AUTH48, but you should send an e-mail to the list giving folks a heads-up first. Note that because the draft is now at the RFC Editor, publishing a new revision probably isn't going to help.",
          "createdAt": "2020-10-06T03:15:01Z",
          "updatedAt": "2020-10-06T03:15:01Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Am 06.10.2020 um 05:15 schrieb Mark Nottingham:\n> I think you can do both of these changes in AUTH48, but you should send\n> an e-mail to the list giving folks a heads-up first. Note that because\n> the draft is now at the RFC Editor, publishing a new revision probably\n> isn't going to help.\n> ...\n\nFWIW, and IMHO, publishing a new version is more transparent, and *will*\nwork if the RPC hasn't started editing yet, and if the AD is ok with it.\n\nBest regards, Julian\n",
          "createdAt": "2020-10-06T06:43:07Z",
          "updatedAt": "2020-10-06T06:43:07Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 1245,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY4NzYxNDI3",
      "title": "Fix: #1215. HTTP/1.1 messaging is not normative anymore.",
      "url": "https://github.com/httpwg/http-extensions/pull/1245",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\n- HTTP 1.1 messaging is not normative\r\n- replaced \"message body\" with a periphrases",
      "createdAt": "2020-08-17T11:06:57Z",
      "updatedAt": "2020-08-17T13:17:57Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "a3c00db173ed74703dd0d0b6d16d72add63cd761",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1215",
      "headRefOid": "311c3ad4acb3dd398d7f0c968012b3d599be3f81",
      "closedAt": "2020-08-17T13:17:41Z",
      "mergedAt": "2020-08-17T13:17:41Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "4cae37ed353d51bf797beeae4f42f2e20314969a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MzgwOTgz",
          "commit": {
            "abbreviatedOid": "311c3ad"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-17T11:27:02Z",
          "updatedAt": "2020-08-17T11:27:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1246,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY4ODMzMzQ0",
      "title": "digest-headers: Fix typos, add changelog.",
      "url": "https://github.com/httpwg/http-extensions/pull/1246",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nfixes typos, add changelog",
      "createdAt": "2020-08-17T13:30:03Z",
      "updatedAt": "2020-08-17T13:32:20Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4cae37ed353d51bf797beeae4f42f2e20314969a",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-fix-typo-1",
      "headRefOid": "67f1d72e645e7f143deb754da013378ff559b4b6",
      "closedAt": "2020-08-17T13:32:19Z",
      "mergedAt": "2020-08-17T13:32:19Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "5af1520b6f163d3601178a1249f2213c0bd3469d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 1247,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY4ODUxMTM2",
      "title": "Fix: #884. multiple transfer coding",
      "url": "https://github.com/httpwg/http-extensions/pull/1247",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\n- explicits that digest does not depend from multiple transfer coding",
      "createdAt": "2020-08-17T13:59:39Z",
      "updatedAt": "2020-08-18T09:08:45Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5af1520b6f163d3601178a1249f2213c0bd3469d",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-884-bis",
      "headRefOid": "10cb171a4cb99c8935e2e0d6f7c04102bc7337b8",
      "closedAt": "2020-08-18T09:08:43Z",
      "mergedAt": "2020-08-18T09:08:43Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "7f9bcd3f446d4bceabfa0ebdf7805af1209d4f1b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5MTM1Nzc4",
          "commit": {
            "abbreviatedOid": "10cb171"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-18T09:07:40Z",
          "updatedAt": "2020-08-18T09:07:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1248,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY4OTQwNDAz",
      "title": "Fix: #970. Digest semantic depends on method.",
      "url": "https://github.com/httpwg/http-extensions/pull/1248",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nClarifies why digest semantic on requests depends on the underlying method semantic and can't be generalized on all methods.\r\n\r\nThe clarification is added in the FAQ.\r\n\r\nFixes: #970 ",
      "createdAt": "2020-08-17T16:38:26Z",
      "updatedAt": "2020-09-09T10:50:51Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "54472b0c7e9f1c66dbef5bf79b8db00c7e058e39",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-970",
      "headRefOid": "c5752448d3e70cf3465b8dc43b4cdbf9aa202b2a",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Clarifies why digest semantic on requests depends on the underlying method semantic and can't be generalized on all methods.\r\n\r\nTo me, that is the opposite of what needs to be done. The semantics of \"Digest\" in a request should always be the same.\r\n\r\nIf would be good to understand *why* you want to make Digest depend on the method.\r\n",
          "createdAt": "2020-08-18T10:03:47Z",
          "updatedAt": "2020-08-18T10:03:47Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Forewords: thanks Julian for all the time you are spending on this spec! I really appreciate it!\r\n\r\n> No.\r\n> Digest should not depend on the method\r\n> The semantics of \"Digest\" in a request should always be the same.\r\n\r\nCan you provide some normative references in SEMANTICS which forbids to create a method or a mechanism conveying a partial representation in a request? It would be really useful :) \r\n\r\n> [..] HTTP spec explicitly forbids (PUT + Range)\r\n\r\nlet it be an `UPDATE` method which conveys a partial representation instead of a patch-document. \r\nProbably the proliferation of different ways of updating resources via partial representations and the (mis)use of Content-MD5 by goog, amz & co requires some attention from us.\r\n\r\n> why you want to make Digest depend on the method\r\n\r\nDigest does not depend directly on the method, but on the SEMANTICS (which may depend on the method).\r\nimho stating that Digest in request just depends on the payload body is not in line with RFC3230 spirit.",
          "createdAt": "2020-08-18T10:34:14Z",
          "updatedAt": "2020-08-18T10:35:46Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Can you provide some normative references in SEMANTICS which forbids to create a method or a mechanism conveying a partial representation in a request? It would be really useful :)\r\n\r\nOf course a method can carry a partial representation. What I'm saying is that even when it does, a Digest request header field would *still* reflect the contents of the payload, in this case the partial payload.\r\n\r\n> Digest does not depend directly on the method, but on the SEMANTICS (which may depend on the method).\r\nimho stating that Digest in request just depends on the payload body is not in line with RFC3230 spirit.\r\n\r\nBut a recipient has no idea about the \"semantics\" of new methods, thus the behavior would essentially be undefined. How is that useful?\r\n\r\nCan wou please provide a *concrete* example where you would want the Digest request header field *not* to refer to the payload, whatever it is?\r\n\r\n(FWIW, the \"spirit\" of RFC 3230 is really irrelevant here unless you can demonstrate that it's actually useful and deployable; revising specs includes cleaning them up)\r\n",
          "createdAt": "2020-08-18T10:41:28Z",
          "updatedAt": "2020-08-18T10:41:28Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There seems to be some similarity to the discussion on CONNECT-UDP at https://github.com/httpwg/http-core/issues/436. What I mean by this is that special-casing things based on methods can be difficult, and that examples are based on legacy behaviours, which we'd rather not encourage any further.\r\n\r\nIf I understand Julien's point (and I might not!), then a spec that has text which says \"you can do anything\" doesn't help the implementers of Digest today. If there is no actionable advice, then the text has dubious value. Therefore it is better to leave this unwritten and allow someone with an actual case to come along later and describe what is required.",
          "createdAt": "2020-08-24T11:51:31Z",
          "updatedAt": "2020-08-24T11:51:31Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Trying to clarify.\r\n\r\nThe spec needs to state what the Digest header field means on *any* request and response. We can't leave that open.\r\n\r\n(And, FWIW, I haven't seen *any* argument in favor of special-casing methods - if there is one, we should discuss it!)\r\n",
          "createdAt": "2020-08-24T12:11:24Z",
          "updatedAt": "2020-08-24T12:11:24Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The spec needs to state what the Digest header field means on any request and response. We can't leave that open.\r\n\r\nI agree. It is up to some future proposal to make the argument for special case behaviour.",
          "createdAt": "2020-08-26T12:56:24Z",
          "updatedAt": "2020-08-26T12:56:24Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the issue name is misleading, as:\r\n\r\n- digest semantic is always the same: digest is computed on the selected resource representation data;\r\n- digest computation depends on method;\r\n\r\nStating that on requests, digest should always be computed on the payload body effectively *alters* digest semantic depending on request and response.\r\n\r\n",
          "createdAt": "2020-09-09T10:20:18Z",
          "updatedAt": "2020-09-09T10:20:18Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Stating that on requests, digest should always be computed on the payload body effectively alters digest semantic depending on request and response.\r\n\r\nSo what do you think the digest *should* refer to in request?",
          "createdAt": "2020-09-09T10:30:50Z",
          "updatedAt": "2020-09-09T10:50:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5MTM0MzMw",
          "commit": {
            "abbreviatedOid": "aac2d05"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T09:05:52Z",
          "updatedAt": "2020-08-18T09:05:53Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n   This [discussion is not trivial](https://github.com/httpwg/http-extensions/pull/923).\r\n   When using POST and PATCH the representation-digest is computed on the payload body but\r\n   this is because of the semantics of those methods. However, other method semantics can vary.\r\n   For example, a hypothetical method where the request body contains a partial representation\r\n   would behave differently, and it's Digest would be computed on the complete representation data.\r\n   An example of such a hypothetical use case would be a resumable upload mechanism \r\n   implemented with PUT + Content-Range, such as\r\n   [this one](https://cloud.google.com/storage/docs/performing-resumable-uploads#resume-upload).\r\n```\r\n\r\njust some editorializing",
              "createdAt": "2020-08-18T09:05:52Z",
              "updatedAt": "2020-08-26T15:38:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5MTQzMzAx",
          "commit": {
            "abbreviatedOid": "aac2d05"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T09:17:32Z",
          "updatedAt": "2020-08-18T09:17:32Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "No. \r\n\r\nThe Digest shoult not depend on the method. And giving an example of something that the HTTP spec explicitly forbids (PUT + Range) doesn't make it better.",
              "createdAt": "2020-08-18T09:17:32Z",
              "updatedAt": "2020-08-26T15:38:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5MTk1OTkx",
          "commit": {
            "abbreviatedOid": "5b1c524"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T10:31:03Z",
          "updatedAt": "2020-08-18T10:31:04Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "See https://github.com/httpwg/http-extensions/pull/1248#issuecomment-675400978",
              "createdAt": "2020-08-18T10:31:03Z",
              "updatedAt": "2020-08-26T15:38:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1249,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5Mzk1NTEz",
      "title": "Fix: #968. Clarifications on Want-Digest.",
      "url": "https://github.com/httpwg/http-extensions/pull/1249",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nclarifies that no normative parts were added to Want-Digest, only examples.",
      "createdAt": "2020-08-18T10:42:36Z",
      "updatedAt": "2020-08-24T14:04:59Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7f9bcd3f446d4bceabfa0ebdf7805af1209d4f1b",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-978",
      "headRefOid": "835468dcab13ed0a4b3c9a4f100e3121d8c2cefe",
      "closedAt": "2020-08-24T14:04:58Z",
      "mergedAt": "2020-08-24T14:04:58Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "329e18637883cb47be248f4ef52f175a1f0770b5"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm I think the issue might have conflated two things. 1) We are deprecating use of the MD5 algorithm in digests (including want-digest with `md5` 2) We are deprecating the use of content-MD5 as described in https://tools.ietf.org/html/rfc3230#section-5. I think we should expand the `deprecate-contentMD5` section a little to explicitly state what want-digest with `contentMD5` means in this draft i.e. is it ignored?. It's easy to confuse these things with the current text.",
          "createdAt": "2020-08-18T12:51:29Z",
          "updatedAt": "2020-08-18T12:52:28Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think we should expand the `deprecate-contentMD5` section a little\r\n> to explicitly state what want-digest with `contentMD5` means in this draft i.e. is it ignored?\r\n\r\nTo me the implementor is free to ignore or error on  contentMD5: OTOH it's an unregistered algorithm.\r\nWe could just reserve that word to avoid that to be registered, but I don't like this kind of entries lingering around (eg. see https://github.com/httpwg/http-core/issues/388 )\r\n\r\nre-reading the draft, I found the message quite clear: forget md5 and all that relates to it.\r\n\r\n\r\n",
          "createdAt": "2020-08-18T16:08:20Z",
          "updatedAt": "2020-08-18T16:08:20Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We could just reserve that word to avoid that to be registered, but I don't like this kind of entries lingering around \r\n\r\nHaving the value in the registry makes a lot of sense, because that's what people are supposed to look up. It should just make clear that it's deprecated.\r\n\r\n>  (eg. see httpwg/http-core#388 )\r\n\r\nThat's IMHO a bit misleading as \"identity\" is not a real content-coding.",
          "createdAt": "2020-08-18T16:22:01Z",
          "updatedAt": "2020-08-18T16:22:01Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My interpretation is different than Roberto's; RFC3230 registers the value `contentMD5` for use in `want-digest`, and only `want-digest`.\r\n\r\n```\r\n   First, we add to the set of digest-algorithm values (in section\r\n   4.1.1) the token \"contentMD5\", with the provision that this digest-\r\n   algorithm MUST NOT be used in a Digest header field.\r\n```\r\n\r\nthen\r\n\r\n```\r\n  The presence of the \"contentMD5\" digest-algorithm with a non-zero\r\n   qvalue in a Want-Digest header field indicates that the sender wishes\r\n   to receive a Content-MD5 header on messages associated with the\r\n   Request-URI.\r\n```\r\n\r\nso a client sending `want-digest: contentMD5;q=1` is asking for the server to provide a `Content-MD5` in the response, independent of the `Digest`. That `contentMD5` is missing from any registry seems like an oversight.\r\n\r\nIn the meantime, RFC 7231 has deprecated Content-MD5 and says:\r\n\r\n```\r\n   The Content-MD5 header field has been removed because it was\r\n   inconsistently implemented with respect to partial responses.\r\n```\r\n\r\nSo the right thing to do, I think, is to register this as an obsolete digest-algorithm. Whether that needs to be a `SHOULD NOT be used in Want-Digest and MUST NOT be used in Digest`, or a MUST NOT in both (probably unenforceable) I don't know.\r\n\r\n",
          "createdAt": "2020-08-18T17:24:37Z",
          "updatedAt": "2020-08-18T17:24:37Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "1- I'll register the algorithm in the table and mark it as Obsolete\r\n2- PTAL https://github.com/httpwg/http-extensions/pull/1249/files#r472865789",
          "createdAt": "2020-08-19T08:48:13Z",
          "updatedAt": "2020-08-19T08:48:13Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue \r\n\r\n> So the right thing to do, I think, is to register this as an obsolete digest-algorithm. Whether that needs to be a SHOULD NOT be used in Want-Digest and MUST NOT be used in Digest, or a MUST NOT in both (probably unenforceable) I don't know.\r\n\r\n\r\n@reschke \r\n>Having the value in the registry makes a lot of sense\r\n\r\nDone :) ",
          "createdAt": "2020-08-24T08:32:19Z",
          "updatedAt": "2020-08-24T08:33:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwMjQ5NDEz",
          "commit": {
            "abbreviatedOid": "4f5378a"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-19T08:45:41Z",
          "updatedAt": "2020-08-19T08:45:41Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n[RFC7231].\r\nThe `contentMD5` token defined in Section 5 of [RFC3230] MUST NOT be used as a digest-algorithm.\r\n```",
              "createdAt": "2020-08-19T08:45:41Z",
              "updatedAt": "2020-08-24T14:03:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMjIyODY0",
          "commit": {
            "abbreviatedOid": "f8389f6"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T08:29:36Z",
          "updatedAt": "2020-08-24T08:29:37Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "```suggestion\r\n   To clarify that `Digest` and `Want-Digest` can be used in both requests and responses\r\n```",
              "createdAt": "2020-08-24T08:29:36Z",
              "updatedAt": "2020-08-24T14:03:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczMzk4ODI1",
          "commit": {
            "abbreviatedOid": "b52fc3d"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-24T12:02:17Z",
          "updatedAt": "2020-08-24T12:02:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNTIwMzM4",
          "commit": {
            "abbreviatedOid": "b52fc3d"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T14:03:26Z",
          "updatedAt": "2020-08-24T14:03:27Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nThis memo adds the \"contentMD5\" token in the [HTTP Digest Algorithm\r\n```",
              "createdAt": "2020-08-24T14:03:27Z",
              "updatedAt": "2020-08-24T14:03:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1253,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc0MDIwMzAy",
      "title": "Fix: #1211. Prefer lowercase digest-algorithm names.",
      "url": "https://github.com/httpwg/http-extensions/pull/1253",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\n- use lowercase for digest-algoritms in the doc\r\n- case is unchanged when referring to the actual algorithms (eg. SHA-1)\r\n- prefer lowercase for digest-algorithms\r\n- update IANA table to use lowercase digest-algorithms\r\n\r\n## Note\r\n\r\ndigest-algorithms remain case insensitive\r\n\r\nFixes #1211 Discussion here https://lists.w3.org/Archives/Public/ietf-http-wg/2020JulSep/0119.html",
      "createdAt": "2020-08-26T16:27:56Z",
      "updatedAt": "2020-09-07T15:24:00Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "87eccb57825cd0822a2025cbe0f8c0c1365eb6c8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "1211-lowercase-algorithms",
      "headRefOid": "11c0c7678a5f9da687172a6036055ef3c6d154a2",
      "closedAt": "2020-09-07T15:23:58Z",
      "mergedAt": "2020-09-07T15:23:58Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "6455201fb9de8368d10f431ead91f792700aa3d8"
      },
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @manger could you please take a look at this PR?",
          "createdAt": "2020-08-26T16:34:27Z",
          "updatedAt": "2020-08-26T16:34:27Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I made one comment on what I thought was an inconsistency in use of uppercase or not. After further reading I think there are other instances where the editorial rule - uppercase for actual algorithm, lowercase for digest-algorithm (or token?), is hard to rationalise about because the document seems to interchangeably use \"algorithm\", \"digest algorithm\" and \"digest-algorithm\". In order to land this change I think we need to solve that editorial problem. Part of what would help that is to state our algorithm editorial rules in the terminology.",
          "createdAt": "2020-08-27T12:33:42Z",
          "updatedAt": "2020-08-27T12:33:42Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> state our algorithm editorial rules in the terminology\r\n\r\n+1. After this PR we should have that:\r\n\r\n- digest algorithms are *always* referred as digest-algorithms, and the associated tokens are always double-quoted, eg \r\n\r\n```\r\nthe \"sha\" digest-algorithm\r\n```\r\n\r\n- for the other cases, we use the algorithm word with the  same casing used in referenced spec\r\n\r\n```\r\nthe SHA-1 algorithm\r\n```\r\n\r\nimho the actual document does not contain instruction which can mislead implementors.",
          "createdAt": "2020-08-27T12:46:56Z",
          "updatedAt": "2020-09-07T13:03:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1Njg4MTUw",
          "commit": {
            "abbreviatedOid": "2f8f2d8"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-26T17:04:12Z",
          "updatedAt": "2020-08-26T17:04:12Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "@LPardue iiuc we forgot to mention the update of UNIX*sum",
              "createdAt": "2020-08-26T17:04:12Z",
              "updatedAt": "2020-09-07T13:57:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1Njk3NjI3",
          "commit": {
            "abbreviatedOid": "2f8f2d8"
          },
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-26T17:16:48Z",
          "updatedAt": "2020-08-26T17:17:24Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "TBH, I'm not sure how a SHOULD is justified here. This is not using SF syntax, so why does it matter?",
              "createdAt": "2020-08-26T17:16:48Z",
              "updatedAt": "2020-09-07T13:57:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NDkyMzMz",
          "commit": {
            "abbreviatedOid": "2f8f2d8"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T08:21:15Z",
          "updatedAt": "2020-08-27T08:21:16Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Which is a sensible way to signal we want to transition to lowercase and in future releases of Digest we may want to switch to SF ?",
              "createdAt": "2020-08-27T08:21:15Z",
              "updatedAt": "2020-09-07T13:57:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTIzODkz",
          "commit": {
            "abbreviatedOid": "2f8f2d8"
          },
          "author": "manger",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T09:02:20Z",
          "updatedAt": "2020-08-27T09:02:21Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "typo: unencrypted",
              "createdAt": "2020-08-27T09:02:21Z",
              "updatedAt": "2020-09-07T13:57:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTI3OTg3",
          "commit": {
            "abbreviatedOid": "2f8f2d8"
          },
          "author": "manger",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T09:07:44Z",
          "updatedAt": "2020-08-27T09:07:45Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Looks ok.\r\nGiven the labels are being changed to lowercase it might be good to add to the note on the IANA page https://www.iana.org/assignments/http-dig-alg/http-dig-alg.xhtml: \"Digest algorithm names are case-insensitive\"",
              "createdAt": "2020-08-27T09:07:44Z",
              "updatedAt": "2020-09-07T13:57:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTI4MDA5",
          "commit": {
            "abbreviatedOid": "2f8f2d8"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T09:07:46Z",
          "updatedAt": "2020-08-27T09:07:46Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "fixed on master, thanks!",
              "createdAt": "2020-08-27T09:07:46Z",
              "updatedAt": "2020-09-07T13:57:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTU5NjEx",
          "commit": {
            "abbreviatedOid": "336095d"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T09:48:57Z",
          "updatedAt": "2020-08-27T09:48:58Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "@manger imho as algorithms are case-insensitive since RFC3230 you can already add the note to the page: do you need any action on my side for that?",
              "createdAt": "2020-08-27T09:48:58Z",
              "updatedAt": "2020-09-07T13:57:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NjY2Nzg3",
          "commit": {
            "abbreviatedOid": "336095d"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T12:24:44Z",
          "updatedAt": "2020-08-27T12:24:44Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Unfortunately due to the overloading of algorithm and the way this section is structured, the lowercasing of these values seems inconsistent with your stated aims. A few ways to fix this come to mind:\r\n\r\n1) Unwind the change and leave them as uppercase\r\n2) \r\n\r\n```\r\nthe \"md5\" token MUST NOT be used due to collision attacks in the MD5 algorithm [link], the \"sha\" token MUST NOT be used due to collision attacks [link]\r\n```\r\n\r\n3) \r\n```\r\nthe MD5 algorithm (token \"md5\") MUST NOT be used ...\r\n```\r\n\r\nI have a slight preference for option 1.",
              "createdAt": "2020-08-27T12:24:44Z",
              "updatedAt": "2020-09-07T13:57:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NjY5NDcw",
          "commit": {
            "abbreviatedOid": "336095d"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T12:28:17Z",
          "updatedAt": "2020-08-27T12:28:17Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "For consistency, probably just easier to do these as separate items, even if it means the text is more verbose.",
              "createdAt": "2020-08-27T12:28:17Z",
              "updatedAt": "2020-09-07T13:57:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2Njg5OTg1",
          "commit": {
            "abbreviatedOid": "336095d"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T12:54:40Z",
          "updatedAt": "2020-08-27T12:54:41Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I interpreted the following as digest-algorithms because the sentence starts with\r\n\r\n> Some algorithms, although registered\r\n\r\nRewording like below should fix imho\r\n\r\n> Some digest-algorithms, although registered\r\n\r\nOTOH to reference algorithm names instead of tokens, we should use SHA-1\r\n\r\n```suggestion\r\nthe MD5 algorithm MUST NOT be used due to collision attacks [CMU-836068]\r\nand the SHA-1 algorithm MUST NOT be used due\r\n```\r\n\r\n\r\n",
              "createdAt": "2020-08-27T12:54:40Z",
              "updatedAt": "2020-09-07T13:57:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNTc4MTY0",
          "commit": {
            "abbreviatedOid": "11c0c76"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-07T13:59:37Z",
          "updatedAt": "2020-09-07T13:59:37Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "@reschke I used `preferred`. WDYT?",
              "createdAt": "2020-09-07T13:59:37Z",
              "updatedAt": "2020-09-07T13:59:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNTc4NTQ1",
          "commit": {
            "abbreviatedOid": "11c0c76"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-07T14:00:16Z",
          "updatedAt": "2020-09-07T14:00:17Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Avoid repetitions.",
              "createdAt": "2020-09-07T14:00:17Z",
              "updatedAt": "2020-09-07T14:00:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNjIxMjMz",
          "commit": {
            "abbreviatedOid": "11c0c76"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-07T15:08:08Z",
          "updatedAt": "2020-09-07T15:08:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1254,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc0NjgzNjkw",
      "title": "Remove references to \"validator fields\"",
      "url": "https://github.com/httpwg/http-extensions/pull/1254",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nRemoves reference to validators as their use is now inferred from http spec.",
      "createdAt": "2020-08-27T12:59:13Z",
      "updatedAt": "2020-08-27T13:06:09Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "17051ff04f9570ed7983a764348b2c04e9b08892",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-936-bis",
      "headRefOid": "9a08812a1718e74e8e0d03d17156556e7ebdfdbd",
      "closedAt": "2020-08-27T13:06:08Z",
      "mergedAt": "2020-08-27T13:06:08Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "2c56984393f9119e93153cdc6c2a4bf8d18a4e0f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 1255,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc2Mjg1MjM0",
      "title": "Always use digest-algorithm (with dash). See #1211.",
      "url": "https://github.com/httpwg/http-extensions/pull/1255",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\n- is preliminary to #1253 \r\n\r\nConsistently use `digest-algorithm` instead of `digest algorithm`.  In case we need to further focus on the value, we can say `digest-algorithm value` or `digest-algorithm token`.\r\n\r\nLooking at \"content-coding\" vs \"content coding\" in https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html I think that this choice makes the document more readable.",
      "createdAt": "2020-08-31T13:04:51Z",
      "updatedAt": "2020-09-07T12:49:14Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "9e8176b00290ae93a936b65baf5147b7a1bb9096",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "1211-algorithm-editorial",
      "headRefOid": "7e7c2d091aa52d657baba3606037234f7f031ac0",
      "closedAt": "2020-09-07T12:49:13Z",
      "mergedAt": "2020-09-07T12:49:13Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "87eccb57825cd0822a2025cbe0f8c0c1365eb6c8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4NTk4Njk5",
          "commit": {
            "abbreviatedOid": "e77efb8"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-31T13:10:00Z",
          "updatedAt": "2020-08-31T13:10:01Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "If we want to reference the crypto algorithm, SHA-1 is the right name.\r\n\r\nGenerally, with this statement we explicitly forbid using SHA-1 and MD5 based digest-algorithms, even if not listed here (that is: a future  multihash digest-algorithm with https://github.com/multiformats/multicodec/blob/master/table.csv#L71)",
              "createdAt": "2020-08-31T13:10:01Z",
              "updatedAt": "2020-09-07T09:45:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4NjAxOTU5",
          "commit": {
            "abbreviatedOid": "e77efb8"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-31T13:14:00Z",
          "updatedAt": "2020-08-31T13:14:00Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "@LPardue here and below, we could replace `digest-algorithm` with `entry`",
              "createdAt": "2020-08-31T13:14:00Z",
              "updatedAt": "2020-09-07T09:45:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNDkzMDYz",
          "commit": {
            "abbreviatedOid": "7e7c2d0"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-07T11:47:29Z",
          "updatedAt": "2020-09-07T11:55:58Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Based on your other PR, I think this would be lower case md5 and sha?",
              "createdAt": "2020-09-07T11:47:29Z",
              "updatedAt": "2020-09-07T11:55:58Z"
            },
            {
              "originalPosition": 82,
              "body": "Based on your other PR, lowercase again?",
              "createdAt": "2020-09-07T11:48:00Z",
              "updatedAt": "2020-09-07T11:55:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNTI2NTI2",
          "commit": {
            "abbreviatedOid": "7e7c2d0"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-07T12:42:54Z",
          "updatedAt": "2020-09-07T12:42:54Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "I split the PRs:\r\n\r\n- #1256  lowercased only the *new* digest algorithms because that doesn't update anything;\r\n- this will consistently use digest-algorithm\r\n- the last PR will lowercase existing algorithms name.",
              "createdAt": "2020-09-07T12:42:54Z",
              "updatedAt": "2020-09-07T12:42:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNTI3NTk0",
          "commit": {
            "abbreviatedOid": "7e7c2d0"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-07T12:44:36Z",
          "updatedAt": "2020-09-07T12:44:37Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Makes sense, please proceed \ud83d\ude42",
              "createdAt": "2020-09-07T12:44:37Z",
              "updatedAt": "2020-09-07T12:44:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNTI3NzMz",
          "commit": {
            "abbreviatedOid": "7e7c2d0"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-07T12:44:50Z",
          "updatedAt": "2020-09-07T12:44:50Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNTMwMTYz",
          "commit": {
            "abbreviatedOid": "7e7c2d0"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-07T12:48:39Z",
          "updatedAt": "2020-09-07T12:48:39Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "will be lowercased by the other PR but not in this one.",
              "createdAt": "2020-09-07T12:48:39Z",
              "updatedAt": "2020-09-07T12:48:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1256,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgxMTc0MTg1",
      "title": "Digest: editorial work (quoting, casing, ..)",
      "url": "https://github.com/httpwg/http-extensions/pull/1256",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nAdds more consistent editorial rules:\r\n\r\n- headers are always backticked to ease readability\r\n- qvalue is quoted like in SEMANTICS\r\n- new digest-algorithms are quoted like content codings in SEMANTICS",
      "createdAt": "2020-09-07T08:18:19Z",
      "updatedAt": "2020-09-07T15:50:01Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7ff98196a9dad193c98c438117852f11f271fb7c",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "1211-editorial-1",
      "headRefOid": "eba9c533de7d4ba6fa49bed032661e409363fca4",
      "closedAt": "2020-09-07T08:55:01Z",
      "mergedAt": "2020-09-07T08:55:01Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "c5bae89d0dc6016d3908f95823853d79d6ca9f84"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 1257,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgxMjIwMDYz",
      "title": "We forgot to align this part with the SHA-1 deprecation.",
      "url": "https://github.com/httpwg/http-extensions/pull/1257",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nAligns a part of the doc with the SHA-1 deprecation we decided in #1020 \r\n\r\n## Note\r\n\r\nWe correctly deprecated SHA-1 but in this part we left it as NOT RECOMMENDED.",
      "createdAt": "2020-09-07T09:23:53Z",
      "updatedAt": "2020-09-07T15:50:02Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "c5bae89d0dc6016d3908f95823853d79d6ca9f84",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1020-ter",
      "headRefOid": "38a07ca6593e528533c6bbdcefee72dd5bfadcae",
      "closedAt": "2020-09-07T09:28:37Z",
      "mergedAt": "2020-09-07T09:28:37Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "9e8176b00290ae93a936b65baf5147b7a1bb9096"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 1258,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgxNTA3MjMz",
      "title": "Align missing digest-algorithm parts. See #1211",
      "url": "https://github.com/httpwg/http-extensions/pull/1258",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\n- editorial fix of digest-algorithms\r\n",
      "createdAt": "2020-09-07T15:57:01Z",
      "updatedAt": "2020-09-07T15:57:31Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6455201fb9de8368d10f431ead91f792700aa3d8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1211-bis",
      "headRefOid": "a4893e65f893a4972bd5355d91faa1108de50245",
      "closedAt": "2020-09-07T15:57:30Z",
      "mergedAt": "2020-09-07T15:57:30Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "01511073277183a21344e8a22ee59eacfb6e5777"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 1259,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgxNTQxNDcw",
      "title": "Fix: #850. Obsolete parameters.",
      "url": "https://github.com/httpwg/http-extensions/pull/1259",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\n- obsoletes digest parameters\r\n\r\nSee #850 ",
      "createdAt": "2020-09-07T16:46:16Z",
      "updatedAt": "2020-10-17T12:02:41Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4490f41d13ca41058c36faa0a120364c17d1df30",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-850-no-parameters",
      "headRefOid": "79def06ee3de69dcf50643ff3098b2c14b4480f8",
      "closedAt": "2020-10-17T12:02:40Z",
      "mergedAt": "2020-10-17T12:02:39Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "b8e8b83abfe3ea7a20be241f9c30c82211b8eeb8"
      },
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue I removed the wrong line. If you PTAL we can merge and cutoff",
          "createdAt": "2020-10-17T11:13:09Z",
          "updatedAt": "2020-10-17T11:13:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzcyODUz",
          "commit": {
            "abbreviatedOid": "1000200"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T17:59:23Z",
          "updatedAt": "2020-09-08T17:59:23Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "These paragraphs are confusing under the section title. I think it would be clearer to \r\n\r\n1) Take what's in the first paragraph and combine it with what's in section 12.2 and 12.3. I suggest we do that in a different PR\r\n\r\n2) Rename the section to something like \"Paramaterising digest-algorithms\"\r\n\r\n3) Take the second paragraph and explain a little more why the old means was \"bad or insecure\". For example, what could have gone wrong? That makes the problem statement clearer so that the solution of embedding parameters make more sense to anyone considering what to do.\r\n",
              "createdAt": "2020-09-08T17:59:23Z",
              "updatedAt": "2020-10-16T22:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3MDcwOTcz",
          "commit": {
            "abbreviatedOid": "1000200"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-27T10:25:21Z",
          "updatedAt": "2020-09-27T10:25:22Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Sure, I'll move \r\n```\r\nAlgorithm agility is achieved establishing the IANA Digest Algorithm Values registry,\r\nand adding it the \"Status\" field making it possible to deprecate and obsolete insecure algorithms.\r\n```\r\nto another PR!",
              "createdAt": "2020-09-27T10:25:22Z",
              "updatedAt": "2020-10-16T22:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MDk1ODQ2",
          "commit": {
            "abbreviatedOid": "1000200"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T17:11:01Z",
          "updatedAt": "2020-10-07T17:11:02Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "I propose to move all this section in {{obsolete-parameters}} as removing parameters we do not have security considerations.",
              "createdAt": "2020-10-07T17:11:01Z",
              "updatedAt": "2020-10-16T22:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MjIzNDMz",
          "commit": {
            "abbreviatedOid": "1fc06ff"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T20:02:38Z",
          "updatedAt": "2020-10-07T20:02:38Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "About combining 12.2 and 12.3, I re-read rfc 8126 and iiuc those sections should remain unchanged (\"keep iana considerations for iana\")... Let's discuss it in https://github.com/httpwg/http-extensions/pull/1284",
              "createdAt": "2020-10-07T20:02:38Z",
              "updatedAt": "2020-10-16T22:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0Mzc2NzY2",
          "commit": {
            "abbreviatedOid": "1fc06ff"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-08T01:47:52Z",
          "updatedAt": "2020-10-08T01:47:53Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "What does this _mean_? `representation-data-digest` above does not contain syntax for `parameters`, so how does a parser know if parameters are present?",
              "createdAt": "2020-10-08T01:47:53Z",
              "updatedAt": "2020-10-16T22:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MjIzMTI5",
          "commit": {
            "abbreviatedOid": "1fc06ff"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T20:02:14Z",
          "updatedAt": "2020-10-08T01:49:26Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Can we be more specific by what we mean by `parameters` here? Is there ABNF we can link to?\r\n\r\nThe danger is that a reader could get confused by our later statement that the representation-data-digest can be parameterized via contained encoding.",
              "createdAt": "2020-10-07T20:02:14Z",
              "updatedAt": "2020-10-16T22:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0Mzc3MzYx",
          "commit": {
            "abbreviatedOid": "1fc06ff"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-08T01:50:09Z",
          "updatedAt": "2020-10-08T01:50:10Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "My comment was stuck pending. I think mnot and I have the same thought",
              "createdAt": "2020-10-08T01:50:10Z",
              "updatedAt": "2020-10-16T22:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0NjY0MzEx",
          "commit": {
            "abbreviatedOid": "1fc06ff"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-08T11:00:00Z",
          "updatedAt": "2020-10-08T11:00:01Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Thanks @mnot @LPardue ! \r\n\r\nThe confusion comes from the fact that the old spec allowed for parameters(even if they were not presenti in the syntax) while this one does not.\r\n\r\nI wanted to provide guidance in how to manage a Digest header sent by an old implementation: which is the correct way to address this issue?\r\n\r\nHyp 1: add the parameter definition to the ABNF and explicit that they SHOULD|MUST be ignored, while the checksum should be processed\r\n\r\nHyp 2: add the parameter definition to the ABNF and explicit that if a `representation-data-digest` contains parameter *only this checksum should be ignored*\r\n\r\nHyp 3: the presence of a parameter in any `representation-data-digest` will invalidate the syntax of the whole Digest value.\r\n\r\n\r\nThanks for your support, R.",
              "createdAt": "2020-10-08T11:00:00Z",
              "updatedAt": "2020-10-16T22:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODI2Mjgx",
          "commit": {
            "abbreviatedOid": "1fc06ff"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T22:15:33Z",
          "updatedAt": "2020-10-16T22:15:33Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\n```\r\n\r\nRemoved this line. I'll open another issue for providing guidance in the parameter transition.",
              "createdAt": "2020-10-16T22:15:33Z",
              "updatedAt": "2020-10-16T22:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODI2ODQ4",
          "commit": {
            "abbreviatedOid": "79def06"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-16T22:17:15Z",
          "updatedAt": "2020-10-16T22:17:15Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Line removed :) \r\n",
              "createdAt": "2020-10-16T22:17:15Z",
              "updatedAt": "2020-10-16T22:17:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwOTc5NTQx",
          "commit": {
            "abbreviatedOid": "79def06"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Let's do it!",
          "createdAt": "2020-10-17T11:41:15Z",
          "updatedAt": "2020-10-17T11:41:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1262,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgzMTkwODUy",
      "title": "Better explain PRIORITY_UPDATE buffering and application",
      "url": "https://github.com/httpwg/http-extensions/pull/1262",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "The old text had a loose definition of when to apply buffered frames.\r\nIt also had a fair amount of repetition.\r\n\r\nThis change tweaks the sections a bit so that we have one that discusses\r\nhow a server should handle PRIORITY_UPDATES for either initial signal or\r\nreprioritization. It incorporates the suggestions on issue #1260 mixed\r\nin with some text we already had.\r\n\r\nThere is still a question about how an implementation can limit its buffering commitments, which depends on the servers applications ability to access stream information. This might no be exposed by a QUIC library for instance. I suggest we punt on that unless there is something easy we can capture now.\r\n\r\nCloses #1260 ",
      "createdAt": "2020-09-09T23:04:26Z",
      "updatedAt": "2020-09-11T10:56:32Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8eb70f80d60f02152f05996d96577df6b41ef59b",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "fix-1260-frame-buffer",
      "headRefOid": "c52dbfcb6e478c2be93082a886a04fbf407a315a",
      "closedAt": "2020-09-11T10:56:31Z",
      "mergedAt": "2020-09-11T10:56:31Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "8b665dce1fdd65105adb7a7d85c9bedd7ea2dbd8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NDY1OTM5",
          "commit": {
            "abbreviatedOid": "cc852d4"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for working on this PR. Just have tiny suggestions and one point that can be solved separately.",
          "createdAt": "2020-09-09T23:20:51Z",
          "updatedAt": "2020-09-10T05:31:01Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Just a slight preference, but it might help if we'd be a bit more specific.\r\n```suggestion\r\nto be sent independent from the stream that carries the response. This means\r\n```\r\n",
              "createdAt": "2020-09-09T23:20:51Z",
              "updatedAt": "2020-09-10T14:31:27Z"
            },
            {
              "originalPosition": 47,
              "body": "Would be less surprising to acknowledge that the main purpose of PRIORITY_UPDATE frames is to \"re\"-prioritize the responses. That's what we state above.\r\n\r\n```suggestion\r\nthey can also be used to signal the initial priority of a response instead of the\r\n```",
              "createdAt": "2020-09-09T23:23:12Z",
              "updatedAt": "2020-09-10T14:31:27Z"
            },
            {
              "originalPosition": 60,
              "body": "(We can leave this as a ToDo in this PR, but) Regarding implementations, I think we should RECOMMEND servers to buffer the most recent PRIORITY_UPDATE frames it receives for all the unopened streams, provided that the stream ID being specified by the frame is within the concurrency window.\r\n\r\nOtherwise, the server will fail to prioritize the responses correctly when a client issues many requests at once (e.g., when finding lots of <IMG> tags in a HTML document).",
              "createdAt": "2020-09-09T23:27:11Z",
              "updatedAt": "2020-09-10T14:31:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1OTg2MjUz",
          "commit": {
            "abbreviatedOid": "cc852d4"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-10T14:19:32Z",
          "updatedAt": "2020-09-10T14:19:33Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I struggled with this, which explains the typo in my text. I was trying to write something that could apply to both requests and push. I'll accept your change and we can refine later if needed.",
              "createdAt": "2020-09-10T14:19:33Z",
              "updatedAt": "2020-09-10T14:31:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1OTkxMzE0",
          "commit": {
            "abbreviatedOid": "cc852d4"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-10T14:24:26Z",
          "updatedAt": "2020-09-10T14:24:26Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Yeah. I was hoping to come back to this when we have a proposal #1261. Let me add that into the TODO comment.",
              "createdAt": "2020-09-10T14:24:26Z",
              "updatedAt": "2020-09-10T14:31:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1OTkzODYw",
          "commit": {
            "abbreviatedOid": "cc852d4"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-10T14:26:51Z",
          "updatedAt": "2020-09-10T14:26:51Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "If you prefer stating it that way then I'll reverse the ordering in this sentence.",
              "createdAt": "2020-09-10T14:26:51Z",
              "updatedAt": "2020-09-10T14:31:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2Njc2Mjcz",
          "commit": {
            "abbreviatedOid": "c52dbfc"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thank you for the changes! LGTM.",
          "createdAt": "2020-09-11T10:05:33Z",
          "updatedAt": "2020-09-11T10:05:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1263,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg4MzI4NDkx",
      "title": "s/headers/fields in priorities",
      "url": "https://github.com/httpwg/http-extensions/pull/1263",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "Update to use Structured Fields terminology",
      "createdAt": "2020-09-17T00:18:37Z",
      "updatedAt": "2020-09-23T12:55:32Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8b665dce1fdd65105adb7a7d85c9bedd7ea2dbd8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "priority-structured-fields",
      "headRefOid": "b777042b92186d9f5c5d499787a0c8bd61380ede",
      "closedAt": "2020-09-23T12:55:31Z",
      "mergedAt": "2020-09-23T12:55:31Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "465911e1b9e7f5acc81e5c4055ae1214207e55d1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 1264,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg4MzM3Nzgy",
      "title": "Be less specific about urgency when behind an intermediary",
      "url": "https://github.com/httpwg/http-extensions/pull/1264",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "Closes #1022",
      "createdAt": "2020-09-17T00:55:30Z",
      "updatedAt": "2020-09-28T11:18:51Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8b665dce1fdd65105adb7a7d85c9bedd7ea2dbd8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "priority-coalescing",
      "headRefOid": "10de5098c138cbea009d9e1f7a4c3b4516520171",
      "closedAt": "2020-09-28T11:18:50Z",
      "mergedAt": "2020-09-28T11:18:50Z",
      "mergedBy": "kazuho",
      "mergeCommit": {
        "oid": "088a4ec551bbb6c2dd4df75d63e732f47eb90940"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc @martinthomson, since it closes your issue.",
          "createdAt": "2020-09-23T14:02:37Z",
          "updatedAt": "2020-09-23T14:02:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe this is now good to go, please approve or speak up if you disagree.",
          "createdAt": "2020-09-25T10:57:12Z",
          "updatedAt": "2020-09-25T10:57:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MjA0NjEz",
          "commit": {
            "abbreviatedOid": "686f799"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T04:06:43Z",
          "updatedAt": "2020-09-24T04:09:21Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I don't know why you would recommend incremental loading at all.  You might just say \"assign all requests the same priority\".  And then add the note about where the bottleneck is.",
              "createdAt": "2020-09-24T04:06:43Z",
              "updatedAt": "2020-09-25T10:55:30Z"
            },
            {
              "originalPosition": 16,
              "body": "This assumes that the network is always the bottleneck.  Sometimes it is processing resources that are being prioritized.\r\n\r\n> This can work if the constrained resource is network capacity between the intermediary and user agent.\r\n\r\n(End client == user agent?)",
              "createdAt": "2020-09-24T04:08:04Z",
              "updatedAt": "2020-09-25T10:55:30Z"
            },
            {
              "originalPosition": 20,
              "body": "I'd drop the last two sentences entirely.  Statements about sophistication will likely seem quaint in 6 months time.",
              "createdAt": "2020-09-24T04:09:17Z",
              "updatedAt": "2020-09-25T10:55:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1OTA0NDEx",
          "commit": {
            "abbreviatedOid": "686f799"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T19:54:20Z",
          "updatedAt": "2020-09-24T19:54:21Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "In this context, incremental means round-robin. We don't care how the thing receiving the response processes it. But we do want to avoid the server responding as FIFO, which might cause a different type of fairness problem.",
              "createdAt": "2020-09-24T19:54:21Z",
              "updatedAt": "2020-09-25T10:55:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1OTA2MzI2",
          "commit": {
            "abbreviatedOid": "686f799"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T19:57:11Z",
          "updatedAt": "2020-09-24T19:57:11Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "What about condensing the two to say \"Weighted round-robin scheduling could improve the use of contained network capacity further.\"?",
              "createdAt": "2020-09-24T19:57:11Z",
              "updatedAt": "2020-09-25T10:55:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MDIyMzEy",
          "commit": {
            "abbreviatedOid": "8d2166a"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T23:49:39Z",
          "updatedAt": "2020-09-24T23:59:14Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Knowing that the intent of this PR is to be less specific, I think we can get rid of suggestions that refer to the specification (i.e., use of words like \"urgency\" and \"incremental\").\r\n\r\nRather, we can condense this sentence and the following one to something like: _For instance, if a server knows that the intermediary is coalescing requests, it could serve the responses in round-robin_.",
              "createdAt": "2020-09-24T23:49:39Z",
              "updatedAt": "2020-09-25T10:55:30Z"
            },
            {
              "originalPosition": 20,
              "body": "I think my preference goes to removing the last two sentences, due to the following reasons:\r\n* Use of WRR degrades fairness, and might have negative impact on perceived performance of an end user.\r\n* This is a problem that we do not need to solve now. Our choice of two priority parameters has been based on what we want to have for web browsing. For web browsing, we do not expect to see the case being described here.",
              "createdAt": "2020-09-24T23:59:05Z",
              "updatedAt": "2020-09-25T10:55:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MzE2MTIw",
          "commit": {
            "abbreviatedOid": "8d2166a"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-25T10:55:41Z",
          "updatedAt": "2020-09-25T10:55:52Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "agreed, thanks!",
              "createdAt": "2020-09-25T10:55:41Z",
              "updatedAt": "2020-09-25T10:55:53Z"
            },
            {
              "originalPosition": 14,
              "body": "agreed, thanks!",
              "createdAt": "2020-09-25T10:55:44Z",
              "updatedAt": "2020-09-25T10:55:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1265,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg4MzQwNTI1",
      "title": "bespoke is uncommon",
      "url": "https://github.com/httpwg/http-extensions/pull/1265",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "cc @dtikhonov",
      "createdAt": "2020-09-17T01:06:18Z",
      "updatedAt": "2020-09-23T12:54:14Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "8b665dce1fdd65105adb7a7d85c9bedd7ea2dbd8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "bespoke-embiggens-confusion",
      "headRefOid": "c2f8131bb6def74253fe7c66e9e40baca019eaca",
      "closedAt": "2020-09-23T12:54:12Z",
      "mergedAt": "2020-09-23T12:54:12Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "0c7cb57e7e73d955992c6b324e309467d3e9605a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 1266,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg4MzY3MDYy",
      "title": "rough in server scheduling guidance",
      "url": "https://github.com/httpwg/http-extensions/pull/1266",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "This tries to address two sets of comments on \"what signals are subsumed by priority hints\" and \"how should a server implement things\". \r\n\r\nOne aspect of this is setting client expectations straight; they should have a vague idea what will happen if a server plays ball but also expect that servers can and will do whatever they want.\r\n\r\nThe other aspect of this is describing what signals servers have at their disposal, and presenting some of the gotchas or tradeoffs that might happen if the extensible priority scheme is implemented too matter-of-fact. Some people would like to see more explicit guidance for servers, that's a fine request. However, I don't see how any single scheduling algorithm would work for the range of vendors and deployments that have shown an interest Priorities, so I've focused on the common criteria.\r\n\r\nWhile adding this section, the thought did cross my mind to move the sections on scheduling. We can always do that as a followup.\r\n\r\nCloses #1216 and #1232.\r\n\r\ncc @ekinnear, @guoye-zhang, @martinthomson ",
      "createdAt": "2020-09-17T02:47:10Z",
      "updatedAt": "2020-09-30T12:02:48Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "088a4ec551bbb6c2dd4df75d63e732f47eb90940",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "priority-server-scheduling",
      "headRefOid": "560235a57aee10a4384e2a5cfedcaa3b35d30d15",
      "closedAt": "2020-09-30T12:02:46Z",
      "mergedAt": "2020-09-30T12:02:46Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "741e80c269f72666c9bcd191804100a1121380fc"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the contribution @kazuho. I'm going to squash and merge this.",
          "createdAt": "2020-09-30T12:02:13Z",
          "updatedAt": "2020-09-30T12:02:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMjQ4ODI1",
          "commit": {
            "abbreviatedOid": "606787f"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-17T05:16:57Z",
          "updatedAt": "2020-09-17T05:46:07Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "\"Priority\" as a proper noun or an error?",
              "createdAt": "2020-09-17T05:16:57Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            },
            {
              "originalPosition": 52,
              "body": "isn't it time from request to last byte delivered?",
              "createdAt": "2020-09-17T05:18:03Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            },
            {
              "originalPosition": 54,
              "body": "For incremental resources, the time to deliver every byte is important.\r\n\r\nI wonder if the split here is between atomic and incremental.",
              "createdAt": "2020-09-17T05:18:58Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-09-17T05:44:29Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            },
            {
              "originalPosition": 58,
              "body": "I don't get this point about unbalanced scheduling.  It seems to imply that there might be some other reason to balance between atomic and incremental resources, but I don't think that is the intent.",
              "createdAt": "2020-09-17T05:45:29Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            },
            {
              "originalPosition": 62,
              "body": "What if that is all it gets?  I think that you need to provide more exposition for this recommendation.",
              "createdAt": "2020-09-17T05:46:04Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NjQ2NjQy",
          "commit": {
            "abbreviatedOid": "6b7d1cd"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T13:15:38Z",
          "updatedAt": "2020-09-23T13:15:38Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "This is probably open to interpretation a little so it would be good to hammer it down. Looking at this again, I don't like how I presented it and will tweak it. I was basing it on my understanding of curl and chrome as shown here https://blog.cloudflare.com/a-question-of-timing/. Do other client have alternative views?\r\n\r\nMy thinking, based on other discussions, is that a non-incremental payload can only be used when the whole payload is received. Therefore, factoring in the delta between request and TTFB is not super helpful in this context. However, non-incremental objects probably do benefit from a shorter TTFB and \"time to significant delineator\", such as a progressive jpeg header.",
              "createdAt": "2020-09-23T13:15:38Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NjQ5NzE4",
          "commit": {
            "abbreviatedOid": "6b7d1cd"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T13:18:49Z",
          "updatedAt": "2020-09-23T13:18:49Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "For some types of content not all bytes are important due to internal boundaries. I'd like to avoid falling into the trap of describing this in too much detail if possible. I tried to use \"chunk\" as the sub-unit that could be as small as 1 byte.\r\n\r\nWhat do you mean by atomic vs incremental?",
              "createdAt": "2020-09-23T13:18:49Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NjU5OTQ1",
          "commit": {
            "abbreviatedOid": "6b7d1cd"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T13:29:04Z",
          "updatedAt": "2020-09-23T13:29:04Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "From https://github.com/httpwg/http-extensions/issues/1232#issuecomment-663724137\r\n\r\n>  Let's imagine two cases:\r\n > 1) At the same urgency level, a huge non-incremental file download has started, then a small incremental resource is requested.\r\n>  2) At the same urgency level, an incremental hanging GET is waiting for response, while a non-incremental file download is requested.\r\n\r\nAn unbalanced scheduler might be designed to completely flush one type of resource before moving on the the other. Especially likely if resources are large in comparison to the BDP. This could starve the other type from ever getting a share. The text is attempting to say don't do that. To avoid it, an implemention could somehow yield sending one type in a given time period. Guoye's suggestion on https://github.com/httpwg/http-extensions/issues/1232#issuecomment-663889717 provides an example. I like to avoid recommending any specific solution.",
              "createdAt": "2020-09-23T13:29:04Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0Njk0MDg4",
          "commit": {
            "abbreviatedOid": "930fe0d"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T14:01:43Z",
          "updatedAt": "2020-09-23T14:01:43Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I added some more exposition in https://github.com/httpwg/http-extensions/pull/1266/commits/3c7f8e6ee059d0b879036560b2a998b53583fb4c. PTAL.",
              "createdAt": "2020-09-23T14:01:43Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MTk4MTcx",
          "commit": {
            "abbreviatedOid": "930fe0d"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T03:43:31Z",
          "updatedAt": "2020-09-24T04:03:28Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "This is a little odd.  It says \"Server's gonna do what server wanna do.\" in a somewhat roundabout way.  How about: \r\n\r\n> Clients cannot depend on particular treatment based on priority signals. Servers can use other information to prioritize responses.",
              "createdAt": "2020-09-24T03:43:31Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            },
            {
              "originalPosition": 48,
              "body": "I think that the \"might server the responses one-by-one\" is distracting, and the phrasing here implies far more discretion for servers.  Maybe just\r\n\r\n> Prioritizing concurrent requests at the same urgency level based on the stream ID, which corresponds to the order in which clients make requests, ensures that clients can use request ordering to influence response order.",
              "createdAt": "2020-09-24T03:46:39Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            },
            {
              "originalPosition": 52,
              "body": "For things like JS, we often can't continue processing until we have all the bytes.  That's what I meant by atomic below: the whole thing is needed, it can't be divided into smaller parts and be useful.  But atomic probably has connotations that aren't helpful.",
              "createdAt": "2020-09-24T03:48:31Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            },
            {
              "originalPosition": 54,
              "body": "See above.\r\n\r\nThis is a simplification: absent more specific information the server must assume that i=false the entire resource needs to be delivered to be of use.  For i=true the more of the resource that is delivered the more utility is obtained.  Obviously this isn't smoothly linear and there are some bytes that don't allow any more value to be extracted than those preceding, but that is the model that we are operating under.\r\n\r\nExtensions can define cut points or chunking.  Like a stepped incremental extension that lists a number of byte offsets that contain significant value (which likely needs to come from the server...).  Or something that says \"don't bother delivering anything less than the following chunk size, because MICE doesn't allow data to be used\".",
              "createdAt": "2020-09-24T03:52:19Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            },
            {
              "originalPosition": 58,
              "body": "I don't think that you want to use the word unbalanced because it carries negative connotations.\r\n\r\nWhat those examples are suggesting is a few questions:\r\n\r\nDo you want to permit small responses to jump ahead of in-progress responses?\r\nWhat if something that is nominally higher priority (by order, not urgency) can't start until a lower priority response has begun? Can it pre-empt?  Can it pre-empt only based on size?\r\n(There's another one I thought of: Do you permit non-incremental responses to start when incremental responses are in progress? Maybe you have an answer for that already.)\r\n\r\nThese imply judgment being exercised or the presence of \"other inputs\".  But it is probably sensible to allow it, but that is clearly not the intent conveyed by the signal.  Maybe size-based discrimination is appropriate, but it's not something that this scheme supports, so you need to be careful.\r\n\r\nWhat I would do then is to enumerate corner cases where we know that strict adherence to the scheme could end up with suboptimal results.  These cases are exactly the ones that I'd include there.\r\n\r\nThis scheme can't address these cases.  So you need a clear delineation between what following the scheme gets you and where you are using \"special sauce\".  This paragraph went from describing how this scheme operates and the consequences of that straight to special sauce stuff with no pause for breath.",
              "createdAt": "2020-09-24T04:03:25Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1OTcxMTY2",
          "commit": {
            "abbreviatedOid": "a215d40"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-24T21:41:35Z",
          "updatedAt": "2020-09-24T21:41:36Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "I've reworked this paragraph to address the points here and in the other comment. See https://github.com/httpwg/http-extensions/pull/1266/commits/a215d40b52b0d1ed5ae67235ee23aad49d75adf5\r\n\r\n(my force push seems to have broken Github's tracking, I aplogize).",
              "createdAt": "2020-09-24T21:41:36Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MDE2Njcy",
          "commit": {
            "abbreviatedOid": "a215d40"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thank you for all the work. Left some comments. PTAL.",
          "createdAt": "2020-09-24T23:32:38Z",
          "updatedAt": "2020-09-24T23:42:03Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nIt is RECOMMENDED that, when possible, servers respect urgency values, sending\r\n```",
              "createdAt": "2020-09-24T23:32:39Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            },
            {
              "originalPosition": 48,
              "body": "How about moving the contents of this paragraph to the one above that talks about urgency, and going like: _When there are multiple responses with same urgency, a server SHOULD ..._",
              "createdAt": "2020-09-24T23:35:55Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            },
            {
              "originalPosition": 74,
              "body": "This sentence sounds like that a server cannot respect the PRIORITY frames sent by a legacy HTTP/2 client.\r\n\r\nI think that the intent is to state something like: When a client sends SETTINGS_DEPRECATE_HTTP2_PRIORITIES, a server SHOULD NOT act ...",
              "createdAt": "2020-09-24T23:41:26Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MjM0NzEx",
          "commit": {
            "abbreviatedOid": "a532966"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-25T08:55:36Z",
          "updatedAt": "2020-09-25T08:55:36Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "Ok I think we come to this from different viewpoints. I was trying to address the statement in {{disabling}}\r\n\r\n> The SETTINGS frame precedes any priority signal sent from a client in HTTP/2, so a server can determine if it should respect the HTTP/2 scheme before building state.\r\n\r\nI've reworked the paragraph to accomodate either client or server sending the setting, PTAL.",
              "createdAt": "2020-09-25T08:55:36Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MjQ0ODkz",
          "commit": {
            "abbreviatedOid": "a532966"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-25T09:09:51Z",
          "updatedAt": "2020-09-25T09:09:51Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "I tried this and didn't like what I came up with. The progression from urgency, to incremental, to request order feels more natural to me. Combining the text as you suggest also produced a strange implication that request order is only important for requests at the same urgency, which I don't agree with.\r\n\r\nI'd happily review a suggestion that avoids these problems. Perhaps we can make a separate editorial PR?",
              "createdAt": "2020-09-25T09:09:51Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NDE3Nzcy",
          "commit": {
            "abbreviatedOid": "a532966"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-28T11:23:23Z",
          "updatedAt": "2020-09-28T11:29:00Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "```suggestion\r\nHTTP/2 endpoints can advertise that they are using the Extensible Priorities scheme\r\n```",
              "createdAt": "2020-09-28T11:23:23Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            },
            {
              "originalPosition": 76,
              "body": "I'm not sure if this sentence is correct. I think that a server is expected to respect the H2 prioritization scheme unless the client sends  SETTINGS_DEPRECATE_HTTP2_SETTINGS.\r\n\r\nI also think that we might want to move the suggestion to {{disabling}}, as it talks about how the client handles the existence (or absence) of the settings parameter? Doing so would be fine, as we refer to that section in the previous sentence.",
              "createdAt": "2020-09-28T11:27:55Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            },
            {
              "originalPosition": 48,
              "body": ":+1: I think I can work on a separate PR. That PR can point to this PR or master, depending on how we proceed.",
              "createdAt": "2020-09-28T11:28:43Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NDM2NDU3",
          "commit": {
            "abbreviatedOid": "d691bec"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-28T11:53:26Z",
          "updatedAt": "2020-09-28T11:53:27Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "I agree this would fit in {{disabling}}. That section includes the sentence \r\n\r\n> The SETTINGS frame precedes any priority signal sent from a client in HTTP/2, so a server can determine if it should respect the HTTP/2 scheme before building state.\r\n\r\nSo I intended the new text to build on that. My mental model was that a server might just want to cut out a lot of H2 priorities code, leaving only the bits necessary for parsing. Such a server cannot act on the signal and declares so using the deprecate setting. It's unfortunate if the client wants to continue using the old scheme, but there would not be an interop failure.\r\n\r\nI could live with downgrading things to only provide this guidance when a server receives the setting. Would that work for you?",
              "createdAt": "2020-09-28T11:53:26Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NDUyMjk5",
          "commit": {
            "abbreviatedOid": "d691bec"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-28T12:17:12Z",
          "updatedAt": "2020-09-28T12:17:12Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "> I could live with downgrading things to only provide this guidance when a server receives the setting. Would that work for you?\r\n\r\nThanks. I think my preference goes there. IMO, we do not need to recommend servers degrade performance of legacy HTTP/2 clients. So maybe something like: When receiving SETTINGS_DEPRECATE_HTTP2_PRIORITIES, a server MUST ignore the HTTP/2 PRIORITY frames received on that connection.",
              "createdAt": "2020-09-28T12:17:12Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NTE1MTk5",
          "commit": {
            "abbreviatedOid": "f29bd50"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-28T13:32:44Z",
          "updatedAt": "2020-09-28T13:32:44Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "done in https://github.com/httpwg/http-extensions/pull/1266/commits/f29bd50a4d8f9c5ac75b6ddee82844c6fdaa19fd",
              "createdAt": "2020-09-28T13:32:44Z",
              "updatedAt": "2020-09-30T11:54:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1271,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkzMDEyNzcy",
      "title": "Describe frame/header dichotomy and error handling for SFV failures",
      "url": "https://github.com/httpwg/http-extensions/pull/1271",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "As noted in the discussion on #1267, there is some asymmetry between the Priority header and PRIORITY_UPDATE frame. This PR addresses the dichotomy by localized description of the frame. I've avoided great exposition of the dichotomy because I feel it could be wordy and distracting; others might disagree.\r\n\r\nThe changes dovetail nicely with the discussion #1268 about how to handle parsing failures. So adding that at the same time.\r\n\r\nCloses #1267 and #1268 \r\n\r\ncc: @martinthomson @dtikhonov @kazuho \r\n",
      "createdAt": "2020-09-25T11:31:47Z",
      "updatedAt": "2020-09-30T19:38:32Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "465911e1b9e7f5acc81e5c4055ae1214207e55d1",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "priority_update_malcontentness",
      "headRefOid": "b9ed66d2b3a2a8cfce04771fc0dcc157eccaaf76",
      "closedAt": "2020-09-28T10:53:24Z",
      "mergedAt": "2020-09-28T10:53:24Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "005d9c19b51df0dd88ce10c98b0eb79f948ab31d"
      },
      "comments": [
        {
          "author": "dtikhonov",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks good: everything is spelled out now.",
          "createdAt": "2020-09-25T14:09:37Z",
          "updatedAt": "2020-09-25T14:09:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "2 approvals is quorum for me. Merging. ",
          "createdAt": "2020-09-28T10:52:22Z",
          "updatedAt": "2020-09-28T10:52:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NDQzNTE1",
          "commit": {
            "abbreviatedOid": "fd9e188"
          },
          "author": "dtikhonov",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-25T13:57:22Z",
          "updatedAt": "2020-09-25T13:57:23Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Priority _header_?  I thought \"header\" is now \"field.\"",
              "createdAt": "2020-09-25T13:57:23Z",
              "updatedAt": "2020-09-25T17:53:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NDU3NjA1",
          "commit": {
            "abbreviatedOid": "fd9e188"
          },
          "author": "dtikhonov",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-25T14:08:55Z",
          "updatedAt": "2020-09-25T14:08:55Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "s/treat/treated/",
              "createdAt": "2020-09-25T14:08:55Z",
              "updatedAt": "2020-09-25T17:53:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NjMwNTE2",
          "commit": {
            "abbreviatedOid": "b9ed66d"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-25T17:54:37Z",
          "updatedAt": "2020-09-25T17:54:37Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "whoops, dang",
              "createdAt": "2020-09-25T17:54:37Z",
              "updatedAt": "2020-09-25T17:54:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NjMwNTQx",
          "commit": {
            "abbreviatedOid": "b9ed66d"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-25T17:54:39Z",
          "updatedAt": "2020-09-25T17:54:40Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "thanks!",
              "createdAt": "2020-09-25T17:54:39Z",
              "updatedAt": "2020-09-25T17:54:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3Mzc4OTk0",
          "commit": {
            "abbreviatedOid": "b9ed66d"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me.\r\n\r\nThe MUST-close clause for the PRIORITY_UPDATE frame sounded bit harsh to me, until I realized that an endpoint is required to support reprioritization. Because we require hop-by-hop handling or priorities, we can assume that an endpoint has the capability of parsing the frame payload, regardless of the role of that endpoint (e.g., intermediary, forwarder).",
          "createdAt": "2020-09-28T10:23:18Z",
          "updatedAt": "2020-09-28T10:23:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1275,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1NTc1Mzgx",
      "title": "Fix typo in the HTTP priorities draft",
      "url": "https://github.com/httpwg/http-extensions/pull/1275",
      "state": "MERGED",
      "author": "dtikhonov",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "",
      "createdAt": "2020-09-30T14:59:53Z",
      "updatedAt": "2020-09-30T19:38:22Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "741e80c269f72666c9bcd191804100a1121380fc",
      "headRepository": "dtikhonov/http-extensions",
      "headRefName": "patch-1",
      "headRefOid": "e65f634bb1f4934939cdd838538bf263c443e3a3",
      "closedAt": "2020-09-30T15:09:17Z",
      "mergedAt": "2020-09-30T15:09:17Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "b4d14ca0a866b181b1f250274a458f1c1ab771e9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5NTM1OTIw",
          "commit": {
            "abbreviatedOid": "e65f634"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "thanks!",
          "createdAt": "2020-09-30T15:09:08Z",
          "updatedAt": "2020-09-30T15:09:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1276,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1NjE3NDQw",
      "title": "Fix paragraph describing how to extend priorities",
      "url": "https://github.com/httpwg/http-extensions/pull/1276",
      "state": "MERGED",
      "author": "dtikhonov",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "",
      "createdAt": "2020-09-30T16:01:32Z",
      "updatedAt": "2020-09-30T19:38:11Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b4d14ca0a866b181b1f250274a458f1c1ab771e9",
      "headRepository": "dtikhonov/http-extensions",
      "headRefName": "202009301200-deawkwardize-extending-priorities",
      "headRefOid": "4227379e8cf1c575c02f138aa796f0455f3d5296",
      "closedAt": "2020-09-30T16:06:44Z",
      "mergedAt": "2020-09-30T16:06:44Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "6d32a39ece881399f34211bb92ea44e71a5bad92"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5NTkxNjAz",
          "commit": {
            "abbreviatedOid": "4227379"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks",
          "createdAt": "2020-09-30T16:06:37Z",
          "updatedAt": "2020-09-30T16:06:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1278,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1NzM2OTMz",
      "title": "fix the error type when PRIORITY_UPDATE is bogus",
      "url": "https://github.com/httpwg/http-extensions/pull/1278",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "Fixes #1277 \r\n\r\n@dtikhonov correctly pointed out that the draft contained a made up error code. On inspection, we need to define specific error codes for both H2 and H3. This change does that.",
      "createdAt": "2020-09-30T19:29:16Z",
      "updatedAt": "2020-10-01T11:00:18Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6d32a39ece881399f34211bb92ea44e71a5bad92",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "priority-update-encoding-error-type",
      "headRefOid": "7427617dd679faff6e7dc92a662b159d014eb7d6",
      "closedAt": "2020-10-01T11:00:17Z",
      "mergedAt": "2020-10-01T11:00:17Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "3c4d5d7a1e996b869b3efd96f0faf80217c3c798"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5NzQ3MTY2",
          "commit": {
            "abbreviatedOid": "7427617"
          },
          "author": "dtikhonov",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-30T19:31:01Z",
          "updatedAt": "2020-09-30T19:31:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5ODgzOTE0",
          "commit": {
            "abbreviatedOid": "7427617"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-30T23:41:11Z",
          "updatedAt": "2020-09-30T23:41:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1279,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1NzQ2MDM0",
      "title": "Priorities-01 changelog",
      "url": "https://github.com/httpwg/http-extensions/pull/1279",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "",
      "createdAt": "2020-09-30T19:45:16Z",
      "updatedAt": "2020-10-01T10:58:39Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "6d32a39ece881399f34211bb92ea44e71a5bad92",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "priority-01-changelog",
      "headRefOid": "842618def07b891063c01e0195c03ca3dd2632f6",
      "closedAt": "2020-10-01T10:58:38Z",
      "mergedAt": "2020-10-01T10:58:38Z",
      "mergedBy": "LPardue",
      "mergeCommit": {
        "oid": "58fff3f0765a7230f128bb1b67f0344d8c50f646"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5ODg0MDU0",
          "commit": {
            "abbreviatedOid": "842618d"
          },
          "author": "kazuho",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-30T23:41:40Z",
          "updatedAt": "2020-09-30T23:41:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1280,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk2NDk0Mzg4",
      "title": "Extract creation and expiration time requirements language",
      "url": "https://github.com/httpwg/http-extensions/pull/1280",
      "state": "OPEN",
      "author": "jricher",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "Originally in #1235",
      "createdAt": "2020-10-01T19:24:19Z",
      "updatedAt": "2020-10-12T21:39:20Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "3c4d5d7a1e996b869b3efd96f0faf80217c3c798",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "jricher-signature-time-check",
      "headRefOid": "fb662931285d2a2c69312c43a616921b5f1eff48",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNjYyODYw",
          "commit": {
            "abbreviatedOid": "fb66293"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "imho this PR introduces a very weak normative part. I'd ask for feedback from the community/ML.",
          "createdAt": "2020-10-04T21:56:55Z",
          "updatedAt": "2020-10-04T21:58:27Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "At first, thanks @jricher  for asking me to review!\r\n\r\nIn this paragraph imho we are giving information that does not help interoperability:\r\n- the first sentence states that \"the verifier MUST comply with their own requirements, that depend on the use case\", but it does not make a clear statement on those requirements;\r\n- the fact that an \"expired\" signature MAY be accepted can be perceived as an abuse from a signer which instead wants to be in control of the data he signed.\r\n\r\nI think that using fields like `nbf`,`iat`,`exp` allows to implement the very same behavior without removing control from the signer, and  putting a solid interoperability ground instead: signer and verifier just have to agree about the interval they accept.\r\n\r\nThis is clearly IMHO, and probably @martinthomson or @jyasskin can give more useful guidance than me on this subject.",
              "createdAt": "2020-10-04T21:56:55Z",
              "updatedAt": "2020-10-04T21:58:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyNDk5ODM4",
          "commit": {
            "abbreviatedOid": "fb66293"
          },
          "author": "richanna",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-06T00:03:28Z",
          "updatedAt": "2020-10-06T00:03:29Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Thanks for the feedback!\r\n\r\nThere are three objectives that this paragraph is trying to achieve:\r\n\r\n- 1st Sentence: Require implementers' time-related constraints to be enforced relative to the Creation Time and Expiration Time properties defined by the spec (as opposed to the Date header, or some proprietary property embedded in the request somewhere).\r\n- 2nd Sentence: Allow verifiers to account for clock skew between the signer and verifier, which may be significant.\r\n- 3rd Sentence: Allow verifiers to reject signatures based on their own requirements, i.e., \"I don't care if you're telling me this 2 year old signature fine, I'm not going to accept it.\"\r\n\r\nOpen to suggestions on rewording to make these objectives clearer.\r\n\r\n> the first sentence states that \"the verifier MUST comply with their own requirements, that depend on the use case\", but it does not make a clear statement on those requirements;\r\n\r\nExplained above, but restating for clarity: the purpose is to ensure that verifiers use the spec-defined Creation Time and Expiration Time properties to evaluate time-related constraints. Would it help to give example constraints? (e.g., a maximum signature age)\r\n\r\n> the fact that an \"expired\" signature MAY be accepted can be perceived as an abuse from a signer which instead wants to be in control of the data he signed.\r\n\r\nIt may be necessary for a verifier to accept a signature whose Expiration Time is after the current time as measured by the verifier, in order to allow verifiers to account for clock skew between signer and verifier. Maybe it would be better to reframe this as a verifier may offset their current time by some amount to account for clock skew, at least for the purposes of evaluating time-related constraints? That would allow us to bring back in the prohibition on accepting signatures past their Expiration Time.\r\n\r\n> I think that using fields like nbf, iat, exp allows to implement the very same behavior\r\n\r\nI'm not sure how to interpret this in the context of this spec, since it does not use JWTs.",
              "createdAt": "2020-10-06T00:03:28Z",
              "updatedAt": "2020-10-06T00:04:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MDIwOTY4",
          "commit": {
            "abbreviatedOid": "fb66293"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T15:44:54Z",
          "updatedAt": "2020-10-07T15:44:55Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "@richanna can we split the sentences over multiple lines? I'd find it easier to discuss them, eg.\r\n\r\n```suggestion\r\nThe verifier MUST examine the signature's Creation Time and Expiration Time and evaluate whether they meet the verifier's requirements.  These requirements may vary depending on the use case. \r\nWhen comparing Creation Time and/or Expiration Time to a timestamp obtained from another source (e.g., testing that the Expiration Time is later than the local time at the verifier), the verifier MAY allow for some variability due to clock skew between the two timestamp sources (e.g., the signer and the verifier). \r\nThe verifier MAY impose its own maximum age limits, and reject signatures that are too old (i.e., have a Creation Time too far in the past) regardless of whether the signer gave the signatures an Expiration Time.\r\n```",
              "createdAt": "2020-10-07T15:44:54Z",
              "updatedAt": "2020-10-07T15:44:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MDU5MTg2",
          "commit": {
            "abbreviatedOid": "fb66293"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T16:26:38Z",
          "updatedAt": "2020-10-07T16:26:38Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I'd rephrase with something like the following. the 2119 keywords can be tuned, and the rest is just an example... your feedback is welcome!\r\n\r\nThe passage below ensures the verifier cannot take action beyond the will of the signer.\r\n\r\n```\r\n[addition] To take into account clock skew, the signer MAY provide the NotBefore Time parameter\r\nindicating that the signature is valid prior to the Creation Time.\r\n\r\nThe verifier MUST NOT process a signature where:\r\n- the Expiration Time is in the past;\r\n- the lowest value between NotBefore and Creation Time is in the future.\r\n```\r\n\r\nThis second sentence ensures that the verifier is free to impose further requirements that may relate - but not limit to - Time parameters, thus giving more freedom to invalidate to the verifier that the previous version:\r\n\r\n```\r\nThe verifier MAY impose further requirements depending on the use case, including:\r\n- maximum age limits;\r\n- constraints between Creation Time and Exipration Time, or on other signature parameter values;\r\n- (insert here some examples).\r\n```\r\n\r\nSome guidance for implementers about how to communicate further requirements could be helpful, because providing extensive information on why a signature is invalid may expose the peers to attacks\r\n\r\n```\r\nThose requirements SHOULD be communicated out-of-band or when it is safe to do so MAY be communicated on the wire (eg. in the response payload or headers).\r\n```\r\n\r\n",
              "createdAt": "2020-10-07T16:26:38Z",
              "updatedAt": "2020-10-07T16:27:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MzI2OTgw",
          "commit": {
            "abbreviatedOid": "fb66293"
          },
          "author": "jyasskin",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T23:05:12Z",
          "updatedAt": "2020-10-07T23:15:39Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I don't have a firm suggestion here, but here are a couple thoughts in the hope that they might help:\r\n\r\n* The discussion of \"the verifier's requirements\" might really be talking about how this header is embedded into a higher-level protocol. The CBOR spec explicitly puts [constraints on CBOR-based protocols](https://tools.ietf.org/id/draft-ietf-cbor-7049bis-16.html#name-creating-cbor-based-protoco) and mandates that they specify certain things. For example [\"The first layer that does process the semantics of an invalid CBOR item MUST take one of two choices: \u2026. A CBOR-based protocol MUST specify which of these options its decoders take\"](https://tools.ietf.org/id/draft-ietf-cbor-7049bis-16.html#name-validity-of-items). Maybe this spec could just say that\r\n    > A protocol using HTTP Message Signatures MUST define how it uses \r\n    >\r\n    > 1. the verifier's current time,\r\n    > 1. the verifier's estimate of any clock skew between the verifier and the signer,\r\n    > 1. the Creation Time, and\r\n    > 1. the Expiration Time \r\n    >\r\n    > to determine whether the signature is currently valid.\r\n\r\n* Handling clock skew is probably more complicated than just offsetting the verifier's current time, and checking that the new time is between the creation and expiration times. Clock skew is inherently uncertain and the verifier's estimate of it might be vulnerable to attack, especially if the verifier is a client. The signed exchange [spec](https://wicg.github.io/webpackage/loading.html#validating-signature) currently says clients may adjust the creation time for skew but mustn't adjust the expiration time. The current Chromium implementation [doesn't adjust for skew at all](https://source.chromium.org/chromium/chromium/src/+/master:content/browser/web_package/signed_exchange_signature_verifier.cc;l=213;drc=7a942548e0af7397f79bf07b4ca03ade10d04019). Leaving it open for protocols to experiment with, as the current PR text does, is probably the right answer for this PR. \r\n\r\n* My reading of [JWT's \"nbf\"](https://tools.ietf.org/html/rfc7519#section-4.1.5) indicates that they don't take the earliest of the not-before and the creation times when comparing to the current time. Instead, it looks like the [\"Issued At\"](https://tools.ietf.org/html/rfc7519#section-4.1.6) value is used for allowing a signature to be created some time before it's supposed to be valid. The signer also can't prevent the verifier from using whatever \"now\" value it wants, so I don't think it's worthwhile to add complexity to attempt to prevent that.\r\n\r\n* I'm intrigued by the suggestion that saying why a signature was invalid could help attackers. Saying \"when it is safe to do so\" probably doesn't help protocol designers much, but it could be useful to have some more detail in the Security Considerations. On the other hand, most of the time, saying \"the requirements are in the higher-level protocol definition\" is likely to be enough.\r\n\r\n* I like the examples of constraints verifiers might impose, like \"MAY impose its own maximum age limits\".",
              "createdAt": "2020-10-07T23:05:12Z",
              "updatedAt": "2020-10-07T23:15:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MDExMTkx",
          "commit": {
            "abbreviatedOid": "fb66293"
          },
          "author": "jricher",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-08T17:32:01Z",
          "updatedAt": "2020-10-08T17:32:02Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "\"not before\" is not really helpful when dealing with clock skew as it falls under the same limitations. \r\n\r\nI'm personally in favor of defining only the \"signature creation time\" and having everything else be decided by the verifier. Look at it from the signer's perspective: Why should I be able to tell you how long to accept my signature? I don't have the security context for that, and you can override it anyway and reject it even if I tell you it's not expired yet. \r\n\r\nBetter, I think, to mark the creation time and have guidelines on reasonable default expiration and lifetimes for validators, especially if we can state them in terms of a delta from the current time (and possibly the \"date\" header). ",
              "createdAt": "2020-10-08T17:32:01Z",
              "updatedAt": "2020-10-08T17:32:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MTMyNDQ2",
          "commit": {
            "abbreviatedOid": "fb66293"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-10T23:28:15Z",
          "updatedAt": "2020-10-10T23:28:16Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "@jyasskin thanks for your feedback!\r\n\r\n> A protocol using HTTP Message Signatures MUST define how it uses\r\n> ... to determine whether the signature is currently valid.\r\n\r\nThis approach is  a good starting point\r\n\r\n> The signed exchange spec currently says clients may adjust the creation time for skew\r\n> but mustn't adjust the expiration time\r\n> Chromium implementation doesn't adjust for skew at all\r\n\r\nI think that this spec should allow to implement this behavior.\r\n\r\n> My reading of JWT's \"nbf\" indicates that they don't take the earliest\r\n\r\nRight, but still it's useful to account for clock skew.\r\n\r\n> The signer also can't prevent the verifier from using whatever \"now\" value it wants\r\n\r\nIt is true if the verifier purposedly wants to accept expired signatures. OTOH if the verifier \r\nhave a very large skew tolerance the protocol could become vulnerable to replay attacks.\r\n\r\n> ... when it is safe to do so ...\r\n\r\nThis part  was just a placeholder to highlight that security considerations are required. \r\n\r\n@jricher \r\n\r\n> reasonable default expiration and lifetimes\r\n\r\nyou know my opinion :D  there can be no reasonable default value, because imho it's for the signer to say :D \r\nnot supporting expiration will hinder adoption of this spec in all cases where an expiration is mandatory...\r\n",
              "createdAt": "2020-10-10T23:28:15Z",
              "updatedAt": "2020-10-10T23:29:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2ODg4NDEw",
          "commit": {
            "abbreviatedOid": "fb66293"
          },
          "author": "richanna",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T20:13:54Z",
          "updatedAt": "2020-10-12T20:13:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I like the idea of including guidance/requirements for profiling specs, though I would want to aggregate those under a separate \"Considerations for Profiling Specifications\" (e.g.) section, rather than have them distributed across the document. That makes it easier for profilers to understand what's needed of them, and for non-profilers to ignore stuff that's irrelevant to them.\r\n\r\n> Why should [the signer] be able to tell [the verifier] how long to accept [the signer's] signature?\r\n\r\nThink of it instead as the signer saying how long they will acknowledge the signature, from a non-repudiation standpoint. That also serves as an implicit recommendation to the verifier \u2013 \"I'm not trusting this after X, so you probably shouldn't either.\" The value of X may be informed by how the signer manages their signing keys, or knowledge about the network environment between signer and verifier that the verifier may not have.\r\n\r\nAt the same time, the signer may not know how the verifier will process the signed message. It may verify the signature on receipt, then forward the whole message (with signature) to an async workflow, which might revalidate the signature minutes or hours later. In such a scenario, the async workflow may need to be looser with expiration time enforcement than recommended by the signer.\r\n\r\nThere are very few absolute statements we can make about time-related signature validity checks, at least at this level of abstraction. I'm 100% in favor of providing examples, and requiring profiling specifications to define requirements and/or provide guidance. \r\n\r\nWith all of this, here is what I think needs to go into the spec:\r\n\r\n1. Define Expiration Time as the signer's statement/recommendation to the verifier.\r\n2. Explicitly state that this spec does not impose any limits on how verifier considers Expiration Time (examples of scenarios where a verifier might apply a higher or lower Expiration Time).\r\n3. State that profiling specifications can (SHOULD? MUST?) impose limits (provide examples).\r\n4. Require time-based checks to use Creation Time and Expiration Time where applicable (e.g., cannot use the value of the Date header field instead of Creation Time).",
              "createdAt": "2020-10-12T20:13:54Z",
              "updatedAt": "2020-10-12T20:13:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2OTMzMjkw",
          "commit": {
            "abbreviatedOid": "fb66293"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T21:36:59Z",
          "updatedAt": "2020-10-12T21:37:00Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> I'm 100% in favor of providing examples, and requiring profiling specifications to define requirements and/or provide guidance.\r\n\r\nProviding examples and discussing is a great way to tune up specs and identify use-cases :)\r\n\r\nLet me know when I can re-review the PR!\r\n",
              "createdAt": "2020-10-12T21:36:59Z",
              "updatedAt": "2020-10-12T21:39:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1281,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk3NDczNDAy",
      "title": "digest-headers: update to semantics-12",
      "url": "https://github.com/httpwg/http-extensions/pull/1281",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers",
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-10-04T17:59:22Z",
      "updatedAt": "2020-10-07T15:42:15Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ec43ebf7444441b4640a0f56d89ef331d5a46715",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-1",
      "headRefOid": "4b5e89977bb23f9a91332ddf06550a0624c8be20",
      "closedAt": "2020-10-07T15:42:06Z",
      "mergedAt": "2020-10-07T15:42:06Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "4490f41d13ca41058c36faa0a120364c17d1df30"
      },
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@reschke thanks!!! :tada: ",
          "createdAt": "2020-10-07T15:42:15Z",
          "updatedAt": "2020-10-07T15:42:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNjQ1NDk2",
          "commit": {
            "abbreviatedOid": "4b5e899"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-10-04T18:00:47Z",
          "updatedAt": "2020-10-04T18:00:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1282,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk3NzMxMjUx",
      "title": "[client-hints] Remove unclosed parens and rearrange related sentences",
      "url": "https://github.com/httpwg/http-extensions/pull/1282",
      "state": "OPEN",
      "author": "yoavweiss",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "Closes #1272",
      "createdAt": "2020-10-05T09:50:07Z",
      "updatedAt": "2020-10-12T23:20:33Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ec43ebf7444441b4640a0f56d89ef331d5a46715",
      "headRepository": "yoavweiss/http-extensions",
      "headRefName": "client_hints_unclosed_parens",
      "headRefOid": "45c20991efd24d8289f73d3847eceb20e41e0ac5",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1283,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk5NDI4Mzgx",
      "title": "Add definition and semantics of applied parameter.",
      "url": "https://github.com/httpwg/http-extensions/pull/1283",
      "state": "CLOSED",
      "author": "roger-on-github",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "priorities"
      ],
      "body": "Define an 'applied' parameter for Priority HTTP Header Field (responses only). The presence of this parameter indicates that a Priority HTTP Header Field was recognized in the request. Its value indicates that the requested prioritization was applied to the scheduling of the response (or not).\r\n\r\nThis parameter will be useful to clients whose optimal behavior depends on whether prioritization controls are available. For example, consider a media client that plays a live stream by successively downloading and displaying short media segments as they are produced. The standard model is to assume a connection whose bandwidth is just slightly above the media bit rate. If each media segment is 400ms, the RTT is 100ms, and the client is playing 3 segments behind the live edge, overall performance can be improved by pipelining successive segment requests to amortize the RTT cost -- but only if the remote end does not send responses in parallel (incremental=0). If responses are sent in parallel then the next segment to play will share bandwidth with subsequent response(s) and take longer than 400ms to arrive, causing playback to stall. A client that requests pipelining and discovers that it is not available can then issue future requests in serial, without pipelining them.",
      "createdAt": "2020-10-07T18:10:56Z",
      "updatedAt": "2020-10-18T00:41:00Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4490f41d13ca41058c36faa0a120364c17d1df30",
      "headRepository": "roger-on-github/http-extensions",
      "headRefName": "add-applied",
      "headRefOid": "930a321d357c52b6f42479b043d653f811afd79b",
      "closedAt": "2020-10-18T00:41:00Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing this since the linked issues has been closed with no action.",
          "createdAt": "2020-10-18T00:40:35Z",
          "updatedAt": "2020-10-18T00:40:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MzM1MDY5",
          "commit": {
            "abbreviatedOid": "930a321"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-07T23:27:24Z",
          "updatedAt": "2020-10-07T23:27:27Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "What if the parameter is not understood?\r\n\r\nWhat if only some parameters were respected?\r\n\r\nWhat if the response carries different priority information intentionally?",
              "createdAt": "2020-10-07T23:27:24Z",
              "updatedAt": "2020-10-07T23:27:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MzQ5NTgz",
          "commit": {
            "abbreviatedOid": "930a321"
          },
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-08T00:11:02Z",
          "updatedAt": "2020-10-08T00:11:02Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "If the parameter is not understood then it cannot be applied, by definition, so applied would be false. Similarly if only some parameters were respected, or if the response intentionally applied different values.",
              "createdAt": "2020-10-08T00:11:02Z",
              "updatedAt": "2020-10-08T00:11:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MzQ5OTY5",
          "commit": {
            "abbreviatedOid": "930a321"
          },
          "author": "roger-on-github",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-08T00:12:19Z",
          "updatedAt": "2020-10-08T00:12:20Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "FYI, there's a discussion of this going on in the Issues section, https://github.com/httpwg/http-extensions/issues/1274",
              "createdAt": "2020-10-08T00:12:19Z",
              "updatedAt": "2020-10-08T00:12:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1284,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk5NDg1NTQ3",
      "title": "Achieving algorithm agility. See #1250",
      "url": "https://github.com/httpwg/http-extensions/pull/1284",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nDescribes how to achieve algorithm agility:\r\n\r\n- add Status to IANA table;\r\n- use Want-Digest to negotiate newer algos\r\n- use multiple digest values while transitioning to new algos (see https://tools.ietf.org/html/rfc7696#section-2.3 but I didn't cite it as I don't think it is worth unless we want to add MANDATORY algorithms)\r\n\r\n## Note:\r\n\r\nI didn't merge this section with IANA Considerations because of [Keep IANA Considerations for IANA]( https://tools.ietf.org/html/rfc8126#section-1.1)",
      "createdAt": "2020-10-07T20:02:23Z",
      "updatedAt": "2020-10-12T23:17:20Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4490f41d13ca41058c36faa0a120364c17d1df30",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1250-algorithm-agility",
      "headRefOid": "07d856daefebf79fddd1275ae3cfbccbb16827a4",
      "closedAt": "2020-10-12T23:17:19Z",
      "mergedAt": "2020-10-12T23:17:19Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "29d47bfa33411ea2cd188a838c5a2f0a6079a2a9"
      },
      "comments": [
        {
          "author": "jricher",
          "authorAssociation": "CONTRIBUTOR",
          "body": "~This only addresses the algorithm used in digesting the message body, not the algorithm used to sign content.~\r\n\r\nSorry, ignore that -- I thought this was a comment on the signatures draft, my mistake.",
          "createdAt": "2020-10-08T17:33:00Z",
          "updatedAt": "2020-10-08T17:34:21Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No problem @jricher :) This is one of the joys of a shared repo. Labels help but aren't a complete solution. ",
          "createdAt": "2020-10-08T17:53:27Z",
          "updatedAt": "2020-10-08T17:53:27Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Sorry, ignore that -- I thought this was a comment on the signatures draft, my mistake.\r\n\r\n@jricher still you are still in time to  provide some feedback on Digest :D we hope to release it soon!\r\n\r\n@LPardue PTAL :P \r\n",
          "createdAt": "2020-10-08T17:58:27Z",
          "updatedAt": "2020-10-08T17:58:27Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue I tried to integrate your text, which improves significantly the description. Thanks!\r\n\r\nIf we want to shorten the text, we could replace some parts referencing RFC7696 and pointing the reader there (explanation of algorithm agility, transition from weaker algorithms, ...)\r\n\r\nWDYT?",
          "createdAt": "2020-10-08T22:10:23Z",
          "updatedAt": "2020-10-08T22:10:23Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Reorganized the algorithm status here https://github.com/httpwg/http-extensions/pull/1284/commits/d389ea9b0e25de45f4f27885d511dc91f4221631# @LPardue ",
          "createdAt": "2020-10-12T23:03:11Z",
          "updatedAt": "2020-10-12T23:03:11Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "looks good. Let's land that sentence deletion and merge this.",
          "createdAt": "2020-10-12T23:07:41Z",
          "updatedAt": "2020-10-12T23:07:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MDM1ODE0",
          "commit": {
            "abbreviatedOid": "0c933f0"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-08T18:02:40Z",
          "updatedAt": "2020-10-08T18:02:40Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "If we're going to expand this we can probably write this better. The first thing that spring into my head is something like\r\n\r\nA `Digest` field MAY contain multiple representation-data-digest values. For example, a server may provide representation-data-digest values using different algorithms, allowing it to support a population of clients with different evolving capabilities.",
              "createdAt": "2020-10-08T18:02:40Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MDM3MzU3",
          "commit": {
            "abbreviatedOid": "0c933f0"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-08T18:04:35Z",
          "updatedAt": "2020-10-08T18:04:35Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "and optionally tack on\r\n\r\n\"This is particularly useful in support of transitioning away from weaker algorithms should the need arise; see {{algorithm-agiity}}\"",
              "createdAt": "2020-10-08T18:04:35Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MDU2MjM1",
          "commit": {
            "abbreviatedOid": "0c933f0"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-08T18:29:11Z",
          "updatedAt": "2020-10-08T18:29:12Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Now that there is text, I can see the bones of what you're trying to say. But I think we can rewrite this to be a bit clearer. Here's strawperson text:\r\n\r\n\"The security properties of digest algorithms are not fixed. It is in an endpoint's best interest to support and use the most secure algorithms that are at its disposal. However, there is little that this specification can do to mandate behaviour. To help endpoints make better algorithm choices a new \"Status\" field has been added to the IANA Digest Algorithm Values registry (see Section xyz), which contains the most-recent appraisal of the algorithm. Algorithms that have been found insecure or otherwise undesirable can be marked as \"deprecated\" or \"obsolete\". Algorithms with no known problems can be marked as \"Standard\", while new algorithms can be marked \"Experimental\".\r\n\r\nAn endpoint might have a preference for algorithms, such as preferring \"standard\" algorithms over \"deprecated\" ones. Algorithm agility is supported by negotiation of digest-algorithm using ``Want-Digest` (see {{want-digest}})` or by sending multiple representation-data-digest values for the receiver to choose. Endpoints are advised that sending multiple values consumes resources, which may be wasted if the receiver ignores them (see {{digest}}).\"",
              "createdAt": "2020-10-08T18:29:12Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MjI0MjE3",
          "commit": {
            "abbreviatedOid": "299446c"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-11T22:43:43Z",
          "updatedAt": "2020-10-11T22:43:43Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This sentence seems to me to just repeat the notion of evolving capability already introduced in the paragraph.\r\n\r\nI suspect this text, originally in RFC 3230, was attempting to address transparent caching proxies. I'm not convinced we need to keep it in that form given how many HTTP deployments work. Maybe @mnot has an opinion.",
              "createdAt": "2020-10-11T22:43:43Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MjI2MDY4",
          "commit": {
            "abbreviatedOid": "299446c"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-11T23:03:47Z",
          "updatedAt": "2020-10-11T23:03:47Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "How about,\r\n\r\n> Algorithm Agility (see {{?RFC7696}}) is achieved by providing implementations flexibility in their choice of digest-algorithm from the IANA Digest Algorithm Values registy in {{iana-digest-algorithm-registry}}.",
              "createdAt": "2020-10-11T23:03:47Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MjI2NTE4",
          "commit": {
            "abbreviatedOid": "299446c"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-11T23:08:51Z",
          "updatedAt": "2020-10-11T23:08:51Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Let's not say secure, because algorithms will inevitably be broken. How about \r\n\r\n```suggestion\r\nTo help endpoints understand weaker algorithms from stonger ones,\r\n```",
              "createdAt": "2020-10-11T23:08:51Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MjI2ODkx",
          "commit": {
            "abbreviatedOid": "299446c"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-11T23:12:22Z",
          "updatedAt": "2020-10-11T23:12:23Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "The remember of the paragraph is hard to parse and I don't think it is strictly true. I'd like to think that we can deprecate algorithms without the need of coordination with the original defining document. The reason some algorithm becomes deprecated or obsolete could because it is a dead one. I think it would be simpler to just remove everything after \"... appraisal of the digest-algorithm.\"",
              "createdAt": "2020-10-11T23:12:22Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MjI3MDAz",
          "commit": {
            "abbreviatedOid": "299446c"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-11T23:13:27Z",
          "updatedAt": "2020-10-11T23:13:28Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nare marked as \"deprecated\",\r\n```\r\n\r\nlet's use the active voice.",
              "createdAt": "2020-10-11T23:13:28Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MjI3MDE5",
          "commit": {
            "abbreviatedOid": "299446c"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-11T23:13:41Z",
          "updatedAt": "2020-10-11T23:13:41Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nwhile the ones associated to a standardized algorithm without known problems are marked\r\n```",
              "createdAt": "2020-10-11T23:13:41Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MjI3MTUw",
          "commit": {
            "abbreviatedOid": "299446c"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-11T23:14:56Z",
          "updatedAt": "2020-10-11T23:14:56Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nor by sending multiple representation-data-digest values from which the receiver chooses.\r\n```",
              "createdAt": "2020-10-11T23:14:56Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MjI3MzEx",
          "commit": {
            "abbreviatedOid": "299446c"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Ahh I'd overlooked RFC 7696 sorry. I think what's here is almost right, and I've made some minor suggestions.",
          "createdAt": "2020-10-11T23:16:46Z",
          "updatedAt": "2020-10-11T23:16:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MjI5MDY0",
          "commit": {
            "abbreviatedOid": "299446c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-11T23:35:27Z",
          "updatedAt": "2020-10-11T23:35:27Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "```suggestion\r\nwhich may be wasted if the receiver ignores them (see {{digest}}).\r\n```",
              "createdAt": "2020-10-11T23:35:27Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2Mzc2NTU5",
          "commit": {
            "abbreviatedOid": "299446c"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T07:56:14Z",
          "updatedAt": "2020-10-12T07:56:15Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nAlgorithm Agility (see {{?RFC7696}}) is achieved by providing implementations flexibility in their choice of\r\ndigest-algorithm from the IANA Digest Algorithm Values registy in {{iana-digest-algorithm-registry}}.\r\n```",
              "createdAt": "2020-10-12T07:56:14Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2Mzc3MDgy",
          "commit": {
            "abbreviatedOid": "299446c"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T07:56:58Z",
          "updatedAt": "2020-10-12T07:56:58Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "applied!",
              "createdAt": "2020-10-12T07:56:58Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NDg0NTkx",
          "commit": {
            "abbreviatedOid": "de85f16"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T10:13:27Z",
          "updatedAt": "2020-10-12T10:13:28Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Done",
              "createdAt": "2020-10-12T10:13:27Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NDk3NzI5",
          "commit": {
            "abbreviatedOid": "de85f16"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T10:32:30Z",
          "updatedAt": "2020-10-12T10:32:30Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "In our spec  https://github.com/httpwg/http-extensions/blame/master/draft-ietf-httpbis-digest-headers.md#L1079:1082\r\nwe reused this part of RFC3864 \r\n\r\n      Specify \"standard\", \"experimental\", \"informational\", \"historic\",\r\n      \"obsoleted\", or some other appropriate value according to the type\r\n      and status of the primary document in which it is defined.  For\r\n      non-IETF specifications, those formally approved by other\r\n      standards bodies should be labelled as \"standard\"; others may be\r\n      \"informational\" or \"deprecated\" depending on the reason for\r\n      registration.\r\n\r\nwhich is more relaxed than the present. I will relax our statement and ask to reviewers for feedback so that we can land this PR.\r\n",
              "createdAt": "2020-10-12T10:32:30Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NDk4NzA1",
          "commit": {
            "abbreviatedOid": "de85f16"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T10:33:55Z",
          "updatedAt": "2020-10-12T10:33:55Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "@LPardue Are you proposing this?\r\n\r\n```suggestion\r\n```\r\n",
              "createdAt": "2020-10-12T10:33:55Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NDk5Mzk1",
          "commit": {
            "abbreviatedOid": "de85f16"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T10:34:59Z",
          "updatedAt": "2020-10-12T10:35:00Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nthis document adds to the IANA Digest Algorithm Values registry\r\na new \"Status\" field containing the most-recent appraisal of the digest-algorithm.\r\n```",
              "createdAt": "2020-10-12T10:34:59Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NTI0NzE0",
          "commit": {
            "abbreviatedOid": "9001894"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-12T11:13:06Z",
          "updatedAt": "2020-10-12T11:13:07Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Yes.",
              "createdAt": "2020-10-12T11:13:06Z",
              "updatedAt": "2020-10-12T23:12:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1285,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwMjI3Mjgw",
      "title": "Detail encryption quirks",
      "url": "https://github.com/httpwg/http-extensions/pull/1285",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\ndetails encryption quirks:\r\n\r\n- encryption functions may produce different results with the same data\r\n- this means that if I GET an encrypted resource twice, I could get two different digest values\r\n- so the digest value is just good to validate the ongoing message and not for further processing of the data at rest, unless I store the encrypted data or use an `id-` algorithm which in turn might disclose information.\r\n\r\nThis  ",
      "createdAt": "2020-10-08T22:34:32Z",
      "updatedAt": "2020-10-12T22:12:35Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4490f41d13ca41058c36faa0a120364c17d1df30",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1250-encrypted-coding",
      "headRefOid": "898310bd23bc8b937de861e1172a06537bd03dca",
      "closedAt": "2020-10-12T22:12:34Z",
      "mergedAt": "2020-10-12T22:12:34Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "bf839471f9fa9760f652af77792a662190a74318"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MjI4NTQ1",
          "commit": {
            "abbreviatedOid": "ec2ddfc"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "looks good, just some nits.",
          "createdAt": "2020-10-11T23:30:20Z",
          "updatedAt": "2020-10-11T23:31:44Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\ndepending on the encryption algorithm used; in those cases its value could not be used to provide\r\n```",
              "createdAt": "2020-10-11T23:30:20Z",
              "updatedAt": "2020-10-12T07:19:18Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\na proof of integrity \"at rest\" unless the whole (e.g. encoded) payload body is persisted.\r\n```",
              "createdAt": "2020-10-11T23:31:24Z",
              "updatedAt": "2020-10-12T07:19:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1286,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAxODczMzA5",
      "title": "Removed reverted Expiration Time change from changelog.",
      "url": "https://github.com/httpwg/http-extensions/pull/1286",
      "state": "MERGED",
      "author": "richanna",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Change to specification text was reverted.",
      "createdAt": "2020-10-12T23:20:15Z",
      "updatedAt": "2020-10-13T14:40:25Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "29d47bfa33411ea2cd188a838c5a2f0a6079a2a9",
      "headRepository": "richanna/http-extensions",
      "headRefName": "master",
      "headRefOid": "70e5241e30a4120f45d3720ddae92981ae4249a1",
      "closedAt": "2020-10-13T14:40:25Z",
      "mergedAt": "2020-10-13T14:40:25Z",
      "mergedBy": "jricher",
      "mergeCommit": {
        "oid": "1b0875b5fbfb42fd6c6ccd5e11ba54b4a53302cf"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 1287,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAxOTYxMDk4",
      "title": "Stop using XSLT, use xml2rfc v3",
      "url": "https://github.com/httpwg/http-extensions/pull/1287",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-13T03:56:24Z",
      "updatedAt": "2020-10-13T04:14:15Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "29d47bfa33411ea2cd188a838c5a2f0a6079a2a9",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "no-xslt",
      "headRefOid": "fe86511072709afe4e073045d2194371489a3d12",
      "closedAt": "2020-10-13T04:14:14Z",
      "mergedAt": "2020-10-13T04:14:14Z",
      "mergedBy": "mnot",
      "mergeCommit": {
        "oid": "6aa85b72d3fb16044d217fa9c4e9a246ab9a262f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 1291,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1MDgyNjQ3",
      "title": "Add changelog since -03",
      "url": "https://github.com/httpwg/http-extensions/pull/1291",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\nAdds changelog since -03",
      "createdAt": "2020-10-16T20:18:46Z",
      "updatedAt": "2020-10-19T08:01:14Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "b8e8b83abfe3ea7a20be241f9c30c82211b8eeb8",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-digest-changelog",
      "headRefOid": "293def930c0f2a8142b997ca561f34addd34efc8",
      "closedAt": "2020-10-17T17:19:39Z",
      "mergedAt": "2020-10-17T17:19:39Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "d0ff172ae63db6dc099b30d5730ce392584ee558"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we missed the parameter changes?\r\n\r\nAlso I just realised that the draft order is ascending, folks typically do it in descending order so the most recent changes are easier to see",
          "createdAt": "2020-10-16T20:23:13Z",
          "updatedAt": "2020-10-16T20:23:13Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "1. The parameter didn't land yet :( https://github.com/httpwg/http-extensions/pull/1259\r\n2. ok :)\r\n",
          "createdAt": "2020-10-16T21:58:53Z",
          "updatedAt": "2020-10-17T11:20:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMjIxMzEw",
          "commit": {
            "abbreviatedOid": "293def9"
          },
          "author": "pes2020kk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "ios 14",
          "createdAt": "2020-10-18T21:19:43Z",
          "updatedAt": "2020-10-18T21:19:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1292,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1MTMyMTgz",
      "title": "Typo: sha is deprecated, not obsoleted.",
      "url": "https://github.com/httpwg/http-extensions/pull/1292",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nsha is deprecated, not obsoleted.",
      "createdAt": "2020-10-16T22:33:07Z",
      "updatedAt": "2020-10-16T22:34:47Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "7b7279310a201572963326add9cc0a8604962d9d",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-sha-deprecated",
      "headRefOid": "0d4b808b35b9811cf682cf3c60c1bb0d52937425",
      "closedAt": "2020-10-16T22:34:46Z",
      "mergedAt": "2020-10-16T22:34:46Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "bdc92b089f5c1e4e0bd29f2cc927eafd163fb052"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 1293,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1MjEyNzUw",
      "title": "digest: subsections of unnumbered sections are already unnumbered [xml2rfc issue]",
      "url": "https://github.com/httpwg/http-extensions/pull/1293",
      "state": "OPEN",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers",
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-10-17T04:25:45Z",
      "updatedAt": "2020-10-18T14:08:55Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "bdc92b089f5c1e4e0bd29f2cc927eafd163fb052",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-1",
      "headRefOid": "67730efb4602c74a167f33a9e54a05146fce74a0",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the PR! The CI gives this error: \r\n> /github/workspace/draft-ietf-httpbis-digest-headers.xml(1743): Error: Did not expect a numbered section under an unnumbered parent section (seen on line 1740)\r\n",
          "createdAt": "2020-10-17T11:16:36Z",
          "updatedAt": "2020-10-17T11:16:36Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh.\r\n\r\nThat's a bug in xml2rfc then (I didn't realize that because I use rfc2629.xslt). So ignore this PR for now until the bug is fixed.",
          "createdAt": "2020-10-17T11:27:48Z",
          "updatedAt": "2020-10-17T11:27:48Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See <https://trac.tools.ietf.org/tools/xml2rfc/trac/ticket/556>.",
          "createdAt": "2020-10-18T14:08:54Z",
          "updatedAt": "2020-10-18T14:08:54Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 1294,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1MzE5MjAw",
      "title": "Fix: 1208. Intermediaries altering content/transfer-coding or content\u2026",
      "url": "https://github.com/httpwg/http-extensions/pull/1294",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\n- [x] avoid ambiguous statement on digest protecting from compressed content-coding https://github.com/httpwg/http-extensions/issues/1208#issuecomment-634351643\r\n- i[x] t can protect from intermediaries altering representation metadata (content-type, content-coding)\r\n\r\n",
      "createdAt": "2020-10-17T17:33:55Z",
      "updatedAt": "2020-10-20T14:31:49Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d0ff172ae63db6dc099b30d5730ce392584ee558",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1208-intermediaries-altering",
      "headRefOid": "5e22ef954101175b66118b1d52d7ed1d85a95557",
      "closedAt": "2020-10-20T14:31:48Z",
      "mergedAt": "2020-10-20T14:31:48Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "ebf3e4885fde4caef47f8277df2e8497a110b7d3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMDIzODY2",
          "commit": {
            "abbreviatedOid": "2c56123"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-18T00:27:58Z",
          "updatedAt": "2020-10-18T00:39:43Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "adding \"in flight\" seems werid. What errors do you expect that TLS integrity wouldn't have caught?",
              "createdAt": "2020-10-18T00:27:59Z",
              "updatedAt": "2020-10-20T14:29:27Z"
            },
            {
              "originalPosition": 13,
              "body": "Do we need this? Isn't it just restating a requirement about end-to-end headers? \r\n\r\nPerhaps we can jsut reference to semantics here too.",
              "createdAt": "2020-10-18T00:31:37Z",
              "updatedAt": "2020-10-20T14:29:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMTAzNjgy",
          "commit": {
            "abbreviatedOid": "2c56123"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-18T07:25:44Z",
          "updatedAt": "2020-10-18T07:25:45Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "It refers to trasfer-coding-like issues without mentioning them. See https://github.com/httpwg/http-extensions/issues/1208#issuecomment-634351643",
              "createdAt": "2020-10-18T07:25:44Z",
              "updatedAt": "2020-10-20T14:29:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMTA0ODQ0",
          "commit": {
            "abbreviatedOid": "2c56123"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-18T07:27:33Z",
          "updatedAt": "2020-10-18T07:27:34Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "The \"considerations on new fields\" in Semantics, asks to explicit whether intermediaries can  alter the field and how.",
              "createdAt": "2020-10-18T07:27:33Z",
              "updatedAt": "2020-10-20T14:29:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMTQ2NTc3",
          "commit": {
            "abbreviatedOid": "2c56123"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-18T13:47:58Z",
          "updatedAt": "2020-10-18T13:47:58Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Yeah its fine to keep then",
              "createdAt": "2020-10-18T13:47:58Z",
              "updatedAt": "2020-10-20T14:29:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNzgxNjI1",
          "commit": {
            "abbreviatedOid": "2c56123"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T14:29:01Z",
          "updatedAt": "2020-10-20T14:29:02Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\n```\r\nNo normative language. Discussed with @martinthomson and @mnot at interim 2020-10",
              "createdAt": "2020-10-20T14:29:01Z",
              "updatedAt": "2020-10-20T14:29:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNzgzMzE3",
          "commit": {
            "abbreviatedOid": "5e22ef9"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-20T14:30:32Z",
          "updatedAt": "2020-10-20T14:30:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1295,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1MzQyNjU0",
      "title": "digest: minor editorial typos",
      "url": "https://github.com/httpwg/http-extensions/pull/1295",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "digest-headers"
      ],
      "body": "## This PR\r\n\r\n- minor editorial improvements",
      "createdAt": "2020-10-17T20:29:02Z",
      "updatedAt": "2020-10-18T13:24:28Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "d0ff172ae63db6dc099b30d5730ce392584ee558",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-typo-digest-2",
      "headRefOid": "33be5a2443beca4961bb8c0e4104bf86f07db449",
      "closedAt": "2020-10-18T13:24:27Z",
      "mergedAt": "2020-10-18T13:24:27Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "5d3d2390c304dc5d2f69ef4dd73e8c2961d539c9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMDIzNjQ0",
          "commit": {
            "abbreviatedOid": "33be5a2"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-18T00:22:27Z",
          "updatedAt": "2020-10-18T00:22:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1297,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA2NDAxNjMy",
      "title": "Adopting Structured Fields",
      "url": "https://github.com/httpwg/http-extensions/pull/1297",
      "state": "MERGED",
      "author": "richanna",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "* Replaced unstructured `Signature` header with `Signature-Input` and `Signature` Dictionary Structured Header Fields.\r\n* Defined content identifiers for individual Dictionary members, e.g., `x-dictionary-field:member-name`.\r\n* Defined content identifiers for first N members of a List, e.g., `x-list-field:4`.\r\n\r\nA signature in a request now looks like this:\r\n```http\r\nSignature-Input: sig1=(*request-target, *created, host, date,\r\n    cache-control, x-empty-header, x-example); keyId=\"test-key-a\";\r\n    alg=hs2019; created=1402170695; expires=1402170995\r\nSignature: sig1=:K2qGT5srn2OGbOIDzQ6kYT+ruaycnDAAUpKv+ePFfD0RAxn/1BUe\r\n    Zx/Kdrq32DrfakQ6bPsvB9aqZqognNT6be4olHROIkeV879RrsrObury8L9SCEibe\r\n    oHyqU/yCjphSmEdd7WD+zrchK57quskKwRefy2iEC5S2uAH0EPyOZKWlvbKmKu5q4\r\n    CaB8X/I5/+HLZLGvDiezqi6/7p2Gngf5hwZ0lSdy39vyNMaaAT0tKo6nuVw0S1MVg\r\n    1Q7MpWYZs0soHjttq0uLIA3DIbQfLiIvK6/l0BdWTU7+2uQj7lBkQAsFZHoA96ZZg\r\n    FquQrXRlmYOh+Hx5D9fJkXcXe5tmAg==:\r\n```\r\nFixes #1198\r\nFixes #1181 \r\nFixes #1184 ",
      "createdAt": "2020-10-20T02:04:05Z",
      "updatedAt": "2020-10-24T16:29:22Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "5d3d2390c304dc5d2f69ef4dd73e8c2961d539c9",
      "headRepository": "richanna/http-extensions",
      "headRefName": "master",
      "headRefOid": "02797f3f7561f095b8443092dc75b62125faf85b",
      "closedAt": "2020-10-23T23:06:29Z",
      "mergedAt": "2020-10-23T23:06:28Z",
      "mergedBy": "richanna",
      "mergeCommit": {
        "oid": "eeffe4f3152d73bee44028c19438eaaec5fac2bf"
      },
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this PR! We just need some tweaks, but it greatly improves the way the spec can be used.",
          "createdAt": "2020-10-20T08:20:50Z",
          "updatedAt": "2020-10-20T08:20:50Z"
        },
        {
          "author": "llorllale",
          "authorAssociation": "NONE",
          "body": "This PR also fixes `B.2.2 Multiple Signature Support`. Should we remove that appendix in this PR?",
          "createdAt": "2020-10-23T21:00:11Z",
          "updatedAt": "2020-10-23T21:00:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNDE3Nzgx",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T07:43:36Z",
          "updatedAt": "2020-10-20T07:43:37Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nAn HTTP header field is identified by its header field name.  While HTTP header field names are case-insensitive, implementations MUST use lowercased field names (e.g., `content-type`, `date`, `etag`) when using them as content identifiers.\r\n```",
              "createdAt": "2020-10-20T07:43:36Z",
              "updatedAt": "2020-10-23T23:04:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNDE5NTcx",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T07:45:43Z",
          "updatedAt": "2020-10-20T07:45:44Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nAn individual member in the value of a Dictionary Structured Field is identified concatenating\r\nthe lowercased field name,\r\na semicolon `\":\"`\r\nand the member name.\r\nAn individual member in the value of a Dictionary Structured Field is canonicalized by applying the serialization algorithm described in Section 4.1.2 of {{StructuredFields}} on a Dictionary containing only that member.\r\n```",
              "createdAt": "2020-10-20T07:45:44Z",
              "updatedAt": "2020-10-23T23:04:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNDMwNzQ2",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T07:59:04Z",
          "updatedAt": "2020-10-20T07:59:04Z",
          "comments": [
            {
              "originalPosition": 259,
              "body": "The line is not clear:\r\n\r\n1- an unexpiring signature has no *expires\r\n2- if *expires is missing, the expiration is undefined\r\n\r\nI think 2) is the right statement\r\n\r\n```suggestion\r\n: OPTIONAL. The `expires` parameter is a Decimal containing the signature's Expiration Time, expressed as the canonicalized value of the `*expires` content identifier, as defined in Section 2.\r\nIf the signature does not have an Expiration Time, this parameter MUST be omitted.  If not specified, the signature's Expiration Time is undefined.\r\n```",
              "createdAt": "2020-10-20T07:59:04Z",
              "updatedAt": "2020-10-23T23:04:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNDQyMTIw",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T08:12:12Z",
          "updatedAt": "2020-10-20T08:12:13Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "I like the parentheses removal! ",
              "createdAt": "2020-10-20T08:12:12Z",
              "updatedAt": "2020-10-23T23:04:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNDQ3MDgz",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T08:17:57Z",
          "updatedAt": "2020-10-20T08:17:58Z",
          "comments": [
            {
              "originalPosition": 304,
              "body": "I like `Signature-Input`! Do you think it would be useful to separate the signed headers and signature parameters (*alg, *created, *expires, ...)?",
              "createdAt": "2020-10-20T08:17:57Z",
              "updatedAt": "2020-10-23T23:04:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNzc4ODMz",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T14:26:38Z",
          "updatedAt": "2020-10-20T14:26:38Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "@richanna following the discussion at the httpwg meeting I suggest to split this part in another PR so that we can land this one.\r\n\r\nSub-referencing header could be leveraged to push the reicever to parse a given header in a certain way which is in control of the sender (eg. triggering keyerror, indexerror, ..).",
              "createdAt": "2020-10-20T14:26:38Z",
              "updatedAt": "2020-10-23T23:04:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTc0MTQ4",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "jricher",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Overall this looks good to me, but with the new structures in place I think we need to raise an issue about whether we should always sign the Signature-Input itself as part of the processing a given signature. We have a method for doing it explicitly but I think it should always be done.",
          "createdAt": "2020-10-23T19:58:01Z",
          "updatedAt": "2020-10-23T20:09:33Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "One thing that concerns me is that the signature input should always include itself, right? You shouldn't have to explicitly state that you're signing a particular input list for a given signature. ",
              "createdAt": "2020-10-23T19:58:01Z",
              "updatedAt": "2020-10-23T23:04:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTg5MjU5",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "jricher",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T20:25:33Z",
          "updatedAt": "2020-10-23T20:25:33Z",
          "comments": [
            {
              "originalPosition": 304,
              "body": "That's already done through the use of the structured elements and being able to \"name\" the signature input fields.",
              "createdAt": "2020-10-23T20:25:33Z",
              "updatedAt": "2020-10-23T23:04:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTk3MjI1",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "llorllale",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T20:40:43Z",
          "updatedAt": "2020-10-23T20:40:43Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "related: #1303 ",
              "createdAt": "2020-10-23T20:40:43Z",
              "updatedAt": "2020-10-23T23:04:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDAxODQ1",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "llorllale",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T20:49:08Z",
          "updatedAt": "2020-10-23T20:49:08Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "There is also a typo - semicolon/colon",
              "createdAt": "2020-10-23T20:49:08Z",
              "updatedAt": "2020-10-23T23:04:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDAzODI1",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "llorllale",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T20:52:57Z",
          "updatedAt": "2020-10-23T20:52:57Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "this PR does not specify the actual format of a dictionary",
              "createdAt": "2020-10-23T20:52:57Z",
              "updatedAt": "2020-10-23T23:04:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDA1MjM5",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "llorllale",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T20:55:47Z",
          "updatedAt": "2020-10-23T20:55:48Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "disregard - wasn't aware of draft-kamp-httpbis-structure-01",
              "createdAt": "2020-10-23T20:55:48Z",
              "updatedAt": "2020-10-23T23:04:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDE1NzAx",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "llorllale",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "I like the direction this PR is taking:\r\n\r\n* spec is more focused because it outsources spec of field format to draft-kamp-httpbis-structure\r\n* dictionary format is more flexible and allows multiple signatures\r\n* fixes #1184 (important)",
          "createdAt": "2020-10-23T21:17:44Z",
          "updatedAt": "2020-10-23T21:17:44Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDMzMTY4",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "richanna",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T21:59:32Z",
          "updatedAt": "2020-10-23T21:59:33Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "I considered adding that, but I think that leads to a bigger change: dropping *created and *expires, as they are no longer needed. Since this PR isn't introducing a new risk here, I opted to leave that to a future PR.",
              "createdAt": "2020-10-23T21:59:32Z",
              "updatedAt": "2020-10-23T23:04:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDM0NzM0",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "richanna",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T22:03:47Z",
          "updatedAt": "2020-10-23T22:03:48Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "FYI, current WG version of the Structured Fields draft is here: https://tools.ietf.org/html/draft-ietf-httpbis-header-structure",
              "createdAt": "2020-10-23T22:03:47Z",
              "updatedAt": "2020-10-23T23:04:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDQ5NDg3",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "richanna",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T22:50:50Z",
          "updatedAt": "2020-10-23T22:50:50Z",
          "comments": [
            {
              "originalPosition": 259,
              "body": "Both statements are correct.\r\n1. When generating a `Signature-Input` member, if the signature's Expiration Time is undefined, you MUST NOT include the `*expires` parameter.\r\n2. When parsing a `Signature-Input` member, if the member does not have an `*expires` parameter, that means the Expiration Time is undefined.",
              "createdAt": "2020-10-23T22:50:50Z",
              "updatedAt": "2020-10-23T23:04:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDUwOTk5",
          "commit": {
            "abbreviatedOid": "efea24a"
          },
          "author": "richanna",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T22:56:55Z",
          "updatedAt": "2020-10-23T22:56:56Z",
          "comments": [
            {
              "originalPosition": 304,
              "body": "I think we can actually replace content identifiers for signature metadata with signing the whole Signature-Input member (e.g., `signature-input:reverse_proxy_sig`). What remains then is header fields and identifiers for other protocol elements like `*request-target` (and similar likely-to-be-defined identifiers like `*method`, `*path`, etc.). I think splitting those out would add complexity without any clear benefit. It would also complicate the field format, since a dictionary member can't contain two lists.",
              "createdAt": "2020-10-23T22:56:55Z",
              "updatedAt": "2020-10-23T23:04:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2Mjg5ODAz",
          "commit": {
            "abbreviatedOid": "02797f3"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-24T16:29:21Z",
          "updatedAt": "2020-10-24T16:29:22Z",
          "comments": [
            {
              "originalPosition": 259,
              "body": "I would replace the current statement with your (1).\r\n\r\nHint: it would be great to have the statements on different lines like in the above suggestion. Readability and Referencing issues would be simpler especially for non-native speakers :P",
              "createdAt": "2020-10-24T16:29:21Z",
              "updatedAt": "2020-10-24T16:29:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1298,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA2ODU3MDA5",
      "title": "rfc6265bis: fix internal link",
      "url": "https://github.com/httpwg/http-extensions/pull/1298",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "6265bis",
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-10-20T14:35:43Z",
      "updatedAt": "2020-10-20T15:36:01Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "ebf3e4885fde4caef47f8277df2e8497a110b7d3",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-2",
      "headRefOid": "7e7cbc6086ab979f031bb5f49a4d46e805a36b50",
      "closedAt": "2020-10-20T15:36:00Z",
      "mergedAt": "2020-10-20T15:36:00Z",
      "mergedBy": "mikewest",
      "mergeCommit": {
        "oid": "aaf9e49b662d2372ca39919cd7bd42af0882d63f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyODcwMTU2",
          "commit": {
            "abbreviatedOid": "7e7cbc6"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2020-10-20T15:35:55Z",
          "updatedAt": "2020-10-20T15:35:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1299,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3MjQ2NDcw",
      "title": "rfc6265bis: update HTTP refs to new core specs",
      "url": "https://github.com/httpwg/http-extensions/pull/1299",
      "state": "OPEN",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-21T04:50:45Z",
      "updatedAt": "2020-10-21T04:50:45Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "aaf9e49b662d2372ca39919cd7bd42af0882d63f",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "reschke-patch-2",
      "headRefOid": "fe72b7f462832a863994139e6f37ea1d773ad14e",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1309,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA5NTAyMTk1",
      "title": "Generalize HTTP protocol",
      "url": "https://github.com/httpwg/http-extensions/pull/1309",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "## This PR\r\n\r\nGeneralize the HTTP messaging protocol.",
      "createdAt": "2020-10-24T22:13:19Z",
      "updatedAt": "2020-10-25T00:10:10Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "eeffe4f3152d73bee44028c19438eaaec5fac2bf",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-patch-2",
      "headRefOid": "799141407a706eab033116c177e5ff82cb923cac",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1310,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA5NTA0Nzg2",
      "title": "Method is defined in semantics. See #1214.",
      "url": "https://github.com/httpwg/http-extensions/pull/1310",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "## This PR\r\n\r\n- separates MESSAGING and SEMANTICS concepts (Eg. fields)\r\n",
      "createdAt": "2020-10-24T22:38:55Z",
      "updatedAt": "2020-10-25T00:10:10Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "eeffe4f3152d73bee44028c19438eaaec5fac2bf",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1214",
      "headRefOid": "e0044eff80d09bf4ecf154f568402a399388971f",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1312,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA5NTA5MzQ5",
      "title": "Remove redundant definitions. See #1311",
      "url": "https://github.com/httpwg/http-extensions/pull/1312",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "## This PR\r\n\r\n- uses sf-integer and sf-decimal to avoid re-defining Integer String and Decimal String\r\n",
      "createdAt": "2020-10-24T23:28:22Z",
      "updatedAt": "2020-10-27T13:46:35Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "eeffe4f3152d73bee44028c19438eaaec5fac2bf",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1311",
      "headRefOid": "e438c1a29dd88faf26a36782abc5ced3903ef490",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3NjQ2MzMw",
          "commit": {
            "abbreviatedOid": "e438c1a"
          },
          "author": "msporny",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-10-27T12:26:37Z",
          "updatedAt": "2020-10-27T12:26:43Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "```suggestion\r\n: OPTIONAL. The `expires` parameter is a `sf-integer` containing the signature's Expiration Time,\r\n```\r\n\r\nI believe this was a decimal initially because I wanted to support millisecond and nanosecond precision... the use case was high frequency trading. In time, it became evident that if people want that sort of resolution, they can create their own X-Header (or the like... High-Precision-Expiration: 234.3342).",
              "createdAt": "2020-10-27T12:26:37Z",
              "updatedAt": "2020-10-27T12:26:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3NzE4NDQ4",
          "commit": {
            "abbreviatedOid": "e438c1a"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-27T13:45:07Z",
          "updatedAt": "2020-10-27T13:45:08Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "@msporny thanks! we are discussing create/expires here https://github.com/httpwg/http-extensions/pull/1280\r\n\r\nIn this PR I just wanted to get rid of duplicate definitions leaving the semantic discussion to other issues. Specifically, there are other parts defining expires as a decimal. Probably we should - in other PRs - address the definition of those parameters in a one-and-only place.",
              "createdAt": "2020-10-27T13:45:08Z",
              "updatedAt": "2020-10-27T13:46:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1313,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA5NTExNjkx",
      "title": "Reuse existing definitions for Unix time and Structured fields.",
      "url": "https://github.com/httpwg/http-extensions/pull/1313",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "signatures"
      ],
      "body": "## This PR\r\n\r\nreuses existing definitions for S-F and Unix time.",
      "createdAt": "2020-10-24T23:56:02Z",
      "updatedAt": "2020-10-25T00:50:17Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "eeffe4f3152d73bee44028c19438eaaec5fac2bf",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1311-bis",
      "headRefOid": "22a1be323a90c6af33bdfd483629df3be84a4be7",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1314,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA5NTE0NTQz",
      "title": "Fix: #1190. Remove algorithm specific rules for content identifiers.",
      "url": "https://github.com/httpwg/http-extensions/pull/1314",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "## This PR\r\n\r\nremoves algorithm specific rules for content identifiers\r\n\r\n## Notes\r\n\r\nCurrent layout is not backward compatible with http-signatures, so it's safe to do it.\r\n\r\n",
      "createdAt": "2020-10-25T00:23:48Z",
      "updatedAt": "2020-10-25T00:48:26Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "eeffe4f3152d73bee44028c19438eaaec5fac2bf",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1190",
      "headRefOid": "26f8a1aee95147d8e435409d7d35ddc66d3b2f89",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1316,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA5NTE2OTIx",
      "title": "remove trailing whitespaces",
      "url": "https://github.com/httpwg/http-extensions/pull/1316",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "signatures"
      ],
      "body": "## This PR\r\n\r\nremoves trailing whitespaces :D ",
      "createdAt": "2020-10-25T00:47:57Z",
      "updatedAt": "2020-10-25T00:50:40Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "eeffe4f3152d73bee44028c19438eaaec5fac2bf",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-typo-5",
      "headRefOid": "41e269a49a9c6344bf047bad2aeaff344a3c1065",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1317,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA5NTE3MDQz",
      "title": "Fix: #1315. Remove subheader covered content.",
      "url": "https://github.com/httpwg/http-extensions/pull/1317",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "## This PR\r\n\r\nremoves sub-header covered content",
      "createdAt": "2020-10-25T00:49:12Z",
      "updatedAt": "2020-10-25T00:50:00Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "eeffe4f3152d73bee44028c19438eaaec5fac2bf",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "ioggstream-1315",
      "headRefOid": "f3e9e44d197529e9ca30dae3e5cd2da2bac7b8a4",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1319,
      "id": "MDExOlB1bGxSZXF1ZXN0NTExMTcyMTM2",
      "title": "Validate Structured Fields, with adjustments",
      "url": "https://github.com/httpwg/http-extensions/pull/1319",
      "state": "OPEN",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "signatures"
      ],
      "body": "This annotates examples with `http-message` so they can be validated; I corrected the errors I saw.\r\n\r\nOne outstanding issue is that you're wrapping long binary content across multiple lines, and HTTP line folding rules means that doing so inserts whitespace, which isn't allowed in structured binary content.\r\n\r\nTwo possible solutions:\r\n\r\n1. Make a note near the top that it's wrapping these long lines for illustrative purposes only, and that they're not valid; I can adjust the tooling to make it validate properly despite that\r\n2. Change structured binary content's definition to allow whitespace\r\n\r\n(2) is unlikely, because that document is in the RFC Editor queue, but not impossible.\r\n",
      "createdAt": "2020-10-27T23:15:47Z",
      "updatedAt": "2020-10-28T23:44:21Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1889a4bb6cd32541db39a7f5f54a6b7be2c4643c",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-signature-sf-validate",
      "headRefOid": "fe6b4bc5c7618ac2992112b054c34fc39682d5c2",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Lukasa",
          "authorAssociation": "NONE",
          "body": "Let\u2019s not do (2), especially not for this reason.",
          "createdAt": "2020-10-28T07:56:01Z",
          "updatedAt": "2020-10-28T07:56:01Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@Lukasa I hear you, but this is turning out to be a nasty issue -- a spec can use folding where whitespace is necessary; consider:\r\n\r\n~~~ http-message\r\nSignature-Input: sig1=(*request-target *created host date\r\n     cache-control x-empty-header x-example); keyid=\"test-key-a\";\r\n     alg=hs2019; created=1402170695; expires=1402170995\r\n Signature: sig1=:K2qGT5srn2OGbOIDzQ6kYT+ruaycnDAAUpKv+ePFfD0RAxn/1BUe\r\n     Zx/Kdrq32DrfakQ6bPsvB9aqZqognNT6be4olHROIkeV879RrsrObury8L9SCEibe\r\n    oHyqU/yCjphSmEdd7WD+zrchK57quskKwRefy2iEC5S2uAH0EPyOZKWlvbKmKu5q4\r\n    CaB8X/I5/+HLZLGvDiezqi6/7p2Gngf5hwZ0lSdy39vyNMaaAT0tKo6nuVw0S1MVg\r\n    1Q7MpWYZs0soHjttq0uLIA3DIbQfLiIvK6/l0BdWTU7+2uQj7lBkQAsFZHoA96ZZg\r\n    FquQrXRlmYOh+Hx5D9fJkXcXe5tmAg==:\r\n~~~\r\n\r\nHere, the inner list in `Signature-Input` requires folding to insert a whitespace, otherwise you lose delimitation; but `Signature` requires it to be withheld. \r\n\r\nAddressing this with (1) means that you'd need to specify different whitespace folding rules for different headers, which is beyond ugly. It's also likely to cause bugs from people who only read examples...\r\n\r\nAlso, base64 implementations already ignore whitespace; e.g., \r\n\r\n~~~ python\r\n>>> base64.encodestring(b\"foo bar baz\")\r\nb'Zm9vIGJhciBiYXo=\\n'\r\n>>> base64.decodestring(b'Zm9vIGJhciBiYXo=\\n')\r\nb'foo bar baz'\r\n>>> base64.decodestring(b'Zm9vIGJhciBiY Xo=\\n')\r\nb'foo bar baz'\r\n>>> base64.decodestring(b'Zm9vIGJhciBiY    Xo=\\n')\r\nb'foo bar baz'\r\n~~~\r\n\r\n... which means that all we need to do is make a small change to allow whitespace [here](https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#name-byte-sequences) and [here](https://httpwg.org/http-extensions/draft-ietf-httpbis-header-structure.html#name-parsing-a-byte-sequence).\r\n\r\nI know it's 11:59:59, but I'm starting to think this change is worth it. Will start a thread on the mailing list.\r\n",
          "createdAt": "2020-10-28T08:11:33Z",
          "updatedAt": "2020-10-28T08:11:33Z"
        },
        {
          "author": "Lukasa",
          "authorAssociation": "NONE",
          "body": "Is that a bug that actually exists? Do people read examples and start adding newlines to their HTTP header fields? This seems surprising to me, though it\u2019s within the realms of possibility.\r\n\r\nIt seems fine to me, in the abstract, to say that we can have folding in specs that are forbidden by the grammar of the field. We already do this in a number of other header fields, so this wouldn\u2019t be the first time. But I\u2019m open to discussion on-list.",
          "createdAt": "2020-10-28T08:27:59Z",
          "updatedAt": "2020-10-28T08:27:59Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Brainstorming: What if it doesn't look like HTTP folding?\r\n\r\n~~~\r\nSignature-Input: sig1=(*request-target *created host date\r\n    cache-control x-empty-header x-example); keyid=\"test-key-a\";\r\n    alg=hs2019; created=1402170695; expires=1402170995\r\nSignature: sig1=:K2qGT5srn2OGbOIDzQ6kYT+ruaycnDAAUpKv+ePFfD0RAxn/1BUe\r\nZx/Kdrq32DrfakQ6bPsvB9aqZqognNT6be4olHROIkeV879RrsrObury8L9SCEibeoHyq\r\nU/yCjphSmEdd7WD+zrchK57quskKwRefy2iEC5S2uAH0EPyOZKWlvbKmKu5q4CaB8X/I5\r\n/+HLZLGvDiezqi6/7p2Gngf5hwZ0lSdy39vyNMaaAT0tKo6nuVw0S1MVg1Q7MpWYZs0so\r\nHjttq0uLIA3DIbQfLiIvK6/l0BdWTU7+2uQj7lBkQAsFZHoA96ZZgFquQrXRlmYOh+Hx5\r\nD9fJkXcXe5tmAg==:\r\n~~~\r\n\r\nAnd that's without restorting to other conventions, like `\\\\\\n` line continuations.",
          "createdAt": "2020-10-28T08:49:06Z",
          "updatedAt": "2020-10-28T08:49:06Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This also works:\r\n\r\n```js\r\nwindow.atob('Zm9vIGJhciBiY  Xo=')\r\n```",
          "createdAt": "2020-10-28T08:49:43Z",
          "updatedAt": "2020-10-28T08:49:43Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "@phluid61 the problem is that we'd be inventing a new format, one that *isn't* the one we're trying to illustrate.",
          "createdAt": "2020-10-28T08:56:56Z",
          "updatedAt": "2020-10-28T08:56:56Z"
        },
        {
          "author": "phluid61",
          "authorAssociation": "COLLABORATOR",
          "body": "Today I learned about RFC 8792.",
          "createdAt": "2020-10-28T23:44:21Z",
          "updatedAt": "2020-10-28T23:44:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NTAwNDcw",
          "commit": {
            "abbreviatedOid": "19162b0"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-28T10:06:44Z",
          "updatedAt": "2020-10-28T10:06:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:06:44Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NTAwOTgy",
          "commit": {
            "abbreviatedOid": "19162b0"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "recover missing spaces after \":\" :P ",
          "createdAt": "2020-10-28T10:07:18Z",
          "updatedAt": "2020-10-28T10:12:24Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "here and elsewhere after \":\", imho the extra space improves format: is that correct?",
              "createdAt": "2020-10-28T10:07:18Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:08:02Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:08:15Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:08:33Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 178,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:08:47Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 183,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:08:56Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 188,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:09:04Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 195,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:09:11Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 232,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:09:21Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 237,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:09:28Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 242,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:09:36Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 251,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:09:42Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 256,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:09:48Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 262,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:09:55Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 272,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:10:10Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 278,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:10:22Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 283,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:10:29Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 289,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:10:46Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 294,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:10:53Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 299,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:10:57Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 305,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:11:03Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 310,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:11:09Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 315,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:11:14Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 321,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:11:19Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 326,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:11:23Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            },
            {
              "originalPosition": 331,
              "body": "```suggestion\r\n: \r\n```",
              "createdAt": "2020-10-28T10:11:27Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MTE3OTYx",
          "commit": {
            "abbreviatedOid": "19162b0"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-28T22:01:37Z",
          "updatedAt": "2020-10-28T22:01:37Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "What do you think those spaces do?",
              "createdAt": "2020-10-28T22:01:37Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MTI3NzEx",
          "commit": {
            "abbreviatedOid": "19162b0"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-28T22:20:04Z",
          "updatedAt": "2020-10-28T22:20:04Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "With space, the HTML/TXT renders like\r\n\r\n```\r\nSigner\r\n    The entity that is generating or has generated an HTTP Message Signature.\r\n```\r\n\r\nwithout space, it renders like\r\n\r\n```\r\nSigner\r\n:    The entity that is generating or has generated an HTTP Message Signature.\r\n```\r\n",
              "createdAt": "2020-10-28T22:20:04Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MTMyMzUy",
          "commit": {
            "abbreviatedOid": "19162b0"
          },
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-28T22:29:36Z",
          "updatedAt": "2020-10-28T22:29:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "The correct way to do this is:\r\n\r\n~~~\r\n{: vspace=\"0\"}\r\nword:\r\n: definition\r\n~~~",
              "createdAt": "2020-10-28T22:29:36Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MTM4NTQ4",
          "commit": {
            "abbreviatedOid": "5548070"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-28T22:43:21Z",
          "updatedAt": "2020-10-28T22:43:22Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nX-OWS-Header:   Leading and trailing whitespace.    \r\n```\r\n\r\n@richanna @mnot are those whitespaces needed? The reader won't probably see them :)",
              "createdAt": "2020-10-28T22:43:22Z",
              "updatedAt": "2020-10-28T23:33:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 1320,
      "id": "MDExOlB1bGxSZXF1ZXN0NTExMTc0NjIw",
      "title": "Validate http headers in CH",
      "url": "https://github.com/httpwg/http-extensions/pull/1320",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-hints"
      ],
      "body": "(FYI, if you're too far into AUTH48 don't worry about merging this, although the RFC Editor might want those sections annotated, and if so, the whitespace should be removed from the beginning of the lines)",
      "createdAt": "2020-10-27T23:23:31Z",
      "updatedAt": "2020-10-28T09:04:08Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1889a4bb6cd32541db39a7f5f54a6b7be2c4643c",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-ch-sh",
      "headRefOid": "bc1bec20934f7ff8b9ef6fc28a0b9c166b7f685d",
      "closedAt": "2020-10-28T09:04:07Z",
      "mergedAt": "2020-10-28T09:04:07Z",
      "mergedBy": "yoavweiss",
      "mergeCommit": {
        "oid": "848116e8bcb5d9723b7358e7f94e41ab12892bed"
      },
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks! I manually marked the examples as `http-message` as part of the AUTH48 process. Might be late for the sf.json changes though",
          "createdAt": "2020-10-28T05:48:04Z",
          "updatedAt": "2020-10-28T05:48:04Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "No worries about `sf.json` - it's just a hint file. If you still can remove the leading whitespace that would be cool, but it's not the end of the world if you don't.",
          "createdAt": "2020-10-28T06:04:19Z",
          "updatedAt": "2020-10-28T06:04:19Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If you still can remove the leading whitespace that would be cool, but it's not the end of the world if you don't.\r\n\r\nToo late for that, I believe.",
          "createdAt": "2020-10-28T06:10:50Z",
          "updatedAt": "2020-10-28T06:10:50Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No.\r\n\r\n<https://www.rfc-editor.org/auth48/C414> says it's waiting for author approval. By definition, it is not too late.",
          "createdAt": "2020-10-28T08:37:41Z",
          "updatedAt": "2020-10-28T08:37:41Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK. I sent out the revised XML yesterday. Should I simply send another revised version that also includes these changes?",
          "createdAt": "2020-10-28T08:58:10Z",
          "updatedAt": "2020-10-28T08:58:10Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "MEMBER",
          "body": "Yes, they'll incorporate (they're very nice that way). Please make sure you remove the leading whitespace as per this PR.",
          "createdAt": "2020-10-28T08:59:10Z",
          "updatedAt": "2020-10-28T08:59:10Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Will do, thanks! :)",
          "createdAt": "2020-10-28T09:02:16Z",
          "updatedAt": "2020-10-28T09:02:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NDQ2NzI3",
          "commit": {
            "abbreviatedOid": "bc1bec2"
          },
          "author": "yoavweiss",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-10-28T09:03:58Z",
          "updatedAt": "2020-10-28T09:03:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1321,
      "id": "MDExOlB1bGxSZXF1ZXN0NTExMTc5MjE5",
      "title": "Validate HTTP message examples in Digest",
      "url": "https://github.com/httpwg/http-extensions/pull/1321",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "... using rfc-http-validate. ",
      "createdAt": "2020-10-27T23:37:53Z",
      "updatedAt": "2020-10-27T23:55:52Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "1889a4bb6cd32541db39a7f5f54a6b7be2c4643c",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-validate-digest",
      "headRefOid": "cc81a3d00b7ee1cc527c8eaee38f618780b97c3f",
      "closedAt": "2020-10-27T23:55:51Z",
      "mergedAt": "2020-10-27T23:55:51Z",
      "mergedBy": "ioggstream",
      "mergeCommit": {
        "oid": "4ee47f6982aa2aa0250c4013aa0b4dd3f02bc4f6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjI5OTM4",
          "commit": {
            "abbreviatedOid": "cc81a3d"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "thanks!",
          "createdAt": "2020-10-27T23:45:36Z",
          "updatedAt": "2020-10-27T23:45:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjMzNDE2",
          "commit": {
            "abbreviatedOid": "cc81a3d"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM thanks :)",
          "createdAt": "2020-10-27T23:55:26Z",
          "updatedAt": "2020-10-27T23:55:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 1322,
      "id": "MDExOlB1bGxSZXF1ZXN0NTExMzc5OTU5",
      "title": "Allow SP in Byte Sequences",
      "url": "https://github.com/httpwg/http-extensions/pull/1322",
      "state": "OPEN",
      "author": "mnot",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "header-structure"
      ],
      "body": "",
      "createdAt": "2020-10-28T08:47:44Z",
      "updatedAt": "2020-10-28T10:13:36Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "4ee47f6982aa2aa0250c4013aa0b4dd3f02bc4f6",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "mnot-binary-ws",
      "headRefOid": "5b6ccd837b672951cb74ee3c7c499dad00ec5687",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1323,
      "id": "MDExOlB1bGxSZXF1ZXN0NTExODU0MDM3",
      "title": "Require \"Secure\" for \"SameSite=None\".",
      "url": "https://github.com/httpwg/http-extensions/pull/1323",
      "state": "OPEN",
      "author": "miketaylr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis",
        "samesite"
      ],
      "body": "Opening for discussion, per the last interim group meeting.\r\n\r\nThis should correspond to https://tools.ietf.org/html/draft-west-cookie-incrementalism-01#section-3.2",
      "createdAt": "2020-10-28T21:40:45Z",
      "updatedAt": "2020-10-28T21:46:19Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "848116e8bcb5d9723b7358e7f94e41ab12892bed",
      "headRepository": "miketaylr/http-extensions",
      "headRefName": "samesite-none-secure",
      "headRefOid": "0edf3861d46f09a4cd9564cd3ca830c5efc04b3e",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1324,
      "id": "MDExOlB1bGxSZXF1ZXN0NTExODU0MTM4",
      "title": "Introduce \"Schemeful Same-Site\" cookies.",
      "url": "https://github.com/httpwg/http-extensions/pull/1324",
      "state": "OPEN",
      "author": "miketaylr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis",
        "samesite"
      ],
      "body": "Opening for discussion, per the last interim group meeting.\r\n\r\nThis should correspond to https://tools.ietf.org/html/draft-west-cookie-incrementalism-01#section-3.3",
      "createdAt": "2020-10-28T21:40:57Z",
      "updatedAt": "2020-10-28T21:46:38Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "848116e8bcb5d9723b7358e7f94e41ab12892bed",
      "headRepository": "miketaylr/http-extensions",
      "headRefName": "schemeful-samesite",
      "headRefOid": "e246ee0d85a7e94dce5a1fc43a899a1d299c157f",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1325,
      "id": "MDExOlB1bGxSZXF1ZXN0NTExODU0MTg2",
      "title": "Treat cookies as \"SameSite=Lax\" by default.",
      "url": "https://github.com/httpwg/http-extensions/pull/1325",
      "state": "OPEN",
      "author": "miketaylr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "6265bis",
        "samesite"
      ],
      "body": "Opening for discussion, per the last interim group meeting.\r\n\r\nThis should correspond to https://tools.ietf.org/html/draft-west-cookie-incrementalism-01#section-3.1\r\n",
      "createdAt": "2020-10-28T21:41:03Z",
      "updatedAt": "2020-10-28T21:46:49Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "848116e8bcb5d9723b7358e7f94e41ab12892bed",
      "headRepository": "miketaylr/http-extensions",
      "headRefName": "lax-by-default",
      "headRefOid": "fa83cba2bd26d7fc77775d259837509014f2c5a9",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1326,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEyMDE1NDc0",
      "title": "Install SF validator only when not present",
      "url": "https://github.com/httpwg/http-extensions/pull/1326",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "That .py suffix is a curse.",
      "createdAt": "2020-10-29T05:06:09Z",
      "updatedAt": "2020-10-29T05:06:09Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "848116e8bcb5d9723b7358e7f94e41ab12892bed",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "install-better",
      "headRefOid": "b2872f1ddb3e57b439181d0aad92d8d9aaff8172",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1327,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEyMDE5NzQ0",
      "title": "Remove trailing whitespace",
      "url": "https://github.com/httpwg/http-extensions/pull/1327",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I started linting by default (I thought that I already had, so I guess I was wrong), which exposed a bunch of junk in these specs.",
      "createdAt": "2020-10-29T05:18:54Z",
      "updatedAt": "2020-10-29T05:18:54Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "848116e8bcb5d9723b7358e7f94e41ab12892bed",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "fix-lints",
      "headRefOid": "c7536139e070cb2c83aec30b11f1d1bd69de9cb8",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 1328,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEyMDIyMTY3",
      "title": "Remove trailing whitespace",
      "url": "https://github.com/httpwg/http-extensions/pull/1328",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Apart from the rubbish empty colon lines, which now get a comment.",
      "createdAt": "2020-10-29T05:26:04Z",
      "updatedAt": "2020-10-29T08:44:29Z",
      "baseRepository": "httpwg/http-extensions",
      "baseRefName": "master",
      "baseRefOid": "848116e8bcb5d9723b7358e7f94e41ab12892bed",
      "headRepository": "httpwg/http-extensions",
      "headRefName": "fixup-colon-space-message",
      "headRefOid": "565e24987198fb4444ae791a33e37d374e690377",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This issue on Signatures are WIP in #1319 See https://github.com/httpwg/http-extensions/pull/1319/files#diff-1d57bca6223a0fee3ef29148c2550c0f862e72f67a56cc7f57b5a72fbd8320e3R146\r\n\r\n+1 for Mark's solution in a separate PR :)",
          "createdAt": "2020-10-29T08:33:41Z",
          "updatedAt": "2020-10-29T08:44:28Z"
        }
      ],
      "reviews": []
    }
  ]
}